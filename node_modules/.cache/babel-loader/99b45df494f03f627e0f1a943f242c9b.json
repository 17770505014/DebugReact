{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n * \n */\nimport { IS_PASSIVE, PASSIVE_NOT_SUPPORTED } from 'legacy-events/EventSystemFlags';\nimport { HostComponent, ScopeComponent, HostPortal } from 'shared/ReactWorkTags';\nimport { batchedEventUpdates, discreteUpdates, flushDiscreteUpdatesIfNeeded, executeUserEventHandler } from 'legacy-events/ReactGenericBatching';\nimport { enqueueStateRestore } from 'legacy-events/ReactControlledComponent';\nimport warning from 'shared/warning';\nimport { enableFlareAPI } from 'shared/ReactFeatureFlags';\nimport invariant from 'shared/invariant';\nimport { getClosestInstanceFromNode } from '../client/ReactDOMComponentTree';\nimport { ContinuousEvent, UserBlockingEvent, DiscreteEvent } from 'shared/ReactTypes'; // Intentionally not named imports because Rollup would use dynamic dispatch for\n// CommonJS interop named imports.\n\nimport * as Scheduler from 'scheduler';\nconst {\n  unstable_UserBlockingPriority: UserBlockingPriority,\n  unstable_runWithPriority: runWithPriority\n} = Scheduler;\nexport let listenToResponderEventTypesImpl;\nexport function setListenToResponderEventTypes(_listenToResponderEventTypesImpl) {\n  listenToResponderEventTypesImpl = _listenToResponderEventTypesImpl;\n}\nconst rootEventTypesToEventResponderInstances = new Map();\nconst DoNotPropagateToNextResponder = 0;\nconst PropagateToNextResponder = 1;\nlet currentTimeStamp = 0;\nlet currentInstance = null;\nlet currentDocument = null;\nlet currentPropagationBehavior = DoNotPropagateToNextResponder;\nconst eventResponderContext = {\n  dispatchEvent(eventValue, eventListener, eventPriority) {\n    validateResponderContext();\n    validateEventValue(eventValue);\n\n    switch (eventPriority) {\n      case DiscreteEvent:\n        {\n          flushDiscreteUpdatesIfNeeded(currentTimeStamp);\n          discreteUpdates(() => executeUserEventHandler(eventListener, eventValue));\n          break;\n        }\n\n      case UserBlockingEvent:\n        {\n          runWithPriority(UserBlockingPriority, () => executeUserEventHandler(eventListener, eventValue));\n          break;\n        }\n\n      case ContinuousEvent:\n        {\n          executeUserEventHandler(eventListener, eventValue);\n          break;\n        }\n    }\n  },\n\n  isTargetWithinResponder(target) {\n    validateResponderContext();\n\n    if (target != null) {\n      let fiber = getClosestInstanceFromNode(target);\n      const responderFiber = currentInstance.fiber;\n\n      while (fiber !== null) {\n        if (fiber === responderFiber || fiber.alternate === responderFiber) {\n          return true;\n        }\n\n        fiber = fiber.return;\n      }\n    }\n\n    return false;\n  },\n\n  isTargetWithinResponderScope(target) {\n    validateResponderContext();\n    const componentInstance = currentInstance;\n    const responder = componentInstance.responder;\n\n    if (target != null) {\n      let fiber = getClosestInstanceFromNode(target);\n      const responderFiber = currentInstance.fiber;\n\n      while (fiber !== null) {\n        if (fiber === responderFiber || fiber.alternate === responderFiber) {\n          return true;\n        }\n\n        if (doesFiberHaveResponder(fiber, responder)) {\n          return false;\n        }\n\n        fiber = fiber.return;\n      }\n    }\n\n    return false;\n  },\n\n  isTargetWithinNode(childTarget, parentTarget) {\n    validateResponderContext();\n    const childFiber = getClosestInstanceFromNode(childTarget);\n    const parentFiber = getClosestInstanceFromNode(parentTarget);\n\n    if (childFiber != null && parentFiber != null) {\n      const parentAlternateFiber = parentFiber.alternate;\n      let node = childFiber;\n\n      while (node !== null) {\n        if (node === parentFiber || node === parentAlternateFiber) {\n          return true;\n        }\n\n        node = node.return;\n      }\n\n      return false;\n    } // Fallback to DOM APIs\n\n\n    return parentTarget.contains(childTarget);\n  },\n\n  addRootEventTypes(rootEventTypes) {\n    validateResponderContext();\n    listenToResponderEventTypesImpl(rootEventTypes, currentDocument);\n\n    for (let i = 0; i < rootEventTypes.length; i++) {\n      const rootEventType = rootEventTypes[i];\n      const eventResponderInstance = currentInstance;\n      registerRootEventType(rootEventType, eventResponderInstance);\n    }\n  },\n\n  removeRootEventTypes(rootEventTypes) {\n    validateResponderContext();\n\n    for (let i = 0; i < rootEventTypes.length; i++) {\n      const rootEventType = rootEventTypes[i];\n      let rootEventResponders = rootEventTypesToEventResponderInstances.get(rootEventType);\n      let rootEventTypesSet = currentInstance.rootEventTypes;\n\n      if (rootEventTypesSet !== null) {\n        rootEventTypesSet.delete(rootEventType);\n      }\n\n      if (rootEventResponders !== undefined) {\n        rootEventResponders.delete(currentInstance);\n      }\n    }\n  },\n\n  getActiveDocument,\n  objectAssign: Object.assign,\n\n  getTimeStamp() {\n    validateResponderContext();\n    return currentTimeStamp;\n  },\n\n  isTargetWithinHostComponent(target, elementType) {\n    validateResponderContext();\n    let fiber = getClosestInstanceFromNode(target);\n\n    while (fiber !== null) {\n      if (fiber.tag === HostComponent && fiber.type === elementType) {\n        return true;\n      }\n\n      fiber = fiber.return;\n    }\n\n    return false;\n  },\n\n  continuePropagation() {\n    currentPropagationBehavior = PropagateToNextResponder;\n  },\n\n  enqueueStateRestore,\n\n  getResponderNode() {\n    validateResponderContext();\n    const responderFiber = currentInstance.fiber;\n\n    if (responderFiber.tag === ScopeComponent) {\n      return null;\n    }\n\n    return responderFiber.stateNode;\n  }\n\n};\n\nfunction validateEventValue(eventValue) {\n  if (typeof eventValue === 'object' && eventValue !== null) {\n    const {\n      target,\n      type,\n      timeStamp\n    } = eventValue;\n\n    if (target == null || type == null || timeStamp == null) {\n      throw new Error('context.dispatchEvent: \"target\", \"timeStamp\", and \"type\" fields on event object are required.');\n    }\n\n    const showWarning = name => {\n      if (__DEV__) {\n        warning(false, '%s is not available on event objects created from event responder modules (React Flare). ' + 'Try wrapping in a conditional, i.e. `if (event.type !== \"press\") { event.%s }`', name, name);\n      }\n    };\n\n    eventValue.isDefaultPrevented = () => {\n      if (__DEV__) {\n        showWarning('isDefaultPrevented()');\n      }\n    };\n\n    eventValue.isPropagationStopped = () => {\n      if (__DEV__) {\n        showWarning('isPropagationStopped()');\n      }\n    }; // $FlowFixMe: we don't need value, Flow thinks we do\n\n\n    Object.defineProperty(eventValue, 'nativeEvent', {\n      get() {\n        if (__DEV__) {\n          showWarning('nativeEvent');\n        }\n      }\n\n    });\n  }\n}\n\nfunction doesFiberHaveResponder(fiber, responder) {\n  const tag = fiber.tag;\n\n  if (tag === HostComponent || tag === ScopeComponent) {\n    const dependencies = fiber.dependencies;\n\n    if (dependencies !== null) {\n      const respondersMap = dependencies.responders;\n\n      if (respondersMap !== null && respondersMap.has(responder)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction getActiveDocument() {\n  return currentDocument;\n}\n\nfunction createDOMResponderEvent(topLevelType, nativeEvent, nativeEventTarget, passive, passiveSupported) {\n  const {\n    buttons,\n    pointerType\n  } = nativeEvent;\n  let eventPointerType = '';\n\n  if (pointerType !== undefined) {\n    eventPointerType = pointerType;\n  } else if (nativeEvent.key !== undefined) {\n    eventPointerType = 'keyboard';\n  } else if (buttons !== undefined) {\n    eventPointerType = 'mouse';\n  } else if (nativeEvent.changedTouches !== undefined) {\n    eventPointerType = 'touch';\n  }\n\n  return {\n    nativeEvent: nativeEvent,\n    passive,\n    passiveSupported,\n    pointerType: eventPointerType,\n    target: nativeEventTarget,\n    type: topLevelType\n  };\n}\n\nfunction responderEventTypesContainType(eventTypes, type) {\n  for (let i = 0, len = eventTypes.length; i < len; i++) {\n    if (eventTypes[i] === type) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction validateResponderTargetEventTypes(eventType, responder) {\n  const {\n    targetEventTypes\n  } = responder; // Validate the target event type exists on the responder\n\n  if (targetEventTypes !== null) {\n    return responderEventTypesContainType(targetEventTypes, eventType);\n  }\n\n  return false;\n}\n\nfunction traverseAndHandleEventResponderInstances(topLevelType, targetFiber, nativeEvent, nativeEventTarget, eventSystemFlags) {\n  const isPassiveEvent = (eventSystemFlags & IS_PASSIVE) !== 0;\n  const isPassiveSupported = (eventSystemFlags & PASSIVE_NOT_SUPPORTED) === 0;\n  const isPassive = isPassiveEvent || !isPassiveSupported;\n  const eventType = isPassive ? topLevelType : topLevelType + '_active'; // Trigger event responders in this order:\n  // - Bubble target responder phase\n  // - Root responder phase\n\n  const visitedResponders = new Set();\n  const responderEvent = createDOMResponderEvent(topLevelType, nativeEvent, nativeEventTarget, isPassiveEvent, isPassiveSupported);\n  let node = targetFiber;\n  let insidePortal = false;\n\n  while (node !== null) {\n    const {\n      dependencies,\n      tag\n    } = node;\n\n    if (tag === HostPortal) {\n      insidePortal = true;\n    } else if ((tag === HostComponent || tag === ScopeComponent) && dependencies !== null) {\n      const respondersMap = dependencies.responders;\n\n      if (respondersMap !== null) {\n        const responderInstances = Array.from(respondersMap.values());\n\n        for (let i = 0, length = responderInstances.length; i < length; i++) {\n          const responderInstance = responderInstances[i];\n          const {\n            props,\n            responder,\n            state\n          } = responderInstance;\n\n          if (!visitedResponders.has(responder) && validateResponderTargetEventTypes(eventType, responder) && (!insidePortal || responder.targetPortalPropagation)) {\n            visitedResponders.add(responder);\n            const onEvent = responder.onEvent;\n\n            if (onEvent !== null) {\n              currentInstance = responderInstance;\n              onEvent(responderEvent, eventResponderContext, props, state);\n\n              if (currentPropagationBehavior === PropagateToNextResponder) {\n                visitedResponders.delete(responder);\n                currentPropagationBehavior = DoNotPropagateToNextResponder;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    node = node.return;\n  } // Root phase\n\n\n  const rootEventResponderInstances = rootEventTypesToEventResponderInstances.get(eventType);\n\n  if (rootEventResponderInstances !== undefined) {\n    const responderInstances = Array.from(rootEventResponderInstances);\n\n    for (let i = 0; i < responderInstances.length; i++) {\n      const responderInstance = responderInstances[i];\n      const {\n        props,\n        responder,\n        state\n      } = responderInstance;\n      const onRootEvent = responder.onRootEvent;\n\n      if (onRootEvent !== null) {\n        currentInstance = responderInstance;\n        onRootEvent(responderEvent, eventResponderContext, props, state);\n      }\n    }\n  }\n}\n\nexport function mountEventResponder(responder, responderInstance, props, state) {\n  const onMount = responder.onMount;\n\n  if (onMount !== null) {\n    const previousInstance = currentInstance;\n    currentInstance = responderInstance;\n\n    try {\n      batchedEventUpdates(() => {\n        onMount(eventResponderContext, props, state);\n      });\n    } finally {\n      currentInstance = previousInstance;\n    }\n  }\n}\nexport function unmountEventResponder(responderInstance) {\n  const responder = responderInstance.responder;\n  const onUnmount = responder.onUnmount;\n\n  if (onUnmount !== null) {\n    let {\n      props,\n      state\n    } = responderInstance;\n    const previousInstance = currentInstance;\n    currentInstance = responderInstance;\n\n    try {\n      batchedEventUpdates(() => {\n        onUnmount(eventResponderContext, props, state);\n      });\n    } finally {\n      currentInstance = previousInstance;\n    }\n  }\n\n  const rootEventTypesSet = responderInstance.rootEventTypes;\n\n  if (rootEventTypesSet !== null) {\n    const rootEventTypes = Array.from(rootEventTypesSet);\n\n    for (let i = 0; i < rootEventTypes.length; i++) {\n      const topLevelEventType = rootEventTypes[i];\n      let rootEventResponderInstances = rootEventTypesToEventResponderInstances.get(topLevelEventType);\n\n      if (rootEventResponderInstances !== undefined) {\n        rootEventResponderInstances.delete(responderInstance);\n      }\n    }\n  }\n}\n\nfunction validateResponderContext() {\n  invariant(currentInstance !== null, 'An event responder context was used outside of an event cycle.');\n}\n\nexport function dispatchEventForResponderEventSystem(topLevelType, targetFiber, nativeEvent, nativeEventTarget, eventSystemFlags) {\n  if (enableFlareAPI) {\n    const previousInstance = currentInstance;\n    const previousTimeStamp = currentTimeStamp;\n    const previousDocument = currentDocument;\n    const previousPropagationBehavior = currentPropagationBehavior;\n    currentPropagationBehavior = DoNotPropagateToNextResponder; // nodeType 9 is DOCUMENT_NODE\n\n    currentDocument = nativeEventTarget.nodeType === 9 ? nativeEventTarget : nativeEventTarget.ownerDocument; // We might want to control timeStamp another way here\n\n    currentTimeStamp = nativeEvent.timeStamp;\n\n    try {\n      batchedEventUpdates(() => {\n        traverseAndHandleEventResponderInstances(topLevelType, targetFiber, nativeEvent, nativeEventTarget, eventSystemFlags);\n      });\n    } finally {\n      currentInstance = previousInstance;\n      currentTimeStamp = previousTimeStamp;\n      currentDocument = previousDocument;\n      currentPropagationBehavior = previousPropagationBehavior;\n    }\n  }\n}\nexport function addRootEventTypesForResponderInstance(responderInstance, rootEventTypes) {\n  for (let i = 0; i < rootEventTypes.length; i++) {\n    const rootEventType = rootEventTypes[i];\n    registerRootEventType(rootEventType, responderInstance);\n  }\n}\n\nfunction registerRootEventType(rootEventType, eventResponderInstance) {\n  let rootEventResponderInstances = rootEventTypesToEventResponderInstances.get(rootEventType);\n\n  if (rootEventResponderInstances === undefined) {\n    rootEventResponderInstances = new Set();\n    rootEventTypesToEventResponderInstances.set(rootEventType, rootEventResponderInstances);\n  }\n\n  let rootEventTypesSet = eventResponderInstance.rootEventTypes;\n\n  if (rootEventTypesSet === null) {\n    rootEventTypesSet = eventResponderInstance.rootEventTypes = new Set();\n  }\n\n  invariant(!rootEventTypesSet.has(rootEventType), 'addRootEventTypes() found a duplicate root event ' + 'type of \"%s\". This might be because the event type exists in the event responder \"rootEventTypes\" ' + 'array or because of a previous addRootEventTypes() using this root event type.', rootEventType);\n  rootEventTypesSet.add(rootEventType);\n  rootEventResponderInstances.add(eventResponderInstance);\n}","map":{"version":3,"sources":["/Users/gaoshaoyun/Documents/library/debug-react/src/react/packages/react-dom/src/events/DOMEventResponderSystem.js"],"names":["IS_PASSIVE","PASSIVE_NOT_SUPPORTED","HostComponent","ScopeComponent","HostPortal","batchedEventUpdates","discreteUpdates","flushDiscreteUpdatesIfNeeded","executeUserEventHandler","enqueueStateRestore","warning","enableFlareAPI","invariant","getClosestInstanceFromNode","ContinuousEvent","UserBlockingEvent","DiscreteEvent","Scheduler","unstable_UserBlockingPriority","UserBlockingPriority","unstable_runWithPriority","runWithPriority","listenToResponderEventTypesImpl","setListenToResponderEventTypes","_listenToResponderEventTypesImpl","rootEventTypesToEventResponderInstances","Map","DoNotPropagateToNextResponder","PropagateToNextResponder","currentTimeStamp","currentInstance","currentDocument","currentPropagationBehavior","eventResponderContext","dispatchEvent","eventValue","eventListener","eventPriority","validateResponderContext","validateEventValue","isTargetWithinResponder","target","fiber","responderFiber","alternate","return","isTargetWithinResponderScope","componentInstance","responder","doesFiberHaveResponder","isTargetWithinNode","childTarget","parentTarget","childFiber","parentFiber","parentAlternateFiber","node","contains","addRootEventTypes","rootEventTypes","i","length","rootEventType","eventResponderInstance","registerRootEventType","removeRootEventTypes","rootEventResponders","get","rootEventTypesSet","delete","undefined","getActiveDocument","objectAssign","Object","assign","getTimeStamp","isTargetWithinHostComponent","elementType","tag","type","continuePropagation","getResponderNode","stateNode","timeStamp","Error","showWarning","name","__DEV__","isDefaultPrevented","isPropagationStopped","defineProperty","dependencies","respondersMap","responders","has","createDOMResponderEvent","topLevelType","nativeEvent","nativeEventTarget","passive","passiveSupported","buttons","pointerType","eventPointerType","key","changedTouches","responderEventTypesContainType","eventTypes","len","validateResponderTargetEventTypes","eventType","targetEventTypes","traverseAndHandleEventResponderInstances","targetFiber","eventSystemFlags","isPassiveEvent","isPassiveSupported","isPassive","visitedResponders","Set","responderEvent","insidePortal","responderInstances","Array","from","values","responderInstance","props","state","targetPortalPropagation","add","onEvent","rootEventResponderInstances","onRootEvent","mountEventResponder","onMount","previousInstance","unmountEventResponder","onUnmount","topLevelEventType","dispatchEventForResponderEventSystem","previousTimeStamp","previousDocument","previousPropagationBehavior","nodeType","ownerDocument","addRootEventTypesForResponderInstance","set"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n * @flow\n */\n\nimport {\n  type EventSystemFlags,\n  IS_PASSIVE,\n  PASSIVE_NOT_SUPPORTED,\n} from 'legacy-events/EventSystemFlags';\nimport type {AnyNativeEvent} from 'legacy-events/PluginModuleType';\nimport {HostComponent, ScopeComponent, HostPortal} from 'shared/ReactWorkTags';\nimport type {EventPriority} from 'shared/ReactTypes';\nimport type {\n  ReactDOMEventResponder,\n  ReactDOMEventResponderInstance,\n  ReactDOMResponderContext,\n  ReactDOMResponderEvent,\n} from 'shared/ReactDOMTypes';\nimport type {DOMTopLevelEventType} from 'legacy-events/TopLevelEventTypes';\nimport {\n  batchedEventUpdates,\n  discreteUpdates,\n  flushDiscreteUpdatesIfNeeded,\n  executeUserEventHandler,\n} from 'legacy-events/ReactGenericBatching';\nimport {enqueueStateRestore} from 'legacy-events/ReactControlledComponent';\nimport type {Fiber} from 'react-reconciler/src/ReactFiber';\nimport warning from 'shared/warning';\nimport {enableFlareAPI} from 'shared/ReactFeatureFlags';\nimport invariant from 'shared/invariant';\n\nimport {getClosestInstanceFromNode} from '../client/ReactDOMComponentTree';\nimport {\n  ContinuousEvent,\n  UserBlockingEvent,\n  DiscreteEvent,\n} from 'shared/ReactTypes';\n\n// Intentionally not named imports because Rollup would use dynamic dispatch for\n// CommonJS interop named imports.\nimport * as Scheduler from 'scheduler';\nconst {\n  unstable_UserBlockingPriority: UserBlockingPriority,\n  unstable_runWithPriority: runWithPriority,\n} = Scheduler;\n\nexport let listenToResponderEventTypesImpl;\n\nexport function setListenToResponderEventTypes(\n  _listenToResponderEventTypesImpl: Function,\n) {\n  listenToResponderEventTypesImpl = _listenToResponderEventTypesImpl;\n}\n\nconst rootEventTypesToEventResponderInstances: Map<\n  DOMTopLevelEventType | string,\n  Set<ReactDOMEventResponderInstance>,\n> = new Map();\n\ntype PropagationBehavior = 0 | 1;\n\nconst DoNotPropagateToNextResponder = 0;\nconst PropagateToNextResponder = 1;\n\nlet currentTimeStamp = 0;\nlet currentInstance: null | ReactDOMEventResponderInstance = null;\nlet currentDocument: null | Document = null;\nlet currentPropagationBehavior: PropagationBehavior = DoNotPropagateToNextResponder;\n\nconst eventResponderContext: ReactDOMResponderContext = {\n  dispatchEvent(\n    eventValue: any,\n    eventListener: any => void,\n    eventPriority: EventPriority,\n  ): void {\n    validateResponderContext();\n    validateEventValue(eventValue);\n    switch (eventPriority) {\n      case DiscreteEvent: {\n        flushDiscreteUpdatesIfNeeded(currentTimeStamp);\n        discreteUpdates(() =>\n          executeUserEventHandler(eventListener, eventValue),\n        );\n        break;\n      }\n      case UserBlockingEvent: {\n        runWithPriority(UserBlockingPriority, () =>\n          executeUserEventHandler(eventListener, eventValue),\n        );\n        break;\n      }\n      case ContinuousEvent: {\n        executeUserEventHandler(eventListener, eventValue);\n        break;\n      }\n    }\n  },\n  isTargetWithinResponder(target: null | Element | Document): boolean {\n    validateResponderContext();\n    if (target != null) {\n      let fiber = getClosestInstanceFromNode(target);\n      const responderFiber = ((currentInstance: any): ReactDOMEventResponderInstance)\n        .fiber;\n\n      while (fiber !== null) {\n        if (fiber === responderFiber || fiber.alternate === responderFiber) {\n          return true;\n        }\n        fiber = fiber.return;\n      }\n    }\n    return false;\n  },\n  isTargetWithinResponderScope(target: null | Element | Document): boolean {\n    validateResponderContext();\n    const componentInstance = ((currentInstance: any): ReactDOMEventResponderInstance);\n    const responder = componentInstance.responder;\n\n    if (target != null) {\n      let fiber = getClosestInstanceFromNode(target);\n      const responderFiber = ((currentInstance: any): ReactDOMEventResponderInstance)\n        .fiber;\n\n      while (fiber !== null) {\n        if (fiber === responderFiber || fiber.alternate === responderFiber) {\n          return true;\n        }\n        if (doesFiberHaveResponder(fiber, responder)) {\n          return false;\n        }\n        fiber = fiber.return;\n      }\n    }\n    return false;\n  },\n  isTargetWithinNode(\n    childTarget: Element | Document,\n    parentTarget: Element | Document,\n  ): boolean {\n    validateResponderContext();\n    const childFiber = getClosestInstanceFromNode(childTarget);\n    const parentFiber = getClosestInstanceFromNode(parentTarget);\n\n    if (childFiber != null && parentFiber != null) {\n      const parentAlternateFiber = parentFiber.alternate;\n      let node = childFiber;\n      while (node !== null) {\n        if (node === parentFiber || node === parentAlternateFiber) {\n          return true;\n        }\n        node = node.return;\n      }\n      return false;\n    }\n    // Fallback to DOM APIs\n    return parentTarget.contains(childTarget);\n  },\n  addRootEventTypes(rootEventTypes: Array<string>): void {\n    validateResponderContext();\n    listenToResponderEventTypesImpl(rootEventTypes, currentDocument);\n    for (let i = 0; i < rootEventTypes.length; i++) {\n      const rootEventType = rootEventTypes[i];\n      const eventResponderInstance = ((currentInstance: any): ReactDOMEventResponderInstance);\n      registerRootEventType(rootEventType, eventResponderInstance);\n    }\n  },\n  removeRootEventTypes(rootEventTypes: Array<string>): void {\n    validateResponderContext();\n    for (let i = 0; i < rootEventTypes.length; i++) {\n      const rootEventType = rootEventTypes[i];\n      let rootEventResponders = rootEventTypesToEventResponderInstances.get(\n        rootEventType,\n      );\n      let rootEventTypesSet = ((currentInstance: any): ReactDOMEventResponderInstance)\n        .rootEventTypes;\n      if (rootEventTypesSet !== null) {\n        rootEventTypesSet.delete(rootEventType);\n      }\n      if (rootEventResponders !== undefined) {\n        rootEventResponders.delete(\n          ((currentInstance: any): ReactDOMEventResponderInstance),\n        );\n      }\n    }\n  },\n  getActiveDocument,\n  objectAssign: Object.assign,\n  getTimeStamp(): number {\n    validateResponderContext();\n    return currentTimeStamp;\n  },\n  isTargetWithinHostComponent(\n    target: Element | Document,\n    elementType: string,\n  ): boolean {\n    validateResponderContext();\n    let fiber = getClosestInstanceFromNode(target);\n\n    while (fiber !== null) {\n      if (fiber.tag === HostComponent && fiber.type === elementType) {\n        return true;\n      }\n      fiber = fiber.return;\n    }\n    return false;\n  },\n  continuePropagation() {\n    currentPropagationBehavior = PropagateToNextResponder;\n  },\n  enqueueStateRestore,\n  getResponderNode(): Element | null {\n    validateResponderContext();\n    const responderFiber = ((currentInstance: any): ReactDOMEventResponderInstance)\n      .fiber;\n    if (responderFiber.tag === ScopeComponent) {\n      return null;\n    }\n    return responderFiber.stateNode;\n  },\n};\n\nfunction validateEventValue(eventValue: any): void {\n  if (typeof eventValue === 'object' && eventValue !== null) {\n    const {target, type, timeStamp} = eventValue;\n\n    if (target == null || type == null || timeStamp == null) {\n      throw new Error(\n        'context.dispatchEvent: \"target\", \"timeStamp\", and \"type\" fields on event object are required.',\n      );\n    }\n    const showWarning = name => {\n      if (__DEV__) {\n        warning(\n          false,\n          '%s is not available on event objects created from event responder modules (React Flare). ' +\n            'Try wrapping in a conditional, i.e. `if (event.type !== \"press\") { event.%s }`',\n          name,\n          name,\n        );\n      }\n    };\n    eventValue.isDefaultPrevented = () => {\n      if (__DEV__) {\n        showWarning('isDefaultPrevented()');\n      }\n    };\n    eventValue.isPropagationStopped = () => {\n      if (__DEV__) {\n        showWarning('isPropagationStopped()');\n      }\n    };\n    // $FlowFixMe: we don't need value, Flow thinks we do\n    Object.defineProperty(eventValue, 'nativeEvent', {\n      get() {\n        if (__DEV__) {\n          showWarning('nativeEvent');\n        }\n      },\n    });\n  }\n}\n\nfunction doesFiberHaveResponder(\n  fiber: Fiber,\n  responder: ReactDOMEventResponder,\n): boolean {\n  const tag = fiber.tag;\n  if (tag === HostComponent || tag === ScopeComponent) {\n    const dependencies = fiber.dependencies;\n    if (dependencies !== null) {\n      const respondersMap = dependencies.responders;\n      if (respondersMap !== null && respondersMap.has(responder)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfunction getActiveDocument(): Document {\n  return ((currentDocument: any): Document);\n}\n\nfunction createDOMResponderEvent(\n  topLevelType: string,\n  nativeEvent: AnyNativeEvent,\n  nativeEventTarget: Element | Document,\n  passive: boolean,\n  passiveSupported: boolean,\n): ReactDOMResponderEvent {\n  const {buttons, pointerType} = (nativeEvent: any);\n  let eventPointerType = '';\n\n  if (pointerType !== undefined) {\n    eventPointerType = pointerType;\n  } else if (nativeEvent.key !== undefined) {\n    eventPointerType = 'keyboard';\n  } else if (buttons !== undefined) {\n    eventPointerType = 'mouse';\n  } else if ((nativeEvent: any).changedTouches !== undefined) {\n    eventPointerType = 'touch';\n  }\n\n  return {\n    nativeEvent: nativeEvent,\n    passive,\n    passiveSupported,\n    pointerType: eventPointerType,\n    target: nativeEventTarget,\n    type: topLevelType,\n  };\n}\n\nfunction responderEventTypesContainType(\n  eventTypes: Array<string>,\n  type: string,\n): boolean {\n  for (let i = 0, len = eventTypes.length; i < len; i++) {\n    if (eventTypes[i] === type) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction validateResponderTargetEventTypes(\n  eventType: string,\n  responder: ReactDOMEventResponder,\n): boolean {\n  const {targetEventTypes} = responder;\n  // Validate the target event type exists on the responder\n  if (targetEventTypes !== null) {\n    return responderEventTypesContainType(targetEventTypes, eventType);\n  }\n  return false;\n}\n\nfunction traverseAndHandleEventResponderInstances(\n  topLevelType: string,\n  targetFiber: null | Fiber,\n  nativeEvent: AnyNativeEvent,\n  nativeEventTarget: Document | Element,\n  eventSystemFlags: EventSystemFlags,\n): void {\n  const isPassiveEvent = (eventSystemFlags & IS_PASSIVE) !== 0;\n  const isPassiveSupported = (eventSystemFlags & PASSIVE_NOT_SUPPORTED) === 0;\n  const isPassive = isPassiveEvent || !isPassiveSupported;\n  const eventType = isPassive ? topLevelType : topLevelType + '_active';\n\n  // Trigger event responders in this order:\n  // - Bubble target responder phase\n  // - Root responder phase\n\n  const visitedResponders = new Set();\n  const responderEvent = createDOMResponderEvent(\n    topLevelType,\n    nativeEvent,\n    nativeEventTarget,\n    isPassiveEvent,\n    isPassiveSupported,\n  );\n  let node = targetFiber;\n  let insidePortal = false;\n  while (node !== null) {\n    const {dependencies, tag} = node;\n    if (tag === HostPortal) {\n      insidePortal = true;\n    } else if (\n      (tag === HostComponent || tag === ScopeComponent) &&\n      dependencies !== null\n    ) {\n      const respondersMap = dependencies.responders;\n      if (respondersMap !== null) {\n        const responderInstances = Array.from(respondersMap.values());\n        for (let i = 0, length = responderInstances.length; i < length; i++) {\n          const responderInstance = responderInstances[i];\n          const {props, responder, state} = responderInstance;\n          if (\n            !visitedResponders.has(responder) &&\n            validateResponderTargetEventTypes(eventType, responder) &&\n            (!insidePortal || responder.targetPortalPropagation)\n          ) {\n            visitedResponders.add(responder);\n            const onEvent = responder.onEvent;\n            if (onEvent !== null) {\n              currentInstance = responderInstance;\n              onEvent(responderEvent, eventResponderContext, props, state);\n              if (currentPropagationBehavior === PropagateToNextResponder) {\n                visitedResponders.delete(responder);\n                currentPropagationBehavior = DoNotPropagateToNextResponder;\n              }\n            }\n          }\n        }\n      }\n    }\n    node = node.return;\n  }\n  // Root phase\n  const rootEventResponderInstances = rootEventTypesToEventResponderInstances.get(\n    eventType,\n  );\n  if (rootEventResponderInstances !== undefined) {\n    const responderInstances = Array.from(rootEventResponderInstances);\n\n    for (let i = 0; i < responderInstances.length; i++) {\n      const responderInstance = responderInstances[i];\n      const {props, responder, state} = responderInstance;\n      const onRootEvent = responder.onRootEvent;\n      if (onRootEvent !== null) {\n        currentInstance = responderInstance;\n        onRootEvent(responderEvent, eventResponderContext, props, state);\n      }\n    }\n  }\n}\n\nexport function mountEventResponder(\n  responder: ReactDOMEventResponder,\n  responderInstance: ReactDOMEventResponderInstance,\n  props: Object,\n  state: Object,\n) {\n  const onMount = responder.onMount;\n  if (onMount !== null) {\n    const previousInstance = currentInstance;\n    currentInstance = responderInstance;\n    try {\n      batchedEventUpdates(() => {\n        onMount(eventResponderContext, props, state);\n      });\n    } finally {\n      currentInstance = previousInstance;\n    }\n  }\n}\n\nexport function unmountEventResponder(\n  responderInstance: ReactDOMEventResponderInstance,\n): void {\n  const responder = ((responderInstance.responder: any): ReactDOMEventResponder);\n  const onUnmount = responder.onUnmount;\n  if (onUnmount !== null) {\n    let {props, state} = responderInstance;\n    const previousInstance = currentInstance;\n    currentInstance = responderInstance;\n    try {\n      batchedEventUpdates(() => {\n        onUnmount(eventResponderContext, props, state);\n      });\n    } finally {\n      currentInstance = previousInstance;\n    }\n  }\n  const rootEventTypesSet = responderInstance.rootEventTypes;\n  if (rootEventTypesSet !== null) {\n    const rootEventTypes = Array.from(rootEventTypesSet);\n\n    for (let i = 0; i < rootEventTypes.length; i++) {\n      const topLevelEventType = rootEventTypes[i];\n      let rootEventResponderInstances = rootEventTypesToEventResponderInstances.get(\n        topLevelEventType,\n      );\n      if (rootEventResponderInstances !== undefined) {\n        rootEventResponderInstances.delete(responderInstance);\n      }\n    }\n  }\n}\n\nfunction validateResponderContext(): void {\n  invariant(\n    currentInstance !== null,\n    'An event responder context was used outside of an event cycle.',\n  );\n}\n\nexport function dispatchEventForResponderEventSystem(\n  topLevelType: string,\n  targetFiber: null | Fiber,\n  nativeEvent: AnyNativeEvent,\n  nativeEventTarget: Document | Element,\n  eventSystemFlags: EventSystemFlags,\n): void {\n  if (enableFlareAPI) {\n    const previousInstance = currentInstance;\n    const previousTimeStamp = currentTimeStamp;\n    const previousDocument = currentDocument;\n    const previousPropagationBehavior = currentPropagationBehavior;\n    currentPropagationBehavior = DoNotPropagateToNextResponder;\n    // nodeType 9 is DOCUMENT_NODE\n    currentDocument =\n      (nativeEventTarget: any).nodeType === 9\n        ? ((nativeEventTarget: any): Document)\n        : (nativeEventTarget: any).ownerDocument;\n    // We might want to control timeStamp another way here\n    currentTimeStamp = (nativeEvent: any).timeStamp;\n    try {\n      batchedEventUpdates(() => {\n        traverseAndHandleEventResponderInstances(\n          topLevelType,\n          targetFiber,\n          nativeEvent,\n          nativeEventTarget,\n          eventSystemFlags,\n        );\n      });\n    } finally {\n      currentInstance = previousInstance;\n      currentTimeStamp = previousTimeStamp;\n      currentDocument = previousDocument;\n      currentPropagationBehavior = previousPropagationBehavior;\n    }\n  }\n}\n\nexport function addRootEventTypesForResponderInstance(\n  responderInstance: ReactDOMEventResponderInstance,\n  rootEventTypes: Array<string>,\n): void {\n  for (let i = 0; i < rootEventTypes.length; i++) {\n    const rootEventType = rootEventTypes[i];\n    registerRootEventType(rootEventType, responderInstance);\n  }\n}\n\nfunction registerRootEventType(\n  rootEventType: string,\n  eventResponderInstance: ReactDOMEventResponderInstance,\n): void {\n  let rootEventResponderInstances = rootEventTypesToEventResponderInstances.get(\n    rootEventType,\n  );\n  if (rootEventResponderInstances === undefined) {\n    rootEventResponderInstances = new Set();\n    rootEventTypesToEventResponderInstances.set(\n      rootEventType,\n      rootEventResponderInstances,\n    );\n  }\n  let rootEventTypesSet = eventResponderInstance.rootEventTypes;\n  if (rootEventTypesSet === null) {\n    rootEventTypesSet = eventResponderInstance.rootEventTypes = new Set();\n  }\n  invariant(\n    !rootEventTypesSet.has(rootEventType),\n    'addRootEventTypes() found a duplicate root event ' +\n      'type of \"%s\". This might be because the event type exists in the event responder \"rootEventTypes\" ' +\n      'array or because of a previous addRootEventTypes() using this root event type.',\n    rootEventType,\n  );\n  rootEventTypesSet.add(rootEventType);\n  rootEventResponderInstances.add(eventResponderInstance);\n}\n"]},"metadata":{},"sourceType":"module"}