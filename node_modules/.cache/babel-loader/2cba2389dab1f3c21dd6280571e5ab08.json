{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { HostComponent, HostText } from 'shared/ReactWorkTags';\nimport invariant from 'shared/invariant';\nimport { getParentSuspenseInstance } from './ReactDOMHostConfig';\nconst randomKey = Math.random().toString(36).slice(2);\nconst internalInstanceKey = '__reactInternalInstance$' + randomKey;\nconst internalEventHandlersKey = '__reactEventHandlers$' + randomKey;\nconst internalContainerInstanceKey = '__reactContainere$' + randomKey;\nexport function precacheFiberNode(hostInst, node) {\n  node[internalInstanceKey] = hostInst;\n}\nexport function markContainerAsRoot(hostRoot, node) {\n  node[internalContainerInstanceKey] = hostRoot;\n} // Given a DOM node, return the closest HostComponent or HostText fiber ancestor.\n// If the target node is part of a hydrated or not yet rendered subtree, then\n// this may also return a SuspenseComponent or HostRoot to indicate that.\n// Conceptually the HostRoot fiber is a child of the Container node. So if you\n// pass the Container node as the targetNode, you wiill not actually get the\n// HostRoot back. To get to the HostRoot, you need to pass a child of it.\n// The same thing applies to Suspense boundaries.\n\nexport function getClosestInstanceFromNode(targetNode) {\n  let targetInst = targetNode[internalInstanceKey];\n\n  if (targetInst) {\n    // Don't return HostRoot or SuspenseComponent here.\n    return targetInst;\n  } // If the direct event target isn't a React owned DOM node, we need to look\n  // to see if one of its parents is a React owned DOM node.\n\n\n  let parentNode = targetNode.parentNode;\n\n  while (parentNode) {\n    // We'll check if this is a container root that could include\n    // React nodes in the future. We need to check this first because\n    // if we're a child of a dehydrated container, we need to first\n    // find that inner container before moving on to finding the parent\n    // instance. Note that we don't check this field on  the targetNode\n    // itself because the fibers are conceptually between the container\n    // node and the first child. It isn't surrounding the container node.\n    // If it's not a container, we check if it's an instance.\n    targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey];\n\n    if (targetInst) {\n      // Since this wasn't the direct target of the event, we might have\n      // stepped past dehydrated DOM nodes to get here. However they could\n      // also have been non-React nodes. We need to answer which one.\n      // If we the instance doesn't have any children, then there can't be\n      // a nested suspense boundary within it. So we can use this as a fast\n      // bailout. Most of the time, when people add non-React children to\n      // the tree, it is using a ref to a child-less DOM node.\n      // We only need to check one of the fibers because if it has ever\n      // gone from having children to deleting them or vice versa it would\n      // have deleted the dehydrated boundary nested inside already.\n      if (targetInst.child !== null) {\n        // Next we need to figure out if the node that skipped past is\n        // nested within a dehydrated boundary and if so, which one.\n        let suspenseInstance = getParentSuspenseInstance(targetNode);\n\n        if (suspenseInstance !== null) {\n          // We found a suspense instance. That means that we haven't\n          // hydrated it yet. Even though we leave the comments in the\n          // DOM after hydrating, and there are boundaries in the DOM\n          // that could already be hydrated, we wouldn't have found them\n          // through this pass since if the target is hydrated it would\n          // have had an internalInstanceKey on it.\n          // Let's get the fiber associated with the SuspenseComponent\n          // as the deepest instance.\n          let targetSuspenseInst = suspenseInstance[internalInstanceKey];\n\n          if (targetSuspenseInst) {\n            return targetSuspenseInst;\n          } // If we don't find a Fiber on the comment, it might be because\n          // we haven't gotten to hydrate it yet. That should mean that\n          // the parent component also hasn't hydrated yet but we can\n          // just return that since it will bail out on the isMounted\n          // check.\n\n        }\n      }\n\n      return targetInst;\n    }\n\n    targetNode = parentNode;\n    parentNode = targetNode.parentNode;\n  }\n\n  return null;\n}\n/**\n * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent\n * instance, or null if the node was not rendered by this React.\n */\n\nexport function getInstanceFromNode(node) {\n  const inst = node[internalInstanceKey];\n\n  if (inst) {\n    if (inst.tag === HostComponent || inst.tag === HostText) {\n      return inst;\n    } else {\n      return null;\n    }\n  }\n\n  return null;\n}\n/**\n * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding\n * DOM node.\n */\n\nexport function getNodeFromInstance(inst) {\n  if (inst.tag === HostComponent || inst.tag === HostText) {\n    // In Fiber this, is just the state node right now. We assume it will be\n    // a host component or host text.\n    return inst.stateNode;\n  } // Without this first invariant, passing a non-DOM-component triggers the next\n  // invariant for a missing parent, which is super confusing.\n\n\n  invariant(false, 'getNodeFromInstance: Invalid argument.');\n}\nexport function getFiberCurrentPropsFromNode(node) {\n  return node[internalEventHandlersKey] || null;\n}\nexport function updateFiberProps(node, props) {\n  node[internalEventHandlersKey] = props;\n}","map":{"version":3,"sources":["/Users/gaoshaoyun/Documents/library/debug-react/src/react/packages/react-dom/src/client/ReactDOMComponentTree.js"],"names":["HostComponent","HostText","invariant","getParentSuspenseInstance","randomKey","Math","random","toString","slice","internalInstanceKey","internalEventHandlersKey","internalContainerInstanceKey","precacheFiberNode","hostInst","node","markContainerAsRoot","hostRoot","getClosestInstanceFromNode","targetNode","targetInst","parentNode","child","suspenseInstance","targetSuspenseInst","getInstanceFromNode","inst","tag","getNodeFromInstance","stateNode","getFiberCurrentPropsFromNode","updateFiberProps","props"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {HostComponent, HostText} from 'shared/ReactWorkTags';\nimport invariant from 'shared/invariant';\n\nimport {getParentSuspenseInstance} from './ReactDOMHostConfig';\n\nconst randomKey = Math.random()\n  .toString(36)\n  .slice(2);\nconst internalInstanceKey = '__reactInternalInstance$' + randomKey;\nconst internalEventHandlersKey = '__reactEventHandlers$' + randomKey;\nconst internalContainerInstanceKey = '__reactContainere$' + randomKey;\n\nexport function precacheFiberNode(hostInst, node) {\n  node[internalInstanceKey] = hostInst;\n}\n\nexport function markContainerAsRoot(hostRoot, node) {\n  node[internalContainerInstanceKey] = hostRoot;\n}\n\n// Given a DOM node, return the closest HostComponent or HostText fiber ancestor.\n// If the target node is part of a hydrated or not yet rendered subtree, then\n// this may also return a SuspenseComponent or HostRoot to indicate that.\n// Conceptually the HostRoot fiber is a child of the Container node. So if you\n// pass the Container node as the targetNode, you wiill not actually get the\n// HostRoot back. To get to the HostRoot, you need to pass a child of it.\n// The same thing applies to Suspense boundaries.\nexport function getClosestInstanceFromNode(targetNode) {\n  let targetInst = targetNode[internalInstanceKey];\n  if (targetInst) {\n    // Don't return HostRoot or SuspenseComponent here.\n    return targetInst;\n  }\n  // If the direct event target isn't a React owned DOM node, we need to look\n  // to see if one of its parents is a React owned DOM node.\n  let parentNode = targetNode.parentNode;\n  while (parentNode) {\n    // We'll check if this is a container root that could include\n    // React nodes in the future. We need to check this first because\n    // if we're a child of a dehydrated container, we need to first\n    // find that inner container before moving on to finding the parent\n    // instance. Note that we don't check this field on  the targetNode\n    // itself because the fibers are conceptually between the container\n    // node and the first child. It isn't surrounding the container node.\n    // If it's not a container, we check if it's an instance.\n    targetInst =\n      parentNode[internalContainerInstanceKey] ||\n      parentNode[internalInstanceKey];\n    if (targetInst) {\n      // Since this wasn't the direct target of the event, we might have\n      // stepped past dehydrated DOM nodes to get here. However they could\n      // also have been non-React nodes. We need to answer which one.\n\n      // If we the instance doesn't have any children, then there can't be\n      // a nested suspense boundary within it. So we can use this as a fast\n      // bailout. Most of the time, when people add non-React children to\n      // the tree, it is using a ref to a child-less DOM node.\n      // We only need to check one of the fibers because if it has ever\n      // gone from having children to deleting them or vice versa it would\n      // have deleted the dehydrated boundary nested inside already.\n      if (targetInst.child !== null) {\n        // Next we need to figure out if the node that skipped past is\n        // nested within a dehydrated boundary and if so, which one.\n        let suspenseInstance = getParentSuspenseInstance(targetNode);\n        if (suspenseInstance !== null) {\n          // We found a suspense instance. That means that we haven't\n          // hydrated it yet. Even though we leave the comments in the\n          // DOM after hydrating, and there are boundaries in the DOM\n          // that could already be hydrated, we wouldn't have found them\n          // through this pass since if the target is hydrated it would\n          // have had an internalInstanceKey on it.\n          // Let's get the fiber associated with the SuspenseComponent\n          // as the deepest instance.\n          let targetSuspenseInst = suspenseInstance[internalInstanceKey];\n          if (targetSuspenseInst) {\n            return targetSuspenseInst;\n          }\n          // If we don't find a Fiber on the comment, it might be because\n          // we haven't gotten to hydrate it yet. That should mean that\n          // the parent component also hasn't hydrated yet but we can\n          // just return that since it will bail out on the isMounted\n          // check.\n        }\n      }\n      return targetInst;\n    }\n    targetNode = parentNode;\n    parentNode = targetNode.parentNode;\n  }\n  return null;\n}\n\n/**\n * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent\n * instance, or null if the node was not rendered by this React.\n */\nexport function getInstanceFromNode(node) {\n  const inst = node[internalInstanceKey];\n  if (inst) {\n    if (inst.tag === HostComponent || inst.tag === HostText) {\n      return inst;\n    } else {\n      return null;\n    }\n  }\n  return null;\n}\n\n/**\n * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding\n * DOM node.\n */\nexport function getNodeFromInstance(inst) {\n  if (inst.tag === HostComponent || inst.tag === HostText) {\n    // In Fiber this, is just the state node right now. We assume it will be\n    // a host component or host text.\n    return inst.stateNode;\n  }\n\n  // Without this first invariant, passing a non-DOM-component triggers the next\n  // invariant for a missing parent, which is super confusing.\n  invariant(false, 'getNodeFromInstance: Invalid argument.');\n}\n\nexport function getFiberCurrentPropsFromNode(node) {\n  return node[internalEventHandlersKey] || null;\n}\n\nexport function updateFiberProps(node, props) {\n  node[internalEventHandlersKey] = props;\n}\n"]},"metadata":{},"sourceType":"module"}