{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { accumulateEnterLeaveDispatches } from 'legacy-events/EventPropagators';\nimport { TOP_MOUSE_OUT, TOP_MOUSE_OVER, TOP_POINTER_OUT, TOP_POINTER_OVER } from './DOMTopLevelEventTypes';\nimport { IS_REPLAYED } from 'legacy-events/EventSystemFlags';\nimport SyntheticMouseEvent from './SyntheticMouseEvent';\nimport SyntheticPointerEvent from './SyntheticPointerEvent';\nimport { getClosestInstanceFromNode, getNodeFromInstance } from '../client/ReactDOMComponentTree';\nimport { HostComponent, HostText } from 'shared/ReactWorkTags';\nimport { getNearestMountedFiber } from 'react-reconciler/reflection';\nconst eventTypes = {\n  mouseEnter: {\n    registrationName: 'onMouseEnter',\n    dependencies: [TOP_MOUSE_OUT, TOP_MOUSE_OVER]\n  },\n  mouseLeave: {\n    registrationName: 'onMouseLeave',\n    dependencies: [TOP_MOUSE_OUT, TOP_MOUSE_OVER]\n  },\n  pointerEnter: {\n    registrationName: 'onPointerEnter',\n    dependencies: [TOP_POINTER_OUT, TOP_POINTER_OVER]\n  },\n  pointerLeave: {\n    registrationName: 'onPointerLeave',\n    dependencies: [TOP_POINTER_OUT, TOP_POINTER_OVER]\n  }\n}; // We track the lastNativeEvent to ensure that when we encounter\n// cases where we process the same nativeEvent multiple times,\n// which can happen when have multiple ancestors, that we don't\n// duplicate enter\n\nlet lastNativeEvent;\nconst EnterLeaveEventPlugin = {\n  eventTypes: eventTypes,\n\n  /**\n   * For almost every interaction we care about, there will be both a top-level\n   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that\n   * we do not extract duplicate events. However, moving the mouse into the\n   * browser from outside will not fire a `mouseout` event. In this case, we use\n   * the `mouseover` top-level event.\n   */\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags) {\n    const isOverEvent = topLevelType === TOP_MOUSE_OVER || topLevelType === TOP_POINTER_OVER;\n    const isOutEvent = topLevelType === TOP_MOUSE_OUT || topLevelType === TOP_POINTER_OUT;\n\n    if (isOverEvent && (eventSystemFlags & IS_REPLAYED) === 0 && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {\n      // If this is an over event with a target, then we've already dispatched\n      // the event in the out event of the other target. If this is replayed,\n      // then it's because we couldn't dispatch against this target previously\n      // so we have to do it now instead.\n      return null;\n    }\n\n    if (!isOutEvent && !isOverEvent) {\n      // Must not be a mouse or pointer in or out - ignoring.\n      return null;\n    }\n\n    let win;\n\n    if (nativeEventTarget.window === nativeEventTarget) {\n      // `nativeEventTarget` is probably a window object.\n      win = nativeEventTarget;\n    } else {\n      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.\n      const doc = nativeEventTarget.ownerDocument;\n\n      if (doc) {\n        win = doc.defaultView || doc.parentWindow;\n      } else {\n        win = window;\n      }\n    }\n\n    let from;\n    let to;\n\n    if (isOutEvent) {\n      from = targetInst;\n      const related = nativeEvent.relatedTarget || nativeEvent.toElement;\n      to = related ? getClosestInstanceFromNode(related) : null;\n\n      if (to !== null) {\n        const nearestMounted = getNearestMountedFiber(to);\n\n        if (to !== nearestMounted || to.tag !== HostComponent && to.tag !== HostText) {\n          to = null;\n        }\n      }\n    } else {\n      // Moving to a node from outside the window.\n      from = null;\n      to = targetInst;\n    }\n\n    if (from === to) {\n      // Nothing pertains to our managed components.\n      return null;\n    }\n\n    let eventInterface, leaveEventType, enterEventType, eventTypePrefix;\n\n    if (topLevelType === TOP_MOUSE_OUT || topLevelType === TOP_MOUSE_OVER) {\n      eventInterface = SyntheticMouseEvent;\n      leaveEventType = eventTypes.mouseLeave;\n      enterEventType = eventTypes.mouseEnter;\n      eventTypePrefix = 'mouse';\n    } else if (topLevelType === TOP_POINTER_OUT || topLevelType === TOP_POINTER_OVER) {\n      eventInterface = SyntheticPointerEvent;\n      leaveEventType = eventTypes.pointerLeave;\n      enterEventType = eventTypes.pointerEnter;\n      eventTypePrefix = 'pointer';\n    }\n\n    const fromNode = from == null ? win : getNodeFromInstance(from);\n    const toNode = to == null ? win : getNodeFromInstance(to);\n    const leave = eventInterface.getPooled(leaveEventType, from, nativeEvent, nativeEventTarget);\n    leave.type = eventTypePrefix + 'leave';\n    leave.target = fromNode;\n    leave.relatedTarget = toNode;\n    const enter = eventInterface.getPooled(enterEventType, to, nativeEvent, nativeEventTarget);\n    enter.type = eventTypePrefix + 'enter';\n    enter.target = toNode;\n    enter.relatedTarget = fromNode;\n    accumulateEnterLeaveDispatches(leave, enter, from, to);\n\n    if (nativeEvent === lastNativeEvent) {\n      lastNativeEvent = null;\n      return [leave];\n    }\n\n    lastNativeEvent = nativeEvent;\n    return [leave, enter];\n  }\n};\nexport default EnterLeaveEventPlugin;","map":{"version":3,"sources":["/Users/gaoshaoyun/Documents/library/debug-react/src/react/packages/react-dom/src/events/EnterLeaveEventPlugin.js"],"names":["accumulateEnterLeaveDispatches","TOP_MOUSE_OUT","TOP_MOUSE_OVER","TOP_POINTER_OUT","TOP_POINTER_OVER","IS_REPLAYED","SyntheticMouseEvent","SyntheticPointerEvent","getClosestInstanceFromNode","getNodeFromInstance","HostComponent","HostText","getNearestMountedFiber","eventTypes","mouseEnter","registrationName","dependencies","mouseLeave","pointerEnter","pointerLeave","lastNativeEvent","EnterLeaveEventPlugin","extractEvents","topLevelType","targetInst","nativeEvent","nativeEventTarget","eventSystemFlags","isOverEvent","isOutEvent","relatedTarget","fromElement","win","window","doc","ownerDocument","defaultView","parentWindow","from","to","related","toElement","nearestMounted","tag","eventInterface","leaveEventType","enterEventType","eventTypePrefix","fromNode","toNode","leave","getPooled","type","target","enter"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {accumulateEnterLeaveDispatches} from 'legacy-events/EventPropagators';\n\nimport {\n  TOP_MOUSE_OUT,\n  TOP_MOUSE_OVER,\n  TOP_POINTER_OUT,\n  TOP_POINTER_OVER,\n} from './DOMTopLevelEventTypes';\nimport {IS_REPLAYED} from 'legacy-events/EventSystemFlags';\nimport SyntheticMouseEvent from './SyntheticMouseEvent';\nimport SyntheticPointerEvent from './SyntheticPointerEvent';\nimport {\n  getClosestInstanceFromNode,\n  getNodeFromInstance,\n} from '../client/ReactDOMComponentTree';\nimport {HostComponent, HostText} from 'shared/ReactWorkTags';\nimport {getNearestMountedFiber} from 'react-reconciler/reflection';\n\nconst eventTypes = {\n  mouseEnter: {\n    registrationName: 'onMouseEnter',\n    dependencies: [TOP_MOUSE_OUT, TOP_MOUSE_OVER],\n  },\n  mouseLeave: {\n    registrationName: 'onMouseLeave',\n    dependencies: [TOP_MOUSE_OUT, TOP_MOUSE_OVER],\n  },\n  pointerEnter: {\n    registrationName: 'onPointerEnter',\n    dependencies: [TOP_POINTER_OUT, TOP_POINTER_OVER],\n  },\n  pointerLeave: {\n    registrationName: 'onPointerLeave',\n    dependencies: [TOP_POINTER_OUT, TOP_POINTER_OVER],\n  },\n};\n\n// We track the lastNativeEvent to ensure that when we encounter\n// cases where we process the same nativeEvent multiple times,\n// which can happen when have multiple ancestors, that we don't\n// duplicate enter\nlet lastNativeEvent;\n\nconst EnterLeaveEventPlugin = {\n  eventTypes: eventTypes,\n\n  /**\n   * For almost every interaction we care about, there will be both a top-level\n   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that\n   * we do not extract duplicate events. However, moving the mouse into the\n   * browser from outside will not fire a `mouseout` event. In this case, we use\n   * the `mouseover` top-level event.\n   */\n  extractEvents: function(\n    topLevelType,\n    targetInst,\n    nativeEvent,\n    nativeEventTarget,\n    eventSystemFlags,\n  ) {\n    const isOverEvent =\n      topLevelType === TOP_MOUSE_OVER || topLevelType === TOP_POINTER_OVER;\n    const isOutEvent =\n      topLevelType === TOP_MOUSE_OUT || topLevelType === TOP_POINTER_OUT;\n\n    if (\n      isOverEvent &&\n      (eventSystemFlags & IS_REPLAYED) === 0 &&\n      (nativeEvent.relatedTarget || nativeEvent.fromElement)\n    ) {\n      // If this is an over event with a target, then we've already dispatched\n      // the event in the out event of the other target. If this is replayed,\n      // then it's because we couldn't dispatch against this target previously\n      // so we have to do it now instead.\n      return null;\n    }\n\n    if (!isOutEvent && !isOverEvent) {\n      // Must not be a mouse or pointer in or out - ignoring.\n      return null;\n    }\n\n    let win;\n    if (nativeEventTarget.window === nativeEventTarget) {\n      // `nativeEventTarget` is probably a window object.\n      win = nativeEventTarget;\n    } else {\n      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.\n      const doc = nativeEventTarget.ownerDocument;\n      if (doc) {\n        win = doc.defaultView || doc.parentWindow;\n      } else {\n        win = window;\n      }\n    }\n\n    let from;\n    let to;\n    if (isOutEvent) {\n      from = targetInst;\n      const related = nativeEvent.relatedTarget || nativeEvent.toElement;\n      to = related ? getClosestInstanceFromNode(related) : null;\n      if (to !== null) {\n        const nearestMounted = getNearestMountedFiber(to);\n        if (\n          to !== nearestMounted ||\n          (to.tag !== HostComponent && to.tag !== HostText)\n        ) {\n          to = null;\n        }\n      }\n    } else {\n      // Moving to a node from outside the window.\n      from = null;\n      to = targetInst;\n    }\n\n    if (from === to) {\n      // Nothing pertains to our managed components.\n      return null;\n    }\n\n    let eventInterface, leaveEventType, enterEventType, eventTypePrefix;\n\n    if (topLevelType === TOP_MOUSE_OUT || topLevelType === TOP_MOUSE_OVER) {\n      eventInterface = SyntheticMouseEvent;\n      leaveEventType = eventTypes.mouseLeave;\n      enterEventType = eventTypes.mouseEnter;\n      eventTypePrefix = 'mouse';\n    } else if (\n      topLevelType === TOP_POINTER_OUT ||\n      topLevelType === TOP_POINTER_OVER\n    ) {\n      eventInterface = SyntheticPointerEvent;\n      leaveEventType = eventTypes.pointerLeave;\n      enterEventType = eventTypes.pointerEnter;\n      eventTypePrefix = 'pointer';\n    }\n\n    const fromNode = from == null ? win : getNodeFromInstance(from);\n    const toNode = to == null ? win : getNodeFromInstance(to);\n\n    const leave = eventInterface.getPooled(\n      leaveEventType,\n      from,\n      nativeEvent,\n      nativeEventTarget,\n    );\n    leave.type = eventTypePrefix + 'leave';\n    leave.target = fromNode;\n    leave.relatedTarget = toNode;\n\n    const enter = eventInterface.getPooled(\n      enterEventType,\n      to,\n      nativeEvent,\n      nativeEventTarget,\n    );\n    enter.type = eventTypePrefix + 'enter';\n    enter.target = toNode;\n    enter.relatedTarget = fromNode;\n\n    accumulateEnterLeaveDispatches(leave, enter, from, to);\n\n    if (nativeEvent === lastNativeEvent) {\n      lastNativeEvent = null;\n      return [leave];\n    }\n    lastNativeEvent = nativeEvent;\n\n    return [leave, enter];\n  },\n};\n\nexport default EnterLeaveEventPlugin;\n"]},"metadata":{},"sourceType":"module"}