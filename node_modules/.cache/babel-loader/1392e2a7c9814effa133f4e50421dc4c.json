{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { mountResponderInstance, unmountResponderInstance } from './ReactFiberHostConfig';\nimport { NoWork } from './ReactFiberExpirationTime';\nimport warning from 'shared/warning';\nimport { REACT_RESPONDER_TYPE } from 'shared/ReactSymbols';\nimport invariant from 'shared/invariant';\nimport { HostComponent, HostRoot } from 'shared/ReactWorkTags';\nconst emptyObject = {};\nconst isArray = Array.isArray;\nexport function createResponderInstance(responder, responderProps, responderState, fiber) {\n  return {\n    fiber,\n    props: responderProps,\n    responder,\n    rootEventTypes: null,\n    state: responderState\n  };\n}\n\nfunction mountEventResponder(responder, responderProps, fiber, respondersMap, rootContainerInstance) {\n  let responderState = emptyObject;\n  const getInitialState = responder.getInitialState;\n\n  if (getInitialState !== null) {\n    responderState = getInitialState(responderProps);\n  }\n\n  const responderInstance = createResponderInstance(responder, responderProps, responderState, fiber);\n\n  if (!rootContainerInstance) {\n    let node = fiber;\n\n    while (node !== null) {\n      const tag = node.tag;\n\n      if (tag === HostComponent) {\n        rootContainerInstance = node.stateNode;\n        break;\n      } else if (tag === HostRoot) {\n        rootContainerInstance = node.stateNode.containerInfo;\n        break;\n      }\n\n      node = node.return;\n    }\n  }\n\n  mountResponderInstance(responder, responderInstance, responderProps, responderState, rootContainerInstance);\n  respondersMap.set(responder, responderInstance);\n}\n\nfunction updateEventListener(listener, fiber, visistedResponders, respondersMap, rootContainerInstance) {\n  let responder;\n  let props;\n\n  if (listener) {\n    responder = listener.responder;\n    props = listener.props;\n  }\n\n  invariant(responder && responder.$$typeof === REACT_RESPONDER_TYPE, 'An invalid value was used as an event listener. Expect one or many event ' + 'listeners created via React.unstable_useResponder().');\n  const listenerProps = props;\n\n  if (visistedResponders.has(responder)) {\n    // show warning\n    if (__DEV__) {\n      warning(false, 'Duplicate event responder \"%s\" found in event listeners. ' + 'Event listeners passed to elements cannot use the same event responder more than once.', responder.displayName);\n    }\n\n    return;\n  }\n\n  visistedResponders.add(responder);\n  const responderInstance = respondersMap.get(responder);\n\n  if (responderInstance === undefined) {\n    // Mount (happens in either complete or commit phase)\n    mountEventResponder(responder, listenerProps, fiber, respondersMap, rootContainerInstance);\n  } else {\n    // Update (happens during commit phase only)\n    responderInstance.props = listenerProps;\n    responderInstance.fiber = fiber;\n  }\n}\n\nexport function updateEventListeners(listeners, fiber, rootContainerInstance) {\n  const visistedResponders = new Set();\n  let dependencies = fiber.dependencies;\n\n  if (listeners != null) {\n    if (dependencies === null) {\n      dependencies = fiber.dependencies = {\n        expirationTime: NoWork,\n        firstContext: null,\n        responders: new Map()\n      };\n    }\n\n    let respondersMap = dependencies.responders;\n\n    if (respondersMap === null) {\n      respondersMap = new Map();\n    }\n\n    if (isArray(listeners)) {\n      for (let i = 0, length = listeners.length; i < length; i++) {\n        const listener = listeners[i];\n        updateEventListener(listener, fiber, visistedResponders, respondersMap, rootContainerInstance);\n      }\n    } else {\n      updateEventListener(listeners, fiber, visistedResponders, respondersMap, rootContainerInstance);\n    }\n  }\n\n  if (dependencies !== null) {\n    const respondersMap = dependencies.responders;\n\n    if (respondersMap !== null) {\n      // Unmount\n      const mountedResponders = Array.from(respondersMap.keys());\n\n      for (let i = 0, length = mountedResponders.length; i < length; i++) {\n        const mountedResponder = mountedResponders[i];\n\n        if (!visistedResponders.has(mountedResponder)) {\n          const responderInstance = respondersMap.get(mountedResponder);\n          unmountResponderInstance(responderInstance);\n          respondersMap.delete(mountedResponder);\n        }\n      }\n    }\n  }\n}\nexport function createResponderListener(responder, props) {\n  const eventResponderListener = {\n    responder,\n    props\n  };\n\n  if (__DEV__) {\n    Object.freeze(eventResponderListener);\n  }\n\n  return eventResponderListener;\n}","map":{"version":3,"sources":["/Users/gaoshaoyun/Documents/library/debug-react/src/react/packages/react-reconciler/src/ReactFiberEvents.js"],"names":["mountResponderInstance","unmountResponderInstance","NoWork","warning","REACT_RESPONDER_TYPE","invariant","HostComponent","HostRoot","emptyObject","isArray","Array","createResponderInstance","responder","responderProps","responderState","fiber","props","rootEventTypes","state","mountEventResponder","respondersMap","rootContainerInstance","getInitialState","responderInstance","node","tag","stateNode","containerInfo","return","set","updateEventListener","listener","visistedResponders","$$typeof","listenerProps","has","__DEV__","displayName","add","get","undefined","updateEventListeners","listeners","Set","dependencies","expirationTime","firstContext","responders","Map","i","length","mountedResponders","from","keys","mountedResponder","delete","createResponderListener","eventResponderListener","Object","freeze"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber} from './ReactFiber';\nimport type {Container, Instance} from './ReactFiberHostConfig';\nimport type {\n  ReactEventResponder,\n  ReactEventResponderInstance,\n  ReactEventResponderListener,\n} from 'shared/ReactTypes';\n\nimport {\n  mountResponderInstance,\n  unmountResponderInstance,\n} from './ReactFiberHostConfig';\nimport {NoWork} from './ReactFiberExpirationTime';\n\nimport warning from 'shared/warning';\nimport {REACT_RESPONDER_TYPE} from 'shared/ReactSymbols';\n\nimport invariant from 'shared/invariant';\nimport {HostComponent, HostRoot} from 'shared/ReactWorkTags';\n\nconst emptyObject = {};\nconst isArray = Array.isArray;\n\nexport function createResponderInstance(\n  responder: ReactEventResponder<any, any>,\n  responderProps: Object,\n  responderState: Object,\n  fiber: Fiber,\n): ReactEventResponderInstance<any, any> {\n  return {\n    fiber,\n    props: responderProps,\n    responder,\n    rootEventTypes: null,\n    state: responderState,\n  };\n}\n\nfunction mountEventResponder(\n  responder: ReactEventResponder<any, any>,\n  responderProps: Object,\n  fiber: Fiber,\n  respondersMap: Map<\n    ReactEventResponder<any, any>,\n    ReactEventResponderInstance<any, any>,\n  >,\n  rootContainerInstance: null | Container,\n) {\n  let responderState = emptyObject;\n  const getInitialState = responder.getInitialState;\n  if (getInitialState !== null) {\n    responderState = getInitialState(responderProps);\n  }\n  const responderInstance = createResponderInstance(\n    responder,\n    responderProps,\n    responderState,\n    fiber,\n  );\n\n  if (!rootContainerInstance) {\n    let node = fiber;\n    while (node !== null) {\n      const tag = node.tag;\n      if (tag === HostComponent) {\n        rootContainerInstance = node.stateNode;\n        break;\n      } else if (tag === HostRoot) {\n        rootContainerInstance = node.stateNode.containerInfo;\n        break;\n      }\n      node = node.return;\n    }\n  }\n\n  mountResponderInstance(\n    responder,\n    responderInstance,\n    responderProps,\n    responderState,\n    ((rootContainerInstance: any): Instance),\n  );\n  respondersMap.set(responder, responderInstance);\n}\n\nfunction updateEventListener(\n  listener: ReactEventResponderListener<any, any>,\n  fiber: Fiber,\n  visistedResponders: Set<ReactEventResponder<any, any>>,\n  respondersMap: Map<\n    ReactEventResponder<any, any>,\n    ReactEventResponderInstance<any, any>,\n  >,\n  rootContainerInstance: null | Container,\n): void {\n  let responder;\n  let props;\n\n  if (listener) {\n    responder = listener.responder;\n    props = listener.props;\n  }\n  invariant(\n    responder && responder.$$typeof === REACT_RESPONDER_TYPE,\n    'An invalid value was used as an event listener. Expect one or many event ' +\n      'listeners created via React.unstable_useResponder().',\n  );\n  const listenerProps = ((props: any): Object);\n  if (visistedResponders.has(responder)) {\n    // show warning\n    if (__DEV__) {\n      warning(\n        false,\n        'Duplicate event responder \"%s\" found in event listeners. ' +\n          'Event listeners passed to elements cannot use the same event responder more than once.',\n        responder.displayName,\n      );\n    }\n    return;\n  }\n  visistedResponders.add(responder);\n  const responderInstance = respondersMap.get(responder);\n\n  if (responderInstance === undefined) {\n    // Mount (happens in either complete or commit phase)\n    mountEventResponder(\n      responder,\n      listenerProps,\n      fiber,\n      respondersMap,\n      rootContainerInstance,\n    );\n  } else {\n    // Update (happens during commit phase only)\n    responderInstance.props = listenerProps;\n    responderInstance.fiber = fiber;\n  }\n}\n\nexport function updateEventListeners(\n  listeners: any,\n  fiber: Fiber,\n  rootContainerInstance: null | Container,\n): void {\n  const visistedResponders = new Set();\n  let dependencies = fiber.dependencies;\n  if (listeners != null) {\n    if (dependencies === null) {\n      dependencies = fiber.dependencies = {\n        expirationTime: NoWork,\n        firstContext: null,\n        responders: new Map(),\n      };\n    }\n    let respondersMap = dependencies.responders;\n    if (respondersMap === null) {\n      respondersMap = new Map();\n    }\n    if (isArray(listeners)) {\n      for (let i = 0, length = listeners.length; i < length; i++) {\n        const listener = listeners[i];\n        updateEventListener(\n          listener,\n          fiber,\n          visistedResponders,\n          respondersMap,\n          rootContainerInstance,\n        );\n      }\n    } else {\n      updateEventListener(\n        listeners,\n        fiber,\n        visistedResponders,\n        respondersMap,\n        rootContainerInstance,\n      );\n    }\n  }\n  if (dependencies !== null) {\n    const respondersMap = dependencies.responders;\n    if (respondersMap !== null) {\n      // Unmount\n      const mountedResponders = Array.from(respondersMap.keys());\n      for (let i = 0, length = mountedResponders.length; i < length; i++) {\n        const mountedResponder = mountedResponders[i];\n        if (!visistedResponders.has(mountedResponder)) {\n          const responderInstance = ((respondersMap.get(\n            mountedResponder,\n          ): any): ReactEventResponderInstance<any, any>);\n          unmountResponderInstance(responderInstance);\n          respondersMap.delete(mountedResponder);\n        }\n      }\n    }\n  }\n}\n\nexport function createResponderListener(\n  responder: ReactEventResponder<any, any>,\n  props: Object,\n): ReactEventResponderListener<any, any> {\n  const eventResponderListener = {\n    responder,\n    props,\n  };\n  if (__DEV__) {\n    Object.freeze(eventResponderListener);\n  }\n  return eventResponderListener;\n}\n"]},"metadata":{},"sourceType":"module"}