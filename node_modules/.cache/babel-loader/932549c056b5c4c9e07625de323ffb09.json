{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { registrationNameDependencies } from 'legacy-events/EventPluginRegistry';\nimport { TOP_BLUR, TOP_CANCEL, TOP_CLOSE, TOP_FOCUS, TOP_INVALID, TOP_RESET, TOP_SCROLL, TOP_SUBMIT, getRawEventName, mediaEventTypes } from './DOMTopLevelEventTypes';\nimport { setEnabled, isEnabled, trapBubbledEvent, trapCapturedEvent } from './ReactDOMEventListener';\nimport isEventSupported from './isEventSupported';\n/**\n * Summary of `ReactBrowserEventEmitter` event handling:\n *\n *  - Top-level delegation is used to trap most native browser events. This\n *    may only occur in the main thread and is the responsibility of\n *    ReactDOMEventListener, which is injected and can therefore support\n *    pluggable event sources. This is the only work that occurs in the main\n *    thread.\n *\n *  - We normalize and de-duplicate events to account for browser quirks. This\n *    may be done in the worker thread.\n *\n *  - Forward these native events (with the associated top-level type used to\n *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want\n *    to extract any synthetic events.\n *\n *  - The `EventPluginHub` will then process each event by annotating them with\n *    \"dispatches\", a sequence of listeners and IDs that care about that event.\n *\n *  - The `EventPluginHub` then dispatches the events.\n *\n * Overview of React and the event system:\n *\n * +------------+    .\n * |    DOM     |    .\n * +------------+    .\n *       |           .\n *       v           .\n * +------------+    .\n * | ReactEvent |    .\n * |  Listener  |    .\n * +------------+    .                         +-----------+\n *       |           .               +--------+|SimpleEvent|\n *       |           .               |         |Plugin     |\n * +-----|------+    .               v         +-----------+\n * |     |      |    .    +--------------+                    +------------+\n * |     +-----------.--->|EventPluginHub|                    |    Event   |\n * |            |    .    |              |     +-----------+  | Propagators|\n * | ReactEvent |    .    |              |     |TapEvent   |  |------------|\n * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|\n * |            |    .    |              |     +-----------+  |  utilities |\n * |     +-----------.--->|              |                    +------------+\n * |     |      |    .    +--------------+\n * +-----|------+    .                ^        +-----------+\n *       |           .                |        |Enter/Leave|\n *       +           .                +-------+|Plugin     |\n * +-------------+   .                         +-----------+\n * | application |   .\n * |-------------|   .\n * |             |   .\n * |             |   .\n * +-------------+   .\n *                   .\n *    React Core     .  General Purpose Event Plugin System\n */\n\nconst PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\nconst elementListeningSets = new PossiblyWeakMap();\nexport function getListeningSetForElement(element) {\n  let listeningSet = elementListeningSets.get(element);\n\n  if (listeningSet === undefined) {\n    listeningSet = new Set();\n    elementListeningSets.set(element, listeningSet);\n  }\n\n  return listeningSet;\n}\n/**\n * We listen for bubbled touch events on the document object.\n *\n * Firefox v8.01 (and possibly others) exhibited strange behavior when\n * mounting `onmousemove` events at some node that was not the document\n * element. The symptoms were that if your mouse is not moving over something\n * contained within that mount point (for example on the background) the\n * top-level listeners for `onmousemove` won't be called. However, if you\n * register the `mousemove` on the document object, then it will of course\n * catch all `mousemove`s. This along with iOS quirks, justifies restricting\n * top-level listeners to the document object only, at least for these\n * movement types of events and possibly all events.\n *\n * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\n *\n * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but\n * they bubble to document.\n *\n * @param {string} registrationName Name of listener (e.g. `onClick`).\n * @param {object} mountAt Container where to mount the listener\n */\n\nexport function listenTo(registrationName, mountAt) {\n  const listeningSet = getListeningSetForElement(mountAt);\n  const dependencies = registrationNameDependencies[registrationName];\n\n  for (let i = 0; i < dependencies.length; i++) {\n    const dependency = dependencies[i];\n    listenToTopLevel(dependency, mountAt, listeningSet);\n  }\n}\nexport function listenToTopLevel(topLevelType, mountAt, listeningSet) {\n  if (!listeningSet.has(topLevelType)) {\n    switch (topLevelType) {\n      case TOP_SCROLL:\n        trapCapturedEvent(TOP_SCROLL, mountAt);\n        break;\n\n      case TOP_FOCUS:\n      case TOP_BLUR:\n        trapCapturedEvent(TOP_FOCUS, mountAt);\n        trapCapturedEvent(TOP_BLUR, mountAt); // We set the flag for a single dependency later in this function,\n        // but this ensures we mark both as attached rather than just one.\n\n        listeningSet.add(TOP_BLUR);\n        listeningSet.add(TOP_FOCUS);\n        break;\n\n      case TOP_CANCEL:\n      case TOP_CLOSE:\n        if (isEventSupported(getRawEventName(topLevelType))) {\n          trapCapturedEvent(topLevelType, mountAt);\n        }\n\n        break;\n\n      case TOP_INVALID:\n      case TOP_SUBMIT:\n      case TOP_RESET:\n        // We listen to them on the target DOM elements.\n        // Some of them bubble so we don't want them to fire twice.\n        break;\n\n      default:\n        // By default, listen on the top level to all non-media events.\n        // Media events don't bubble so adding the listener wouldn't do anything.\n        const isMediaEvent = mediaEventTypes.indexOf(topLevelType) !== -1;\n\n        if (!isMediaEvent) {\n          trapBubbledEvent(topLevelType, mountAt);\n        }\n\n        break;\n    }\n\n    listeningSet.add(topLevelType);\n  }\n}\nexport function isListeningToAllDependencies(registrationName, mountAt) {\n  const listeningSet = getListeningSetForElement(mountAt);\n  const dependencies = registrationNameDependencies[registrationName];\n\n  for (let i = 0; i < dependencies.length; i++) {\n    const dependency = dependencies[i];\n\n    if (!listeningSet.has(dependency)) {\n      return false;\n    }\n  }\n\n  return true;\n}\nexport { setEnabled, isEnabled, trapBubbledEvent, trapCapturedEvent };","map":{"version":3,"sources":["/Users/gaoshaoyun/Documents/library/debug-react/src/react/packages/react-dom/src/events/ReactBrowserEventEmitter.js"],"names":["registrationNameDependencies","TOP_BLUR","TOP_CANCEL","TOP_CLOSE","TOP_FOCUS","TOP_INVALID","TOP_RESET","TOP_SCROLL","TOP_SUBMIT","getRawEventName","mediaEventTypes","setEnabled","isEnabled","trapBubbledEvent","trapCapturedEvent","isEventSupported","PossiblyWeakMap","WeakMap","Map","elementListeningSets","getListeningSetForElement","element","listeningSet","get","undefined","Set","set","listenTo","registrationName","mountAt","dependencies","i","length","dependency","listenToTopLevel","topLevelType","has","add","isMediaEvent","indexOf","isListeningToAllDependencies"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport {registrationNameDependencies} from 'legacy-events/EventPluginRegistry';\nimport type {DOMTopLevelEventType} from 'legacy-events/TopLevelEventTypes';\nimport {\n  TOP_BLUR,\n  TOP_CANCEL,\n  TOP_CLOSE,\n  TOP_FOCUS,\n  TOP_INVALID,\n  TOP_RESET,\n  TOP_SCROLL,\n  TOP_SUBMIT,\n  getRawEventName,\n  mediaEventTypes,\n} from './DOMTopLevelEventTypes';\nimport {\n  setEnabled,\n  isEnabled,\n  trapBubbledEvent,\n  trapCapturedEvent,\n} from './ReactDOMEventListener';\nimport isEventSupported from './isEventSupported';\n\n/**\n * Summary of `ReactBrowserEventEmitter` event handling:\n *\n *  - Top-level delegation is used to trap most native browser events. This\n *    may only occur in the main thread and is the responsibility of\n *    ReactDOMEventListener, which is injected and can therefore support\n *    pluggable event sources. This is the only work that occurs in the main\n *    thread.\n *\n *  - We normalize and de-duplicate events to account for browser quirks. This\n *    may be done in the worker thread.\n *\n *  - Forward these native events (with the associated top-level type used to\n *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want\n *    to extract any synthetic events.\n *\n *  - The `EventPluginHub` will then process each event by annotating them with\n *    \"dispatches\", a sequence of listeners and IDs that care about that event.\n *\n *  - The `EventPluginHub` then dispatches the events.\n *\n * Overview of React and the event system:\n *\n * +------------+    .\n * |    DOM     |    .\n * +------------+    .\n *       |           .\n *       v           .\n * +------------+    .\n * | ReactEvent |    .\n * |  Listener  |    .\n * +------------+    .                         +-----------+\n *       |           .               +--------+|SimpleEvent|\n *       |           .               |         |Plugin     |\n * +-----|------+    .               v         +-----------+\n * |     |      |    .    +--------------+                    +------------+\n * |     +-----------.--->|EventPluginHub|                    |    Event   |\n * |            |    .    |              |     +-----------+  | Propagators|\n * | ReactEvent |    .    |              |     |TapEvent   |  |------------|\n * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|\n * |            |    .    |              |     +-----------+  |  utilities |\n * |     +-----------.--->|              |                    +------------+\n * |     |      |    .    +--------------+\n * +-----|------+    .                ^        +-----------+\n *       |           .                |        |Enter/Leave|\n *       +           .                +-------+|Plugin     |\n * +-------------+   .                         +-----------+\n * | application |   .\n * |-------------|   .\n * |             |   .\n * |             |   .\n * +-------------+   .\n *                   .\n *    React Core     .  General Purpose Event Plugin System\n */\n\nconst PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\nconst elementListeningSets:\n  | WeakMap\n  | Map<\n      Document | Element | Node,\n      Set<DOMTopLevelEventType | string>,\n    > = new PossiblyWeakMap();\n\nexport function getListeningSetForElement(\n  element: Document | Element | Node,\n): Set<DOMTopLevelEventType | string> {\n  let listeningSet = elementListeningSets.get(element);\n  if (listeningSet === undefined) {\n    listeningSet = new Set();\n    elementListeningSets.set(element, listeningSet);\n  }\n  return listeningSet;\n}\n\n/**\n * We listen for bubbled touch events on the document object.\n *\n * Firefox v8.01 (and possibly others) exhibited strange behavior when\n * mounting `onmousemove` events at some node that was not the document\n * element. The symptoms were that if your mouse is not moving over something\n * contained within that mount point (for example on the background) the\n * top-level listeners for `onmousemove` won't be called. However, if you\n * register the `mousemove` on the document object, then it will of course\n * catch all `mousemove`s. This along with iOS quirks, justifies restricting\n * top-level listeners to the document object only, at least for these\n * movement types of events and possibly all events.\n *\n * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\n *\n * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but\n * they bubble to document.\n *\n * @param {string} registrationName Name of listener (e.g. `onClick`).\n * @param {object} mountAt Container where to mount the listener\n */\nexport function listenTo(\n  registrationName: string,\n  mountAt: Document | Element | Node,\n): void {\n  const listeningSet = getListeningSetForElement(mountAt);\n  const dependencies = registrationNameDependencies[registrationName];\n\n  for (let i = 0; i < dependencies.length; i++) {\n    const dependency = dependencies[i];\n    listenToTopLevel(dependency, mountAt, listeningSet);\n  }\n}\n\nexport function listenToTopLevel(\n  topLevelType: DOMTopLevelEventType,\n  mountAt: Document | Element | Node,\n  listeningSet: Set<DOMTopLevelEventType | string>,\n): void {\n  if (!listeningSet.has(topLevelType)) {\n    switch (topLevelType) {\n      case TOP_SCROLL:\n        trapCapturedEvent(TOP_SCROLL, mountAt);\n        break;\n      case TOP_FOCUS:\n      case TOP_BLUR:\n        trapCapturedEvent(TOP_FOCUS, mountAt);\n        trapCapturedEvent(TOP_BLUR, mountAt);\n        // We set the flag for a single dependency later in this function,\n        // but this ensures we mark both as attached rather than just one.\n        listeningSet.add(TOP_BLUR);\n        listeningSet.add(TOP_FOCUS);\n        break;\n      case TOP_CANCEL:\n      case TOP_CLOSE:\n        if (isEventSupported(getRawEventName(topLevelType))) {\n          trapCapturedEvent(topLevelType, mountAt);\n        }\n        break;\n      case TOP_INVALID:\n      case TOP_SUBMIT:\n      case TOP_RESET:\n        // We listen to them on the target DOM elements.\n        // Some of them bubble so we don't want them to fire twice.\n        break;\n      default:\n        // By default, listen on the top level to all non-media events.\n        // Media events don't bubble so adding the listener wouldn't do anything.\n        const isMediaEvent = mediaEventTypes.indexOf(topLevelType) !== -1;\n        if (!isMediaEvent) {\n          trapBubbledEvent(topLevelType, mountAt);\n        }\n        break;\n    }\n    listeningSet.add(topLevelType);\n  }\n}\n\nexport function isListeningToAllDependencies(\n  registrationName: string,\n  mountAt: Document | Element,\n): boolean {\n  const listeningSet = getListeningSetForElement(mountAt);\n  const dependencies = registrationNameDependencies[registrationName];\n\n  for (let i = 0; i < dependencies.length; i++) {\n    const dependency = dependencies[i];\n    if (!listeningSet.has(dependency)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport {setEnabled, isEnabled, trapBubbledEvent, trapCapturedEvent};\n"]},"metadata":{},"sourceType":"module"}