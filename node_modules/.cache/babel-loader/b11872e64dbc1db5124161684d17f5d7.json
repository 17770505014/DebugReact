{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport React from 'react';\nimport { Update, Snapshot } from 'shared/ReactSideEffectTags';\nimport { debugRenderPhaseSideEffectsForStrictMode, disableLegacyContext, warnAboutDeprecatedLifecycles } from 'shared/ReactFeatureFlags';\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings';\nimport { isMounted } from 'react-reconciler/reflection';\nimport { get as getInstance, set as setInstance } from 'shared/ReactInstanceMap';\nimport shallowEqual from 'shared/shallowEqual';\nimport getComponentName from 'shared/getComponentName';\nimport invariant from 'shared/invariant';\nimport warningWithoutStack from 'shared/warningWithoutStack';\nimport { REACT_CONTEXT_TYPE, REACT_PROVIDER_TYPE } from 'shared/ReactSymbols';\nimport { startPhaseTimer, stopPhaseTimer } from './ReactDebugFiberPerf';\nimport { resolveDefaultProps } from './ReactFiberLazyComponent';\nimport { StrictMode } from './ReactTypeOfMode';\nimport { enqueueUpdate, processUpdateQueue, checkHasForceUpdateAfterProcessing, resetHasForceUpdateBeforeProcessing, createUpdate, ReplaceState, ForceUpdate } from './ReactUpdateQueue';\nimport { NoWork } from './ReactFiberExpirationTime';\nimport { cacheContext, getMaskedContext, getUnmaskedContext, hasContextChanged, emptyContextObject } from './ReactFiberContext';\nimport { readContext } from './ReactFiberNewContext';\nimport { requestCurrentTimeForUpdate, computeExpirationForFiber, scheduleWork } from './ReactFiberWorkLoop';\nimport { requestCurrentSuspenseConfig } from './ReactFiberSuspenseConfig';\nconst fakeInternalInstance = {};\nconst isArray = Array.isArray; // React.Component uses a shared frozen object by default.\n// We'll use it to determine whether we need to initialize legacy refs.\n\nexport const emptyRefsObject = new React.Component().refs;\nlet didWarnAboutStateAssignmentForComponent;\nlet didWarnAboutUninitializedState;\nlet didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;\nlet didWarnAboutLegacyLifecyclesAndDerivedState;\nlet didWarnAboutUndefinedDerivedState;\nlet warnOnUndefinedDerivedState;\nlet warnOnInvalidCallback;\nlet didWarnAboutDirectlyAssigningPropsToState;\nlet didWarnAboutContextTypeAndContextTypes;\nlet didWarnAboutInvalidateContextType;\n\nif (__DEV__) {\n  didWarnAboutStateAssignmentForComponent = new Set();\n  didWarnAboutUninitializedState = new Set();\n  didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n  didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n  didWarnAboutDirectlyAssigningPropsToState = new Set();\n  didWarnAboutUndefinedDerivedState = new Set();\n  didWarnAboutContextTypeAndContextTypes = new Set();\n  didWarnAboutInvalidateContextType = new Set();\n  const didWarnOnInvalidCallback = new Set();\n\n  warnOnInvalidCallback = function (callback, callerName) {\n    if (callback === null || typeof callback === 'function') {\n      return;\n    }\n\n    const key = `${callerName}_${callback}`;\n\n    if (!didWarnOnInvalidCallback.has(key)) {\n      didWarnOnInvalidCallback.add(key);\n      warningWithoutStack(false, '%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);\n    }\n  };\n\n  warnOnUndefinedDerivedState = function (type, partialState) {\n    if (partialState === undefined) {\n      const componentName = getComponentName(type) || 'Component';\n\n      if (!didWarnAboutUndefinedDerivedState.has(componentName)) {\n        didWarnAboutUndefinedDerivedState.add(componentName);\n        warningWithoutStack(false, '%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. ' + 'You have returned undefined.', componentName);\n      }\n    }\n  }; // This is so gross but it's at least non-critical and can be removed if\n  // it causes problems. This is meant to give a nicer error message for\n  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n  // ...)) which otherwise throws a \"_processChildContext is not a function\"\n  // exception.\n\n\n  Object.defineProperty(fakeInternalInstance, '_processChildContext', {\n    enumerable: false,\n    value: function () {\n      invariant(false, '_processChildContext is not available in React 16+. This likely ' + 'means you have multiple copies of React and are attempting to nest ' + 'a React 15 tree inside a React 16 tree using ' + \"unstable_renderSubtreeIntoContainer, which isn't supported. Try \" + 'to make sure you have only one copy of React (and ideally, switch ' + 'to ReactDOM.createPortal).');\n    }\n  });\n  Object.freeze(fakeInternalInstance);\n}\n\nexport function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {\n  const prevState = workInProgress.memoizedState;\n\n  if (__DEV__) {\n    if (debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {\n      // Invoke the function an extra time to help detect side-effects.\n      getDerivedStateFromProps(nextProps, prevState);\n    }\n  }\n\n  const partialState = getDerivedStateFromProps(nextProps, prevState);\n\n  if (__DEV__) {\n    warnOnUndefinedDerivedState(ctor, partialState);\n  } // Merge the partial state and the previous state.\n\n\n  const memoizedState = partialState === null || partialState === undefined ? prevState : Object.assign({}, prevState, partialState);\n  workInProgress.memoizedState = memoizedState; // Once the update queue is empty, persist the derived state onto the\n  // base state.\n\n  const updateQueue = workInProgress.updateQueue;\n\n  if (updateQueue !== null && workInProgress.expirationTime === NoWork) {\n    updateQueue.baseState = memoizedState;\n  }\n}\nconst classComponentUpdater = {\n  isMounted,\n\n  enqueueSetState(inst, payload, callback) {\n    const fiber = getInstance(inst);\n    const currentTime = requestCurrentTimeForUpdate();\n    const suspenseConfig = requestCurrentSuspenseConfig();\n    const expirationTime = computeExpirationForFiber(currentTime, fiber, suspenseConfig);\n    const update = createUpdate(expirationTime, suspenseConfig);\n    update.payload = payload;\n\n    if (callback !== undefined && callback !== null) {\n      if (__DEV__) {\n        warnOnInvalidCallback(callback, 'setState');\n      }\n\n      update.callback = callback;\n    }\n\n    enqueueUpdate(fiber, update);\n    scheduleWork(fiber, expirationTime);\n  },\n\n  enqueueReplaceState(inst, payload, callback) {\n    const fiber = getInstance(inst);\n    const currentTime = requestCurrentTimeForUpdate();\n    const suspenseConfig = requestCurrentSuspenseConfig();\n    const expirationTime = computeExpirationForFiber(currentTime, fiber, suspenseConfig);\n    const update = createUpdate(expirationTime, suspenseConfig);\n    update.tag = ReplaceState;\n    update.payload = payload;\n\n    if (callback !== undefined && callback !== null) {\n      if (__DEV__) {\n        warnOnInvalidCallback(callback, 'replaceState');\n      }\n\n      update.callback = callback;\n    }\n\n    enqueueUpdate(fiber, update);\n    scheduleWork(fiber, expirationTime);\n  },\n\n  enqueueForceUpdate(inst, callback) {\n    const fiber = getInstance(inst);\n    const currentTime = requestCurrentTimeForUpdate();\n    const suspenseConfig = requestCurrentSuspenseConfig();\n    const expirationTime = computeExpirationForFiber(currentTime, fiber, suspenseConfig);\n    const update = createUpdate(expirationTime, suspenseConfig);\n    update.tag = ForceUpdate;\n\n    if (callback !== undefined && callback !== null) {\n      if (__DEV__) {\n        warnOnInvalidCallback(callback, 'forceUpdate');\n      }\n\n      update.callback = callback;\n    }\n\n    enqueueUpdate(fiber, update);\n    scheduleWork(fiber, expirationTime);\n  }\n\n};\n\nfunction checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {\n  const instance = workInProgress.stateNode;\n\n  if (typeof instance.shouldComponentUpdate === 'function') {\n    startPhaseTimer(workInProgress, 'shouldComponentUpdate');\n    const shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);\n    stopPhaseTimer();\n\n    if (__DEV__) {\n      warningWithoutStack(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', getComponentName(ctor) || 'Component');\n    }\n\n    return shouldUpdate;\n  }\n\n  if (ctor.prototype && ctor.prototype.isPureReactComponent) {\n    return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);\n  }\n\n  return true;\n}\n\nfunction checkClassInstance(workInProgress, ctor, newProps) {\n  const instance = workInProgress.stateNode;\n\n  if (__DEV__) {\n    const name = getComponentName(ctor) || 'Component';\n    const renderPresent = instance.render;\n\n    if (!renderPresent) {\n      if (ctor.prototype && typeof ctor.prototype.render === 'function') {\n        warningWithoutStack(false, '%s(...): No `render` method found on the returned component ' + 'instance: did you accidentally return an object from the constructor?', name);\n      } else {\n        warningWithoutStack(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', name);\n      }\n    }\n\n    const noGetInitialStateOnES6 = !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state;\n    warningWithoutStack(noGetInitialStateOnES6, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', name);\n    const noGetDefaultPropsOnES6 = !instance.getDefaultProps || instance.getDefaultProps.isReactClassApproved;\n    warningWithoutStack(noGetDefaultPropsOnES6, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', name);\n    const noInstancePropTypes = !instance.propTypes;\n    warningWithoutStack(noInstancePropTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', name);\n    const noInstanceContextType = !instance.contextType;\n    warningWithoutStack(noInstanceContextType, 'contextType was defined as an instance property on %s. Use a static ' + 'property to define contextType instead.', name);\n\n    if (disableLegacyContext) {\n      if (ctor.childContextTypes) {\n        warningWithoutStack(false, '%s uses the legacy childContextTypes API which is no longer supported. ' + 'Use React.createContext() instead.', name);\n      }\n\n      if (ctor.contextTypes) {\n        warningWithoutStack(false, '%s uses the legacy contextTypes API which is no longer supported. ' + 'Use React.createContext() with static contextType instead.', name);\n      }\n    } else {\n      const noInstanceContextTypes = !instance.contextTypes;\n      warningWithoutStack(noInstanceContextTypes, 'contextTypes was defined as an instance property on %s. Use a static ' + 'property to define contextTypes instead.', name);\n\n      if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {\n        didWarnAboutContextTypeAndContextTypes.add(ctor);\n        warningWithoutStack(false, '%s declares both contextTypes and contextType static properties. ' + 'The legacy contextTypes property will be ignored.', name);\n      }\n    }\n\n    const noComponentShouldUpdate = typeof instance.componentShouldUpdate !== 'function';\n    warningWithoutStack(noComponentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', name);\n\n    if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') {\n      warningWithoutStack(false, '%s has a method called shouldComponentUpdate(). ' + 'shouldComponentUpdate should not be used when extending React.PureComponent. ' + 'Please extend React.Component if shouldComponentUpdate is used.', getComponentName(ctor) || 'A pure component');\n    }\n\n    const noComponentDidUnmount = typeof instance.componentDidUnmount !== 'function';\n    warningWithoutStack(noComponentDidUnmount, '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', name);\n    const noComponentDidReceiveProps = typeof instance.componentDidReceiveProps !== 'function';\n    warningWithoutStack(noComponentDidReceiveProps, '%s has a method called ' + 'componentDidReceiveProps(). But there is no such lifecycle method. ' + 'If you meant to update the state in response to changing props, ' + 'use componentWillReceiveProps(). If you meant to fetch data or ' + 'run side-effects or mutations after React has updated the UI, use componentDidUpdate().', name);\n    const noComponentWillRecieveProps = typeof instance.componentWillRecieveProps !== 'function';\n    warningWithoutStack(noComponentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', name);\n    const noUnsafeComponentWillRecieveProps = typeof instance.UNSAFE_componentWillRecieveProps !== 'function';\n    warningWithoutStack(noUnsafeComponentWillRecieveProps, '%s has a method called ' + 'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?', name);\n    const hasMutatedProps = instance.props !== newProps;\n    warningWithoutStack(instance.props === undefined || !hasMutatedProps, '%s(...): When calling super() in `%s`, make sure to pass ' + \"up the same props that your component's constructor was passed.\", name, name);\n    const noInstanceDefaultProps = !instance.defaultProps;\n    warningWithoutStack(noInstanceDefaultProps, 'Setting defaultProps as an instance property on %s is not supported and will be ignored.' + ' Instead, define defaultProps as a static property on %s.', name, name);\n\n    if (typeof instance.getSnapshotBeforeUpdate === 'function' && typeof instance.componentDidUpdate !== 'function' && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {\n      didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);\n      warningWithoutStack(false, '%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). ' + 'This component defines getSnapshotBeforeUpdate() only.', getComponentName(ctor));\n    }\n\n    const noInstanceGetDerivedStateFromProps = typeof instance.getDerivedStateFromProps !== 'function';\n    warningWithoutStack(noInstanceGetDerivedStateFromProps, '%s: getDerivedStateFromProps() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name);\n    const noInstanceGetDerivedStateFromCatch = typeof instance.getDerivedStateFromError !== 'function';\n    warningWithoutStack(noInstanceGetDerivedStateFromCatch, '%s: getDerivedStateFromError() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name);\n    const noStaticGetSnapshotBeforeUpdate = typeof ctor.getSnapshotBeforeUpdate !== 'function';\n    warningWithoutStack(noStaticGetSnapshotBeforeUpdate, '%s: getSnapshotBeforeUpdate() is defined as a static method ' + 'and will be ignored. Instead, declare it as an instance method.', name);\n    const state = instance.state;\n\n    if (state && (typeof state !== 'object' || isArray(state))) {\n      warningWithoutStack(false, '%s.state: must be set to an object or null', name);\n    }\n\n    if (typeof instance.getChildContext === 'function') {\n      warningWithoutStack(typeof ctor.childContextTypes === 'object', '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', name);\n    }\n  }\n}\n\nfunction adoptClassInstance(workInProgress, instance) {\n  instance.updater = classComponentUpdater;\n  workInProgress.stateNode = instance; // The instance needs access to the fiber so that it can schedule updates\n\n  setInstance(instance, workInProgress);\n\n  if (__DEV__) {\n    instance._reactInternalInstance = fakeInternalInstance;\n  }\n}\n\nfunction constructClassInstance(workInProgress, ctor, props, renderExpirationTime) {\n  let isLegacyContextConsumer = false;\n  let unmaskedContext = emptyContextObject;\n  let context = emptyContextObject;\n  const contextType = ctor.contextType;\n\n  if (__DEV__) {\n    if ('contextType' in ctor) {\n      let isValid = // Allow null for conditional declaration\n      contextType === null || contextType !== undefined && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === undefined; // Not a <Context.Consumer>\n\n      if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {\n        didWarnAboutInvalidateContextType.add(ctor);\n        let addendum = '';\n\n        if (contextType === undefined) {\n          addendum = ' However, it is set to undefined. ' + 'This can be caused by a typo or by mixing up named and default imports. ' + 'This can also happen due to a circular dependency, so ' + 'try moving the createContext() call to a separate file.';\n        } else if (typeof contextType !== 'object') {\n          addendum = ' However, it is set to a ' + typeof contextType + '.';\n        } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {\n          addendum = ' Did you accidentally pass the Context.Provider instead?';\n        } else if (contextType._context !== undefined) {\n          // <Context.Consumer>\n          addendum = ' Did you accidentally pass the Context.Consumer instead?';\n        } else {\n          addendum = ' However, it is set to an object with keys {' + Object.keys(contextType).join(', ') + '}.';\n        }\n\n        warningWithoutStack(false, '%s defines an invalid contextType. ' + 'contextType should point to the Context object returned by React.createContext().%s', getComponentName(ctor) || 'Component', addendum);\n      }\n    }\n  }\n\n  if (typeof contextType === 'object' && contextType !== null) {\n    context = readContext(contextType);\n  } else if (!disableLegacyContext) {\n    unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n    const contextTypes = ctor.contextTypes;\n    isLegacyContextConsumer = contextTypes !== null && contextTypes !== undefined;\n    context = isLegacyContextConsumer ? getMaskedContext(workInProgress, unmaskedContext) : emptyContextObject;\n  } // Instantiate twice to help detect side-effects.\n\n\n  if (__DEV__) {\n    if (debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {\n      new ctor(props, context); // eslint-disable-line no-new\n    }\n  }\n\n  const instance = new ctor(props, context);\n  const state = workInProgress.memoizedState = instance.state !== null && instance.state !== undefined ? instance.state : null;\n  adoptClassInstance(workInProgress, instance);\n\n  if (__DEV__) {\n    if (typeof ctor.getDerivedStateFromProps === 'function' && state === null) {\n      const componentName = getComponentName(ctor) || 'Component';\n\n      if (!didWarnAboutUninitializedState.has(componentName)) {\n        didWarnAboutUninitializedState.add(componentName);\n        warningWithoutStack(false, '`%s` uses `getDerivedStateFromProps` but its initial state is ' + '%s. This is not recommended. Instead, define the initial state by ' + 'assigning an object to `this.state` in the constructor of `%s`. ' + 'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.', componentName, instance.state === null ? 'null' : 'undefined', componentName);\n      }\n    } // If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n    // Warn about these lifecycles if they are present.\n    // Don't warn about react-lifecycles-compat polyfilled methods though.\n\n\n    if (typeof ctor.getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function') {\n      let foundWillMountName = null;\n      let foundWillReceivePropsName = null;\n      let foundWillUpdateName = null;\n\n      if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning !== true) {\n        foundWillMountName = 'componentWillMount';\n      } else if (typeof instance.UNSAFE_componentWillMount === 'function') {\n        foundWillMountName = 'UNSAFE_componentWillMount';\n      }\n\n      if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n        foundWillReceivePropsName = 'componentWillReceiveProps';\n      } else if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n        foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';\n      }\n\n      if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n        foundWillUpdateName = 'componentWillUpdate';\n      } else if (typeof instance.UNSAFE_componentWillUpdate === 'function') {\n        foundWillUpdateName = 'UNSAFE_componentWillUpdate';\n      }\n\n      if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {\n        const componentName = getComponentName(ctor) || 'Component';\n        const newApiName = typeof ctor.getDerivedStateFromProps === 'function' ? 'getDerivedStateFromProps()' : 'getSnapshotBeforeUpdate()';\n\n        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(componentName)) {\n          didWarnAboutLegacyLifecyclesAndDerivedState.add(componentName);\n          warningWithoutStack(false, 'Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n' + '%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n' + 'The above lifecycles should be removed. Learn more about this warning here:\\n' + 'https://fb.me/react-unsafe-component-lifecycles', componentName, newApiName, foundWillMountName !== null ? `\\n  ${foundWillMountName}` : '', foundWillReceivePropsName !== null ? `\\n  ${foundWillReceivePropsName}` : '', foundWillUpdateName !== null ? `\\n  ${foundWillUpdateName}` : '');\n        }\n      }\n    }\n  } // Cache unmasked context so we can avoid recreating masked context unless necessary.\n  // ReactFiberContext usually updates this cache but can't for newly-created instances.\n\n\n  if (isLegacyContextConsumer) {\n    cacheContext(workInProgress, unmaskedContext, context);\n  }\n\n  return instance;\n}\n\nfunction callComponentWillMount(workInProgress, instance) {\n  startPhaseTimer(workInProgress, 'componentWillMount');\n  const oldState = instance.state;\n\n  if (typeof instance.componentWillMount === 'function') {\n    instance.componentWillMount();\n  }\n\n  if (typeof instance.UNSAFE_componentWillMount === 'function') {\n    instance.UNSAFE_componentWillMount();\n  }\n\n  stopPhaseTimer();\n\n  if (oldState !== instance.state) {\n    if (__DEV__) {\n      warningWithoutStack(false, '%s.componentWillMount(): Assigning directly to this.state is ' + \"deprecated (except inside a component's \" + 'constructor). Use setState instead.', getComponentName(workInProgress.type) || 'Component');\n    }\n\n    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n  }\n}\n\nfunction callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {\n  const oldState = instance.state;\n  startPhaseTimer(workInProgress, 'componentWillReceiveProps');\n\n  if (typeof instance.componentWillReceiveProps === 'function') {\n    instance.componentWillReceiveProps(newProps, nextContext);\n  }\n\n  if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n    instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);\n  }\n\n  stopPhaseTimer();\n\n  if (instance.state !== oldState) {\n    if (__DEV__) {\n      const componentName = getComponentName(workInProgress.type) || 'Component';\n\n      if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {\n        didWarnAboutStateAssignmentForComponent.add(componentName);\n        warningWithoutStack(false, '%s.componentWillReceiveProps(): Assigning directly to ' + \"this.state is deprecated (except inside a component's \" + 'constructor). Use setState instead.', componentName);\n      }\n    }\n\n    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n  }\n} // Invokes the mount life-cycles on a previously never rendered instance.\n\n\nfunction mountClassInstance(workInProgress, ctor, newProps, renderExpirationTime) {\n  if (__DEV__) {\n    checkClassInstance(workInProgress, ctor, newProps);\n  }\n\n  const instance = workInProgress.stateNode;\n  instance.props = newProps;\n  instance.state = workInProgress.memoizedState;\n  instance.refs = emptyRefsObject;\n  const contextType = ctor.contextType;\n\n  if (typeof contextType === 'object' && contextType !== null) {\n    instance.context = readContext(contextType);\n  } else if (disableLegacyContext) {\n    instance.context = emptyContextObject;\n  } else {\n    const unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n    instance.context = getMaskedContext(workInProgress, unmaskedContext);\n  }\n\n  if (__DEV__) {\n    if (instance.state === newProps) {\n      const componentName = getComponentName(ctor) || 'Component';\n\n      if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {\n        didWarnAboutDirectlyAssigningPropsToState.add(componentName);\n        warningWithoutStack(false, '%s: It is not recommended to assign props directly to state ' + \"because updates to props won't be reflected in state. \" + 'In most cases, it is better to use props directly.', componentName);\n      }\n    }\n\n    if (workInProgress.mode & StrictMode) {\n      ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, instance);\n    }\n\n    if (warnAboutDeprecatedLifecycles) {\n      ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, instance);\n    }\n  }\n\n  let updateQueue = workInProgress.updateQueue;\n\n  if (updateQueue !== null) {\n    processUpdateQueue(workInProgress, updateQueue, newProps, instance, renderExpirationTime);\n    instance.state = workInProgress.memoizedState;\n  }\n\n  const getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n\n  if (typeof getDerivedStateFromProps === 'function') {\n    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n    instance.state = workInProgress.memoizedState;\n  } // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n\n\n  if (typeof ctor.getDerivedStateFromProps !== 'function' && typeof instance.getSnapshotBeforeUpdate !== 'function' && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {\n    callComponentWillMount(workInProgress, instance); // If we had additional state updates during this life-cycle, let's\n    // process them now.\n\n    updateQueue = workInProgress.updateQueue;\n\n    if (updateQueue !== null) {\n      processUpdateQueue(workInProgress, updateQueue, newProps, instance, renderExpirationTime);\n      instance.state = workInProgress.memoizedState;\n    }\n  }\n\n  if (typeof instance.componentDidMount === 'function') {\n    workInProgress.effectTag |= Update;\n  }\n}\n\nfunction resumeMountClassInstance(workInProgress, ctor, newProps, renderExpirationTime) {\n  const instance = workInProgress.stateNode;\n  const oldProps = workInProgress.memoizedProps;\n  instance.props = oldProps;\n  const oldContext = instance.context;\n  const contextType = ctor.contextType;\n  let nextContext = emptyContextObject;\n\n  if (typeof contextType === 'object' && contextType !== null) {\n    nextContext = readContext(contextType);\n  } else if (!disableLegacyContext) {\n    const nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n    nextContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext);\n  }\n\n  const getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n  const hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function'; // Note: During these life-cycles, instance.props/instance.state are what\n  // ever the previously attempted to render - not the \"current\". However,\n  // during componentDidUpdate we pass the \"current\" props.\n  // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n\n  if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {\n    if (oldProps !== newProps || oldContext !== nextContext) {\n      callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);\n    }\n  }\n\n  resetHasForceUpdateBeforeProcessing();\n  const oldState = workInProgress.memoizedState;\n  let newState = instance.state = oldState;\n  let updateQueue = workInProgress.updateQueue;\n\n  if (updateQueue !== null) {\n    processUpdateQueue(workInProgress, updateQueue, newProps, instance, renderExpirationTime);\n    newState = workInProgress.memoizedState;\n  }\n\n  if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidMount === 'function') {\n      workInProgress.effectTag |= Update;\n    }\n\n    return false;\n  }\n\n  if (typeof getDerivedStateFromProps === 'function') {\n    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n    newState = workInProgress.memoizedState;\n  }\n\n  const shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);\n\n  if (shouldUpdate) {\n    // In order to support react-lifecycles-compat polyfilled components,\n    // Unsafe lifecycles should not be invoked for components using the new APIs.\n    if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {\n      startPhaseTimer(workInProgress, 'componentWillMount');\n\n      if (typeof instance.componentWillMount === 'function') {\n        instance.componentWillMount();\n      }\n\n      if (typeof instance.UNSAFE_componentWillMount === 'function') {\n        instance.UNSAFE_componentWillMount();\n      }\n\n      stopPhaseTimer();\n    }\n\n    if (typeof instance.componentDidMount === 'function') {\n      workInProgress.effectTag |= Update;\n    }\n  } else {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidMount === 'function') {\n      workInProgress.effectTag |= Update;\n    } // If shouldComponentUpdate returned false, we should still update the\n    // memoized state to indicate that this work can be reused.\n\n\n    workInProgress.memoizedProps = newProps;\n    workInProgress.memoizedState = newState;\n  } // Update the existing instance's state, props, and context pointers even\n  // if shouldComponentUpdate returns false.\n\n\n  instance.props = newProps;\n  instance.state = newState;\n  instance.context = nextContext;\n  return shouldUpdate;\n} // Invokes the update life-cycles and returns false if it shouldn't rerender.\n\n\nfunction updateClassInstance(current, workInProgress, ctor, newProps, renderExpirationTime) {\n  const instance = workInProgress.stateNode;\n  const oldProps = workInProgress.memoizedProps;\n  instance.props = workInProgress.type === workInProgress.elementType ? oldProps : resolveDefaultProps(workInProgress.type, oldProps);\n  const oldContext = instance.context;\n  const contextType = ctor.contextType;\n  let nextContext = emptyContextObject;\n\n  if (typeof contextType === 'object' && contextType !== null) {\n    nextContext = readContext(contextType);\n  } else if (!disableLegacyContext) {\n    const nextUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n    nextContext = getMaskedContext(workInProgress, nextUnmaskedContext);\n  }\n\n  const getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n  const hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function'; // Note: During these life-cycles, instance.props/instance.state are what\n  // ever the previously attempted to render - not the \"current\". However,\n  // during componentDidUpdate we pass the \"current\" props.\n  // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n\n  if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {\n    if (oldProps !== newProps || oldContext !== nextContext) {\n      callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);\n    }\n  }\n\n  resetHasForceUpdateBeforeProcessing();\n  const oldState = workInProgress.memoizedState;\n  let newState = instance.state = oldState;\n  let updateQueue = workInProgress.updateQueue;\n\n  if (updateQueue !== null) {\n    processUpdateQueue(workInProgress, updateQueue, newProps, instance, renderExpirationTime);\n    newState = workInProgress.memoizedState;\n  }\n\n  if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidUpdate === 'function') {\n      if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n        workInProgress.effectTag |= Update;\n      }\n    }\n\n    if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n      if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n        workInProgress.effectTag |= Snapshot;\n      }\n    }\n\n    return false;\n  }\n\n  if (typeof getDerivedStateFromProps === 'function') {\n    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n    newState = workInProgress.memoizedState;\n  }\n\n  const shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);\n\n  if (shouldUpdate) {\n    // In order to support react-lifecycles-compat polyfilled components,\n    // Unsafe lifecycles should not be invoked for components using the new APIs.\n    if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === 'function' || typeof instance.componentWillUpdate === 'function')) {\n      startPhaseTimer(workInProgress, 'componentWillUpdate');\n\n      if (typeof instance.componentWillUpdate === 'function') {\n        instance.componentWillUpdate(newProps, newState, nextContext);\n      }\n\n      if (typeof instance.UNSAFE_componentWillUpdate === 'function') {\n        instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);\n      }\n\n      stopPhaseTimer();\n    }\n\n    if (typeof instance.componentDidUpdate === 'function') {\n      workInProgress.effectTag |= Update;\n    }\n\n    if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n      workInProgress.effectTag |= Snapshot;\n    }\n  } else {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidUpdate === 'function') {\n      if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n        workInProgress.effectTag |= Update;\n      }\n    }\n\n    if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n      if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n        workInProgress.effectTag |= Snapshot;\n      }\n    } // If shouldComponentUpdate returned false, we should still update the\n    // memoized props/state to indicate that this work can be reused.\n\n\n    workInProgress.memoizedProps = newProps;\n    workInProgress.memoizedState = newState;\n  } // Update the existing instance's state, props, and context pointers even\n  // if shouldComponentUpdate returns false.\n\n\n  instance.props = newProps;\n  instance.state = newState;\n  instance.context = nextContext;\n  return shouldUpdate;\n}\n\nexport { adoptClassInstance, constructClassInstance, mountClassInstance, resumeMountClassInstance, updateClassInstance };","map":{"version":3,"sources":["/Users/gaoshaoyun/Documents/library/debug-react/src/react/packages/react-reconciler/src/ReactFiberClassComponent.js"],"names":["React","Update","Snapshot","debugRenderPhaseSideEffectsForStrictMode","disableLegacyContext","warnAboutDeprecatedLifecycles","ReactStrictModeWarnings","isMounted","get","getInstance","set","setInstance","shallowEqual","getComponentName","invariant","warningWithoutStack","REACT_CONTEXT_TYPE","REACT_PROVIDER_TYPE","startPhaseTimer","stopPhaseTimer","resolveDefaultProps","StrictMode","enqueueUpdate","processUpdateQueue","checkHasForceUpdateAfterProcessing","resetHasForceUpdateBeforeProcessing","createUpdate","ReplaceState","ForceUpdate","NoWork","cacheContext","getMaskedContext","getUnmaskedContext","hasContextChanged","emptyContextObject","readContext","requestCurrentTimeForUpdate","computeExpirationForFiber","scheduleWork","requestCurrentSuspenseConfig","fakeInternalInstance","isArray","Array","emptyRefsObject","Component","refs","didWarnAboutStateAssignmentForComponent","didWarnAboutUninitializedState","didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate","didWarnAboutLegacyLifecyclesAndDerivedState","didWarnAboutUndefinedDerivedState","warnOnUndefinedDerivedState","warnOnInvalidCallback","didWarnAboutDirectlyAssigningPropsToState","didWarnAboutContextTypeAndContextTypes","didWarnAboutInvalidateContextType","__DEV__","Set","didWarnOnInvalidCallback","callback","callerName","key","has","add","type","partialState","undefined","componentName","Object","defineProperty","enumerable","value","freeze","applyDerivedStateFromProps","workInProgress","ctor","getDerivedStateFromProps","nextProps","prevState","memoizedState","mode","assign","updateQueue","expirationTime","baseState","classComponentUpdater","enqueueSetState","inst","payload","fiber","currentTime","suspenseConfig","update","enqueueReplaceState","tag","enqueueForceUpdate","checkShouldComponentUpdate","oldProps","newProps","oldState","newState","nextContext","instance","stateNode","shouldComponentUpdate","shouldUpdate","prototype","isPureReactComponent","checkClassInstance","name","renderPresent","render","noGetInitialStateOnES6","getInitialState","isReactClassApproved","state","noGetDefaultPropsOnES6","getDefaultProps","noInstancePropTypes","propTypes","noInstanceContextType","contextType","childContextTypes","contextTypes","noInstanceContextTypes","noComponentShouldUpdate","componentShouldUpdate","noComponentDidUnmount","componentDidUnmount","noComponentDidReceiveProps","componentDidReceiveProps","noComponentWillRecieveProps","componentWillRecieveProps","noUnsafeComponentWillRecieveProps","UNSAFE_componentWillRecieveProps","hasMutatedProps","props","noInstanceDefaultProps","defaultProps","getSnapshotBeforeUpdate","componentDidUpdate","noInstanceGetDerivedStateFromProps","noInstanceGetDerivedStateFromCatch","getDerivedStateFromError","noStaticGetSnapshotBeforeUpdate","getChildContext","adoptClassInstance","updater","_reactInternalInstance","constructClassInstance","renderExpirationTime","isLegacyContextConsumer","unmaskedContext","context","isValid","$$typeof","_context","addendum","keys","join","foundWillMountName","foundWillReceivePropsName","foundWillUpdateName","componentWillMount","__suppressDeprecationWarning","UNSAFE_componentWillMount","componentWillReceiveProps","UNSAFE_componentWillReceiveProps","componentWillUpdate","UNSAFE_componentWillUpdate","newApiName","callComponentWillMount","callComponentWillReceiveProps","mountClassInstance","recordLegacyContextWarning","recordUnsafeLifecycleWarnings","componentDidMount","effectTag","resumeMountClassInstance","memoizedProps","oldContext","nextLegacyUnmaskedContext","hasNewLifecycles","updateClassInstance","current","elementType","nextUnmaskedContext"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber} from './ReactFiber';\nimport type {ExpirationTime} from './ReactFiberExpirationTime';\n\nimport React from 'react';\nimport {Update, Snapshot} from 'shared/ReactSideEffectTags';\nimport {\n  debugRenderPhaseSideEffectsForStrictMode,\n  disableLegacyContext,\n  warnAboutDeprecatedLifecycles,\n} from 'shared/ReactFeatureFlags';\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings';\nimport {isMounted} from 'react-reconciler/reflection';\nimport {get as getInstance, set as setInstance} from 'shared/ReactInstanceMap';\nimport shallowEqual from 'shared/shallowEqual';\nimport getComponentName from 'shared/getComponentName';\nimport invariant from 'shared/invariant';\nimport warningWithoutStack from 'shared/warningWithoutStack';\nimport {REACT_CONTEXT_TYPE, REACT_PROVIDER_TYPE} from 'shared/ReactSymbols';\n\nimport {startPhaseTimer, stopPhaseTimer} from './ReactDebugFiberPerf';\nimport {resolveDefaultProps} from './ReactFiberLazyComponent';\nimport {StrictMode} from './ReactTypeOfMode';\n\nimport {\n  enqueueUpdate,\n  processUpdateQueue,\n  checkHasForceUpdateAfterProcessing,\n  resetHasForceUpdateBeforeProcessing,\n  createUpdate,\n  ReplaceState,\n  ForceUpdate,\n} from './ReactUpdateQueue';\nimport {NoWork} from './ReactFiberExpirationTime';\nimport {\n  cacheContext,\n  getMaskedContext,\n  getUnmaskedContext,\n  hasContextChanged,\n  emptyContextObject,\n} from './ReactFiberContext';\nimport {readContext} from './ReactFiberNewContext';\nimport {\n  requestCurrentTimeForUpdate,\n  computeExpirationForFiber,\n  scheduleWork,\n} from './ReactFiberWorkLoop';\nimport {requestCurrentSuspenseConfig} from './ReactFiberSuspenseConfig';\n\nconst fakeInternalInstance = {};\nconst isArray = Array.isArray;\n\n// React.Component uses a shared frozen object by default.\n// We'll use it to determine whether we need to initialize legacy refs.\nexport const emptyRefsObject = new React.Component().refs;\n\nlet didWarnAboutStateAssignmentForComponent;\nlet didWarnAboutUninitializedState;\nlet didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;\nlet didWarnAboutLegacyLifecyclesAndDerivedState;\nlet didWarnAboutUndefinedDerivedState;\nlet warnOnUndefinedDerivedState;\nlet warnOnInvalidCallback;\nlet didWarnAboutDirectlyAssigningPropsToState;\nlet didWarnAboutContextTypeAndContextTypes;\nlet didWarnAboutInvalidateContextType;\n\nif (__DEV__) {\n  didWarnAboutStateAssignmentForComponent = new Set();\n  didWarnAboutUninitializedState = new Set();\n  didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n  didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n  didWarnAboutDirectlyAssigningPropsToState = new Set();\n  didWarnAboutUndefinedDerivedState = new Set();\n  didWarnAboutContextTypeAndContextTypes = new Set();\n  didWarnAboutInvalidateContextType = new Set();\n\n  const didWarnOnInvalidCallback = new Set();\n\n  warnOnInvalidCallback = function(callback: mixed, callerName: string) {\n    if (callback === null || typeof callback === 'function') {\n      return;\n    }\n    const key = `${callerName}_${(callback: any)}`;\n    if (!didWarnOnInvalidCallback.has(key)) {\n      didWarnOnInvalidCallback.add(key);\n      warningWithoutStack(\n        false,\n        '%s(...): Expected the last optional `callback` argument to be a ' +\n          'function. Instead received: %s.',\n        callerName,\n        callback,\n      );\n    }\n  };\n\n  warnOnUndefinedDerivedState = function(type, partialState) {\n    if (partialState === undefined) {\n      const componentName = getComponentName(type) || 'Component';\n      if (!didWarnAboutUndefinedDerivedState.has(componentName)) {\n        didWarnAboutUndefinedDerivedState.add(componentName);\n        warningWithoutStack(\n          false,\n          '%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. ' +\n            'You have returned undefined.',\n          componentName,\n        );\n      }\n    }\n  };\n\n  // This is so gross but it's at least non-critical and can be removed if\n  // it causes problems. This is meant to give a nicer error message for\n  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n  // ...)) which otherwise throws a \"_processChildContext is not a function\"\n  // exception.\n  Object.defineProperty(fakeInternalInstance, '_processChildContext', {\n    enumerable: false,\n    value: function() {\n      invariant(\n        false,\n        '_processChildContext is not available in React 16+. This likely ' +\n          'means you have multiple copies of React and are attempting to nest ' +\n          'a React 15 tree inside a React 16 tree using ' +\n          \"unstable_renderSubtreeIntoContainer, which isn't supported. Try \" +\n          'to make sure you have only one copy of React (and ideally, switch ' +\n          'to ReactDOM.createPortal).',\n      );\n    },\n  });\n  Object.freeze(fakeInternalInstance);\n}\n\nexport function applyDerivedStateFromProps(\n  workInProgress: Fiber,\n  ctor: any,\n  getDerivedStateFromProps: (props: any, state: any) => any,\n  nextProps: any,\n) {\n  const prevState = workInProgress.memoizedState;\n\n  if (__DEV__) {\n    if (\n      debugRenderPhaseSideEffectsForStrictMode &&\n      workInProgress.mode & StrictMode\n    ) {\n      // Invoke the function an extra time to help detect side-effects.\n      getDerivedStateFromProps(nextProps, prevState);\n    }\n  }\n\n  const partialState = getDerivedStateFromProps(nextProps, prevState);\n\n  if (__DEV__) {\n    warnOnUndefinedDerivedState(ctor, partialState);\n  }\n  // Merge the partial state and the previous state.\n  const memoizedState =\n    partialState === null || partialState === undefined\n      ? prevState\n      : Object.assign({}, prevState, partialState);\n  workInProgress.memoizedState = memoizedState;\n\n  // Once the update queue is empty, persist the derived state onto the\n  // base state.\n  const updateQueue = workInProgress.updateQueue;\n  if (updateQueue !== null && workInProgress.expirationTime === NoWork) {\n    updateQueue.baseState = memoizedState;\n  }\n}\n\nconst classComponentUpdater = {\n  isMounted,\n  enqueueSetState(inst, payload, callback) {\n    const fiber = getInstance(inst);\n    const currentTime = requestCurrentTimeForUpdate();\n    const suspenseConfig = requestCurrentSuspenseConfig();\n    const expirationTime = computeExpirationForFiber(\n      currentTime,\n      fiber,\n      suspenseConfig,\n    );\n\n    const update = createUpdate(expirationTime, suspenseConfig);\n    update.payload = payload;\n    if (callback !== undefined && callback !== null) {\n      if (__DEV__) {\n        warnOnInvalidCallback(callback, 'setState');\n      }\n      update.callback = callback;\n    }\n\n    enqueueUpdate(fiber, update);\n    scheduleWork(fiber, expirationTime);\n  },\n  enqueueReplaceState(inst, payload, callback) {\n    const fiber = getInstance(inst);\n    const currentTime = requestCurrentTimeForUpdate();\n    const suspenseConfig = requestCurrentSuspenseConfig();\n    const expirationTime = computeExpirationForFiber(\n      currentTime,\n      fiber,\n      suspenseConfig,\n    );\n\n    const update = createUpdate(expirationTime, suspenseConfig);\n    update.tag = ReplaceState;\n    update.payload = payload;\n\n    if (callback !== undefined && callback !== null) {\n      if (__DEV__) {\n        warnOnInvalidCallback(callback, 'replaceState');\n      }\n      update.callback = callback;\n    }\n\n    enqueueUpdate(fiber, update);\n    scheduleWork(fiber, expirationTime);\n  },\n  enqueueForceUpdate(inst, callback) {\n    const fiber = getInstance(inst);\n    const currentTime = requestCurrentTimeForUpdate();\n    const suspenseConfig = requestCurrentSuspenseConfig();\n    const expirationTime = computeExpirationForFiber(\n      currentTime,\n      fiber,\n      suspenseConfig,\n    );\n\n    const update = createUpdate(expirationTime, suspenseConfig);\n    update.tag = ForceUpdate;\n\n    if (callback !== undefined && callback !== null) {\n      if (__DEV__) {\n        warnOnInvalidCallback(callback, 'forceUpdate');\n      }\n      update.callback = callback;\n    }\n\n    enqueueUpdate(fiber, update);\n    scheduleWork(fiber, expirationTime);\n  },\n};\n\nfunction checkShouldComponentUpdate(\n  workInProgress,\n  ctor,\n  oldProps,\n  newProps,\n  oldState,\n  newState,\n  nextContext,\n) {\n  const instance = workInProgress.stateNode;\n  if (typeof instance.shouldComponentUpdate === 'function') {\n    startPhaseTimer(workInProgress, 'shouldComponentUpdate');\n    const shouldUpdate = instance.shouldComponentUpdate(\n      newProps,\n      newState,\n      nextContext,\n    );\n    stopPhaseTimer();\n\n    if (__DEV__) {\n      warningWithoutStack(\n        shouldUpdate !== undefined,\n        '%s.shouldComponentUpdate(): Returned undefined instead of a ' +\n          'boolean value. Make sure to return true or false.',\n        getComponentName(ctor) || 'Component',\n      );\n    }\n\n    return shouldUpdate;\n  }\n\n  if (ctor.prototype && ctor.prototype.isPureReactComponent) {\n    return (\n      !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)\n    );\n  }\n\n  return true;\n}\n\nfunction checkClassInstance(workInProgress: Fiber, ctor: any, newProps: any) {\n  const instance = workInProgress.stateNode;\n  if (__DEV__) {\n    const name = getComponentName(ctor) || 'Component';\n    const renderPresent = instance.render;\n\n    if (!renderPresent) {\n      if (ctor.prototype && typeof ctor.prototype.render === 'function') {\n        warningWithoutStack(\n          false,\n          '%s(...): No `render` method found on the returned component ' +\n            'instance: did you accidentally return an object from the constructor?',\n          name,\n        );\n      } else {\n        warningWithoutStack(\n          false,\n          '%s(...): No `render` method found on the returned component ' +\n            'instance: you may have forgotten to define `render`.',\n          name,\n        );\n      }\n    }\n\n    const noGetInitialStateOnES6 =\n      !instance.getInitialState ||\n      instance.getInitialState.isReactClassApproved ||\n      instance.state;\n    warningWithoutStack(\n      noGetInitialStateOnES6,\n      'getInitialState was defined on %s, a plain JavaScript class. ' +\n        'This is only supported for classes created using React.createClass. ' +\n        'Did you mean to define a state property instead?',\n      name,\n    );\n    const noGetDefaultPropsOnES6 =\n      !instance.getDefaultProps ||\n      instance.getDefaultProps.isReactClassApproved;\n    warningWithoutStack(\n      noGetDefaultPropsOnES6,\n      'getDefaultProps was defined on %s, a plain JavaScript class. ' +\n        'This is only supported for classes created using React.createClass. ' +\n        'Use a static property to define defaultProps instead.',\n      name,\n    );\n    const noInstancePropTypes = !instance.propTypes;\n    warningWithoutStack(\n      noInstancePropTypes,\n      'propTypes was defined as an instance property on %s. Use a static ' +\n        'property to define propTypes instead.',\n      name,\n    );\n    const noInstanceContextType = !instance.contextType;\n    warningWithoutStack(\n      noInstanceContextType,\n      'contextType was defined as an instance property on %s. Use a static ' +\n        'property to define contextType instead.',\n      name,\n    );\n\n    if (disableLegacyContext) {\n      if (ctor.childContextTypes) {\n        warningWithoutStack(\n          false,\n          '%s uses the legacy childContextTypes API which is no longer supported. ' +\n            'Use React.createContext() instead.',\n          name,\n        );\n      }\n      if (ctor.contextTypes) {\n        warningWithoutStack(\n          false,\n          '%s uses the legacy contextTypes API which is no longer supported. ' +\n            'Use React.createContext() with static contextType instead.',\n          name,\n        );\n      }\n    } else {\n      const noInstanceContextTypes = !instance.contextTypes;\n      warningWithoutStack(\n        noInstanceContextTypes,\n        'contextTypes was defined as an instance property on %s. Use a static ' +\n          'property to define contextTypes instead.',\n        name,\n      );\n\n      if (\n        ctor.contextType &&\n        ctor.contextTypes &&\n        !didWarnAboutContextTypeAndContextTypes.has(ctor)\n      ) {\n        didWarnAboutContextTypeAndContextTypes.add(ctor);\n        warningWithoutStack(\n          false,\n          '%s declares both contextTypes and contextType static properties. ' +\n            'The legacy contextTypes property will be ignored.',\n          name,\n        );\n      }\n    }\n\n    const noComponentShouldUpdate =\n      typeof instance.componentShouldUpdate !== 'function';\n    warningWithoutStack(\n      noComponentShouldUpdate,\n      '%s has a method called ' +\n        'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' +\n        'The name is phrased as a question because the function is ' +\n        'expected to return a value.',\n      name,\n    );\n    if (\n      ctor.prototype &&\n      ctor.prototype.isPureReactComponent &&\n      typeof instance.shouldComponentUpdate !== 'undefined'\n    ) {\n      warningWithoutStack(\n        false,\n        '%s has a method called shouldComponentUpdate(). ' +\n          'shouldComponentUpdate should not be used when extending React.PureComponent. ' +\n          'Please extend React.Component if shouldComponentUpdate is used.',\n        getComponentName(ctor) || 'A pure component',\n      );\n    }\n    const noComponentDidUnmount =\n      typeof instance.componentDidUnmount !== 'function';\n    warningWithoutStack(\n      noComponentDidUnmount,\n      '%s has a method called ' +\n        'componentDidUnmount(). But there is no such lifecycle method. ' +\n        'Did you mean componentWillUnmount()?',\n      name,\n    );\n    const noComponentDidReceiveProps =\n      typeof instance.componentDidReceiveProps !== 'function';\n    warningWithoutStack(\n      noComponentDidReceiveProps,\n      '%s has a method called ' +\n        'componentDidReceiveProps(). But there is no such lifecycle method. ' +\n        'If you meant to update the state in response to changing props, ' +\n        'use componentWillReceiveProps(). If you meant to fetch data or ' +\n        'run side-effects or mutations after React has updated the UI, use componentDidUpdate().',\n      name,\n    );\n    const noComponentWillRecieveProps =\n      typeof instance.componentWillRecieveProps !== 'function';\n    warningWithoutStack(\n      noComponentWillRecieveProps,\n      '%s has a method called ' +\n        'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?',\n      name,\n    );\n    const noUnsafeComponentWillRecieveProps =\n      typeof instance.UNSAFE_componentWillRecieveProps !== 'function';\n    warningWithoutStack(\n      noUnsafeComponentWillRecieveProps,\n      '%s has a method called ' +\n        'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?',\n      name,\n    );\n    const hasMutatedProps = instance.props !== newProps;\n    warningWithoutStack(\n      instance.props === undefined || !hasMutatedProps,\n      '%s(...): When calling super() in `%s`, make sure to pass ' +\n        \"up the same props that your component's constructor was passed.\",\n      name,\n      name,\n    );\n    const noInstanceDefaultProps = !instance.defaultProps;\n    warningWithoutStack(\n      noInstanceDefaultProps,\n      'Setting defaultProps as an instance property on %s is not supported and will be ignored.' +\n        ' Instead, define defaultProps as a static property on %s.',\n      name,\n      name,\n    );\n\n    if (\n      typeof instance.getSnapshotBeforeUpdate === 'function' &&\n      typeof instance.componentDidUpdate !== 'function' &&\n      !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)\n    ) {\n      didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);\n      warningWithoutStack(\n        false,\n        '%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). ' +\n          'This component defines getSnapshotBeforeUpdate() only.',\n        getComponentName(ctor),\n      );\n    }\n\n    const noInstanceGetDerivedStateFromProps =\n      typeof instance.getDerivedStateFromProps !== 'function';\n    warningWithoutStack(\n      noInstanceGetDerivedStateFromProps,\n      '%s: getDerivedStateFromProps() is defined as an instance method ' +\n        'and will be ignored. Instead, declare it as a static method.',\n      name,\n    );\n    const noInstanceGetDerivedStateFromCatch =\n      typeof instance.getDerivedStateFromError !== 'function';\n    warningWithoutStack(\n      noInstanceGetDerivedStateFromCatch,\n      '%s: getDerivedStateFromError() is defined as an instance method ' +\n        'and will be ignored. Instead, declare it as a static method.',\n      name,\n    );\n    const noStaticGetSnapshotBeforeUpdate =\n      typeof ctor.getSnapshotBeforeUpdate !== 'function';\n    warningWithoutStack(\n      noStaticGetSnapshotBeforeUpdate,\n      '%s: getSnapshotBeforeUpdate() is defined as a static method ' +\n        'and will be ignored. Instead, declare it as an instance method.',\n      name,\n    );\n    const state = instance.state;\n    if (state && (typeof state !== 'object' || isArray(state))) {\n      warningWithoutStack(\n        false,\n        '%s.state: must be set to an object or null',\n        name,\n      );\n    }\n    if (typeof instance.getChildContext === 'function') {\n      warningWithoutStack(\n        typeof ctor.childContextTypes === 'object',\n        '%s.getChildContext(): childContextTypes must be defined in order to ' +\n          'use getChildContext().',\n        name,\n      );\n    }\n  }\n}\n\nfunction adoptClassInstance(workInProgress: Fiber, instance: any): void {\n  instance.updater = classComponentUpdater;\n  workInProgress.stateNode = instance;\n  // The instance needs access to the fiber so that it can schedule updates\n  setInstance(instance, workInProgress);\n  if (__DEV__) {\n    instance._reactInternalInstance = fakeInternalInstance;\n  }\n}\n\nfunction constructClassInstance(\n  workInProgress: Fiber,\n  ctor: any,\n  props: any,\n  renderExpirationTime: ExpirationTime,\n): any {\n  let isLegacyContextConsumer = false;\n  let unmaskedContext = emptyContextObject;\n  let context = emptyContextObject;\n  const contextType = ctor.contextType;\n\n  if (__DEV__) {\n    if ('contextType' in ctor) {\n      let isValid =\n        // Allow null for conditional declaration\n        contextType === null ||\n        (contextType !== undefined &&\n          contextType.$$typeof === REACT_CONTEXT_TYPE &&\n          contextType._context === undefined); // Not a <Context.Consumer>\n\n      if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {\n        didWarnAboutInvalidateContextType.add(ctor);\n\n        let addendum = '';\n        if (contextType === undefined) {\n          addendum =\n            ' However, it is set to undefined. ' +\n            'This can be caused by a typo or by mixing up named and default imports. ' +\n            'This can also happen due to a circular dependency, so ' +\n            'try moving the createContext() call to a separate file.';\n        } else if (typeof contextType !== 'object') {\n          addendum = ' However, it is set to a ' + typeof contextType + '.';\n        } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {\n          addendum = ' Did you accidentally pass the Context.Provider instead?';\n        } else if (contextType._context !== undefined) {\n          // <Context.Consumer>\n          addendum = ' Did you accidentally pass the Context.Consumer instead?';\n        } else {\n          addendum =\n            ' However, it is set to an object with keys {' +\n            Object.keys(contextType).join(', ') +\n            '}.';\n        }\n        warningWithoutStack(\n          false,\n          '%s defines an invalid contextType. ' +\n            'contextType should point to the Context object returned by React.createContext().%s',\n          getComponentName(ctor) || 'Component',\n          addendum,\n        );\n      }\n    }\n  }\n\n  if (typeof contextType === 'object' && contextType !== null) {\n    context = readContext((contextType: any));\n  } else if (!disableLegacyContext) {\n    unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n    const contextTypes = ctor.contextTypes;\n    isLegacyContextConsumer =\n      contextTypes !== null && contextTypes !== undefined;\n    context = isLegacyContextConsumer\n      ? getMaskedContext(workInProgress, unmaskedContext)\n      : emptyContextObject;\n  }\n\n  // Instantiate twice to help detect side-effects.\n  if (__DEV__) {\n    if (\n      debugRenderPhaseSideEffectsForStrictMode &&\n      workInProgress.mode & StrictMode\n    ) {\n      new ctor(props, context); // eslint-disable-line no-new\n    }\n  }\n\n  const instance = new ctor(props, context);\n  const state = (workInProgress.memoizedState =\n    instance.state !== null && instance.state !== undefined\n      ? instance.state\n      : null);\n  adoptClassInstance(workInProgress, instance);\n\n  if (__DEV__) {\n    if (typeof ctor.getDerivedStateFromProps === 'function' && state === null) {\n      const componentName = getComponentName(ctor) || 'Component';\n      if (!didWarnAboutUninitializedState.has(componentName)) {\n        didWarnAboutUninitializedState.add(componentName);\n        warningWithoutStack(\n          false,\n          '`%s` uses `getDerivedStateFromProps` but its initial state is ' +\n            '%s. This is not recommended. Instead, define the initial state by ' +\n            'assigning an object to `this.state` in the constructor of `%s`. ' +\n            'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.',\n          componentName,\n          instance.state === null ? 'null' : 'undefined',\n          componentName,\n        );\n      }\n    }\n\n    // If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n    // Warn about these lifecycles if they are present.\n    // Don't warn about react-lifecycles-compat polyfilled methods though.\n    if (\n      typeof ctor.getDerivedStateFromProps === 'function' ||\n      typeof instance.getSnapshotBeforeUpdate === 'function'\n    ) {\n      let foundWillMountName = null;\n      let foundWillReceivePropsName = null;\n      let foundWillUpdateName = null;\n      if (\n        typeof instance.componentWillMount === 'function' &&\n        instance.componentWillMount.__suppressDeprecationWarning !== true\n      ) {\n        foundWillMountName = 'componentWillMount';\n      } else if (typeof instance.UNSAFE_componentWillMount === 'function') {\n        foundWillMountName = 'UNSAFE_componentWillMount';\n      }\n      if (\n        typeof instance.componentWillReceiveProps === 'function' &&\n        instance.componentWillReceiveProps.__suppressDeprecationWarning !== true\n      ) {\n        foundWillReceivePropsName = 'componentWillReceiveProps';\n      } else if (\n        typeof instance.UNSAFE_componentWillReceiveProps === 'function'\n      ) {\n        foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';\n      }\n      if (\n        typeof instance.componentWillUpdate === 'function' &&\n        instance.componentWillUpdate.__suppressDeprecationWarning !== true\n      ) {\n        foundWillUpdateName = 'componentWillUpdate';\n      } else if (typeof instance.UNSAFE_componentWillUpdate === 'function') {\n        foundWillUpdateName = 'UNSAFE_componentWillUpdate';\n      }\n      if (\n        foundWillMountName !== null ||\n        foundWillReceivePropsName !== null ||\n        foundWillUpdateName !== null\n      ) {\n        const componentName = getComponentName(ctor) || 'Component';\n        const newApiName =\n          typeof ctor.getDerivedStateFromProps === 'function'\n            ? 'getDerivedStateFromProps()'\n            : 'getSnapshotBeforeUpdate()';\n        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(componentName)) {\n          didWarnAboutLegacyLifecyclesAndDerivedState.add(componentName);\n          warningWithoutStack(\n            false,\n            'Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n' +\n              '%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n' +\n              'The above lifecycles should be removed. Learn more about this warning here:\\n' +\n              'https://fb.me/react-unsafe-component-lifecycles',\n            componentName,\n            newApiName,\n            foundWillMountName !== null ? `\\n  ${foundWillMountName}` : '',\n            foundWillReceivePropsName !== null\n              ? `\\n  ${foundWillReceivePropsName}`\n              : '',\n            foundWillUpdateName !== null ? `\\n  ${foundWillUpdateName}` : '',\n          );\n        }\n      }\n    }\n  }\n\n  // Cache unmasked context so we can avoid recreating masked context unless necessary.\n  // ReactFiberContext usually updates this cache but can't for newly-created instances.\n  if (isLegacyContextConsumer) {\n    cacheContext(workInProgress, unmaskedContext, context);\n  }\n\n  return instance;\n}\n\nfunction callComponentWillMount(workInProgress, instance) {\n  startPhaseTimer(workInProgress, 'componentWillMount');\n  const oldState = instance.state;\n\n  if (typeof instance.componentWillMount === 'function') {\n    instance.componentWillMount();\n  }\n  if (typeof instance.UNSAFE_componentWillMount === 'function') {\n    instance.UNSAFE_componentWillMount();\n  }\n\n  stopPhaseTimer();\n\n  if (oldState !== instance.state) {\n    if (__DEV__) {\n      warningWithoutStack(\n        false,\n        '%s.componentWillMount(): Assigning directly to this.state is ' +\n          \"deprecated (except inside a component's \" +\n          'constructor). Use setState instead.',\n        getComponentName(workInProgress.type) || 'Component',\n      );\n    }\n    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n  }\n}\n\nfunction callComponentWillReceiveProps(\n  workInProgress,\n  instance,\n  newProps,\n  nextContext,\n) {\n  const oldState = instance.state;\n  startPhaseTimer(workInProgress, 'componentWillReceiveProps');\n  if (typeof instance.componentWillReceiveProps === 'function') {\n    instance.componentWillReceiveProps(newProps, nextContext);\n  }\n  if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n    instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);\n  }\n  stopPhaseTimer();\n\n  if (instance.state !== oldState) {\n    if (__DEV__) {\n      const componentName =\n        getComponentName(workInProgress.type) || 'Component';\n      if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {\n        didWarnAboutStateAssignmentForComponent.add(componentName);\n        warningWithoutStack(\n          false,\n          '%s.componentWillReceiveProps(): Assigning directly to ' +\n            \"this.state is deprecated (except inside a component's \" +\n            'constructor). Use setState instead.',\n          componentName,\n        );\n      }\n    }\n    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n  }\n}\n\n// Invokes the mount life-cycles on a previously never rendered instance.\nfunction mountClassInstance(\n  workInProgress: Fiber,\n  ctor: any,\n  newProps: any,\n  renderExpirationTime: ExpirationTime,\n): void {\n  if (__DEV__) {\n    checkClassInstance(workInProgress, ctor, newProps);\n  }\n\n  const instance = workInProgress.stateNode;\n  instance.props = newProps;\n  instance.state = workInProgress.memoizedState;\n  instance.refs = emptyRefsObject;\n\n  const contextType = ctor.contextType;\n  if (typeof contextType === 'object' && contextType !== null) {\n    instance.context = readContext(contextType);\n  } else if (disableLegacyContext) {\n    instance.context = emptyContextObject;\n  } else {\n    const unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n    instance.context = getMaskedContext(workInProgress, unmaskedContext);\n  }\n\n  if (__DEV__) {\n    if (instance.state === newProps) {\n      const componentName = getComponentName(ctor) || 'Component';\n      if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {\n        didWarnAboutDirectlyAssigningPropsToState.add(componentName);\n        warningWithoutStack(\n          false,\n          '%s: It is not recommended to assign props directly to state ' +\n            \"because updates to props won't be reflected in state. \" +\n            'In most cases, it is better to use props directly.',\n          componentName,\n        );\n      }\n    }\n\n    if (workInProgress.mode & StrictMode) {\n      ReactStrictModeWarnings.recordLegacyContextWarning(\n        workInProgress,\n        instance,\n      );\n    }\n\n    if (warnAboutDeprecatedLifecycles) {\n      ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(\n        workInProgress,\n        instance,\n      );\n    }\n  }\n\n  let updateQueue = workInProgress.updateQueue;\n  if (updateQueue !== null) {\n    processUpdateQueue(\n      workInProgress,\n      updateQueue,\n      newProps,\n      instance,\n      renderExpirationTime,\n    );\n    instance.state = workInProgress.memoizedState;\n  }\n\n  const getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n  if (typeof getDerivedStateFromProps === 'function') {\n    applyDerivedStateFromProps(\n      workInProgress,\n      ctor,\n      getDerivedStateFromProps,\n      newProps,\n    );\n    instance.state = workInProgress.memoizedState;\n  }\n\n  // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n  if (\n    typeof ctor.getDerivedStateFromProps !== 'function' &&\n    typeof instance.getSnapshotBeforeUpdate !== 'function' &&\n    (typeof instance.UNSAFE_componentWillMount === 'function' ||\n      typeof instance.componentWillMount === 'function')\n  ) {\n    callComponentWillMount(workInProgress, instance);\n    // If we had additional state updates during this life-cycle, let's\n    // process them now.\n    updateQueue = workInProgress.updateQueue;\n    if (updateQueue !== null) {\n      processUpdateQueue(\n        workInProgress,\n        updateQueue,\n        newProps,\n        instance,\n        renderExpirationTime,\n      );\n      instance.state = workInProgress.memoizedState;\n    }\n  }\n\n  if (typeof instance.componentDidMount === 'function') {\n    workInProgress.effectTag |= Update;\n  }\n}\n\nfunction resumeMountClassInstance(\n  workInProgress: Fiber,\n  ctor: any,\n  newProps: any,\n  renderExpirationTime: ExpirationTime,\n): boolean {\n  const instance = workInProgress.stateNode;\n\n  const oldProps = workInProgress.memoizedProps;\n  instance.props = oldProps;\n\n  const oldContext = instance.context;\n  const contextType = ctor.contextType;\n  let nextContext = emptyContextObject;\n  if (typeof contextType === 'object' && contextType !== null) {\n    nextContext = readContext(contextType);\n  } else if (!disableLegacyContext) {\n    const nextLegacyUnmaskedContext = getUnmaskedContext(\n      workInProgress,\n      ctor,\n      true,\n    );\n    nextContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext);\n  }\n\n  const getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n  const hasNewLifecycles =\n    typeof getDerivedStateFromProps === 'function' ||\n    typeof instance.getSnapshotBeforeUpdate === 'function';\n\n  // Note: During these life-cycles, instance.props/instance.state are what\n  // ever the previously attempted to render - not the \"current\". However,\n  // during componentDidUpdate we pass the \"current\" props.\n\n  // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n  if (\n    !hasNewLifecycles &&\n    (typeof instance.UNSAFE_componentWillReceiveProps === 'function' ||\n      typeof instance.componentWillReceiveProps === 'function')\n  ) {\n    if (oldProps !== newProps || oldContext !== nextContext) {\n      callComponentWillReceiveProps(\n        workInProgress,\n        instance,\n        newProps,\n        nextContext,\n      );\n    }\n  }\n\n  resetHasForceUpdateBeforeProcessing();\n\n  const oldState = workInProgress.memoizedState;\n  let newState = (instance.state = oldState);\n  let updateQueue = workInProgress.updateQueue;\n  if (updateQueue !== null) {\n    processUpdateQueue(\n      workInProgress,\n      updateQueue,\n      newProps,\n      instance,\n      renderExpirationTime,\n    );\n    newState = workInProgress.memoizedState;\n  }\n  if (\n    oldProps === newProps &&\n    oldState === newState &&\n    !hasContextChanged() &&\n    !checkHasForceUpdateAfterProcessing()\n  ) {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidMount === 'function') {\n      workInProgress.effectTag |= Update;\n    }\n    return false;\n  }\n\n  if (typeof getDerivedStateFromProps === 'function') {\n    applyDerivedStateFromProps(\n      workInProgress,\n      ctor,\n      getDerivedStateFromProps,\n      newProps,\n    );\n    newState = workInProgress.memoizedState;\n  }\n\n  const shouldUpdate =\n    checkHasForceUpdateAfterProcessing() ||\n    checkShouldComponentUpdate(\n      workInProgress,\n      ctor,\n      oldProps,\n      newProps,\n      oldState,\n      newState,\n      nextContext,\n    );\n\n  if (shouldUpdate) {\n    // In order to support react-lifecycles-compat polyfilled components,\n    // Unsafe lifecycles should not be invoked for components using the new APIs.\n    if (\n      !hasNewLifecycles &&\n      (typeof instance.UNSAFE_componentWillMount === 'function' ||\n        typeof instance.componentWillMount === 'function')\n    ) {\n      startPhaseTimer(workInProgress, 'componentWillMount');\n      if (typeof instance.componentWillMount === 'function') {\n        instance.componentWillMount();\n      }\n      if (typeof instance.UNSAFE_componentWillMount === 'function') {\n        instance.UNSAFE_componentWillMount();\n      }\n      stopPhaseTimer();\n    }\n    if (typeof instance.componentDidMount === 'function') {\n      workInProgress.effectTag |= Update;\n    }\n  } else {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidMount === 'function') {\n      workInProgress.effectTag |= Update;\n    }\n\n    // If shouldComponentUpdate returned false, we should still update the\n    // memoized state to indicate that this work can be reused.\n    workInProgress.memoizedProps = newProps;\n    workInProgress.memoizedState = newState;\n  }\n\n  // Update the existing instance's state, props, and context pointers even\n  // if shouldComponentUpdate returns false.\n  instance.props = newProps;\n  instance.state = newState;\n  instance.context = nextContext;\n\n  return shouldUpdate;\n}\n\n// Invokes the update life-cycles and returns false if it shouldn't rerender.\nfunction updateClassInstance(\n  current: Fiber,\n  workInProgress: Fiber,\n  ctor: any,\n  newProps: any,\n  renderExpirationTime: ExpirationTime,\n): boolean {\n  const instance = workInProgress.stateNode;\n\n  const oldProps = workInProgress.memoizedProps;\n  instance.props =\n    workInProgress.type === workInProgress.elementType\n      ? oldProps\n      : resolveDefaultProps(workInProgress.type, oldProps);\n\n  const oldContext = instance.context;\n  const contextType = ctor.contextType;\n  let nextContext = emptyContextObject;\n  if (typeof contextType === 'object' && contextType !== null) {\n    nextContext = readContext(contextType);\n  } else if (!disableLegacyContext) {\n    const nextUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n    nextContext = getMaskedContext(workInProgress, nextUnmaskedContext);\n  }\n\n  const getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n  const hasNewLifecycles =\n    typeof getDerivedStateFromProps === 'function' ||\n    typeof instance.getSnapshotBeforeUpdate === 'function';\n\n  // Note: During these life-cycles, instance.props/instance.state are what\n  // ever the previously attempted to render - not the \"current\". However,\n  // during componentDidUpdate we pass the \"current\" props.\n\n  // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n  if (\n    !hasNewLifecycles &&\n    (typeof instance.UNSAFE_componentWillReceiveProps === 'function' ||\n      typeof instance.componentWillReceiveProps === 'function')\n  ) {\n    if (oldProps !== newProps || oldContext !== nextContext) {\n      callComponentWillReceiveProps(\n        workInProgress,\n        instance,\n        newProps,\n        nextContext,\n      );\n    }\n  }\n\n  resetHasForceUpdateBeforeProcessing();\n\n  const oldState = workInProgress.memoizedState;\n  let newState = (instance.state = oldState);\n  let updateQueue = workInProgress.updateQueue;\n  if (updateQueue !== null) {\n    processUpdateQueue(\n      workInProgress,\n      updateQueue,\n      newProps,\n      instance,\n      renderExpirationTime,\n    );\n    newState = workInProgress.memoizedState;\n  }\n\n  if (\n    oldProps === newProps &&\n    oldState === newState &&\n    !hasContextChanged() &&\n    !checkHasForceUpdateAfterProcessing()\n  ) {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidUpdate === 'function') {\n      if (\n        oldProps !== current.memoizedProps ||\n        oldState !== current.memoizedState\n      ) {\n        workInProgress.effectTag |= Update;\n      }\n    }\n    if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n      if (\n        oldProps !== current.memoizedProps ||\n        oldState !== current.memoizedState\n      ) {\n        workInProgress.effectTag |= Snapshot;\n      }\n    }\n    return false;\n  }\n\n  if (typeof getDerivedStateFromProps === 'function') {\n    applyDerivedStateFromProps(\n      workInProgress,\n      ctor,\n      getDerivedStateFromProps,\n      newProps,\n    );\n    newState = workInProgress.memoizedState;\n  }\n\n  const shouldUpdate =\n    checkHasForceUpdateAfterProcessing() ||\n    checkShouldComponentUpdate(\n      workInProgress,\n      ctor,\n      oldProps,\n      newProps,\n      oldState,\n      newState,\n      nextContext,\n    );\n\n  if (shouldUpdate) {\n    // In order to support react-lifecycles-compat polyfilled components,\n    // Unsafe lifecycles should not be invoked for components using the new APIs.\n    if (\n      !hasNewLifecycles &&\n      (typeof instance.UNSAFE_componentWillUpdate === 'function' ||\n        typeof instance.componentWillUpdate === 'function')\n    ) {\n      startPhaseTimer(workInProgress, 'componentWillUpdate');\n      if (typeof instance.componentWillUpdate === 'function') {\n        instance.componentWillUpdate(newProps, newState, nextContext);\n      }\n      if (typeof instance.UNSAFE_componentWillUpdate === 'function') {\n        instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);\n      }\n      stopPhaseTimer();\n    }\n    if (typeof instance.componentDidUpdate === 'function') {\n      workInProgress.effectTag |= Update;\n    }\n    if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n      workInProgress.effectTag |= Snapshot;\n    }\n  } else {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidUpdate === 'function') {\n      if (\n        oldProps !== current.memoizedProps ||\n        oldState !== current.memoizedState\n      ) {\n        workInProgress.effectTag |= Update;\n      }\n    }\n    if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n      if (\n        oldProps !== current.memoizedProps ||\n        oldState !== current.memoizedState\n      ) {\n        workInProgress.effectTag |= Snapshot;\n      }\n    }\n\n    // If shouldComponentUpdate returned false, we should still update the\n    // memoized props/state to indicate that this work can be reused.\n    workInProgress.memoizedProps = newProps;\n    workInProgress.memoizedState = newState;\n  }\n\n  // Update the existing instance's state, props, and context pointers even\n  // if shouldComponentUpdate returns false.\n  instance.props = newProps;\n  instance.state = newState;\n  instance.context = nextContext;\n\n  return shouldUpdate;\n}\n\nexport {\n  adoptClassInstance,\n  constructClassInstance,\n  mountClassInstance,\n  resumeMountClassInstance,\n  updateClassInstance,\n};\n"]},"metadata":{},"sourceType":"module"}