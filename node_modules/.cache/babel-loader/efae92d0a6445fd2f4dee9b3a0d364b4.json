{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/**\n * ReactElementValidator provides a wrapper around a element factory\n * which validates the props passed to the element. This is intended to be\n * used only in DEV and could be replaced by a static type checker for languages\n * that support it.\n */\nimport lowPriorityWarning from 'shared/lowPriorityWarning';\nimport isValidElementType from 'shared/isValidElementType';\nimport getComponentName from 'shared/getComponentName';\nimport { getIteratorFn, REACT_FORWARD_REF_TYPE, REACT_MEMO_TYPE, REACT_FRAGMENT_TYPE, REACT_ELEMENT_TYPE } from 'shared/ReactSymbols';\nimport checkPropTypes from 'prop-types/checkPropTypes';\nimport warning from 'shared/warning';\nimport warningWithoutStack from 'shared/warningWithoutStack';\nimport ReactCurrentOwner from './ReactCurrentOwner';\nimport { isValidElement, createElement, cloneElement, jsxDEV } from './ReactElement';\nimport ReactDebugCurrentFrame, { setCurrentlyValidatingElement } from './ReactDebugCurrentFrame';\nlet propTypesMisspellWarningShown;\n\nif (__DEV__) {\n  propTypesMisspellWarningShown = false;\n}\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction getDeclarationErrorAddendum() {\n  if (ReactCurrentOwner.current) {\n    const name = getComponentName(ReactCurrentOwner.current.type);\n\n    if (name) {\n      return '\\n\\nCheck the render method of `' + name + '`.';\n    }\n  }\n\n  return '';\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  if (source !== undefined) {\n    const fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n    const lineNumber = source.lineNumber;\n    return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n  }\n\n  return '';\n}\n\nfunction getSourceInfoErrorAddendumForProps(elementProps) {\n  if (elementProps !== null && elementProps !== undefined) {\n    return getSourceInfoErrorAddendum(elementProps.__source);\n  }\n\n  return '';\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nconst ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  let info = getDeclarationErrorAddendum();\n\n  if (!info) {\n    const parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n    if (parentName) {\n      info = `\\n\\nCheck the top-level render call using <${parentName}>.`;\n    }\n  }\n\n  return info;\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  if (!element._store || element._store.validated || element.key != null) {\n    return;\n  }\n\n  element._store.validated = true;\n  const currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n    return;\n  }\n\n  ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n  // property, it may be the creator of the child that's responsible for\n  // assigning it a key.\n\n  let childOwner = '';\n\n  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n    // Give the component that originally created this child.\n    childOwner = ` It was passed a child from ${getComponentName(element._owner.type)}.`;\n  }\n\n  setCurrentlyValidatingElement(element);\n\n  if (__DEV__) {\n    warning(false, 'Each child in a list should have a unique \"key\" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.', currentComponentErrorInfo, childOwner);\n  }\n\n  setCurrentlyValidatingElement(null);\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  if (typeof node !== 'object') {\n    return;\n  }\n\n  if (Array.isArray(node)) {\n    for (let i = 0; i < node.length; i++) {\n      const child = node[i];\n\n      if (isValidElement(child)) {\n        validateExplicitKey(child, parentType);\n      }\n    }\n  } else if (isValidElement(node)) {\n    // This element was passed in a valid location.\n    if (node._store) {\n      node._store.validated = true;\n    }\n  } else if (node) {\n    const iteratorFn = getIteratorFn(node);\n\n    if (typeof iteratorFn === 'function') {\n      // Entry iterators used to provide implicit keys,\n      // but now we print a separate warning for them later.\n      if (iteratorFn !== node.entries) {\n        const iterator = iteratorFn.call(node);\n        let step;\n\n        while (!(step = iterator.next()).done) {\n          if (isValidElement(step.value)) {\n            validateExplicitKey(step.value, parentType);\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  const type = element.type;\n\n  if (type === null || type === undefined || typeof type === 'string') {\n    return;\n  }\n\n  const name = getComponentName(type);\n  let propTypes;\n\n  if (typeof type === 'function') {\n    propTypes = type.propTypes;\n  } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n  // Inner props are checked in the reconciler.\n  type.$$typeof === REACT_MEMO_TYPE)) {\n    propTypes = type.propTypes;\n  } else {\n    return;\n  }\n\n  if (propTypes) {\n    setCurrentlyValidatingElement(element);\n    checkPropTypes(propTypes, element.props, 'prop', name, ReactDebugCurrentFrame.getStackAddendum);\n    setCurrentlyValidatingElement(null);\n  } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n    propTypesMisspellWarningShown = true;\n    warningWithoutStack(false, 'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', name || 'Unknown');\n  }\n\n  if (typeof type.getDefaultProps === 'function') {\n    warningWithoutStack(type.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  setCurrentlyValidatingElement(fragment);\n  const keys = Object.keys(fragment.props);\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n\n    if (key !== 'children' && key !== 'key') {\n      warning(false, 'Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n      break;\n    }\n  }\n\n  if (fragment.ref !== null) {\n    warning(false, 'Invalid attribute `ref` supplied to `React.Fragment`.');\n  }\n\n  setCurrentlyValidatingElement(null);\n}\n\nexport function jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n  const validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n  // succeed and there will likely be errors in render.\n\n  if (!validType) {\n    let info = '';\n\n    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n      info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n    }\n\n    const sourceInfo = getSourceInfoErrorAddendum(source);\n\n    if (sourceInfo) {\n      info += sourceInfo;\n    } else {\n      info += getDeclarationErrorAddendum();\n    }\n\n    let typeString;\n\n    if (type === null) {\n      typeString = 'null';\n    } else if (Array.isArray(type)) {\n      typeString = 'array';\n    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n      typeString = `<${getComponentName(type.type) || 'Unknown'} />`;\n      info = ' Did you accidentally export a JSX literal instead of a component?';\n    } else {\n      typeString = typeof type;\n    }\n\n    warning(false, 'React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n  }\n\n  const element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n  // TODO: Drop this when these are no longer allowed as the type argument.\n\n  if (element == null) {\n    return element;\n  } // Skip key warning if the type isn't valid since our key validation logic\n  // doesn't expect a non-string/function type and can throw confusing errors.\n  // We don't want exception behavior to differ between dev and prod.\n  // (Rendering will throw with a helpful message and as soon as the type is\n  // fixed, the key warnings will appear.)\n\n\n  if (validType) {\n    const children = props.children;\n\n    if (children !== undefined) {\n      if (isStaticChildren) {\n        if (Array.isArray(children)) {\n          for (let i = 0; i < children.length; i++) {\n            validateChildKeys(children[i], type);\n          }\n\n          if (Object.freeze) {\n            Object.freeze(children);\n          }\n        } else {\n          warning(false, 'React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n        }\n      } else {\n        validateChildKeys(children, type);\n      }\n    }\n  }\n\n  if (hasOwnProperty.call(props, 'key')) {\n    warning(false, 'React.jsx: Spreading a key to JSX is a deprecated pattern. ' + 'Explicitly pass a key after spreading props in your JSX call. ' + 'E.g. <ComponentName {...props} key={key} />');\n  }\n\n  if (type === REACT_FRAGMENT_TYPE) {\n    validateFragmentProps(element);\n  } else {\n    validatePropTypes(element);\n  }\n\n  return element;\n} // These two functions exist to still get child warnings in dev\n// even with the prod transform. This means that jsxDEV is purely\n// opt-in behavior for better messages but that we won't stop\n// giving you warnings if you use production apis.\n\nexport function jsxWithValidationStatic(type, props, key) {\n  return jsxWithValidation(type, props, key, true);\n}\nexport function jsxWithValidationDynamic(type, props, key) {\n  return jsxWithValidation(type, props, key, false);\n}\nexport function createElementWithValidation(type, props, children) {\n  const validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n  // succeed and there will likely be errors in render.\n\n  if (!validType) {\n    let info = '';\n\n    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n      info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n    }\n\n    const sourceInfo = getSourceInfoErrorAddendumForProps(props);\n\n    if (sourceInfo) {\n      info += sourceInfo;\n    } else {\n      info += getDeclarationErrorAddendum();\n    }\n\n    let typeString;\n\n    if (type === null) {\n      typeString = 'null';\n    } else if (Array.isArray(type)) {\n      typeString = 'array';\n    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n      typeString = `<${getComponentName(type.type) || 'Unknown'} />`;\n      info = ' Did you accidentally export a JSX literal instead of a component?';\n    } else {\n      typeString = typeof type;\n    }\n\n    warning(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n  }\n\n  const element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.\n  // TODO: Drop this when these are no longer allowed as the type argument.\n\n  if (element == null) {\n    return element;\n  } // Skip key warning if the type isn't valid since our key validation logic\n  // doesn't expect a non-string/function type and can throw confusing errors.\n  // We don't want exception behavior to differ between dev and prod.\n  // (Rendering will throw with a helpful message and as soon as the type is\n  // fixed, the key warnings will appear.)\n\n\n  if (validType) {\n    for (let i = 2; i < arguments.length; i++) {\n      validateChildKeys(arguments[i], type);\n    }\n  }\n\n  if (type === REACT_FRAGMENT_TYPE) {\n    validateFragmentProps(element);\n  } else {\n    validatePropTypes(element);\n  }\n\n  return element;\n}\nexport function createFactoryWithValidation(type) {\n  const validatedFactory = createElementWithValidation.bind(null, type);\n  validatedFactory.type = type; // Legacy hook: remove it\n\n  if (__DEV__) {\n    Object.defineProperty(validatedFactory, 'type', {\n      enumerable: false,\n      get: function () {\n        lowPriorityWarning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');\n        Object.defineProperty(this, 'type', {\n          value: type\n        });\n        return type;\n      }\n    });\n  }\n\n  return validatedFactory;\n}\nexport function cloneElementWithValidation(element, props, children) {\n  const newElement = cloneElement.apply(this, arguments);\n\n  for (let i = 2; i < arguments.length; i++) {\n    validateChildKeys(arguments[i], newElement.type);\n  }\n\n  validatePropTypes(newElement);\n  return newElement;\n}","map":{"version":3,"sources":["/Users/gaoshaoyun/Documents/library/debug-react/src/react/packages/react/src/ReactElementValidator.js"],"names":["lowPriorityWarning","isValidElementType","getComponentName","getIteratorFn","REACT_FORWARD_REF_TYPE","REACT_MEMO_TYPE","REACT_FRAGMENT_TYPE","REACT_ELEMENT_TYPE","checkPropTypes","warning","warningWithoutStack","ReactCurrentOwner","isValidElement","createElement","cloneElement","jsxDEV","ReactDebugCurrentFrame","setCurrentlyValidatingElement","propTypesMisspellWarningShown","__DEV__","hasOwnProperty","Object","prototype","getDeclarationErrorAddendum","current","name","type","getSourceInfoErrorAddendum","source","undefined","fileName","replace","lineNumber","getSourceInfoErrorAddendumForProps","elementProps","__source","ownerHasKeyUseWarning","getCurrentComponentErrorInfo","parentType","info","parentName","displayName","validateExplicitKey","element","_store","validated","key","currentComponentErrorInfo","childOwner","_owner","validateChildKeys","node","Array","isArray","i","length","child","iteratorFn","entries","iterator","call","step","next","done","value","validatePropTypes","propTypes","$$typeof","props","getStackAddendum","PropTypes","getDefaultProps","isReactClassApproved","validateFragmentProps","fragment","keys","ref","jsxWithValidation","isStaticChildren","self","validType","sourceInfo","typeString","children","freeze","jsxWithValidationStatic","jsxWithValidationDynamic","createElementWithValidation","apply","arguments","createFactoryWithValidation","validatedFactory","bind","defineProperty","enumerable","get","cloneElementWithValidation","newElement"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/**\n * ReactElementValidator provides a wrapper around a element factory\n * which validates the props passed to the element. This is intended to be\n * used only in DEV and could be replaced by a static type checker for languages\n * that support it.\n */\n\nimport lowPriorityWarning from 'shared/lowPriorityWarning';\nimport isValidElementType from 'shared/isValidElementType';\nimport getComponentName from 'shared/getComponentName';\nimport {\n  getIteratorFn,\n  REACT_FORWARD_REF_TYPE,\n  REACT_MEMO_TYPE,\n  REACT_FRAGMENT_TYPE,\n  REACT_ELEMENT_TYPE,\n} from 'shared/ReactSymbols';\nimport checkPropTypes from 'prop-types/checkPropTypes';\nimport warning from 'shared/warning';\nimport warningWithoutStack from 'shared/warningWithoutStack';\n\nimport ReactCurrentOwner from './ReactCurrentOwner';\nimport {\n  isValidElement,\n  createElement,\n  cloneElement,\n  jsxDEV,\n} from './ReactElement';\nimport ReactDebugCurrentFrame, {\n  setCurrentlyValidatingElement,\n} from './ReactDebugCurrentFrame';\n\nlet propTypesMisspellWarningShown;\n\nif (__DEV__) {\n  propTypesMisspellWarningShown = false;\n}\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction getDeclarationErrorAddendum() {\n  if (ReactCurrentOwner.current) {\n    const name = getComponentName(ReactCurrentOwner.current.type);\n    if (name) {\n      return '\\n\\nCheck the render method of `' + name + '`.';\n    }\n  }\n  return '';\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  if (source !== undefined) {\n    const fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n    const lineNumber = source.lineNumber;\n    return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n  }\n  return '';\n}\n\nfunction getSourceInfoErrorAddendumForProps(elementProps) {\n  if (elementProps !== null && elementProps !== undefined) {\n    return getSourceInfoErrorAddendum(elementProps.__source);\n  }\n  return '';\n}\n\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\nconst ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  let info = getDeclarationErrorAddendum();\n\n  if (!info) {\n    const parentName =\n      typeof parentType === 'string'\n        ? parentType\n        : parentType.displayName || parentType.name;\n    if (parentName) {\n      info = `\\n\\nCheck the top-level render call using <${parentName}>.`;\n    }\n  }\n  return info;\n}\n\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\nfunction validateExplicitKey(element, parentType) {\n  if (!element._store || element._store.validated || element.key != null) {\n    return;\n  }\n  element._store.validated = true;\n\n  const currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n    return;\n  }\n  ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n\n  // Usually the current owner is the offender, but if it accepts children as a\n  // property, it may be the creator of the child that's responsible for\n  // assigning it a key.\n  let childOwner = '';\n  if (\n    element &&\n    element._owner &&\n    element._owner !== ReactCurrentOwner.current\n  ) {\n    // Give the component that originally created this child.\n    childOwner = ` It was passed a child from ${getComponentName(\n      element._owner.type,\n    )}.`;\n  }\n\n  setCurrentlyValidatingElement(element);\n  if (__DEV__) {\n    warning(\n      false,\n      'Each child in a list should have a unique \"key\" prop.' +\n        '%s%s See https://fb.me/react-warning-keys for more information.',\n      currentComponentErrorInfo,\n      childOwner,\n    );\n  }\n  setCurrentlyValidatingElement(null);\n}\n\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\nfunction validateChildKeys(node, parentType) {\n  if (typeof node !== 'object') {\n    return;\n  }\n  if (Array.isArray(node)) {\n    for (let i = 0; i < node.length; i++) {\n      const child = node[i];\n      if (isValidElement(child)) {\n        validateExplicitKey(child, parentType);\n      }\n    }\n  } else if (isValidElement(node)) {\n    // This element was passed in a valid location.\n    if (node._store) {\n      node._store.validated = true;\n    }\n  } else if (node) {\n    const iteratorFn = getIteratorFn(node);\n    if (typeof iteratorFn === 'function') {\n      // Entry iterators used to provide implicit keys,\n      // but now we print a separate warning for them later.\n      if (iteratorFn !== node.entries) {\n        const iterator = iteratorFn.call(node);\n        let step;\n        while (!(step = iterator.next()).done) {\n          if (isValidElement(step.value)) {\n            validateExplicitKey(step.value, parentType);\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\nfunction validatePropTypes(element) {\n  const type = element.type;\n  if (type === null || type === undefined || typeof type === 'string') {\n    return;\n  }\n  const name = getComponentName(type);\n  let propTypes;\n  if (typeof type === 'function') {\n    propTypes = type.propTypes;\n  } else if (\n    typeof type === 'object' &&\n    (type.$$typeof === REACT_FORWARD_REF_TYPE ||\n      // Note: Memo only checks outer props here.\n      // Inner props are checked in the reconciler.\n      type.$$typeof === REACT_MEMO_TYPE)\n  ) {\n    propTypes = type.propTypes;\n  } else {\n    return;\n  }\n  if (propTypes) {\n    setCurrentlyValidatingElement(element);\n    checkPropTypes(\n      propTypes,\n      element.props,\n      'prop',\n      name,\n      ReactDebugCurrentFrame.getStackAddendum,\n    );\n    setCurrentlyValidatingElement(null);\n  } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n    propTypesMisspellWarningShown = true;\n    warningWithoutStack(\n      false,\n      'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?',\n      name || 'Unknown',\n    );\n  }\n  if (typeof type.getDefaultProps === 'function') {\n    warningWithoutStack(\n      type.getDefaultProps.isReactClassApproved,\n      'getDefaultProps is only used on classic React.createClass ' +\n        'definitions. Use a static property named `defaultProps` instead.',\n    );\n  }\n}\n\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\nfunction validateFragmentProps(fragment) {\n  setCurrentlyValidatingElement(fragment);\n\n  const keys = Object.keys(fragment.props);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if (key !== 'children' && key !== 'key') {\n      warning(\n        false,\n        'Invalid prop `%s` supplied to `React.Fragment`. ' +\n          'React.Fragment can only have `key` and `children` props.',\n        key,\n      );\n      break;\n    }\n  }\n\n  if (fragment.ref !== null) {\n    warning(false, 'Invalid attribute `ref` supplied to `React.Fragment`.');\n  }\n\n  setCurrentlyValidatingElement(null);\n}\n\nexport function jsxWithValidation(\n  type,\n  props,\n  key,\n  isStaticChildren,\n  source,\n  self,\n) {\n  const validType = isValidElementType(type);\n\n  // We warn in this case but don't throw. We expect the element creation to\n  // succeed and there will likely be errors in render.\n  if (!validType) {\n    let info = '';\n    if (\n      type === undefined ||\n      (typeof type === 'object' &&\n        type !== null &&\n        Object.keys(type).length === 0)\n    ) {\n      info +=\n        ' You likely forgot to export your component from the file ' +\n        \"it's defined in, or you might have mixed up default and named imports.\";\n    }\n\n    const sourceInfo = getSourceInfoErrorAddendum(source);\n    if (sourceInfo) {\n      info += sourceInfo;\n    } else {\n      info += getDeclarationErrorAddendum();\n    }\n\n    let typeString;\n    if (type === null) {\n      typeString = 'null';\n    } else if (Array.isArray(type)) {\n      typeString = 'array';\n    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n      typeString = `<${getComponentName(type.type) || 'Unknown'} />`;\n      info =\n        ' Did you accidentally export a JSX literal instead of a component?';\n    } else {\n      typeString = typeof type;\n    }\n\n    warning(\n      false,\n      'React.jsx: type is invalid -- expected a string (for ' +\n        'built-in components) or a class/function (for composite ' +\n        'components) but got: %s.%s',\n      typeString,\n      info,\n    );\n  }\n\n  const element = jsxDEV(type, props, key, source, self);\n\n  // The result can be nullish if a mock or a custom function is used.\n  // TODO: Drop this when these are no longer allowed as the type argument.\n  if (element == null) {\n    return element;\n  }\n\n  // Skip key warning if the type isn't valid since our key validation logic\n  // doesn't expect a non-string/function type and can throw confusing errors.\n  // We don't want exception behavior to differ between dev and prod.\n  // (Rendering will throw with a helpful message and as soon as the type is\n  // fixed, the key warnings will appear.)\n\n  if (validType) {\n    const children = props.children;\n    if (children !== undefined) {\n      if (isStaticChildren) {\n        if (Array.isArray(children)) {\n          for (let i = 0; i < children.length; i++) {\n            validateChildKeys(children[i], type);\n          }\n\n          if (Object.freeze) {\n            Object.freeze(children);\n          }\n        } else {\n          warning(\n            false,\n            'React.jsx: Static children should always be an array. ' +\n              'You are likely explicitly calling React.jsxs or React.jsxDEV. ' +\n              'Use the Babel transform instead.',\n          );\n        }\n      } else {\n        validateChildKeys(children, type);\n      }\n    }\n  }\n\n  if (hasOwnProperty.call(props, 'key')) {\n    warning(\n      false,\n      'React.jsx: Spreading a key to JSX is a deprecated pattern. ' +\n        'Explicitly pass a key after spreading props in your JSX call. ' +\n        'E.g. <ComponentName {...props} key={key} />',\n    );\n  }\n\n  if (type === REACT_FRAGMENT_TYPE) {\n    validateFragmentProps(element);\n  } else {\n    validatePropTypes(element);\n  }\n\n  return element;\n}\n\n// These two functions exist to still get child warnings in dev\n// even with the prod transform. This means that jsxDEV is purely\n// opt-in behavior for better messages but that we won't stop\n// giving you warnings if you use production apis.\nexport function jsxWithValidationStatic(type, props, key) {\n  return jsxWithValidation(type, props, key, true);\n}\n\nexport function jsxWithValidationDynamic(type, props, key) {\n  return jsxWithValidation(type, props, key, false);\n}\n\nexport function createElementWithValidation(type, props, children) {\n  const validType = isValidElementType(type);\n\n  // We warn in this case but don't throw. We expect the element creation to\n  // succeed and there will likely be errors in render.\n  if (!validType) {\n    let info = '';\n    if (\n      type === undefined ||\n      (typeof type === 'object' &&\n        type !== null &&\n        Object.keys(type).length === 0)\n    ) {\n      info +=\n        ' You likely forgot to export your component from the file ' +\n        \"it's defined in, or you might have mixed up default and named imports.\";\n    }\n\n    const sourceInfo = getSourceInfoErrorAddendumForProps(props);\n    if (sourceInfo) {\n      info += sourceInfo;\n    } else {\n      info += getDeclarationErrorAddendum();\n    }\n\n    let typeString;\n    if (type === null) {\n      typeString = 'null';\n    } else if (Array.isArray(type)) {\n      typeString = 'array';\n    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n      typeString = `<${getComponentName(type.type) || 'Unknown'} />`;\n      info =\n        ' Did you accidentally export a JSX literal instead of a component?';\n    } else {\n      typeString = typeof type;\n    }\n\n    warning(\n      false,\n      'React.createElement: type is invalid -- expected a string (for ' +\n        'built-in components) or a class/function (for composite ' +\n        'components) but got: %s.%s',\n      typeString,\n      info,\n    );\n  }\n\n  const element = createElement.apply(this, arguments);\n\n  // The result can be nullish if a mock or a custom function is used.\n  // TODO: Drop this when these are no longer allowed as the type argument.\n  if (element == null) {\n    return element;\n  }\n\n  // Skip key warning if the type isn't valid since our key validation logic\n  // doesn't expect a non-string/function type and can throw confusing errors.\n  // We don't want exception behavior to differ between dev and prod.\n  // (Rendering will throw with a helpful message and as soon as the type is\n  // fixed, the key warnings will appear.)\n  if (validType) {\n    for (let i = 2; i < arguments.length; i++) {\n      validateChildKeys(arguments[i], type);\n    }\n  }\n\n  if (type === REACT_FRAGMENT_TYPE) {\n    validateFragmentProps(element);\n  } else {\n    validatePropTypes(element);\n  }\n\n  return element;\n}\n\nexport function createFactoryWithValidation(type) {\n  const validatedFactory = createElementWithValidation.bind(null, type);\n  validatedFactory.type = type;\n  // Legacy hook: remove it\n  if (__DEV__) {\n    Object.defineProperty(validatedFactory, 'type', {\n      enumerable: false,\n      get: function() {\n        lowPriorityWarning(\n          false,\n          'Factory.type is deprecated. Access the class directly ' +\n            'before passing it to createFactory.',\n        );\n        Object.defineProperty(this, 'type', {\n          value: type,\n        });\n        return type;\n      },\n    });\n  }\n\n  return validatedFactory;\n}\n\nexport function cloneElementWithValidation(element, props, children) {\n  const newElement = cloneElement.apply(this, arguments);\n  for (let i = 2; i < arguments.length; i++) {\n    validateChildKeys(arguments[i], newElement.type);\n  }\n  validatePropTypes(newElement);\n  return newElement;\n}\n"]},"metadata":{},"sourceType":"module"}