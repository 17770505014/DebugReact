{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport getComponentName from 'shared/getComponentName';\nimport { Placement, Deletion } from 'shared/ReactSideEffectTags';\nimport { getIteratorFn, REACT_ELEMENT_TYPE, REACT_FRAGMENT_TYPE, REACT_PORTAL_TYPE } from 'shared/ReactSymbols';\nimport { FunctionComponent, ClassComponent, HostText, HostPortal, Fragment } from 'shared/ReactWorkTags';\nimport invariant from 'shared/invariant';\nimport warning from 'shared/warning';\nimport warningWithoutStack from 'shared/warningWithoutStack';\nimport { warnAboutStringRefs } from 'shared/ReactFeatureFlags';\nimport { createWorkInProgress, resetWorkInProgress, createFiberFromElement, createFiberFromFragment, createFiberFromText, createFiberFromPortal } from './ReactFiber';\nimport { emptyRefsObject } from './ReactFiberClassComponent';\nimport { getCurrentFiberStackInDev, getStackByFiberInDevAndProd } from './ReactCurrentFiber';\nimport { isCompatibleFamilyForHotReloading } from './ReactFiberHotReloading';\nimport { StrictMode } from './ReactTypeOfMode';\nlet didWarnAboutMaps;\nlet didWarnAboutGenerators;\nlet didWarnAboutStringRefs;\nlet ownerHasKeyUseWarning;\nlet ownerHasFunctionTypeWarning;\n\nlet warnForMissingKey = child => {};\n\nif (__DEV__) {\n  didWarnAboutMaps = false;\n  didWarnAboutGenerators = false;\n  didWarnAboutStringRefs = {};\n  /**\n   * Warn if there's no key explicitly set on dynamic arrays of children or\n   * object keys are not valid. This allows us to keep track of children between\n   * updates.\n   */\n\n  ownerHasKeyUseWarning = {};\n  ownerHasFunctionTypeWarning = {};\n\n  warnForMissingKey = child => {\n    if (child === null || typeof child !== 'object') {\n      return;\n    }\n\n    if (!child._store || child._store.validated || child.key != null) {\n      return;\n    }\n\n    invariant(typeof child._store === 'object', 'React Component in warnForMissingKey should have a _store. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n    child._store.validated = true;\n    const currentComponentErrorInfo = 'Each child in a list should have a unique ' + '\"key\" prop. See https://fb.me/react-warning-keys for ' + 'more information.' + getCurrentFiberStackInDev();\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n    warning(false, 'Each child in a list should have a unique ' + '\"key\" prop. See https://fb.me/react-warning-keys for ' + 'more information.');\n  };\n}\n\nconst isArray = Array.isArray;\n\nfunction coerceRef(returnFiber, current, element) {\n  let mixedRef = element.ref;\n\n  if (mixedRef !== null && typeof mixedRef !== 'function' && typeof mixedRef !== 'object') {\n    if (__DEV__) {\n      // TODO: Clean this up once we turn on the string ref warning for\n      // everyone, because the strict mode case will no longer be relevant\n      if (returnFiber.mode & StrictMode || warnAboutStringRefs) {\n        const componentName = getComponentName(returnFiber.type) || 'Component';\n\n        if (!didWarnAboutStringRefs[componentName]) {\n          if (warnAboutStringRefs) {\n            warningWithoutStack(false, 'Component \"%s\" contains the string ref \"%s\". Support for string refs ' + 'will be removed in a future major release. We recommend using ' + 'useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://fb.me/react-strict-mode-string-ref%s', componentName, mixedRef, getStackByFiberInDevAndProd(returnFiber));\n          } else {\n            warningWithoutStack(false, 'A string ref, \"%s\", has been found within a strict mode tree. ' + 'String refs are a source of potential bugs and should be avoided. ' + 'We recommend using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://fb.me/react-strict-mode-string-ref%s', mixedRef, getStackByFiberInDevAndProd(returnFiber));\n          }\n\n          didWarnAboutStringRefs[componentName] = true;\n        }\n      }\n    }\n\n    if (element._owner) {\n      const owner = element._owner;\n      let inst;\n\n      if (owner) {\n        const ownerFiber = owner;\n        invariant(ownerFiber.tag === ClassComponent, 'Function components cannot have refs. ' + 'Did you mean to use React.forwardRef()?');\n        inst = ownerFiber.stateNode;\n      }\n\n      invariant(inst, 'Missing owner for string ref %s. This error is likely caused by a ' + 'bug in React. Please file an issue.', mixedRef);\n      const stringRef = '' + mixedRef; // Check if previous string ref matches new string ref\n\n      if (current !== null && current.ref !== null && typeof current.ref === 'function' && current.ref._stringRef === stringRef) {\n        return current.ref;\n      }\n\n      const ref = function (value) {\n        let refs = inst.refs;\n\n        if (refs === emptyRefsObject) {\n          // This is a lazy pooled frozen object, so we need to initialize.\n          refs = inst.refs = {};\n        }\n\n        if (value === null) {\n          delete refs[stringRef];\n        } else {\n          refs[stringRef] = value;\n        }\n      };\n\n      ref._stringRef = stringRef;\n      return ref;\n    } else {\n      invariant(typeof mixedRef === 'string', 'Expected ref to be a function, a string, an object returned by React.createRef(), or null.');\n      invariant(element._owner, 'Element ref was specified as a string (%s) but no owner was set. This could happen for one of' + ' the following reasons:\\n' + '1. You may be adding a ref to a function component\\n' + \"2. You may be adding a ref to a component that was not created inside a component's render method\\n\" + '3. You have multiple copies of React loaded\\n' + 'See https://fb.me/react-refs-must-have-owner for more information.', mixedRef);\n    }\n  }\n\n  return mixedRef;\n}\n\nfunction throwOnInvalidObjectType(returnFiber, newChild) {\n  if (returnFiber.type !== 'textarea') {\n    let addendum = '';\n\n    if (__DEV__) {\n      addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + getCurrentFiberStackInDev();\n    }\n\n    invariant(false, 'Objects are not valid as a React child (found: %s).%s', Object.prototype.toString.call(newChild) === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : newChild, addendum);\n  }\n}\n\nfunction warnOnFunctionType() {\n  const currentComponentErrorInfo = 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.' + getCurrentFiberStackInDev();\n\n  if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {\n    return;\n  }\n\n  ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;\n  warning(false, 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.');\n} // This wrapper function exists because I expect to clone the code in each path\n// to be able to optimize each path individually by branching early. This needs\n// a compiler or we can do it manually. Helpers that don't need this branching\n// live outside of this function.\n\n\nfunction ChildReconciler(shouldTrackSideEffects) {\n  function deleteChild(returnFiber, childToDelete) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return;\n    } // Deletions are added in reversed order so we add it to the front.\n    // At this point, the return fiber's effect list is empty except for\n    // deletions, so we can just append the deletion to the list. The remaining\n    // effects aren't added until the complete phase. Once we implement\n    // resuming, this may not be true.\n\n\n    const last = returnFiber.lastEffect;\n\n    if (last !== null) {\n      last.nextEffect = childToDelete;\n      returnFiber.lastEffect = childToDelete;\n    } else {\n      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n    }\n\n    childToDelete.nextEffect = null;\n    childToDelete.effectTag = Deletion;\n  }\n\n  function deleteRemainingChildren(returnFiber, currentFirstChild) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return null;\n    } // TODO: For the shouldClone case, this could be micro-optimized a bit by\n    // assuming that after the first child we've already added everything.\n\n\n    let childToDelete = currentFirstChild;\n\n    while (childToDelete !== null) {\n      deleteChild(returnFiber, childToDelete);\n      childToDelete = childToDelete.sibling;\n    }\n\n    return null;\n  }\n\n  function mapRemainingChildren(returnFiber, currentFirstChild) {\n    // Add the remaining children to a temporary map so that we can find them by\n    // keys quickly. Implicit (null) keys get added to this set with their index\n    // instead.\n    const existingChildren = new Map();\n    let existingChild = currentFirstChild;\n\n    while (existingChild !== null) {\n      if (existingChild.key !== null) {\n        existingChildren.set(existingChild.key, existingChild);\n      } else {\n        existingChildren.set(existingChild.index, existingChild);\n      }\n\n      existingChild = existingChild.sibling;\n    }\n\n    return existingChildren;\n  }\n\n  function useFiber(fiber, pendingProps, expirationTime) {\n    // We currently set sibling to null and index to 0 here because it is easy\n    // to forget to do before returning it. E.g. for the single child case.\n    const clone = createWorkInProgress(fiber, pendingProps, expirationTime);\n    clone.index = 0;\n    clone.sibling = null;\n    return clone;\n  }\n\n  function placeChild(newFiber, lastPlacedIndex, newIndex) {\n    newFiber.index = newIndex;\n\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return lastPlacedIndex;\n    }\n\n    const current = newFiber.alternate;\n\n    if (current !== null) {\n      const oldIndex = current.index;\n\n      if (oldIndex < lastPlacedIndex) {\n        // This is a move.\n        newFiber.effectTag = Placement;\n        return lastPlacedIndex;\n      } else {\n        // This item can stay in place.\n        return oldIndex;\n      }\n    } else {\n      // This is an insertion.\n      newFiber.effectTag = Placement;\n      return lastPlacedIndex;\n    }\n  }\n\n  function placeSingleChild(newFiber) {\n    // This is simpler for the single child case. We only need to do a\n    // placement for inserting new children.\n    if (shouldTrackSideEffects && newFiber.alternate === null) {\n      newFiber.effectTag = Placement;\n    }\n\n    return newFiber;\n  }\n\n  function updateTextNode(returnFiber, current, textContent, expirationTime) {\n    if (current === null || current.tag !== HostText) {\n      // Insert\n      const created = createFiberFromText(textContent, returnFiber.mode, expirationTime);\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      const existing = useFiber(current, textContent, expirationTime);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateElement(returnFiber, current, element, expirationTime) {\n    if (current !== null && (current.elementType === element.type || ( // Keep this check inline so it only runs on the false path:\n    __DEV__ ? isCompatibleFamilyForHotReloading(current, element) : false))) {\n      // Move based on index\n      const existing = useFiber(current, element.props, expirationTime);\n      existing.ref = coerceRef(returnFiber, current, element);\n      existing.return = returnFiber;\n\n      if (__DEV__) {\n        existing._debugSource = element._source;\n        existing._debugOwner = element._owner;\n      }\n\n      return existing;\n    } else {\n      // Insert\n      const created = createFiberFromElement(element, returnFiber.mode, expirationTime);\n      created.ref = coerceRef(returnFiber, current, element);\n      created.return = returnFiber;\n      return created;\n    }\n  }\n\n  function updatePortal(returnFiber, current, portal, expirationTime) {\n    if (current === null || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {\n      // Insert\n      const created = createFiberFromPortal(portal, returnFiber.mode, expirationTime);\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      const existing = useFiber(current, portal.children || [], expirationTime);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateFragment(returnFiber, current, fragment, expirationTime, key) {\n    if (current === null || current.tag !== Fragment) {\n      // Insert\n      const created = createFiberFromFragment(fragment, returnFiber.mode, expirationTime, key);\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      const existing = useFiber(current, fragment, expirationTime);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function createChild(returnFiber, newChild, expirationTime) {\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      const created = createFiberFromText('' + newChild, returnFiber.mode, expirationTime);\n      created.return = returnFiber;\n      return created;\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            const created = createFiberFromElement(newChild, returnFiber.mode, expirationTime);\n            created.ref = coerceRef(returnFiber, null, newChild);\n            created.return = returnFiber;\n            return created;\n          }\n\n        case REACT_PORTAL_TYPE:\n          {\n            const created = createFiberFromPortal(newChild, returnFiber.mode, expirationTime);\n            created.return = returnFiber;\n            return created;\n          }\n      }\n\n      if (isArray(newChild) || getIteratorFn(newChild)) {\n        const created = createFiberFromFragment(newChild, returnFiber.mode, expirationTime, null);\n        created.return = returnFiber;\n        return created;\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    if (__DEV__) {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {\n    // Update the fiber if the keys match, otherwise return null.\n    const key = oldFiber !== null ? oldFiber.key : null;\n\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      if (key !== null) {\n        return null;\n      }\n\n      return updateTextNode(returnFiber, oldFiber, '' + newChild, expirationTime);\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            if (newChild.key === key) {\n              if (newChild.type === REACT_FRAGMENT_TYPE) {\n                return updateFragment(returnFiber, oldFiber, newChild.props.children, expirationTime, key);\n              }\n\n              return updateElement(returnFiber, oldFiber, newChild, expirationTime);\n            } else {\n              return null;\n            }\n          }\n\n        case REACT_PORTAL_TYPE:\n          {\n            if (newChild.key === key) {\n              return updatePortal(returnFiber, oldFiber, newChild, expirationTime);\n            } else {\n              return null;\n            }\n          }\n      }\n\n      if (isArray(newChild) || getIteratorFn(newChild)) {\n        if (key !== null) {\n          return null;\n        }\n\n        return updateFragment(returnFiber, oldFiber, newChild, expirationTime, null);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    if (__DEV__) {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  function updateFromMap(existingChildren, returnFiber, newIdx, newChild, expirationTime) {\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys, so we neither have to check the old nor\n      // new node for the key. If both are text nodes, they match.\n      const matchedFiber = existingChildren.get(newIdx) || null;\n      return updateTextNode(returnFiber, matchedFiber, '' + newChild, expirationTime);\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            const matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n\n            if (newChild.type === REACT_FRAGMENT_TYPE) {\n              return updateFragment(returnFiber, matchedFiber, newChild.props.children, expirationTime, newChild.key);\n            }\n\n            return updateElement(returnFiber, matchedFiber, newChild, expirationTime);\n          }\n\n        case REACT_PORTAL_TYPE:\n          {\n            const matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n            return updatePortal(returnFiber, matchedFiber, newChild, expirationTime);\n          }\n      }\n\n      if (isArray(newChild) || getIteratorFn(newChild)) {\n        const matchedFiber = existingChildren.get(newIdx) || null;\n        return updateFragment(returnFiber, matchedFiber, newChild, expirationTime, null);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    if (__DEV__) {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Warns if there is a duplicate or missing key\n   */\n\n\n  function warnOnInvalidKey(child, knownKeys) {\n    if (__DEV__) {\n      if (typeof child !== 'object' || child === null) {\n        return knownKeys;\n      }\n\n      switch (child.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n        case REACT_PORTAL_TYPE:\n          warnForMissingKey(child);\n          const key = child.key;\n\n          if (typeof key !== 'string') {\n            break;\n          }\n\n          if (knownKeys === null) {\n            knownKeys = new Set();\n            knownKeys.add(key);\n            break;\n          }\n\n          if (!knownKeys.has(key)) {\n            knownKeys.add(key);\n            break;\n          }\n\n          warning(false, 'Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted — the behavior is unsupported and ' + 'could change in a future version.', key);\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    return knownKeys;\n  }\n\n  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, expirationTime) {\n    // This algorithm can't optimize by searching from both ends since we\n    // don't have backpointers on fibers. I'm trying to see how far we can get\n    // with that model. If it ends up not being worth the tradeoffs, we can\n    // add it later.\n    // Even with a two ended optimization, we'd want to optimize for the case\n    // where there are few changes and brute force the comparison instead of\n    // going for the Map. It'd like to explore hitting that path first in\n    // forward-only mode and only go for the Map once we notice that we need\n    // lots of look ahead. This doesn't handle reversal as well as two ended\n    // search but that's unusual. Besides, for the two ended optimization to\n    // work on Iterables, we'd need to copy the whole set.\n    // In this first iteration, we'll just live with hitting the bad case\n    // (adding everything to a Map) in for every insert/move.\n    // If you change this code, also update reconcileChildrenIterator() which\n    // uses the same algorithm.\n    if (__DEV__) {\n      // First, validate keys.\n      let knownKeys = null;\n\n      for (let i = 0; i < newChildren.length; i++) {\n        const child = newChildren[i];\n        knownKeys = warnOnInvalidKey(child, knownKeys);\n      }\n    }\n\n    let resultingFirstChild = null;\n    let previousNewFiber = null;\n    let oldFiber = currentFirstChild;\n    let lastPlacedIndex = 0;\n    let newIdx = 0;\n    let nextOldFiber = null;\n\n    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n\n      const newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], expirationTime);\n\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (oldFiber === null) {\n          oldFiber = nextOldFiber;\n        }\n\n        break;\n      }\n\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (newIdx === newChildren.length) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; newIdx < newChildren.length; newIdx++) {\n        const newFiber = createChild(returnFiber, newChildren[newIdx], expirationTime);\n\n        if (newFiber === null) {\n          continue;\n        }\n\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = newFiber;\n        } else {\n          previousNewFiber.sibling = newFiber;\n        }\n\n        previousNewFiber = newFiber;\n      }\n\n      return resultingFirstChild;\n    } // Add all children to a key map for quick lookups.\n\n\n    const existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.\n\n    for (; newIdx < newChildren.length; newIdx++) {\n      const newFiber = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], expirationTime);\n\n      if (newFiber !== null) {\n        if (shouldTrackSideEffects) {\n          if (newFiber.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren.delete(newFiber.key === null ? newIdx : newFiber.key);\n          }\n        }\n\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n\n        if (previousNewFiber === null) {\n          resultingFirstChild = newFiber;\n        } else {\n          previousNewFiber.sibling = newFiber;\n        }\n\n        previousNewFiber = newFiber;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(child => deleteChild(returnFiber, child));\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, expirationTime) {\n    // This is the same implementation as reconcileChildrenArray(),\n    // but using the iterator instead.\n    const iteratorFn = getIteratorFn(newChildrenIterable);\n    invariant(typeof iteratorFn === 'function', 'An object is not an iterable. This error is likely caused by a bug in ' + 'React. Please file an issue.');\n\n    if (__DEV__) {\n      // We don't support rendering Generators because it's a mutation.\n      // See https://github.com/facebook/react/issues/12995\n      if (typeof Symbol === 'function' && // $FlowFixMe Flow doesn't know about toStringTag\n      newChildrenIterable[Symbol.toStringTag] === 'Generator') {\n        warning(didWarnAboutGenerators, 'Using Generators as children is unsupported and will likely yield ' + 'unexpected results because enumerating a generator mutates it. ' + 'You may convert it to an array with `Array.from()` or the ' + '`[...spread]` operator before rendering. Keep in mind ' + 'you might need to polyfill these features for older browsers.');\n        didWarnAboutGenerators = true;\n      } // Warn about using Maps as children\n\n\n      if (newChildrenIterable.entries === iteratorFn) {\n        warning(didWarnAboutMaps, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.');\n        didWarnAboutMaps = true;\n      } // First, validate keys.\n      // We'll get a different iterator later for the main pass.\n\n\n      const newChildren = iteratorFn.call(newChildrenIterable);\n\n      if (newChildren) {\n        let knownKeys = null;\n        let step = newChildren.next();\n\n        for (; !step.done; step = newChildren.next()) {\n          const child = step.value;\n          knownKeys = warnOnInvalidKey(child, knownKeys);\n        }\n      }\n    }\n\n    const newChildren = iteratorFn.call(newChildrenIterable);\n    invariant(newChildren != null, 'An iterable object provided no iterator.');\n    let resultingFirstChild = null;\n    let previousNewFiber = null;\n    let oldFiber = currentFirstChild;\n    let lastPlacedIndex = 0;\n    let newIdx = 0;\n    let nextOldFiber = null;\n    let step = newChildren.next();\n\n    for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n\n      const newFiber = updateSlot(returnFiber, oldFiber, step.value, expirationTime);\n\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (oldFiber === null) {\n          oldFiber = nextOldFiber;\n        }\n\n        break;\n      }\n\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (step.done) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; !step.done; newIdx++, step = newChildren.next()) {\n        const newFiber = createChild(returnFiber, step.value, expirationTime);\n\n        if (newFiber === null) {\n          continue;\n        }\n\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = newFiber;\n        } else {\n          previousNewFiber.sibling = newFiber;\n        }\n\n        previousNewFiber = newFiber;\n      }\n\n      return resultingFirstChild;\n    } // Add all children to a key map for quick lookups.\n\n\n    const existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.\n\n    for (; !step.done; newIdx++, step = newChildren.next()) {\n      const newFiber = updateFromMap(existingChildren, returnFiber, newIdx, step.value, expirationTime);\n\n      if (newFiber !== null) {\n        if (shouldTrackSideEffects) {\n          if (newFiber.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren.delete(newFiber.key === null ? newIdx : newFiber.key);\n          }\n        }\n\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n\n        if (previousNewFiber === null) {\n          resultingFirstChild = newFiber;\n        } else {\n          previousNewFiber.sibling = newFiber;\n        }\n\n        previousNewFiber = newFiber;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(child => deleteChild(returnFiber, child));\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, expirationTime) {\n    // There's no need to check for keys on text nodes since we don't have a\n    // way to define them.\n    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n      // We already have an existing node so let's just update it and delete\n      // the rest.\n      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n      const existing = useFiber(currentFirstChild, textContent, expirationTime);\n      existing.return = returnFiber;\n      return existing;\n    } // The existing first child is not a text node so we need to create one\n    // and delete the existing ones.\n\n\n    deleteRemainingChildren(returnFiber, currentFirstChild);\n    const created = createFiberFromText(textContent, returnFiber.mode, expirationTime);\n    created.return = returnFiber;\n    return created;\n  }\n\n  function reconcileSingleElement(returnFiber, currentFirstChild, element, expirationTime) {\n    const key = element.key;\n    let child = currentFirstChild;\n\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (child.tag === Fragment ? element.type === REACT_FRAGMENT_TYPE : child.elementType === element.type || ( // Keep this check inline so it only runs on the false path:\n        __DEV__ ? isCompatibleFamilyForHotReloading(child, element) : false)) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          const existing = useFiber(child, element.type === REACT_FRAGMENT_TYPE ? element.props.children : element.props, expirationTime);\n          existing.ref = coerceRef(returnFiber, child, element);\n          existing.return = returnFiber;\n\n          if (__DEV__) {\n            existing._debugSource = element._source;\n            existing._debugOwner = element._owner;\n          }\n\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n\n      child = child.sibling;\n    }\n\n    if (element.type === REACT_FRAGMENT_TYPE) {\n      const created = createFiberFromFragment(element.props.children, returnFiber.mode, expirationTime, element.key);\n      created.return = returnFiber;\n      return created;\n    } else {\n      const created = createFiberFromElement(element, returnFiber.mode, expirationTime);\n      created.ref = coerceRef(returnFiber, currentFirstChild, element);\n      created.return = returnFiber;\n      return created;\n    }\n  }\n\n  function reconcileSinglePortal(returnFiber, currentFirstChild, portal, expirationTime) {\n    const key = portal.key;\n    let child = currentFirstChild;\n\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          const existing = useFiber(child, portal.children || [], expirationTime);\n          existing.return = returnFiber;\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n\n      child = child.sibling;\n    }\n\n    const created = createFiberFromPortal(portal, returnFiber.mode, expirationTime);\n    created.return = returnFiber;\n    return created;\n  } // This API will tag the children with the side-effect of the reconciliation\n  // itself. They will be added to the side-effect list as we pass through the\n  // children and the parent.\n\n\n  function reconcileChildFibers(returnFiber, currentFirstChild, newChild, expirationTime) {\n    // This function is not recursive.\n    // If the top level item is an array, we treat it as a set of children,\n    // not as a fragment. Nested arrays on the other hand will be treated as\n    // fragment nodes. Recursion happens at the normal flow.\n    // Handle top level unkeyed fragments as if they were arrays.\n    // This leads to an ambiguity between <>{[...]}</> and <>...</>.\n    // We treat the ambiguous cases above the same.\n    const isUnkeyedTopLevelFragment = typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;\n\n    if (isUnkeyedTopLevelFragment) {\n      newChild = newChild.props.children;\n    } // Handle object types\n\n\n    const isObject = typeof newChild === 'object' && newChild !== null;\n\n    if (isObject) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, expirationTime));\n\n        case REACT_PORTAL_TYPE:\n          return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, expirationTime));\n      }\n    }\n\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, expirationTime));\n    }\n\n    if (isArray(newChild)) {\n      return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, expirationTime);\n    }\n\n    if (getIteratorFn(newChild)) {\n      return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, expirationTime);\n    }\n\n    if (isObject) {\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    if (__DEV__) {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    if (typeof newChild === 'undefined' && !isUnkeyedTopLevelFragment) {\n      // If the new child is undefined, and the return fiber is a composite\n      // component, throw an error. If Fiber return types are disabled,\n      // we already threw above.\n      switch (returnFiber.tag) {\n        case ClassComponent:\n          {\n            if (__DEV__) {\n              const instance = returnFiber.stateNode;\n\n              if (instance.render._isMockFunction) {\n                // We allow auto-mocks to proceed as if they're returning null.\n                break;\n              }\n            }\n          }\n        // Intentionally fall through to the next case, which handles both\n        // functions and classes\n        // eslint-disable-next-lined no-fallthrough\n\n        case FunctionComponent:\n          {\n            const Component = returnFiber.type;\n            invariant(false, '%s(...): Nothing was returned from render. This usually means a ' + 'return statement is missing. Or, to render nothing, ' + 'return null.', Component.displayName || Component.name || 'Component');\n          }\n      }\n    } // Remaining cases are all treated as empty.\n\n\n    return deleteRemainingChildren(returnFiber, currentFirstChild);\n  }\n\n  return reconcileChildFibers;\n}\n\nexport const reconcileChildFibers = ChildReconciler(true);\nexport const mountChildFibers = ChildReconciler(false);\nexport function cloneChildFibers(current, workInProgress) {\n  invariant(current === null || workInProgress.child === current.child, 'Resuming work not yet implemented.');\n\n  if (workInProgress.child === null) {\n    return;\n  }\n\n  let currentChild = workInProgress.child;\n  let newChild = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);\n  workInProgress.child = newChild;\n  newChild.return = workInProgress;\n\n  while (currentChild.sibling !== null) {\n    currentChild = currentChild.sibling;\n    newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);\n    newChild.return = workInProgress;\n  }\n\n  newChild.sibling = null;\n} // Reset a workInProgress child set to prepare it for a second pass.\n\nexport function resetChildFibers(workInProgress, renderExpirationTime) {\n  let child = workInProgress.child;\n\n  while (child !== null) {\n    resetWorkInProgress(child, renderExpirationTime);\n    child = child.sibling;\n  }\n}","map":{"version":3,"sources":["/Users/gaoshaoyun/Documents/library/debug-react/src/react/packages/react-reconciler/src/ReactChildFiber.js"],"names":["getComponentName","Placement","Deletion","getIteratorFn","REACT_ELEMENT_TYPE","REACT_FRAGMENT_TYPE","REACT_PORTAL_TYPE","FunctionComponent","ClassComponent","HostText","HostPortal","Fragment","invariant","warning","warningWithoutStack","warnAboutStringRefs","createWorkInProgress","resetWorkInProgress","createFiberFromElement","createFiberFromFragment","createFiberFromText","createFiberFromPortal","emptyRefsObject","getCurrentFiberStackInDev","getStackByFiberInDevAndProd","isCompatibleFamilyForHotReloading","StrictMode","didWarnAboutMaps","didWarnAboutGenerators","didWarnAboutStringRefs","ownerHasKeyUseWarning","ownerHasFunctionTypeWarning","warnForMissingKey","child","__DEV__","_store","validated","key","currentComponentErrorInfo","isArray","Array","coerceRef","returnFiber","current","element","mixedRef","ref","mode","componentName","type","_owner","owner","inst","ownerFiber","tag","stateNode","stringRef","_stringRef","value","refs","throwOnInvalidObjectType","newChild","addendum","Object","prototype","toString","call","keys","join","warnOnFunctionType","ChildReconciler","shouldTrackSideEffects","deleteChild","childToDelete","last","lastEffect","nextEffect","firstEffect","effectTag","deleteRemainingChildren","currentFirstChild","sibling","mapRemainingChildren","existingChildren","Map","existingChild","set","index","useFiber","fiber","pendingProps","expirationTime","clone","placeChild","newFiber","lastPlacedIndex","newIndex","alternate","oldIndex","placeSingleChild","updateTextNode","textContent","created","return","existing","updateElement","elementType","props","_debugSource","_source","_debugOwner","updatePortal","portal","containerInfo","implementation","children","updateFragment","fragment","createChild","$$typeof","updateSlot","oldFiber","updateFromMap","newIdx","matchedFiber","get","warnOnInvalidKey","knownKeys","Set","add","has","reconcileChildrenArray","newChildren","i","length","resultingFirstChild","previousNewFiber","nextOldFiber","delete","forEach","reconcileChildrenIterator","newChildrenIterable","iteratorFn","Symbol","toStringTag","entries","step","next","done","reconcileSingleTextNode","reconcileSingleElement","reconcileSinglePortal","reconcileChildFibers","isUnkeyedTopLevelFragment","isObject","instance","render","_isMockFunction","Component","displayName","name","mountChildFibers","cloneChildFibers","workInProgress","currentChild","resetChildFibers","renderExpirationTime"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {ReactElement} from 'shared/ReactElementType';\nimport type {ReactPortal} from 'shared/ReactTypes';\nimport type {Fiber} from './ReactFiber';\nimport type {ExpirationTime} from './ReactFiberExpirationTime';\n\nimport getComponentName from 'shared/getComponentName';\nimport {Placement, Deletion} from 'shared/ReactSideEffectTags';\nimport {\n  getIteratorFn,\n  REACT_ELEMENT_TYPE,\n  REACT_FRAGMENT_TYPE,\n  REACT_PORTAL_TYPE,\n} from 'shared/ReactSymbols';\nimport {\n  FunctionComponent,\n  ClassComponent,\n  HostText,\n  HostPortal,\n  Fragment,\n} from 'shared/ReactWorkTags';\nimport invariant from 'shared/invariant';\nimport warning from 'shared/warning';\nimport warningWithoutStack from 'shared/warningWithoutStack';\nimport {warnAboutStringRefs} from 'shared/ReactFeatureFlags';\n\nimport {\n  createWorkInProgress,\n  resetWorkInProgress,\n  createFiberFromElement,\n  createFiberFromFragment,\n  createFiberFromText,\n  createFiberFromPortal,\n} from './ReactFiber';\nimport {emptyRefsObject} from './ReactFiberClassComponent';\nimport {\n  getCurrentFiberStackInDev,\n  getStackByFiberInDevAndProd,\n} from './ReactCurrentFiber';\nimport {isCompatibleFamilyForHotReloading} from './ReactFiberHotReloading';\nimport {StrictMode} from './ReactTypeOfMode';\n\nlet didWarnAboutMaps;\nlet didWarnAboutGenerators;\nlet didWarnAboutStringRefs;\nlet ownerHasKeyUseWarning;\nlet ownerHasFunctionTypeWarning;\nlet warnForMissingKey = (child: mixed) => {};\n\nif (__DEV__) {\n  didWarnAboutMaps = false;\n  didWarnAboutGenerators = false;\n  didWarnAboutStringRefs = {};\n\n  /**\n   * Warn if there's no key explicitly set on dynamic arrays of children or\n   * object keys are not valid. This allows us to keep track of children between\n   * updates.\n   */\n  ownerHasKeyUseWarning = {};\n  ownerHasFunctionTypeWarning = {};\n\n  warnForMissingKey = (child: mixed) => {\n    if (child === null || typeof child !== 'object') {\n      return;\n    }\n    if (!child._store || child._store.validated || child.key != null) {\n      return;\n    }\n    invariant(\n      typeof child._store === 'object',\n      'React Component in warnForMissingKey should have a _store. ' +\n        'This error is likely caused by a bug in React. Please file an issue.',\n    );\n    child._store.validated = true;\n\n    const currentComponentErrorInfo =\n      'Each child in a list should have a unique ' +\n      '\"key\" prop. See https://fb.me/react-warning-keys for ' +\n      'more information.' +\n      getCurrentFiberStackInDev();\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n\n    warning(\n      false,\n      'Each child in a list should have a unique ' +\n        '\"key\" prop. See https://fb.me/react-warning-keys for ' +\n        'more information.',\n    );\n  };\n}\n\nconst isArray = Array.isArray;\n\nfunction coerceRef(\n  returnFiber: Fiber,\n  current: Fiber | null,\n  element: ReactElement,\n) {\n  let mixedRef = element.ref;\n  if (\n    mixedRef !== null &&\n    typeof mixedRef !== 'function' &&\n    typeof mixedRef !== 'object'\n  ) {\n    if (__DEV__) {\n      // TODO: Clean this up once we turn on the string ref warning for\n      // everyone, because the strict mode case will no longer be relevant\n      if (returnFiber.mode & StrictMode || warnAboutStringRefs) {\n        const componentName = getComponentName(returnFiber.type) || 'Component';\n        if (!didWarnAboutStringRefs[componentName]) {\n          if (warnAboutStringRefs) {\n            warningWithoutStack(\n              false,\n              'Component \"%s\" contains the string ref \"%s\". Support for string refs ' +\n                'will be removed in a future major release. We recommend using ' +\n                'useRef() or createRef() instead. ' +\n                'Learn more about using refs safely here: ' +\n                'https://fb.me/react-strict-mode-string-ref%s',\n              componentName,\n              mixedRef,\n              getStackByFiberInDevAndProd(returnFiber),\n            );\n          } else {\n            warningWithoutStack(\n              false,\n              'A string ref, \"%s\", has been found within a strict mode tree. ' +\n                'String refs are a source of potential bugs and should be avoided. ' +\n                'We recommend using useRef() or createRef() instead. ' +\n                'Learn more about using refs safely here: ' +\n                'https://fb.me/react-strict-mode-string-ref%s',\n              mixedRef,\n              getStackByFiberInDevAndProd(returnFiber),\n            );\n          }\n          didWarnAboutStringRefs[componentName] = true;\n        }\n      }\n    }\n\n    if (element._owner) {\n      const owner: ?Fiber = (element._owner: any);\n      let inst;\n      if (owner) {\n        const ownerFiber = ((owner: any): Fiber);\n        invariant(\n          ownerFiber.tag === ClassComponent,\n          'Function components cannot have refs. ' +\n            'Did you mean to use React.forwardRef()?',\n        );\n        inst = ownerFiber.stateNode;\n      }\n      invariant(\n        inst,\n        'Missing owner for string ref %s. This error is likely caused by a ' +\n          'bug in React. Please file an issue.',\n        mixedRef,\n      );\n      const stringRef = '' + mixedRef;\n      // Check if previous string ref matches new string ref\n      if (\n        current !== null &&\n        current.ref !== null &&\n        typeof current.ref === 'function' &&\n        current.ref._stringRef === stringRef\n      ) {\n        return current.ref;\n      }\n      const ref = function(value) {\n        let refs = inst.refs;\n        if (refs === emptyRefsObject) {\n          // This is a lazy pooled frozen object, so we need to initialize.\n          refs = inst.refs = {};\n        }\n        if (value === null) {\n          delete refs[stringRef];\n        } else {\n          refs[stringRef] = value;\n        }\n      };\n      ref._stringRef = stringRef;\n      return ref;\n    } else {\n      invariant(\n        typeof mixedRef === 'string',\n        'Expected ref to be a function, a string, an object returned by React.createRef(), or null.',\n      );\n      invariant(\n        element._owner,\n        'Element ref was specified as a string (%s) but no owner was set. This could happen for one of' +\n          ' the following reasons:\\n' +\n          '1. You may be adding a ref to a function component\\n' +\n          \"2. You may be adding a ref to a component that was not created inside a component's render method\\n\" +\n          '3. You have multiple copies of React loaded\\n' +\n          'See https://fb.me/react-refs-must-have-owner for more information.',\n        mixedRef,\n      );\n    }\n  }\n  return mixedRef;\n}\n\nfunction throwOnInvalidObjectType(returnFiber: Fiber, newChild: Object) {\n  if (returnFiber.type !== 'textarea') {\n    let addendum = '';\n    if (__DEV__) {\n      addendum =\n        ' If you meant to render a collection of children, use an array ' +\n        'instead.' +\n        getCurrentFiberStackInDev();\n    }\n    invariant(\n      false,\n      'Objects are not valid as a React child (found: %s).%s',\n      Object.prototype.toString.call(newChild) === '[object Object]'\n        ? 'object with keys {' + Object.keys(newChild).join(', ') + '}'\n        : newChild,\n      addendum,\n    );\n  }\n}\n\nfunction warnOnFunctionType() {\n  const currentComponentErrorInfo =\n    'Functions are not valid as a React child. This may happen if ' +\n    'you return a Component instead of <Component /> from render. ' +\n    'Or maybe you meant to call this function rather than return it.' +\n    getCurrentFiberStackInDev();\n\n  if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {\n    return;\n  }\n  ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;\n\n  warning(\n    false,\n    'Functions are not valid as a React child. This may happen if ' +\n      'you return a Component instead of <Component /> from render. ' +\n      'Or maybe you meant to call this function rather than return it.',\n  );\n}\n\n// This wrapper function exists because I expect to clone the code in each path\n// to be able to optimize each path individually by branching early. This needs\n// a compiler or we can do it manually. Helpers that don't need this branching\n// live outside of this function.\nfunction ChildReconciler(shouldTrackSideEffects) {\n  function deleteChild(returnFiber: Fiber, childToDelete: Fiber): void {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return;\n    }\n    // Deletions are added in reversed order so we add it to the front.\n    // At this point, the return fiber's effect list is empty except for\n    // deletions, so we can just append the deletion to the list. The remaining\n    // effects aren't added until the complete phase. Once we implement\n    // resuming, this may not be true.\n    const last = returnFiber.lastEffect;\n    if (last !== null) {\n      last.nextEffect = childToDelete;\n      returnFiber.lastEffect = childToDelete;\n    } else {\n      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n    }\n    childToDelete.nextEffect = null;\n    childToDelete.effectTag = Deletion;\n  }\n\n  function deleteRemainingChildren(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber | null,\n  ): null {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return null;\n    }\n\n    // TODO: For the shouldClone case, this could be micro-optimized a bit by\n    // assuming that after the first child we've already added everything.\n    let childToDelete = currentFirstChild;\n    while (childToDelete !== null) {\n      deleteChild(returnFiber, childToDelete);\n      childToDelete = childToDelete.sibling;\n    }\n    return null;\n  }\n\n  function mapRemainingChildren(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber,\n  ): Map<string | number, Fiber> {\n    // Add the remaining children to a temporary map so that we can find them by\n    // keys quickly. Implicit (null) keys get added to this set with their index\n    // instead.\n    const existingChildren: Map<string | number, Fiber> = new Map();\n\n    let existingChild = currentFirstChild;\n    while (existingChild !== null) {\n      if (existingChild.key !== null) {\n        existingChildren.set(existingChild.key, existingChild);\n      } else {\n        existingChildren.set(existingChild.index, existingChild);\n      }\n      existingChild = existingChild.sibling;\n    }\n    return existingChildren;\n  }\n\n  function useFiber(\n    fiber: Fiber,\n    pendingProps: mixed,\n    expirationTime: ExpirationTime,\n  ): Fiber {\n    // We currently set sibling to null and index to 0 here because it is easy\n    // to forget to do before returning it. E.g. for the single child case.\n    const clone = createWorkInProgress(fiber, pendingProps, expirationTime);\n    clone.index = 0;\n    clone.sibling = null;\n    return clone;\n  }\n\n  function placeChild(\n    newFiber: Fiber,\n    lastPlacedIndex: number,\n    newIndex: number,\n  ): number {\n    newFiber.index = newIndex;\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return lastPlacedIndex;\n    }\n    const current = newFiber.alternate;\n    if (current !== null) {\n      const oldIndex = current.index;\n      if (oldIndex < lastPlacedIndex) {\n        // This is a move.\n        newFiber.effectTag = Placement;\n        return lastPlacedIndex;\n      } else {\n        // This item can stay in place.\n        return oldIndex;\n      }\n    } else {\n      // This is an insertion.\n      newFiber.effectTag = Placement;\n      return lastPlacedIndex;\n    }\n  }\n\n  function placeSingleChild(newFiber: Fiber): Fiber {\n    // This is simpler for the single child case. We only need to do a\n    // placement for inserting new children.\n    if (shouldTrackSideEffects && newFiber.alternate === null) {\n      newFiber.effectTag = Placement;\n    }\n    return newFiber;\n  }\n\n  function updateTextNode(\n    returnFiber: Fiber,\n    current: Fiber | null,\n    textContent: string,\n    expirationTime: ExpirationTime,\n  ) {\n    if (current === null || current.tag !== HostText) {\n      // Insert\n      const created = createFiberFromText(\n        textContent,\n        returnFiber.mode,\n        expirationTime,\n      );\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      const existing = useFiber(current, textContent, expirationTime);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateElement(\n    returnFiber: Fiber,\n    current: Fiber | null,\n    element: ReactElement,\n    expirationTime: ExpirationTime,\n  ): Fiber {\n    if (\n      current !== null &&\n      (current.elementType === element.type ||\n        // Keep this check inline so it only runs on the false path:\n        (__DEV__ ? isCompatibleFamilyForHotReloading(current, element) : false))\n    ) {\n      // Move based on index\n      const existing = useFiber(current, element.props, expirationTime);\n      existing.ref = coerceRef(returnFiber, current, element);\n      existing.return = returnFiber;\n      if (__DEV__) {\n        existing._debugSource = element._source;\n        existing._debugOwner = element._owner;\n      }\n      return existing;\n    } else {\n      // Insert\n      const created = createFiberFromElement(\n        element,\n        returnFiber.mode,\n        expirationTime,\n      );\n      created.ref = coerceRef(returnFiber, current, element);\n      created.return = returnFiber;\n      return created;\n    }\n  }\n\n  function updatePortal(\n    returnFiber: Fiber,\n    current: Fiber | null,\n    portal: ReactPortal,\n    expirationTime: ExpirationTime,\n  ): Fiber {\n    if (\n      current === null ||\n      current.tag !== HostPortal ||\n      current.stateNode.containerInfo !== portal.containerInfo ||\n      current.stateNode.implementation !== portal.implementation\n    ) {\n      // Insert\n      const created = createFiberFromPortal(\n        portal,\n        returnFiber.mode,\n        expirationTime,\n      );\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      const existing = useFiber(current, portal.children || [], expirationTime);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateFragment(\n    returnFiber: Fiber,\n    current: Fiber | null,\n    fragment: Iterable<*>,\n    expirationTime: ExpirationTime,\n    key: null | string,\n  ): Fiber {\n    if (current === null || current.tag !== Fragment) {\n      // Insert\n      const created = createFiberFromFragment(\n        fragment,\n        returnFiber.mode,\n        expirationTime,\n        key,\n      );\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      const existing = useFiber(current, fragment, expirationTime);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function createChild(\n    returnFiber: Fiber,\n    newChild: any,\n    expirationTime: ExpirationTime,\n  ): Fiber | null {\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      const created = createFiberFromText(\n        '' + newChild,\n        returnFiber.mode,\n        expirationTime,\n      );\n      created.return = returnFiber;\n      return created;\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE: {\n          const created = createFiberFromElement(\n            newChild,\n            returnFiber.mode,\n            expirationTime,\n          );\n          created.ref = coerceRef(returnFiber, null, newChild);\n          created.return = returnFiber;\n          return created;\n        }\n        case REACT_PORTAL_TYPE: {\n          const created = createFiberFromPortal(\n            newChild,\n            returnFiber.mode,\n            expirationTime,\n          );\n          created.return = returnFiber;\n          return created;\n        }\n      }\n\n      if (isArray(newChild) || getIteratorFn(newChild)) {\n        const created = createFiberFromFragment(\n          newChild,\n          returnFiber.mode,\n          expirationTime,\n          null,\n        );\n        created.return = returnFiber;\n        return created;\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    if (__DEV__) {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  function updateSlot(\n    returnFiber: Fiber,\n    oldFiber: Fiber | null,\n    newChild: any,\n    expirationTime: ExpirationTime,\n  ): Fiber | null {\n    // Update the fiber if the keys match, otherwise return null.\n\n    const key = oldFiber !== null ? oldFiber.key : null;\n\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      if (key !== null) {\n        return null;\n      }\n      return updateTextNode(\n        returnFiber,\n        oldFiber,\n        '' + newChild,\n        expirationTime,\n      );\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE: {\n          if (newChild.key === key) {\n            if (newChild.type === REACT_FRAGMENT_TYPE) {\n              return updateFragment(\n                returnFiber,\n                oldFiber,\n                newChild.props.children,\n                expirationTime,\n                key,\n              );\n            }\n            return updateElement(\n              returnFiber,\n              oldFiber,\n              newChild,\n              expirationTime,\n            );\n          } else {\n            return null;\n          }\n        }\n        case REACT_PORTAL_TYPE: {\n          if (newChild.key === key) {\n            return updatePortal(\n              returnFiber,\n              oldFiber,\n              newChild,\n              expirationTime,\n            );\n          } else {\n            return null;\n          }\n        }\n      }\n\n      if (isArray(newChild) || getIteratorFn(newChild)) {\n        if (key !== null) {\n          return null;\n        }\n\n        return updateFragment(\n          returnFiber,\n          oldFiber,\n          newChild,\n          expirationTime,\n          null,\n        );\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    if (__DEV__) {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  function updateFromMap(\n    existingChildren: Map<string | number, Fiber>,\n    returnFiber: Fiber,\n    newIdx: number,\n    newChild: any,\n    expirationTime: ExpirationTime,\n  ): Fiber | null {\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys, so we neither have to check the old nor\n      // new node for the key. If both are text nodes, they match.\n      const matchedFiber = existingChildren.get(newIdx) || null;\n      return updateTextNode(\n        returnFiber,\n        matchedFiber,\n        '' + newChild,\n        expirationTime,\n      );\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE: {\n          const matchedFiber =\n            existingChildren.get(\n              newChild.key === null ? newIdx : newChild.key,\n            ) || null;\n          if (newChild.type === REACT_FRAGMENT_TYPE) {\n            return updateFragment(\n              returnFiber,\n              matchedFiber,\n              newChild.props.children,\n              expirationTime,\n              newChild.key,\n            );\n          }\n          return updateElement(\n            returnFiber,\n            matchedFiber,\n            newChild,\n            expirationTime,\n          );\n        }\n        case REACT_PORTAL_TYPE: {\n          const matchedFiber =\n            existingChildren.get(\n              newChild.key === null ? newIdx : newChild.key,\n            ) || null;\n          return updatePortal(\n            returnFiber,\n            matchedFiber,\n            newChild,\n            expirationTime,\n          );\n        }\n      }\n\n      if (isArray(newChild) || getIteratorFn(newChild)) {\n        const matchedFiber = existingChildren.get(newIdx) || null;\n        return updateFragment(\n          returnFiber,\n          matchedFiber,\n          newChild,\n          expirationTime,\n          null,\n        );\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    if (__DEV__) {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Warns if there is a duplicate or missing key\n   */\n  function warnOnInvalidKey(\n    child: mixed,\n    knownKeys: Set<string> | null,\n  ): Set<string> | null {\n    if (__DEV__) {\n      if (typeof child !== 'object' || child === null) {\n        return knownKeys;\n      }\n      switch (child.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n        case REACT_PORTAL_TYPE:\n          warnForMissingKey(child);\n          const key = child.key;\n          if (typeof key !== 'string') {\n            break;\n          }\n          if (knownKeys === null) {\n            knownKeys = new Set();\n            knownKeys.add(key);\n            break;\n          }\n          if (!knownKeys.has(key)) {\n            knownKeys.add(key);\n            break;\n          }\n          warning(\n            false,\n            'Encountered two children with the same key, `%s`. ' +\n              'Keys should be unique so that components maintain their identity ' +\n              'across updates. Non-unique keys may cause children to be ' +\n              'duplicated and/or omitted — the behavior is unsupported and ' +\n              'could change in a future version.',\n            key,\n          );\n          break;\n        default:\n          break;\n      }\n    }\n    return knownKeys;\n  }\n\n  function reconcileChildrenArray(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber | null,\n    newChildren: Array<*>,\n    expirationTime: ExpirationTime,\n  ): Fiber | null {\n    // This algorithm can't optimize by searching from both ends since we\n    // don't have backpointers on fibers. I'm trying to see how far we can get\n    // with that model. If it ends up not being worth the tradeoffs, we can\n    // add it later.\n\n    // Even with a two ended optimization, we'd want to optimize for the case\n    // where there are few changes and brute force the comparison instead of\n    // going for the Map. It'd like to explore hitting that path first in\n    // forward-only mode and only go for the Map once we notice that we need\n    // lots of look ahead. This doesn't handle reversal as well as two ended\n    // search but that's unusual. Besides, for the two ended optimization to\n    // work on Iterables, we'd need to copy the whole set.\n\n    // In this first iteration, we'll just live with hitting the bad case\n    // (adding everything to a Map) in for every insert/move.\n\n    // If you change this code, also update reconcileChildrenIterator() which\n    // uses the same algorithm.\n\n    if (__DEV__) {\n      // First, validate keys.\n      let knownKeys = null;\n      for (let i = 0; i < newChildren.length; i++) {\n        const child = newChildren[i];\n        knownKeys = warnOnInvalidKey(child, knownKeys);\n      }\n    }\n\n    let resultingFirstChild: Fiber | null = null;\n    let previousNewFiber: Fiber | null = null;\n\n    let oldFiber = currentFirstChild;\n    let lastPlacedIndex = 0;\n    let newIdx = 0;\n    let nextOldFiber = null;\n    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n      const newFiber = updateSlot(\n        returnFiber,\n        oldFiber,\n        newChildren[newIdx],\n        expirationTime,\n      );\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (oldFiber === null) {\n          oldFiber = nextOldFiber;\n        }\n        break;\n      }\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (newIdx === newChildren.length) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; newIdx < newChildren.length; newIdx++) {\n        const newFiber = createChild(\n          returnFiber,\n          newChildren[newIdx],\n          expirationTime,\n        );\n        if (newFiber === null) {\n          continue;\n        }\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = newFiber;\n        } else {\n          previousNewFiber.sibling = newFiber;\n        }\n        previousNewFiber = newFiber;\n      }\n      return resultingFirstChild;\n    }\n\n    // Add all children to a key map for quick lookups.\n    const existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n    // Keep scanning and use the map to restore deleted items as moves.\n    for (; newIdx < newChildren.length; newIdx++) {\n      const newFiber = updateFromMap(\n        existingChildren,\n        returnFiber,\n        newIdx,\n        newChildren[newIdx],\n        expirationTime,\n      );\n      if (newFiber !== null) {\n        if (shouldTrackSideEffects) {\n          if (newFiber.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren.delete(\n              newFiber.key === null ? newIdx : newFiber.key,\n            );\n          }\n        }\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          resultingFirstChild = newFiber;\n        } else {\n          previousNewFiber.sibling = newFiber;\n        }\n        previousNewFiber = newFiber;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(child => deleteChild(returnFiber, child));\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileChildrenIterator(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber | null,\n    newChildrenIterable: Iterable<*>,\n    expirationTime: ExpirationTime,\n  ): Fiber | null {\n    // This is the same implementation as reconcileChildrenArray(),\n    // but using the iterator instead.\n\n    const iteratorFn = getIteratorFn(newChildrenIterable);\n    invariant(\n      typeof iteratorFn === 'function',\n      'An object is not an iterable. This error is likely caused by a bug in ' +\n        'React. Please file an issue.',\n    );\n\n    if (__DEV__) {\n      // We don't support rendering Generators because it's a mutation.\n      // See https://github.com/facebook/react/issues/12995\n      if (\n        typeof Symbol === 'function' &&\n        // $FlowFixMe Flow doesn't know about toStringTag\n        newChildrenIterable[Symbol.toStringTag] === 'Generator'\n      ) {\n        warning(\n          didWarnAboutGenerators,\n          'Using Generators as children is unsupported and will likely yield ' +\n            'unexpected results because enumerating a generator mutates it. ' +\n            'You may convert it to an array with `Array.from()` or the ' +\n            '`[...spread]` operator before rendering. Keep in mind ' +\n            'you might need to polyfill these features for older browsers.',\n        );\n        didWarnAboutGenerators = true;\n      }\n\n      // Warn about using Maps as children\n      if ((newChildrenIterable: any).entries === iteratorFn) {\n        warning(\n          didWarnAboutMaps,\n          'Using Maps as children is unsupported and will likely yield ' +\n            'unexpected results. Convert it to a sequence/iterable of keyed ' +\n            'ReactElements instead.',\n        );\n        didWarnAboutMaps = true;\n      }\n\n      // First, validate keys.\n      // We'll get a different iterator later for the main pass.\n      const newChildren = iteratorFn.call(newChildrenIterable);\n      if (newChildren) {\n        let knownKeys = null;\n        let step = newChildren.next();\n        for (; !step.done; step = newChildren.next()) {\n          const child = step.value;\n          knownKeys = warnOnInvalidKey(child, knownKeys);\n        }\n      }\n    }\n\n    const newChildren = iteratorFn.call(newChildrenIterable);\n    invariant(newChildren != null, 'An iterable object provided no iterator.');\n\n    let resultingFirstChild: Fiber | null = null;\n    let previousNewFiber: Fiber | null = null;\n\n    let oldFiber = currentFirstChild;\n    let lastPlacedIndex = 0;\n    let newIdx = 0;\n    let nextOldFiber = null;\n\n    let step = newChildren.next();\n    for (\n      ;\n      oldFiber !== null && !step.done;\n      newIdx++, step = newChildren.next()\n    ) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n      const newFiber = updateSlot(\n        returnFiber,\n        oldFiber,\n        step.value,\n        expirationTime,\n      );\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (oldFiber === null) {\n          oldFiber = nextOldFiber;\n        }\n        break;\n      }\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (step.done) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; !step.done; newIdx++, step = newChildren.next()) {\n        const newFiber = createChild(returnFiber, step.value, expirationTime);\n        if (newFiber === null) {\n          continue;\n        }\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = newFiber;\n        } else {\n          previousNewFiber.sibling = newFiber;\n        }\n        previousNewFiber = newFiber;\n      }\n      return resultingFirstChild;\n    }\n\n    // Add all children to a key map for quick lookups.\n    const existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n    // Keep scanning and use the map to restore deleted items as moves.\n    for (; !step.done; newIdx++, step = newChildren.next()) {\n      const newFiber = updateFromMap(\n        existingChildren,\n        returnFiber,\n        newIdx,\n        step.value,\n        expirationTime,\n      );\n      if (newFiber !== null) {\n        if (shouldTrackSideEffects) {\n          if (newFiber.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren.delete(\n              newFiber.key === null ? newIdx : newFiber.key,\n            );\n          }\n        }\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          resultingFirstChild = newFiber;\n        } else {\n          previousNewFiber.sibling = newFiber;\n        }\n        previousNewFiber = newFiber;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(child => deleteChild(returnFiber, child));\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileSingleTextNode(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber | null,\n    textContent: string,\n    expirationTime: ExpirationTime,\n  ): Fiber {\n    // There's no need to check for keys on text nodes since we don't have a\n    // way to define them.\n    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n      // We already have an existing node so let's just update it and delete\n      // the rest.\n      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n      const existing = useFiber(currentFirstChild, textContent, expirationTime);\n      existing.return = returnFiber;\n      return existing;\n    }\n    // The existing first child is not a text node so we need to create one\n    // and delete the existing ones.\n    deleteRemainingChildren(returnFiber, currentFirstChild);\n    const created = createFiberFromText(\n      textContent,\n      returnFiber.mode,\n      expirationTime,\n    );\n    created.return = returnFiber;\n    return created;\n  }\n\n  function reconcileSingleElement(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber | null,\n    element: ReactElement,\n    expirationTime: ExpirationTime,\n  ): Fiber {\n    const key = element.key;\n    let child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (\n          child.tag === Fragment\n            ? element.type === REACT_FRAGMENT_TYPE\n            : child.elementType === element.type ||\n              // Keep this check inline so it only runs on the false path:\n              (__DEV__\n                ? isCompatibleFamilyForHotReloading(child, element)\n                : false)\n        ) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          const existing = useFiber(\n            child,\n            element.type === REACT_FRAGMENT_TYPE\n              ? element.props.children\n              : element.props,\n            expirationTime,\n          );\n          existing.ref = coerceRef(returnFiber, child, element);\n          existing.return = returnFiber;\n          if (__DEV__) {\n            existing._debugSource = element._source;\n            existing._debugOwner = element._owner;\n          }\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    if (element.type === REACT_FRAGMENT_TYPE) {\n      const created = createFiberFromFragment(\n        element.props.children,\n        returnFiber.mode,\n        expirationTime,\n        element.key,\n      );\n      created.return = returnFiber;\n      return created;\n    } else {\n      const created = createFiberFromElement(\n        element,\n        returnFiber.mode,\n        expirationTime,\n      );\n      created.ref = coerceRef(returnFiber, currentFirstChild, element);\n      created.return = returnFiber;\n      return created;\n    }\n  }\n\n  function reconcileSinglePortal(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber | null,\n    portal: ReactPortal,\n    expirationTime: ExpirationTime,\n  ): Fiber {\n    const key = portal.key;\n    let child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (\n          child.tag === HostPortal &&\n          child.stateNode.containerInfo === portal.containerInfo &&\n          child.stateNode.implementation === portal.implementation\n        ) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          const existing = useFiber(\n            child,\n            portal.children || [],\n            expirationTime,\n          );\n          existing.return = returnFiber;\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    const created = createFiberFromPortal(\n      portal,\n      returnFiber.mode,\n      expirationTime,\n    );\n    created.return = returnFiber;\n    return created;\n  }\n\n  // This API will tag the children with the side-effect of the reconciliation\n  // itself. They will be added to the side-effect list as we pass through the\n  // children and the parent.\n  function reconcileChildFibers(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber | null,\n    newChild: any,\n    expirationTime: ExpirationTime,\n  ): Fiber | null {\n    // This function is not recursive.\n    // If the top level item is an array, we treat it as a set of children,\n    // not as a fragment. Nested arrays on the other hand will be treated as\n    // fragment nodes. Recursion happens at the normal flow.\n\n    // Handle top level unkeyed fragments as if they were arrays.\n    // This leads to an ambiguity between <>{[...]}</> and <>...</>.\n    // We treat the ambiguous cases above the same.\n    const isUnkeyedTopLevelFragment =\n      typeof newChild === 'object' &&\n      newChild !== null &&\n      newChild.type === REACT_FRAGMENT_TYPE &&\n      newChild.key === null;\n    if (isUnkeyedTopLevelFragment) {\n      newChild = newChild.props.children;\n    }\n\n    // Handle object types\n    const isObject = typeof newChild === 'object' && newChild !== null;\n\n    if (isObject) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          return placeSingleChild(\n            reconcileSingleElement(\n              returnFiber,\n              currentFirstChild,\n              newChild,\n              expirationTime,\n            ),\n          );\n        case REACT_PORTAL_TYPE:\n          return placeSingleChild(\n            reconcileSinglePortal(\n              returnFiber,\n              currentFirstChild,\n              newChild,\n              expirationTime,\n            ),\n          );\n      }\n    }\n\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      return placeSingleChild(\n        reconcileSingleTextNode(\n          returnFiber,\n          currentFirstChild,\n          '' + newChild,\n          expirationTime,\n        ),\n      );\n    }\n\n    if (isArray(newChild)) {\n      return reconcileChildrenArray(\n        returnFiber,\n        currentFirstChild,\n        newChild,\n        expirationTime,\n      );\n    }\n\n    if (getIteratorFn(newChild)) {\n      return reconcileChildrenIterator(\n        returnFiber,\n        currentFirstChild,\n        newChild,\n        expirationTime,\n      );\n    }\n\n    if (isObject) {\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    if (__DEV__) {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n    if (typeof newChild === 'undefined' && !isUnkeyedTopLevelFragment) {\n      // If the new child is undefined, and the return fiber is a composite\n      // component, throw an error. If Fiber return types are disabled,\n      // we already threw above.\n      switch (returnFiber.tag) {\n        case ClassComponent: {\n          if (__DEV__) {\n            const instance = returnFiber.stateNode;\n            if (instance.render._isMockFunction) {\n              // We allow auto-mocks to proceed as if they're returning null.\n              break;\n            }\n          }\n        }\n        // Intentionally fall through to the next case, which handles both\n        // functions and classes\n        // eslint-disable-next-lined no-fallthrough\n        case FunctionComponent: {\n          const Component = returnFiber.type;\n          invariant(\n            false,\n            '%s(...): Nothing was returned from render. This usually means a ' +\n              'return statement is missing. Or, to render nothing, ' +\n              'return null.',\n            Component.displayName || Component.name || 'Component',\n          );\n        }\n      }\n    }\n\n    // Remaining cases are all treated as empty.\n    return deleteRemainingChildren(returnFiber, currentFirstChild);\n  }\n\n  return reconcileChildFibers;\n}\n\nexport const reconcileChildFibers = ChildReconciler(true);\nexport const mountChildFibers = ChildReconciler(false);\n\nexport function cloneChildFibers(\n  current: Fiber | null,\n  workInProgress: Fiber,\n): void {\n  invariant(\n    current === null || workInProgress.child === current.child,\n    'Resuming work not yet implemented.',\n  );\n\n  if (workInProgress.child === null) {\n    return;\n  }\n\n  let currentChild = workInProgress.child;\n  let newChild = createWorkInProgress(\n    currentChild,\n    currentChild.pendingProps,\n    currentChild.expirationTime,\n  );\n  workInProgress.child = newChild;\n\n  newChild.return = workInProgress;\n  while (currentChild.sibling !== null) {\n    currentChild = currentChild.sibling;\n    newChild = newChild.sibling = createWorkInProgress(\n      currentChild,\n      currentChild.pendingProps,\n      currentChild.expirationTime,\n    );\n    newChild.return = workInProgress;\n  }\n  newChild.sibling = null;\n}\n\n// Reset a workInProgress child set to prepare it for a second pass.\nexport function resetChildFibers(\n  workInProgress: Fiber,\n  renderExpirationTime: ExpirationTime,\n): void {\n  let child = workInProgress.child;\n  while (child !== null) {\n    resetWorkInProgress(child, renderExpirationTime);\n    child = child.sibling;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}