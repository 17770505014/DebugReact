{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// Intentionally not named imports because Rollup would use dynamic dispatch for\n// CommonJS interop named imports.\nimport * as Scheduler from 'scheduler';\nimport { batchedEventUpdates, discreteUpdates, flushDiscreteUpdatesIfNeeded } from 'legacy-events/ReactGenericBatching';\nimport { runExtractedPluginEventsInBatch } from 'legacy-events/EventPluginHub';\nimport { dispatchEventForResponderEventSystem } from '../events/DOMEventResponderSystem';\nimport { getNearestMountedFiber } from 'react-reconciler/reflection';\nimport { HostRoot, SuspenseComponent, HostComponent, HostText } from 'shared/ReactWorkTags';\nimport { PLUGIN_EVENT_SYSTEM, RESPONDER_EVENT_SYSTEM, IS_PASSIVE, IS_ACTIVE, PASSIVE_NOT_SUPPORTED } from 'legacy-events/EventSystemFlags';\nimport { addEventBubbleListener, addEventCaptureListener, addEventCaptureListenerWithPassiveFlag } from './EventListener';\nimport getEventTarget from './getEventTarget';\nimport { getClosestInstanceFromNode } from '../client/ReactDOMComponentTree';\nimport SimpleEventPlugin from './SimpleEventPlugin';\nimport { getRawEventName } from './DOMTopLevelEventTypes';\nimport { passiveBrowserEventsSupported } from './checkPassiveEvents';\nimport { enableFlareAPI, enableUserBlockingEvents } from 'shared/ReactFeatureFlags';\nimport { UserBlockingEvent, ContinuousEvent, DiscreteEvent } from 'shared/ReactTypes';\nconst {\n  unstable_UserBlockingPriority: UserBlockingPriority,\n  unstable_runWithPriority: runWithPriority\n} = Scheduler;\nconst {\n  getEventPriority\n} = SimpleEventPlugin;\nconst CALLBACK_BOOKKEEPING_POOL_SIZE = 10;\nconst callbackBookkeepingPool = [];\n\n/**\n * Find the deepest React component completely containing the root of the\n * passed-in instance (for use when entire React trees are nested within each\n * other). If React trees are not nested, returns null.\n */\nfunction findRootContainerNode(inst) {\n  if (inst.tag === HostRoot) {\n    return inst.stateNode.containerInfo;\n  } // TODO: It may be a good idea to cache this to prevent unnecessary DOM\n  // traversal, but caching is difficult to do correctly without using a\n  // mutation observer to listen for all DOM changes.\n\n\n  while (inst.return) {\n    inst = inst.return;\n  }\n\n  if (inst.tag !== HostRoot) {\n    // This can happen if we're in a detached tree.\n    return null;\n  }\n\n  return inst.stateNode.containerInfo;\n} // Used to store ancestor hierarchy in top level callback\n\n\nfunction getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst) {\n  if (callbackBookkeepingPool.length) {\n    const instance = callbackBookkeepingPool.pop();\n    instance.topLevelType = topLevelType;\n    instance.nativeEvent = nativeEvent;\n    instance.targetInst = targetInst;\n    return instance;\n  }\n\n  return {\n    topLevelType,\n    nativeEvent,\n    targetInst,\n    ancestors: []\n  };\n}\n\nfunction releaseTopLevelCallbackBookKeeping(instance) {\n  instance.topLevelType = null;\n  instance.nativeEvent = null;\n  instance.targetInst = null;\n  instance.ancestors.length = 0;\n\n  if (callbackBookkeepingPool.length < CALLBACK_BOOKKEEPING_POOL_SIZE) {\n    callbackBookkeepingPool.push(instance);\n  }\n}\n\nfunction handleTopLevel(bookKeeping) {\n  let targetInst = bookKeeping.targetInst; // Loop through the hierarchy, in case there's any nested components.\n  // It's important that we build the array of ancestors before calling any\n  // event handlers, because event handlers can modify the DOM, leading to\n  // inconsistencies with ReactMount's node cache. See #1105.\n\n  let ancestor = targetInst;\n\n  do {\n    if (!ancestor) {\n      const ancestors = bookKeeping.ancestors;\n      ancestors.push(ancestor);\n      break;\n    }\n\n    const root = findRootContainerNode(ancestor);\n\n    if (!root) {\n      break;\n    }\n\n    const tag = ancestor.tag;\n\n    if (tag === HostComponent || tag === HostText) {\n      bookKeeping.ancestors.push(ancestor);\n    }\n\n    ancestor = getClosestInstanceFromNode(root);\n  } while (ancestor);\n\n  for (let i = 0; i < bookKeeping.ancestors.length; i++) {\n    targetInst = bookKeeping.ancestors[i];\n    const eventTarget = getEventTarget(bookKeeping.nativeEvent);\n    const topLevelType = bookKeeping.topLevelType;\n    const nativeEvent = bookKeeping.nativeEvent;\n    runExtractedPluginEventsInBatch(topLevelType, targetInst, nativeEvent, eventTarget);\n  }\n} // TODO: can we stop exporting these?\n\n\nexport let _enabled = true;\nexport function setEnabled(enabled) {\n  _enabled = !!enabled;\n}\nexport function isEnabled() {\n  return _enabled;\n}\nexport function trapBubbledEvent(topLevelType, element) {\n  trapEventForPluginEventSystem(element, topLevelType, false);\n}\nexport function trapCapturedEvent(topLevelType, element) {\n  trapEventForPluginEventSystem(element, topLevelType, true);\n}\nexport function trapEventForResponderEventSystem(element, topLevelType, passive) {\n  if (enableFlareAPI) {\n    const rawEventName = getRawEventName(topLevelType);\n    let eventFlags = RESPONDER_EVENT_SYSTEM; // If passive option is not supported, then the event will be\n    // active and not passive, but we flag it as using not being\n    // supported too. This way the responder event plugins know,\n    // and can provide polyfills if needed.\n\n    if (passive) {\n      if (passiveBrowserEventsSupported) {\n        eventFlags |= IS_PASSIVE;\n      } else {\n        eventFlags |= IS_ACTIVE;\n        eventFlags |= PASSIVE_NOT_SUPPORTED;\n        passive = false;\n      }\n    } else {\n      eventFlags |= IS_ACTIVE;\n    } // Check if interactive and wrap in discreteUpdates\n\n\n    const listener = dispatchEvent.bind(null, topLevelType, eventFlags);\n\n    if (passiveBrowserEventsSupported) {\n      addEventCaptureListenerWithPassiveFlag(element, rawEventName, listener, passive);\n    } else {\n      addEventCaptureListener(element, rawEventName, listener);\n    }\n  }\n}\n\nfunction trapEventForPluginEventSystem(element, topLevelType, capture) {\n  let listener;\n\n  switch (getEventPriority(topLevelType)) {\n    case DiscreteEvent:\n      listener = dispatchDiscreteEvent.bind(null, topLevelType, PLUGIN_EVENT_SYSTEM);\n      break;\n\n    case UserBlockingEvent:\n      listener = dispatchUserBlockingUpdate.bind(null, topLevelType, PLUGIN_EVENT_SYSTEM);\n      break;\n\n    case ContinuousEvent:\n    default:\n      listener = dispatchEvent.bind(null, topLevelType, PLUGIN_EVENT_SYSTEM);\n      break;\n  }\n\n  const rawEventName = getRawEventName(topLevelType);\n\n  if (capture) {\n    addEventCaptureListener(element, rawEventName, listener);\n  } else {\n    addEventBubbleListener(element, rawEventName, listener);\n  }\n}\n\nfunction dispatchDiscreteEvent(topLevelType, eventSystemFlags, nativeEvent) {\n  flushDiscreteUpdatesIfNeeded(nativeEvent.timeStamp);\n  discreteUpdates(dispatchEvent, topLevelType, eventSystemFlags, nativeEvent);\n}\n\nfunction dispatchUserBlockingUpdate(topLevelType, eventSystemFlags, nativeEvent) {\n  if (enableUserBlockingEvents) {\n    runWithPriority(UserBlockingPriority, dispatchEvent.bind(null, topLevelType, eventSystemFlags, nativeEvent));\n  } else {\n    dispatchEvent(topLevelType, eventSystemFlags, nativeEvent);\n  }\n}\n\nfunction dispatchEventForPluginEventSystem(topLevelType, eventSystemFlags, nativeEvent, targetInst) {\n  const bookKeeping = getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst);\n\n  try {\n    // Event queue being processed in the same cycle allows\n    // `preventDefault`.\n    batchedEventUpdates(handleTopLevel, bookKeeping);\n  } finally {\n    releaseTopLevelCallbackBookKeeping(bookKeeping);\n  }\n}\n\nexport function dispatchEvent(topLevelType, eventSystemFlags, nativeEvent) {\n  if (!_enabled) {\n    return;\n  }\n\n  const nativeEventTarget = getEventTarget(nativeEvent);\n  let targetInst = getClosestInstanceFromNode(nativeEventTarget);\n\n  if (targetInst !== null) {\n    let nearestMounted = getNearestMountedFiber(targetInst);\n\n    if (nearestMounted === null) {\n      // This tree has been unmounted already.\n      targetInst = null;\n    } else {\n      const tag = nearestMounted.tag;\n\n      if (tag === SuspenseComponent) {\n        // TODO: This is a good opportunity to schedule a replay of\n        // the event instead once this boundary has been hydrated.\n        // For now we're going to just ignore this event as if it's\n        // not mounted.\n        targetInst = null;\n      } else if (tag === HostRoot) {\n        // We have not yet mounted/hydrated the first children.\n        // TODO: This is a good opportunity to schedule a replay of\n        // the event instead once this root has been hydrated.\n        // For now we're going to just ignore this event as if it's\n        // not mounted.\n        targetInst = null;\n      } else if (nearestMounted !== targetInst) {\n        // If we get an event (ex: img onload) before committing that\n        // component's mount, ignore it for now (that is, treat it as if it was an\n        // event on a non-React tree). We might also consider queueing events and\n        // dispatching them after the mount.\n        targetInst = null;\n      }\n    }\n  }\n\n  if (enableFlareAPI) {\n    if (eventSystemFlags === PLUGIN_EVENT_SYSTEM) {\n      dispatchEventForPluginEventSystem(topLevelType, eventSystemFlags, nativeEvent, targetInst);\n    } else {\n      // React Flare event system\n      dispatchEventForResponderEventSystem(topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);\n    }\n  } else {\n    dispatchEventForPluginEventSystem(topLevelType, eventSystemFlags, nativeEvent, targetInst);\n  }\n}","map":{"version":3,"sources":["/Users/gaoshaoyun/Documents/library/debug-react/src/react/packages/react-dom/src/events/ReactDOMEventListener.js"],"names":["Scheduler","batchedEventUpdates","discreteUpdates","flushDiscreteUpdatesIfNeeded","runExtractedPluginEventsInBatch","dispatchEventForResponderEventSystem","getNearestMountedFiber","HostRoot","SuspenseComponent","HostComponent","HostText","PLUGIN_EVENT_SYSTEM","RESPONDER_EVENT_SYSTEM","IS_PASSIVE","IS_ACTIVE","PASSIVE_NOT_SUPPORTED","addEventBubbleListener","addEventCaptureListener","addEventCaptureListenerWithPassiveFlag","getEventTarget","getClosestInstanceFromNode","SimpleEventPlugin","getRawEventName","passiveBrowserEventsSupported","enableFlareAPI","enableUserBlockingEvents","UserBlockingEvent","ContinuousEvent","DiscreteEvent","unstable_UserBlockingPriority","UserBlockingPriority","unstable_runWithPriority","runWithPriority","getEventPriority","CALLBACK_BOOKKEEPING_POOL_SIZE","callbackBookkeepingPool","findRootContainerNode","inst","tag","stateNode","containerInfo","return","getTopLevelCallbackBookKeeping","topLevelType","nativeEvent","targetInst","length","instance","pop","ancestors","releaseTopLevelCallbackBookKeeping","push","handleTopLevel","bookKeeping","ancestor","root","i","eventTarget","_enabled","setEnabled","enabled","isEnabled","trapBubbledEvent","element","trapEventForPluginEventSystem","trapCapturedEvent","trapEventForResponderEventSystem","passive","rawEventName","eventFlags","listener","dispatchEvent","bind","capture","dispatchDiscreteEvent","dispatchUserBlockingUpdate","eventSystemFlags","timeStamp","dispatchEventForPluginEventSystem","nativeEventTarget","nearestMounted"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {AnyNativeEvent} from 'legacy-events/PluginModuleType';\nimport type {Fiber} from 'react-reconciler/src/ReactFiber';\nimport type {DOMTopLevelEventType} from 'legacy-events/TopLevelEventTypes';\n\n// Intentionally not named imports because Rollup would use dynamic dispatch for\n// CommonJS interop named imports.\nimport * as Scheduler from 'scheduler';\n\nimport {\n  batchedEventUpdates,\n  discreteUpdates,\n  flushDiscreteUpdatesIfNeeded,\n} from 'legacy-events/ReactGenericBatching';\nimport {runExtractedPluginEventsInBatch} from 'legacy-events/EventPluginHub';\nimport {dispatchEventForResponderEventSystem} from '../events/DOMEventResponderSystem';\nimport {getNearestMountedFiber} from 'react-reconciler/reflection';\nimport {\n  HostRoot,\n  SuspenseComponent,\n  HostComponent,\n  HostText,\n} from 'shared/ReactWorkTags';\nimport {\n  type EventSystemFlags,\n  PLUGIN_EVENT_SYSTEM,\n  RESPONDER_EVENT_SYSTEM,\n  IS_PASSIVE,\n  IS_ACTIVE,\n  PASSIVE_NOT_SUPPORTED,\n} from 'legacy-events/EventSystemFlags';\n\nimport {\n  addEventBubbleListener,\n  addEventCaptureListener,\n  addEventCaptureListenerWithPassiveFlag,\n} from './EventListener';\nimport getEventTarget from './getEventTarget';\nimport {getClosestInstanceFromNode} from '../client/ReactDOMComponentTree';\nimport SimpleEventPlugin from './SimpleEventPlugin';\nimport {getRawEventName} from './DOMTopLevelEventTypes';\nimport {passiveBrowserEventsSupported} from './checkPassiveEvents';\n\nimport {\n  enableFlareAPI,\n  enableUserBlockingEvents,\n} from 'shared/ReactFeatureFlags';\nimport {\n  UserBlockingEvent,\n  ContinuousEvent,\n  DiscreteEvent,\n} from 'shared/ReactTypes';\n\nconst {\n  unstable_UserBlockingPriority: UserBlockingPriority,\n  unstable_runWithPriority: runWithPriority,\n} = Scheduler;\n\nconst {getEventPriority} = SimpleEventPlugin;\n\nconst CALLBACK_BOOKKEEPING_POOL_SIZE = 10;\nconst callbackBookkeepingPool = [];\n\ntype BookKeepingInstance = {\n  topLevelType: DOMTopLevelEventType | null,\n  nativeEvent: AnyNativeEvent | null,\n  targetInst: Fiber | null,\n  ancestors: Array<Fiber | null>,\n};\n\n/**\n * Find the deepest React component completely containing the root of the\n * passed-in instance (for use when entire React trees are nested within each\n * other). If React trees are not nested, returns null.\n */\nfunction findRootContainerNode(inst) {\n  if (inst.tag === HostRoot) {\n    return inst.stateNode.containerInfo;\n  }\n  // TODO: It may be a good idea to cache this to prevent unnecessary DOM\n  // traversal, but caching is difficult to do correctly without using a\n  // mutation observer to listen for all DOM changes.\n  while (inst.return) {\n    inst = inst.return;\n  }\n  if (inst.tag !== HostRoot) {\n    // This can happen if we're in a detached tree.\n    return null;\n  }\n  return inst.stateNode.containerInfo;\n}\n\n// Used to store ancestor hierarchy in top level callback\nfunction getTopLevelCallbackBookKeeping(\n  topLevelType: DOMTopLevelEventType,\n  nativeEvent: AnyNativeEvent,\n  targetInst: Fiber | null,\n): BookKeepingInstance {\n  if (callbackBookkeepingPool.length) {\n    const instance = callbackBookkeepingPool.pop();\n    instance.topLevelType = topLevelType;\n    instance.nativeEvent = nativeEvent;\n    instance.targetInst = targetInst;\n    return instance;\n  }\n  return {\n    topLevelType,\n    nativeEvent,\n    targetInst,\n    ancestors: [],\n  };\n}\n\nfunction releaseTopLevelCallbackBookKeeping(\n  instance: BookKeepingInstance,\n): void {\n  instance.topLevelType = null;\n  instance.nativeEvent = null;\n  instance.targetInst = null;\n  instance.ancestors.length = 0;\n  if (callbackBookkeepingPool.length < CALLBACK_BOOKKEEPING_POOL_SIZE) {\n    callbackBookkeepingPool.push(instance);\n  }\n}\n\nfunction handleTopLevel(bookKeeping: BookKeepingInstance) {\n  let targetInst = bookKeeping.targetInst;\n\n  // Loop through the hierarchy, in case there's any nested components.\n  // It's important that we build the array of ancestors before calling any\n  // event handlers, because event handlers can modify the DOM, leading to\n  // inconsistencies with ReactMount's node cache. See #1105.\n  let ancestor = targetInst;\n  do {\n    if (!ancestor) {\n      const ancestors = bookKeeping.ancestors;\n      ((ancestors: any): Array<Fiber | null>).push(ancestor);\n      break;\n    }\n    const root = findRootContainerNode(ancestor);\n    if (!root) {\n      break;\n    }\n    const tag = ancestor.tag;\n    if (tag === HostComponent || tag === HostText) {\n      bookKeeping.ancestors.push(ancestor);\n    }\n    ancestor = getClosestInstanceFromNode(root);\n  } while (ancestor);\n\n  for (let i = 0; i < bookKeeping.ancestors.length; i++) {\n    targetInst = bookKeeping.ancestors[i];\n    const eventTarget = getEventTarget(bookKeeping.nativeEvent);\n    const topLevelType = ((bookKeeping.topLevelType: any): DOMTopLevelEventType);\n    const nativeEvent = ((bookKeeping.nativeEvent: any): AnyNativeEvent);\n\n    runExtractedPluginEventsInBatch(\n      topLevelType,\n      targetInst,\n      nativeEvent,\n      eventTarget,\n    );\n  }\n}\n\n// TODO: can we stop exporting these?\nexport let _enabled = true;\n\nexport function setEnabled(enabled: ?boolean) {\n  _enabled = !!enabled;\n}\n\nexport function isEnabled() {\n  return _enabled;\n}\n\nexport function trapBubbledEvent(\n  topLevelType: DOMTopLevelEventType,\n  element: Document | Element | Node,\n): void {\n  trapEventForPluginEventSystem(element, topLevelType, false);\n}\n\nexport function trapCapturedEvent(\n  topLevelType: DOMTopLevelEventType,\n  element: Document | Element | Node,\n): void {\n  trapEventForPluginEventSystem(element, topLevelType, true);\n}\n\nexport function trapEventForResponderEventSystem(\n  element: Document | Element | Node,\n  topLevelType: DOMTopLevelEventType,\n  passive: boolean,\n): void {\n  if (enableFlareAPI) {\n    const rawEventName = getRawEventName(topLevelType);\n    let eventFlags = RESPONDER_EVENT_SYSTEM;\n\n    // If passive option is not supported, then the event will be\n    // active and not passive, but we flag it as using not being\n    // supported too. This way the responder event plugins know,\n    // and can provide polyfills if needed.\n    if (passive) {\n      if (passiveBrowserEventsSupported) {\n        eventFlags |= IS_PASSIVE;\n      } else {\n        eventFlags |= IS_ACTIVE;\n        eventFlags |= PASSIVE_NOT_SUPPORTED;\n        passive = false;\n      }\n    } else {\n      eventFlags |= IS_ACTIVE;\n    }\n    // Check if interactive and wrap in discreteUpdates\n    const listener = dispatchEvent.bind(null, topLevelType, eventFlags);\n    if (passiveBrowserEventsSupported) {\n      addEventCaptureListenerWithPassiveFlag(\n        element,\n        rawEventName,\n        listener,\n        passive,\n      );\n    } else {\n      addEventCaptureListener(element, rawEventName, listener);\n    }\n  }\n}\n\nfunction trapEventForPluginEventSystem(\n  element: Document | Element | Node,\n  topLevelType: DOMTopLevelEventType,\n  capture: boolean,\n): void {\n  let listener;\n  switch (getEventPriority(topLevelType)) {\n    case DiscreteEvent:\n      listener = dispatchDiscreteEvent.bind(\n        null,\n        topLevelType,\n        PLUGIN_EVENT_SYSTEM,\n      );\n      break;\n    case UserBlockingEvent:\n      listener = dispatchUserBlockingUpdate.bind(\n        null,\n        topLevelType,\n        PLUGIN_EVENT_SYSTEM,\n      );\n      break;\n    case ContinuousEvent:\n    default:\n      listener = dispatchEvent.bind(null, topLevelType, PLUGIN_EVENT_SYSTEM);\n      break;\n  }\n\n  const rawEventName = getRawEventName(topLevelType);\n  if (capture) {\n    addEventCaptureListener(element, rawEventName, listener);\n  } else {\n    addEventBubbleListener(element, rawEventName, listener);\n  }\n}\n\nfunction dispatchDiscreteEvent(topLevelType, eventSystemFlags, nativeEvent) {\n  flushDiscreteUpdatesIfNeeded(nativeEvent.timeStamp);\n  discreteUpdates(dispatchEvent, topLevelType, eventSystemFlags, nativeEvent);\n}\n\nfunction dispatchUserBlockingUpdate(\n  topLevelType,\n  eventSystemFlags,\n  nativeEvent,\n) {\n  if (enableUserBlockingEvents) {\n    runWithPriority(\n      UserBlockingPriority,\n      dispatchEvent.bind(null, topLevelType, eventSystemFlags, nativeEvent),\n    );\n  } else {\n    dispatchEvent(topLevelType, eventSystemFlags, nativeEvent);\n  }\n}\n\nfunction dispatchEventForPluginEventSystem(\n  topLevelType: DOMTopLevelEventType,\n  eventSystemFlags: EventSystemFlags,\n  nativeEvent: AnyNativeEvent,\n  targetInst: null | Fiber,\n): void {\n  const bookKeeping = getTopLevelCallbackBookKeeping(\n    topLevelType,\n    nativeEvent,\n    targetInst,\n  );\n\n  try {\n    // Event queue being processed in the same cycle allows\n    // `preventDefault`.\n    batchedEventUpdates(handleTopLevel, bookKeeping);\n  } finally {\n    releaseTopLevelCallbackBookKeeping(bookKeeping);\n  }\n}\n\nexport function dispatchEvent(\n  topLevelType: DOMTopLevelEventType,\n  eventSystemFlags: EventSystemFlags,\n  nativeEvent: AnyNativeEvent,\n): void {\n  if (!_enabled) {\n    return;\n  }\n  const nativeEventTarget = getEventTarget(nativeEvent);\n  let targetInst = getClosestInstanceFromNode(nativeEventTarget);\n\n  if (targetInst !== null) {\n    let nearestMounted = getNearestMountedFiber(targetInst);\n    if (nearestMounted === null) {\n      // This tree has been unmounted already.\n      targetInst = null;\n    } else {\n      const tag = nearestMounted.tag;\n      if (tag === SuspenseComponent) {\n        // TODO: This is a good opportunity to schedule a replay of\n        // the event instead once this boundary has been hydrated.\n        // For now we're going to just ignore this event as if it's\n        // not mounted.\n        targetInst = null;\n      } else if (tag === HostRoot) {\n        // We have not yet mounted/hydrated the first children.\n        // TODO: This is a good opportunity to schedule a replay of\n        // the event instead once this root has been hydrated.\n        // For now we're going to just ignore this event as if it's\n        // not mounted.\n        targetInst = null;\n      } else if (nearestMounted !== targetInst) {\n        // If we get an event (ex: img onload) before committing that\n        // component's mount, ignore it for now (that is, treat it as if it was an\n        // event on a non-React tree). We might also consider queueing events and\n        // dispatching them after the mount.\n        targetInst = null;\n      }\n    }\n  }\n\n  if (enableFlareAPI) {\n    if (eventSystemFlags === PLUGIN_EVENT_SYSTEM) {\n      dispatchEventForPluginEventSystem(\n        topLevelType,\n        eventSystemFlags,\n        nativeEvent,\n        targetInst,\n      );\n    } else {\n      // React Flare event system\n      dispatchEventForResponderEventSystem(\n        (topLevelType: any),\n        targetInst,\n        nativeEvent,\n        nativeEventTarget,\n        eventSystemFlags,\n      );\n    }\n  } else {\n    dispatchEventForPluginEventSystem(\n      topLevelType,\n      eventSystemFlags,\n      nativeEvent,\n      targetInst,\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}