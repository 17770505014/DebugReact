{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { noTimeout } from './ReactFiberHostConfig';\nimport { createHostRootFiber } from './ReactFiber';\nimport { NoWork } from './ReactFiberExpirationTime';\nimport { enableSchedulerTracing, enableSuspenseCallback } from 'shared/ReactFeatureFlags';\nimport { unstable_getThreadID } from 'scheduler/tracing';\nimport { NoPriority } from './SchedulerWithReactIntegration'; // TODO: This should be lifted into the renderer.\n\nfunction FiberRootNode(containerInfo, tag, hydrate) {\n  this.tag = tag;\n  this.current = null;\n  this.containerInfo = containerInfo;\n  this.pendingChildren = null;\n  this.pingCache = null;\n  this.finishedExpirationTime = NoWork;\n  this.finishedWork = null;\n  this.timeoutHandle = noTimeout;\n  this.context = null;\n  this.pendingContext = null;\n  this.hydrate = hydrate;\n  this.firstBatch = null;\n  this.callbackNode = null;\n  this.callbackPriority = NoPriority;\n  this.firstPendingTime = NoWork;\n  this.firstSuspendedTime = NoWork;\n  this.lastSuspendedTime = NoWork;\n  this.nextKnownPendingLevel = NoWork;\n  this.lastPingedTime = NoWork;\n  this.lastExpiredTime = NoWork;\n\n  if (enableSchedulerTracing) {\n    this.interactionThreadID = unstable_getThreadID();\n    this.memoizedInteractions = new Set();\n    this.pendingInteractionMap = new Map();\n  }\n\n  if (enableSuspenseCallback) {\n    this.hydrationCallbacks = null;\n  }\n}\n\nexport function createFiberRoot(containerInfo, tag, hydrate, hydrationCallbacks) {\n  const root = new FiberRootNode(containerInfo, tag, hydrate);\n\n  if (enableSuspenseCallback) {\n    root.hydrationCallbacks = hydrationCallbacks;\n  } // Cyclic construction. This cheats the type system right now because\n  // stateNode is any.\n\n\n  const uninitializedFiber = createHostRootFiber(tag);\n  root.current = uninitializedFiber;\n  uninitializedFiber.stateNode = root;\n  return root;\n}\nexport function isRootSuspendedAtTime(root, expirationTime) {\n  const firstSuspendedTime = root.firstSuspendedTime;\n  const lastSuspendedTime = root.lastSuspendedTime;\n  return firstSuspendedTime !== NoWork && firstSuspendedTime >= expirationTime && lastSuspendedTime <= expirationTime;\n}\nexport function markRootSuspendedAtTime(root, expirationTime) {\n  const firstSuspendedTime = root.firstSuspendedTime;\n  const lastSuspendedTime = root.lastSuspendedTime;\n\n  if (firstSuspendedTime < expirationTime) {\n    root.firstSuspendedTime = expirationTime;\n  }\n\n  if (lastSuspendedTime > expirationTime || firstSuspendedTime === NoWork) {\n    root.lastSuspendedTime = expirationTime;\n  }\n\n  if (expirationTime <= root.lastPingedTime) {\n    root.lastPingedTime = NoWork;\n  }\n\n  if (expirationTime <= root.lastExpiredTime) {\n    root.lastExpiredTime = NoWork;\n  }\n}\nexport function markRootUpdatedAtTime(root, expirationTime) {\n  // Update the range of pending times\n  const firstPendingTime = root.firstPendingTime;\n\n  if (expirationTime > firstPendingTime) {\n    root.firstPendingTime = expirationTime;\n  } // Update the range of suspended times. Treat everything lower priority or\n  // equal to this update as unsuspended.\n\n\n  const firstSuspendedTime = root.firstSuspendedTime;\n\n  if (firstSuspendedTime !== NoWork) {\n    if (expirationTime >= firstSuspendedTime) {\n      // The entire suspended range is now unsuspended.\n      root.firstSuspendedTime = root.lastSuspendedTime = root.nextKnownPendingLevel = NoWork;\n    } else if (expirationTime >= root.lastSuspendedTime) {\n      root.lastSuspendedTime = expirationTime + 1;\n    } // This is a pending level. Check if it's higher priority than the next\n    // known pending level.\n\n\n    if (expirationTime > root.nextKnownPendingLevel) {\n      root.nextKnownPendingLevel = expirationTime;\n    }\n  }\n}\nexport function markRootFinishedAtTime(root, finishedExpirationTime, remainingExpirationTime) {\n  // Update the range of pending times\n  root.firstPendingTime = remainingExpirationTime; // Update the range of suspended times. Treat everything higher priority or\n  // equal to this update as unsuspended.\n\n  if (finishedExpirationTime <= root.lastSuspendedTime) {\n    // The entire suspended range is now unsuspended.\n    root.firstSuspendedTime = root.lastSuspendedTime = root.nextKnownPendingLevel = NoWork;\n  } else if (finishedExpirationTime <= root.firstSuspendedTime) {\n    // Part of the suspended range is now unsuspended. Narrow the range to\n    // include everything between the unsuspended time (non-inclusive) and the\n    // last suspended time.\n    root.firstSuspendedTime = finishedExpirationTime - 1;\n  }\n\n  if (finishedExpirationTime <= root.lastPingedTime) {\n    // Clear the pinged time\n    root.lastPingedTime = NoWork;\n  }\n\n  if (finishedExpirationTime <= root.lastExpiredTime) {\n    // Clear the expired time\n    root.lastExpiredTime = NoWork;\n  }\n}\nexport function markRootExpiredAtTime(root, expirationTime) {\n  const lastExpiredTime = root.lastExpiredTime;\n\n  if (lastExpiredTime === NoWork || lastExpiredTime > expirationTime) {\n    root.lastExpiredTime = expirationTime;\n  }\n}","map":{"version":3,"sources":["/Users/gaoshaoyun/Documents/library/debug-react/src/react/packages/react-reconciler/src/ReactFiberRoot.js"],"names":["noTimeout","createHostRootFiber","NoWork","enableSchedulerTracing","enableSuspenseCallback","unstable_getThreadID","NoPriority","FiberRootNode","containerInfo","tag","hydrate","current","pendingChildren","pingCache","finishedExpirationTime","finishedWork","timeoutHandle","context","pendingContext","firstBatch","callbackNode","callbackPriority","firstPendingTime","firstSuspendedTime","lastSuspendedTime","nextKnownPendingLevel","lastPingedTime","lastExpiredTime","interactionThreadID","memoizedInteractions","Set","pendingInteractionMap","Map","hydrationCallbacks","createFiberRoot","root","uninitializedFiber","stateNode","isRootSuspendedAtTime","expirationTime","markRootSuspendedAtTime","markRootUpdatedAtTime","markRootFinishedAtTime","remainingExpirationTime","markRootExpiredAtTime"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber} from './ReactFiber';\nimport type {ExpirationTime} from './ReactFiberExpirationTime';\nimport type {RootTag} from 'shared/ReactRootTags';\nimport type {TimeoutHandle, NoTimeout} from './ReactFiberHostConfig';\nimport type {Thenable} from './ReactFiberWorkLoop';\nimport type {Interaction} from 'scheduler/src/Tracing';\nimport type {SuspenseHydrationCallbacks} from './ReactFiberSuspenseComponent';\nimport type {ReactPriorityLevel} from './SchedulerWithReactIntegration';\n\nimport {noTimeout} from './ReactFiberHostConfig';\nimport {createHostRootFiber} from './ReactFiber';\nimport {NoWork} from './ReactFiberExpirationTime';\nimport {\n  enableSchedulerTracing,\n  enableSuspenseCallback,\n} from 'shared/ReactFeatureFlags';\nimport {unstable_getThreadID} from 'scheduler/tracing';\nimport {NoPriority} from './SchedulerWithReactIntegration';\n\n// TODO: This should be lifted into the renderer.\nexport type Batch = {\n  _defer: boolean,\n  _expirationTime: ExpirationTime,\n  _onComplete: () => mixed,\n  _next: Batch | null,\n};\n\nexport type PendingInteractionMap = Map<ExpirationTime, Set<Interaction>>;\n\ntype BaseFiberRootProperties = {|\n  // The type of root (legacy, batched, concurrent, etc.)\n  tag: RootTag,\n\n  // Any additional information from the host associated with this root.\n  containerInfo: any,\n  // Used only by persistent updates.\n  pendingChildren: any,\n  // The currently active root fiber. This is the mutable root of the tree.\n  current: Fiber,\n\n  pingCache:\n    | WeakMap<Thenable, Set<ExpirationTime>>\n    | Map<Thenable, Set<ExpirationTime>>\n    | null,\n\n  finishedExpirationTime: ExpirationTime,\n  // A finished work-in-progress HostRoot that's ready to be committed.\n  finishedWork: Fiber | null,\n  // Timeout handle returned by setTimeout. Used to cancel a pending timeout, if\n  // it's superseded by a new one.\n  timeoutHandle: TimeoutHandle | NoTimeout,\n  // Top context object, used by renderSubtreeIntoContainer\n  context: Object | null,\n  pendingContext: Object | null,\n  // Determines if we should attempt to hydrate on the initial mount\n  +hydrate: boolean,\n  // List of top-level batches. This list indicates whether a commit should be\n  // deferred. Also contains completion callbacks.\n  // TODO: Lift this into the renderer\n  firstBatch: Batch | null,\n  // Node returned by Scheduler.scheduleCallback\n  callbackNode: *,\n  // Expiration of the callback associated with this root\n  callbackExpirationTime: ExpirationTime,\n  // Priority of the callback associated with this root\n  callbackPriority: ReactPriorityLevel,\n  // The earliest pending expiration time that exists in the tree\n  firstPendingTime: ExpirationTime,\n  // The earliest suspended expiration time that exists in the tree\n  firstSuspendedTime: ExpirationTime,\n  // The latest suspended expiration time that exists in the tree\n  lastSuspendedTime: ExpirationTime,\n  // The next known expiration time after the suspended range\n  nextKnownPendingLevel: ExpirationTime,\n  // The latest time at which a suspended component pinged the root to\n  // render again\n  lastPingedTime: ExpirationTime,\n  lastExpiredTime: ExpirationTime,\n|};\n\n// The following attributes are only used by interaction tracing builds.\n// They enable interactions to be associated with their async work,\n// And expose interaction metadata to the React DevTools Profiler plugin.\n// Note that these attributes are only defined when the enableSchedulerTracing flag is enabled.\ntype ProfilingOnlyFiberRootProperties = {|\n  interactionThreadID: number,\n  memoizedInteractions: Set<Interaction>,\n  pendingInteractionMap: PendingInteractionMap,\n|};\n\n// The follow fields are only used by enableSuspenseCallback for hydration.\ntype SuspenseCallbackOnlyFiberRootProperties = {|\n  hydrationCallbacks: null | SuspenseHydrationCallbacks,\n|};\n\n// Exported FiberRoot type includes all properties,\n// To avoid requiring potentially error-prone :any casts throughout the project.\n// Profiling properties are only safe to access in profiling builds (when enableSchedulerTracing is true).\n// The types are defined separately within this file to ensure they stay in sync.\n// (We don't have to use an inline :any cast when enableSchedulerTracing is disabled.)\nexport type FiberRoot = {\n  ...BaseFiberRootProperties,\n  ...ProfilingOnlyFiberRootProperties,\n  ...SuspenseCallbackOnlyFiberRootProperties,\n};\n\nfunction FiberRootNode(containerInfo, tag, hydrate) {\n  this.tag = tag;\n  this.current = null;\n  this.containerInfo = containerInfo;\n  this.pendingChildren = null;\n  this.pingCache = null;\n  this.finishedExpirationTime = NoWork;\n  this.finishedWork = null;\n  this.timeoutHandle = noTimeout;\n  this.context = null;\n  this.pendingContext = null;\n  this.hydrate = hydrate;\n  this.firstBatch = null;\n  this.callbackNode = null;\n  this.callbackPriority = NoPriority;\n  this.firstPendingTime = NoWork;\n  this.firstSuspendedTime = NoWork;\n  this.lastSuspendedTime = NoWork;\n  this.nextKnownPendingLevel = NoWork;\n  this.lastPingedTime = NoWork;\n  this.lastExpiredTime = NoWork;\n\n  if (enableSchedulerTracing) {\n    this.interactionThreadID = unstable_getThreadID();\n    this.memoizedInteractions = new Set();\n    this.pendingInteractionMap = new Map();\n  }\n  if (enableSuspenseCallback) {\n    this.hydrationCallbacks = null;\n  }\n}\n\nexport function createFiberRoot(\n  containerInfo: any,\n  tag: RootTag,\n  hydrate: boolean,\n  hydrationCallbacks: null | SuspenseHydrationCallbacks,\n): FiberRoot {\n  const root: FiberRoot = (new FiberRootNode(containerInfo, tag, hydrate): any);\n  if (enableSuspenseCallback) {\n    root.hydrationCallbacks = hydrationCallbacks;\n  }\n\n  // Cyclic construction. This cheats the type system right now because\n  // stateNode is any.\n  const uninitializedFiber = createHostRootFiber(tag);\n  root.current = uninitializedFiber;\n  uninitializedFiber.stateNode = root;\n\n  return root;\n}\n\nexport function isRootSuspendedAtTime(\n  root: FiberRoot,\n  expirationTime: ExpirationTime,\n): boolean {\n  const firstSuspendedTime = root.firstSuspendedTime;\n  const lastSuspendedTime = root.lastSuspendedTime;\n  return (\n    firstSuspendedTime !== NoWork &&\n    (firstSuspendedTime >= expirationTime &&\n      lastSuspendedTime <= expirationTime)\n  );\n}\n\nexport function markRootSuspendedAtTime(\n  root: FiberRoot,\n  expirationTime: ExpirationTime,\n): void {\n  const firstSuspendedTime = root.firstSuspendedTime;\n  const lastSuspendedTime = root.lastSuspendedTime;\n  if (firstSuspendedTime < expirationTime) {\n    root.firstSuspendedTime = expirationTime;\n  }\n  if (lastSuspendedTime > expirationTime || firstSuspendedTime === NoWork) {\n    root.lastSuspendedTime = expirationTime;\n  }\n\n  if (expirationTime <= root.lastPingedTime) {\n    root.lastPingedTime = NoWork;\n  }\n\n  if (expirationTime <= root.lastExpiredTime) {\n    root.lastExpiredTime = NoWork;\n  }\n}\n\nexport function markRootUpdatedAtTime(\n  root: FiberRoot,\n  expirationTime: ExpirationTime,\n): void {\n  // Update the range of pending times\n  const firstPendingTime = root.firstPendingTime;\n  if (expirationTime > firstPendingTime) {\n    root.firstPendingTime = expirationTime;\n  }\n\n  // Update the range of suspended times. Treat everything lower priority or\n  // equal to this update as unsuspended.\n  const firstSuspendedTime = root.firstSuspendedTime;\n  if (firstSuspendedTime !== NoWork) {\n    if (expirationTime >= firstSuspendedTime) {\n      // The entire suspended range is now unsuspended.\n      root.firstSuspendedTime = root.lastSuspendedTime = root.nextKnownPendingLevel = NoWork;\n    } else if (expirationTime >= root.lastSuspendedTime) {\n      root.lastSuspendedTime = expirationTime + 1;\n    }\n\n    // This is a pending level. Check if it's higher priority than the next\n    // known pending level.\n    if (expirationTime > root.nextKnownPendingLevel) {\n      root.nextKnownPendingLevel = expirationTime;\n    }\n  }\n}\n\nexport function markRootFinishedAtTime(\n  root: FiberRoot,\n  finishedExpirationTime: ExpirationTime,\n  remainingExpirationTime: ExpirationTime,\n): void {\n  // Update the range of pending times\n  root.firstPendingTime = remainingExpirationTime;\n\n  // Update the range of suspended times. Treat everything higher priority or\n  // equal to this update as unsuspended.\n  if (finishedExpirationTime <= root.lastSuspendedTime) {\n    // The entire suspended range is now unsuspended.\n    root.firstSuspendedTime = root.lastSuspendedTime = root.nextKnownPendingLevel = NoWork;\n  } else if (finishedExpirationTime <= root.firstSuspendedTime) {\n    // Part of the suspended range is now unsuspended. Narrow the range to\n    // include everything between the unsuspended time (non-inclusive) and the\n    // last suspended time.\n    root.firstSuspendedTime = finishedExpirationTime - 1;\n  }\n\n  if (finishedExpirationTime <= root.lastPingedTime) {\n    // Clear the pinged time\n    root.lastPingedTime = NoWork;\n  }\n\n  if (finishedExpirationTime <= root.lastExpiredTime) {\n    // Clear the expired time\n    root.lastExpiredTime = NoWork;\n  }\n}\n\nexport function markRootExpiredAtTime(\n  root: FiberRoot,\n  expirationTime: ExpirationTime,\n): void {\n  const lastExpiredTime = root.lastExpiredTime;\n  if (lastExpiredTime === NoWork || lastExpiredTime > expirationTime) {\n    root.lastExpiredTime = expirationTime;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}