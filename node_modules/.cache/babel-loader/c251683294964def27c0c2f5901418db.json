{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { getPublicInstance, getInstanceFromNode } from './ReactFiberHostConfig';\nimport { HostComponent, SuspenseComponent, ScopeComponent } from 'shared/ReactWorkTags';\nimport { enableScopeAPI } from 'shared/ReactFeatureFlags';\n\nfunction isFiberSuspenseAndTimedOut(fiber) {\n  return fiber.tag === SuspenseComponent && fiber.memoizedState !== null;\n}\n\nfunction getSuspenseFallbackChild(fiber) {\n  return fiber.child.sibling.child;\n}\n\nconst emptyObject = {};\n\nfunction collectScopedNodes(node, fn, scopedNodes) {\n  if (enableScopeAPI) {\n    if (node.tag === HostComponent) {\n      const {\n        type,\n        memoizedProps,\n        stateNode\n      } = node;\n      const instance = getPublicInstance(stateNode);\n\n      if (instance !== null && fn(type, memoizedProps || emptyObject, instance) === true) {\n        scopedNodes.push(instance);\n      }\n    }\n\n    let child = node.child;\n\n    if (isFiberSuspenseAndTimedOut(node)) {\n      child = getSuspenseFallbackChild(node);\n    }\n\n    if (child !== null) {\n      collectScopedNodesFromChildren(child, fn, scopedNodes);\n    }\n  }\n}\n\nfunction collectFirstScopedNode(node, fn) {\n  if (enableScopeAPI) {\n    if (node.tag === HostComponent) {\n      const {\n        type,\n        memoizedProps,\n        stateNode\n      } = node;\n      const instance = getPublicInstance(stateNode);\n\n      if (instance !== null && fn(type, memoizedProps, instance) === true) {\n        return instance;\n      }\n    }\n\n    let child = node.child;\n\n    if (isFiberSuspenseAndTimedOut(node)) {\n      child = getSuspenseFallbackChild(node);\n    }\n\n    if (child !== null) {\n      return collectFirstScopedNodeFromChildren(child, fn);\n    }\n  }\n\n  return null;\n}\n\nfunction collectScopedNodesFromChildren(startingChild, fn, scopedNodes) {\n  let child = startingChild;\n\n  while (child !== null) {\n    collectScopedNodes(child, fn, scopedNodes);\n    child = child.sibling;\n  }\n}\n\nfunction collectFirstScopedNodeFromChildren(startingChild, fn) {\n  let child = startingChild;\n\n  while (child !== null) {\n    const scopedNode = collectFirstScopedNode(child, fn);\n\n    if (scopedNode !== null) {\n      return scopedNode;\n    }\n\n    child = child.sibling;\n  }\n\n  return null;\n}\n\nfunction collectNearestScopeMethods(node, scope, childrenScopes) {\n  if (isValidScopeNode(node, scope)) {\n    childrenScopes.push(node.stateNode.methods);\n  } else {\n    let child = node.child;\n\n    if (isFiberSuspenseAndTimedOut(node)) {\n      child = getSuspenseFallbackChild(node);\n    }\n\n    if (child !== null) {\n      collectNearestChildScopeMethods(child, scope, childrenScopes);\n    }\n  }\n}\n\nfunction collectNearestChildScopeMethods(startingChild, scope, childrenScopes) {\n  let child = startingChild;\n\n  while (child !== null) {\n    collectNearestScopeMethods(child, scope, childrenScopes);\n    child = child.sibling;\n  }\n}\n\nfunction isValidScopeNode(node, scope) {\n  return node.tag === ScopeComponent && node.type === scope && node.stateNode !== null;\n}\n\nexport function createScopeMethods(scope, instance) {\n  return {\n    getChildren() {\n      const currentFiber = instance.fiber;\n      const child = currentFiber.child;\n      const childrenScopes = [];\n\n      if (child !== null) {\n        collectNearestChildScopeMethods(child, scope, childrenScopes);\n      }\n\n      return childrenScopes.length === 0 ? null : childrenScopes;\n    },\n\n    getChildrenFromRoot() {\n      const currentFiber = instance.fiber;\n      let node = currentFiber;\n\n      while (node !== null) {\n        const parent = node.return;\n\n        if (parent === null) {\n          break;\n        }\n\n        node = parent;\n\n        if (node.tag === ScopeComponent && node.type === scope) {\n          break;\n        }\n      }\n\n      const childrenScopes = [];\n      collectNearestChildScopeMethods(node.child, scope, childrenScopes);\n      return childrenScopes.length === 0 ? null : childrenScopes;\n    },\n\n    getParent() {\n      let node = instance.fiber.return;\n\n      while (node !== null) {\n        if (node.tag === ScopeComponent && node.type === scope) {\n          return node.stateNode.methods;\n        }\n\n        node = node.return;\n      }\n\n      return null;\n    },\n\n    getProps() {\n      const currentFiber = instance.fiber;\n      return currentFiber.memoizedProps;\n    },\n\n    queryAllNodes(fn) {\n      const currentFiber = instance.fiber;\n      const child = currentFiber.child;\n      const scopedNodes = [];\n\n      if (child !== null) {\n        collectScopedNodesFromChildren(child, fn, scopedNodes);\n      }\n\n      return scopedNodes.length === 0 ? null : scopedNodes;\n    },\n\n    queryFirstNode(fn) {\n      const currentFiber = instance.fiber;\n      const child = currentFiber.child;\n\n      if (child !== null) {\n        return collectFirstScopedNodeFromChildren(child, fn);\n      }\n\n      return null;\n    },\n\n    containsNode(node) {\n      let fiber = getInstanceFromNode(node);\n\n      while (fiber !== null) {\n        if (fiber.tag === ScopeComponent && fiber.type === scope && fiber.stateNode === instance) {\n          return true;\n        }\n\n        fiber = fiber.return;\n      }\n\n      return false;\n    }\n\n  };\n}","map":{"version":3,"sources":["/Users/gaoshaoyun/Documents/library/debug-react/src/react/packages/react-reconciler/src/ReactFiberScope.js"],"names":["getPublicInstance","getInstanceFromNode","HostComponent","SuspenseComponent","ScopeComponent","enableScopeAPI","isFiberSuspenseAndTimedOut","fiber","tag","memoizedState","getSuspenseFallbackChild","child","sibling","emptyObject","collectScopedNodes","node","fn","scopedNodes","type","memoizedProps","stateNode","instance","push","collectScopedNodesFromChildren","collectFirstScopedNode","collectFirstScopedNodeFromChildren","startingChild","scopedNode","collectNearestScopeMethods","scope","childrenScopes","isValidScopeNode","methods","collectNearestChildScopeMethods","createScopeMethods","getChildren","currentFiber","length","getChildrenFromRoot","parent","return","getParent","getProps","queryAllNodes","queryFirstNode","containsNode"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber} from './ReactFiber';\nimport type {\n  ReactScope,\n  ReactScopeInstance,\n  ReactScopeMethods,\n} from 'shared/ReactTypes';\n\nimport {getPublicInstance, getInstanceFromNode} from './ReactFiberHostConfig';\n\nimport {\n  HostComponent,\n  SuspenseComponent,\n  ScopeComponent,\n} from 'shared/ReactWorkTags';\nimport {enableScopeAPI} from 'shared/ReactFeatureFlags';\n\nfunction isFiberSuspenseAndTimedOut(fiber: Fiber): boolean {\n  return fiber.tag === SuspenseComponent && fiber.memoizedState !== null;\n}\n\nfunction getSuspenseFallbackChild(fiber: Fiber): Fiber | null {\n  return ((((fiber.child: any): Fiber).sibling: any): Fiber).child;\n}\n\nconst emptyObject = {};\n\nfunction collectScopedNodes(\n  node: Fiber,\n  fn: (type: string | Object, props: Object, instance: Object) => boolean,\n  scopedNodes: Array<any>,\n): void {\n  if (enableScopeAPI) {\n    if (node.tag === HostComponent) {\n      const {type, memoizedProps, stateNode} = node;\n      const instance = getPublicInstance(stateNode);\n      if (\n        instance !== null &&\n        fn(type, memoizedProps || emptyObject, instance) === true\n      ) {\n        scopedNodes.push(instance);\n      }\n    }\n    let child = node.child;\n\n    if (isFiberSuspenseAndTimedOut(node)) {\n      child = getSuspenseFallbackChild(node);\n    }\n    if (child !== null) {\n      collectScopedNodesFromChildren(child, fn, scopedNodes);\n    }\n  }\n}\n\nfunction collectFirstScopedNode(\n  node: Fiber,\n  fn: (type: string | Object, props: Object, instance: Object) => boolean,\n): null | Object {\n  if (enableScopeAPI) {\n    if (node.tag === HostComponent) {\n      const {type, memoizedProps, stateNode} = node;\n      const instance = getPublicInstance(stateNode);\n      if (instance !== null && fn(type, memoizedProps, instance) === true) {\n        return instance;\n      }\n    }\n    let child = node.child;\n\n    if (isFiberSuspenseAndTimedOut(node)) {\n      child = getSuspenseFallbackChild(node);\n    }\n    if (child !== null) {\n      return collectFirstScopedNodeFromChildren(child, fn);\n    }\n  }\n  return null;\n}\n\nfunction collectScopedNodesFromChildren(\n  startingChild: Fiber,\n  fn: (type: string | Object, props: Object, instance: Object) => boolean,\n  scopedNodes: Array<any>,\n): void {\n  let child = startingChild;\n  while (child !== null) {\n    collectScopedNodes(child, fn, scopedNodes);\n    child = child.sibling;\n  }\n}\n\nfunction collectFirstScopedNodeFromChildren(\n  startingChild: Fiber,\n  fn: (type: string | Object, props: Object, instance: Object) => boolean,\n): Object | null {\n  let child = startingChild;\n  while (child !== null) {\n    const scopedNode = collectFirstScopedNode(child, fn);\n    if (scopedNode !== null) {\n      return scopedNode;\n    }\n    child = child.sibling;\n  }\n  return null;\n}\n\nfunction collectNearestScopeMethods(\n  node: Fiber,\n  scope: ReactScope,\n  childrenScopes: Array<ReactScopeMethods>,\n): void {\n  if (isValidScopeNode(node, scope)) {\n    childrenScopes.push(node.stateNode.methods);\n  } else {\n    let child = node.child;\n\n    if (isFiberSuspenseAndTimedOut(node)) {\n      child = getSuspenseFallbackChild(node);\n    }\n    if (child !== null) {\n      collectNearestChildScopeMethods(child, scope, childrenScopes);\n    }\n  }\n}\n\nfunction collectNearestChildScopeMethods(\n  startingChild: Fiber | null,\n  scope: ReactScope,\n  childrenScopes: Array<ReactScopeMethods>,\n): void {\n  let child = startingChild;\n  while (child !== null) {\n    collectNearestScopeMethods(child, scope, childrenScopes);\n    child = child.sibling;\n  }\n}\n\nfunction isValidScopeNode(node, scope) {\n  return (\n    node.tag === ScopeComponent &&\n    node.type === scope &&\n    node.stateNode !== null\n  );\n}\n\nexport function createScopeMethods(\n  scope: ReactScope,\n  instance: ReactScopeInstance,\n): ReactScopeMethods {\n  return {\n    getChildren(): null | Array<ReactScopeMethods> {\n      const currentFiber = ((instance.fiber: any): Fiber);\n      const child = currentFiber.child;\n      const childrenScopes = [];\n      if (child !== null) {\n        collectNearestChildScopeMethods(child, scope, childrenScopes);\n      }\n      return childrenScopes.length === 0 ? null : childrenScopes;\n    },\n    getChildrenFromRoot(): null | Array<ReactScopeMethods> {\n      const currentFiber = ((instance.fiber: any): Fiber);\n      let node = currentFiber;\n      while (node !== null) {\n        const parent = node.return;\n        if (parent === null) {\n          break;\n        }\n        node = parent;\n        if (node.tag === ScopeComponent && node.type === scope) {\n          break;\n        }\n      }\n      const childrenScopes = [];\n      collectNearestChildScopeMethods(node.child, scope, childrenScopes);\n      return childrenScopes.length === 0 ? null : childrenScopes;\n    },\n    getParent(): null | ReactScopeMethods {\n      let node = ((instance.fiber: any): Fiber).return;\n      while (node !== null) {\n        if (node.tag === ScopeComponent && node.type === scope) {\n          return node.stateNode.methods;\n        }\n        node = node.return;\n      }\n      return null;\n    },\n    getProps(): Object {\n      const currentFiber = ((instance.fiber: any): Fiber);\n      return currentFiber.memoizedProps;\n    },\n    queryAllNodes(\n      fn: (type: string | Object, props: Object, instance: Object) => boolean,\n    ): null | Array<Object> {\n      const currentFiber = ((instance.fiber: any): Fiber);\n      const child = currentFiber.child;\n      const scopedNodes = [];\n      if (child !== null) {\n        collectScopedNodesFromChildren(child, fn, scopedNodes);\n      }\n      return scopedNodes.length === 0 ? null : scopedNodes;\n    },\n    queryFirstNode(\n      fn: (type: string | Object, props: Object, instance: Object) => boolean,\n    ): null | Object {\n      const currentFiber = ((instance.fiber: any): Fiber);\n      const child = currentFiber.child;\n      if (child !== null) {\n        return collectFirstScopedNodeFromChildren(child, fn);\n      }\n      return null;\n    },\n    containsNode(node: Object): boolean {\n      let fiber = getInstanceFromNode(node);\n      while (fiber !== null) {\n        if (\n          fiber.tag === ScopeComponent &&\n          fiber.type === scope &&\n          fiber.stateNode === instance\n        ) {\n          return true;\n        }\n        fiber = fiber.return;\n      }\n      return false;\n    },\n  };\n}\n"]},"metadata":{},"sourceType":"module"}