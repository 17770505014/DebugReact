{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// Intentionally not named imports because Rollup would use dynamic dispatch for\n// CommonJS interop named imports.\nimport * as Scheduler from 'scheduler';\nimport { batchedEventUpdates, discreteUpdates, flushDiscreteUpdatesIfNeeded } from 'legacy-events/ReactGenericBatching';\nimport { runExtractedPluginEventsInBatch } from 'legacy-events/EventPluginHub';\nimport { dispatchEventForResponderEventSystem } from './DOMEventResponderSystem';\nimport { isReplayableDiscreteEvent, queueDiscreteEvent, hasQueuedDiscreteEvents, clearIfContinuousEvent, queueIfContinuousEvent } from './ReactDOMEventReplaying';\nimport { getNearestMountedFiber, getContainerFromFiber, getSuspenseInstanceFromFiber } from 'react-reconciler/reflection';\nimport { HostRoot, SuspenseComponent, HostComponent, HostText } from 'shared/ReactWorkTags';\nimport { PLUGIN_EVENT_SYSTEM, RESPONDER_EVENT_SYSTEM, IS_PASSIVE, IS_ACTIVE, PASSIVE_NOT_SUPPORTED } from 'legacy-events/EventSystemFlags';\nimport { addEventBubbleListener, addEventCaptureListener, addEventCaptureListenerWithPassiveFlag } from './EventListener';\nimport getEventTarget from './getEventTarget';\nimport { getClosestInstanceFromNode } from '../client/ReactDOMComponentTree';\nimport SimpleEventPlugin from './SimpleEventPlugin';\nimport { getRawEventName } from './DOMTopLevelEventTypes';\nimport { passiveBrowserEventsSupported } from './checkPassiveEvents';\nimport { enableFlareAPI } from 'shared/ReactFeatureFlags';\nimport { UserBlockingEvent, ContinuousEvent, DiscreteEvent } from 'shared/ReactTypes';\nconst {\n  unstable_UserBlockingPriority: UserBlockingPriority,\n  unstable_runWithPriority: runWithPriority\n} = Scheduler;\nconst {\n  getEventPriority\n} = SimpleEventPlugin;\nconst CALLBACK_BOOKKEEPING_POOL_SIZE = 10;\nconst callbackBookkeepingPool = [];\n\n/**\n * Find the deepest React component completely containing the root of the\n * passed-in instance (for use when entire React trees are nested within each\n * other). If React trees are not nested, returns null.\n */\nfunction findRootContainerNode(inst) {\n  if (inst.tag === HostRoot) {\n    return inst.stateNode.containerInfo;\n  } // TODO: It may be a good idea to cache this to prevent unnecessary DOM\n  // traversal, but caching is difficult to do correctly without using a\n  // mutation observer to listen for all DOM changes.\n\n\n  while (inst.return) {\n    inst = inst.return;\n  }\n\n  if (inst.tag !== HostRoot) {\n    // This can happen if we're in a detached tree.\n    return null;\n  }\n\n  return inst.stateNode.containerInfo;\n} // Used to store ancestor hierarchy in top level callback\n\n\nfunction getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst, eventSystemFlags) {\n  if (callbackBookkeepingPool.length) {\n    const instance = callbackBookkeepingPool.pop();\n    instance.topLevelType = topLevelType;\n    instance.eventSystemFlags = eventSystemFlags;\n    instance.nativeEvent = nativeEvent;\n    instance.targetInst = targetInst;\n    return instance;\n  }\n\n  return {\n    topLevelType,\n    eventSystemFlags,\n    nativeEvent,\n    targetInst,\n    ancestors: []\n  };\n}\n\nfunction releaseTopLevelCallbackBookKeeping(instance) {\n  instance.topLevelType = null;\n  instance.nativeEvent = null;\n  instance.targetInst = null;\n  instance.ancestors.length = 0;\n\n  if (callbackBookkeepingPool.length < CALLBACK_BOOKKEEPING_POOL_SIZE) {\n    callbackBookkeepingPool.push(instance);\n  }\n}\n\nfunction handleTopLevel(bookKeeping) {\n  let targetInst = bookKeeping.targetInst; // Loop through the hierarchy, in case there's any nested components.\n  // It's important that we build the array of ancestors before calling any\n  // event handlers, because event handlers can modify the DOM, leading to\n  // inconsistencies with ReactMount's node cache. See #1105.\n\n  let ancestor = targetInst;\n\n  do {\n    if (!ancestor) {\n      const ancestors = bookKeeping.ancestors;\n      ancestors.push(ancestor);\n      break;\n    }\n\n    const root = findRootContainerNode(ancestor);\n\n    if (!root) {\n      break;\n    }\n\n    const tag = ancestor.tag;\n\n    if (tag === HostComponent || tag === HostText) {\n      bookKeeping.ancestors.push(ancestor);\n    }\n\n    ancestor = getClosestInstanceFromNode(root);\n  } while (ancestor);\n\n  for (let i = 0; i < bookKeeping.ancestors.length; i++) {\n    targetInst = bookKeeping.ancestors[i];\n    const eventTarget = getEventTarget(bookKeeping.nativeEvent);\n    const topLevelType = bookKeeping.topLevelType;\n    const nativeEvent = bookKeeping.nativeEvent;\n    runExtractedPluginEventsInBatch(topLevelType, targetInst, nativeEvent, eventTarget, bookKeeping.eventSystemFlags);\n  }\n} // TODO: can we stop exporting these?\n\n\nexport let _enabled = true;\nexport function setEnabled(enabled) {\n  _enabled = !!enabled;\n}\nexport function isEnabled() {\n  return _enabled;\n}\nexport function trapBubbledEvent(topLevelType, element) {\n  trapEventForPluginEventSystem(element, topLevelType, false);\n}\nexport function trapCapturedEvent(topLevelType, element) {\n  trapEventForPluginEventSystem(element, topLevelType, true);\n}\nexport function trapEventForResponderEventSystem(element, topLevelType, passive) {\n  if (enableFlareAPI) {\n    const rawEventName = getRawEventName(topLevelType);\n    let eventFlags = RESPONDER_EVENT_SYSTEM; // If passive option is not supported, then the event will be\n    // active and not passive, but we flag it as using not being\n    // supported too. This way the responder event plugins know,\n    // and can provide polyfills if needed.\n\n    if (passive) {\n      if (passiveBrowserEventsSupported) {\n        eventFlags |= IS_PASSIVE;\n      } else {\n        eventFlags |= IS_ACTIVE;\n        eventFlags |= PASSIVE_NOT_SUPPORTED;\n        passive = false;\n      }\n    } else {\n      eventFlags |= IS_ACTIVE;\n    } // Check if interactive and wrap in discreteUpdates\n\n\n    const listener = dispatchEvent.bind(null, topLevelType, eventFlags);\n\n    if (passiveBrowserEventsSupported) {\n      addEventCaptureListenerWithPassiveFlag(element, rawEventName, listener, passive);\n    } else {\n      addEventCaptureListener(element, rawEventName, listener);\n    }\n  }\n}\n\nfunction trapEventForPluginEventSystem(element, topLevelType, capture) {\n  let listener;\n\n  switch (getEventPriority(topLevelType)) {\n    case DiscreteEvent:\n      listener = dispatchDiscreteEvent.bind(null, topLevelType, PLUGIN_EVENT_SYSTEM);\n      break;\n\n    case UserBlockingEvent:\n      listener = dispatchUserBlockingUpdate.bind(null, topLevelType, PLUGIN_EVENT_SYSTEM);\n      break;\n\n    case ContinuousEvent:\n    default:\n      listener = dispatchEvent.bind(null, topLevelType, PLUGIN_EVENT_SYSTEM);\n      break;\n  }\n\n  const rawEventName = getRawEventName(topLevelType);\n\n  if (capture) {\n    addEventCaptureListener(element, rawEventName, listener);\n  } else {\n    addEventBubbleListener(element, rawEventName, listener);\n  }\n}\n\nfunction dispatchDiscreteEvent(topLevelType, eventSystemFlags, nativeEvent) {\n  flushDiscreteUpdatesIfNeeded(nativeEvent.timeStamp);\n  discreteUpdates(dispatchEvent, topLevelType, eventSystemFlags, nativeEvent);\n}\n\nfunction dispatchUserBlockingUpdate(topLevelType, eventSystemFlags, nativeEvent) {\n  runWithPriority(UserBlockingPriority, dispatchEvent.bind(null, topLevelType, eventSystemFlags, nativeEvent));\n}\n\nfunction dispatchEventForPluginEventSystem(topLevelType, eventSystemFlags, nativeEvent, targetInst) {\n  const bookKeeping = getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst, eventSystemFlags);\n\n  try {\n    // Event queue being processed in the same cycle allows\n    // `preventDefault`.\n    batchedEventUpdates(handleTopLevel, bookKeeping);\n  } finally {\n    releaseTopLevelCallbackBookKeeping(bookKeeping);\n  }\n}\n\nexport function dispatchEvent(topLevelType, eventSystemFlags, nativeEvent) {\n  if (!_enabled) {\n    return;\n  }\n\n  if (hasQueuedDiscreteEvents() && isReplayableDiscreteEvent(topLevelType)) {\n    // If we already have a queue of discrete events, and this is another discrete\n    // event, then we can't dispatch it regardless of its target, since they\n    // need to dispatch in order.\n    queueDiscreteEvent(null, // Flags that we're not actually blocked on anything as far as we know.\n    topLevelType, eventSystemFlags, nativeEvent);\n    return;\n  }\n\n  const blockedOn = attemptToDispatchEvent(topLevelType, eventSystemFlags, nativeEvent);\n\n  if (blockedOn === null) {\n    // We successfully dispatched this event.\n    clearIfContinuousEvent(topLevelType, nativeEvent);\n    return;\n  }\n\n  if (isReplayableDiscreteEvent(topLevelType)) {\n    // This this to be replayed later once the target is available.\n    queueDiscreteEvent(blockedOn, topLevelType, eventSystemFlags, nativeEvent);\n    return;\n  }\n\n  if (queueIfContinuousEvent(blockedOn, topLevelType, eventSystemFlags, nativeEvent)) {\n    return;\n  } // We need to clear only if we didn't queue because\n  // queueing is accummulative.\n\n\n  clearIfContinuousEvent(topLevelType, nativeEvent); // This is not replayable so we'll invoke it but without a target,\n  // in case the event system needs to trace it.\n\n  if (enableFlareAPI) {\n    if (eventSystemFlags & PLUGIN_EVENT_SYSTEM) {\n      dispatchEventForPluginEventSystem(topLevelType, eventSystemFlags, nativeEvent, null);\n    }\n\n    if (eventSystemFlags & RESPONDER_EVENT_SYSTEM) {\n      // React Flare event system\n      dispatchEventForResponderEventSystem(topLevelType, null, nativeEvent, getEventTarget(nativeEvent), eventSystemFlags);\n    }\n  } else {\n    dispatchEventForPluginEventSystem(topLevelType, eventSystemFlags, nativeEvent, null);\n  }\n} // Attempt dispatching an event. Returns a SuspenseInstance or Container if it's blocked.\n\nexport function attemptToDispatchEvent(topLevelType, eventSystemFlags, nativeEvent) {\n  // TODO: Warn if _enabled is false.\n  const nativeEventTarget = getEventTarget(nativeEvent);\n  let targetInst = getClosestInstanceFromNode(nativeEventTarget);\n\n  if (targetInst !== null) {\n    let nearestMounted = getNearestMountedFiber(targetInst);\n\n    if (nearestMounted === null) {\n      // This tree has been unmounted already. Dispatch without a target.\n      targetInst = null;\n    } else {\n      const tag = nearestMounted.tag;\n\n      if (tag === SuspenseComponent) {\n        let instance = getSuspenseInstanceFromFiber(nearestMounted);\n\n        if (instance !== null) {\n          // Queue the event to be replayed later. Abort dispatching since we\n          // don't want this event dispatched twice through the event system.\n          // TODO: If this is the first discrete event in the queue. Schedule an increased\n          // priority for this boundary.\n          return instance;\n        } // This shouldn't happen, something went wrong but to avoid blocking\n        // the whole system, dispatch the event without a target.\n        // TODO: Warn.\n\n\n        targetInst = null;\n      } else if (tag === HostRoot) {\n        const root = nearestMounted.stateNode;\n\n        if (root.hydrate) {\n          // If this happens during a replay something went wrong and it might block\n          // the whole system.\n          return getContainerFromFiber(nearestMounted);\n        }\n\n        targetInst = null;\n      } else if (nearestMounted !== targetInst) {\n        // If we get an event (ex: img onload) before committing that\n        // component's mount, ignore it for now (that is, treat it as if it was an\n        // event on a non-React tree). We might also consider queueing events and\n        // dispatching them after the mount.\n        targetInst = null;\n      }\n    }\n  }\n\n  if (enableFlareAPI) {\n    if (eventSystemFlags & PLUGIN_EVENT_SYSTEM) {\n      dispatchEventForPluginEventSystem(topLevelType, eventSystemFlags, nativeEvent, targetInst);\n    }\n\n    if (eventSystemFlags & RESPONDER_EVENT_SYSTEM) {\n      // React Flare event system\n      dispatchEventForResponderEventSystem(topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);\n    }\n  } else {\n    dispatchEventForPluginEventSystem(topLevelType, eventSystemFlags, nativeEvent, targetInst);\n  } // We're not blocked on anything.\n\n\n  return null;\n}","map":{"version":3,"sources":["/Users/gaoshaoyun/Documents/library/debug-react/src/react/packages/react-dom/src/events/ReactDOMEventListener.js"],"names":["Scheduler","batchedEventUpdates","discreteUpdates","flushDiscreteUpdatesIfNeeded","runExtractedPluginEventsInBatch","dispatchEventForResponderEventSystem","isReplayableDiscreteEvent","queueDiscreteEvent","hasQueuedDiscreteEvents","clearIfContinuousEvent","queueIfContinuousEvent","getNearestMountedFiber","getContainerFromFiber","getSuspenseInstanceFromFiber","HostRoot","SuspenseComponent","HostComponent","HostText","PLUGIN_EVENT_SYSTEM","RESPONDER_EVENT_SYSTEM","IS_PASSIVE","IS_ACTIVE","PASSIVE_NOT_SUPPORTED","addEventBubbleListener","addEventCaptureListener","addEventCaptureListenerWithPassiveFlag","getEventTarget","getClosestInstanceFromNode","SimpleEventPlugin","getRawEventName","passiveBrowserEventsSupported","enableFlareAPI","UserBlockingEvent","ContinuousEvent","DiscreteEvent","unstable_UserBlockingPriority","UserBlockingPriority","unstable_runWithPriority","runWithPriority","getEventPriority","CALLBACK_BOOKKEEPING_POOL_SIZE","callbackBookkeepingPool","findRootContainerNode","inst","tag","stateNode","containerInfo","return","getTopLevelCallbackBookKeeping","topLevelType","nativeEvent","targetInst","eventSystemFlags","length","instance","pop","ancestors","releaseTopLevelCallbackBookKeeping","push","handleTopLevel","bookKeeping","ancestor","root","i","eventTarget","_enabled","setEnabled","enabled","isEnabled","trapBubbledEvent","element","trapEventForPluginEventSystem","trapCapturedEvent","trapEventForResponderEventSystem","passive","rawEventName","eventFlags","listener","dispatchEvent","bind","capture","dispatchDiscreteEvent","dispatchUserBlockingUpdate","timeStamp","dispatchEventForPluginEventSystem","blockedOn","attemptToDispatchEvent","nativeEventTarget","nearestMounted","hydrate"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {AnyNativeEvent} from 'legacy-events/PluginModuleType';\nimport type {Fiber} from 'react-reconciler/src/ReactFiber';\nimport type {FiberRoot} from 'react-reconciler/src/ReactFiberRoot';\nimport type {Container, SuspenseInstance} from '../client/ReactDOMHostConfig';\nimport type {DOMTopLevelEventType} from 'legacy-events/TopLevelEventTypes';\n\n// Intentionally not named imports because Rollup would use dynamic dispatch for\n// CommonJS interop named imports.\nimport * as Scheduler from 'scheduler';\n\nimport {\n  batchedEventUpdates,\n  discreteUpdates,\n  flushDiscreteUpdatesIfNeeded,\n} from 'legacy-events/ReactGenericBatching';\nimport {runExtractedPluginEventsInBatch} from 'legacy-events/EventPluginHub';\nimport {dispatchEventForResponderEventSystem} from './DOMEventResponderSystem';\nimport {\n  isReplayableDiscreteEvent,\n  queueDiscreteEvent,\n  hasQueuedDiscreteEvents,\n  clearIfContinuousEvent,\n  queueIfContinuousEvent,\n} from './ReactDOMEventReplaying';\nimport {\n  getNearestMountedFiber,\n  getContainerFromFiber,\n  getSuspenseInstanceFromFiber,\n} from 'react-reconciler/reflection';\nimport {\n  HostRoot,\n  SuspenseComponent,\n  HostComponent,\n  HostText,\n} from 'shared/ReactWorkTags';\nimport {\n  type EventSystemFlags,\n  PLUGIN_EVENT_SYSTEM,\n  RESPONDER_EVENT_SYSTEM,\n  IS_PASSIVE,\n  IS_ACTIVE,\n  PASSIVE_NOT_SUPPORTED,\n} from 'legacy-events/EventSystemFlags';\n\nimport {\n  addEventBubbleListener,\n  addEventCaptureListener,\n  addEventCaptureListenerWithPassiveFlag,\n} from './EventListener';\nimport getEventTarget from './getEventTarget';\nimport {getClosestInstanceFromNode} from '../client/ReactDOMComponentTree';\nimport SimpleEventPlugin from './SimpleEventPlugin';\nimport {getRawEventName} from './DOMTopLevelEventTypes';\nimport {passiveBrowserEventsSupported} from './checkPassiveEvents';\n\nimport {enableFlareAPI} from 'shared/ReactFeatureFlags';\nimport {\n  UserBlockingEvent,\n  ContinuousEvent,\n  DiscreteEvent,\n} from 'shared/ReactTypes';\n\nconst {\n  unstable_UserBlockingPriority: UserBlockingPriority,\n  unstable_runWithPriority: runWithPriority,\n} = Scheduler;\n\nconst {getEventPriority} = SimpleEventPlugin;\n\nconst CALLBACK_BOOKKEEPING_POOL_SIZE = 10;\nconst callbackBookkeepingPool = [];\n\ntype BookKeepingInstance = {|\n  topLevelType: DOMTopLevelEventType | null,\n  eventSystemFlags: EventSystemFlags,\n  nativeEvent: AnyNativeEvent | null,\n  targetInst: Fiber | null,\n  ancestors: Array<Fiber | null>,\n|};\n\n/**\n * Find the deepest React component completely containing the root of the\n * passed-in instance (for use when entire React trees are nested within each\n * other). If React trees are not nested, returns null.\n */\nfunction findRootContainerNode(inst) {\n  if (inst.tag === HostRoot) {\n    return inst.stateNode.containerInfo;\n  }\n  // TODO: It may be a good idea to cache this to prevent unnecessary DOM\n  // traversal, but caching is difficult to do correctly without using a\n  // mutation observer to listen for all DOM changes.\n  while (inst.return) {\n    inst = inst.return;\n  }\n  if (inst.tag !== HostRoot) {\n    // This can happen if we're in a detached tree.\n    return null;\n  }\n  return inst.stateNode.containerInfo;\n}\n\n// Used to store ancestor hierarchy in top level callback\nfunction getTopLevelCallbackBookKeeping(\n  topLevelType: DOMTopLevelEventType,\n  nativeEvent: AnyNativeEvent,\n  targetInst: Fiber | null,\n  eventSystemFlags: EventSystemFlags,\n): BookKeepingInstance {\n  if (callbackBookkeepingPool.length) {\n    const instance = callbackBookkeepingPool.pop();\n    instance.topLevelType = topLevelType;\n    instance.eventSystemFlags = eventSystemFlags;\n    instance.nativeEvent = nativeEvent;\n    instance.targetInst = targetInst;\n    return instance;\n  }\n  return {\n    topLevelType,\n    eventSystemFlags,\n    nativeEvent,\n    targetInst,\n    ancestors: [],\n  };\n}\n\nfunction releaseTopLevelCallbackBookKeeping(\n  instance: BookKeepingInstance,\n): void {\n  instance.topLevelType = null;\n  instance.nativeEvent = null;\n  instance.targetInst = null;\n  instance.ancestors.length = 0;\n  if (callbackBookkeepingPool.length < CALLBACK_BOOKKEEPING_POOL_SIZE) {\n    callbackBookkeepingPool.push(instance);\n  }\n}\n\nfunction handleTopLevel(bookKeeping: BookKeepingInstance) {\n  let targetInst = bookKeeping.targetInst;\n\n  // Loop through the hierarchy, in case there's any nested components.\n  // It's important that we build the array of ancestors before calling any\n  // event handlers, because event handlers can modify the DOM, leading to\n  // inconsistencies with ReactMount's node cache. See #1105.\n  let ancestor = targetInst;\n  do {\n    if (!ancestor) {\n      const ancestors = bookKeeping.ancestors;\n      ((ancestors: any): Array<Fiber | null>).push(ancestor);\n      break;\n    }\n    const root = findRootContainerNode(ancestor);\n    if (!root) {\n      break;\n    }\n    const tag = ancestor.tag;\n    if (tag === HostComponent || tag === HostText) {\n      bookKeeping.ancestors.push(ancestor);\n    }\n    ancestor = getClosestInstanceFromNode(root);\n  } while (ancestor);\n\n  for (let i = 0; i < bookKeeping.ancestors.length; i++) {\n    targetInst = bookKeeping.ancestors[i];\n    const eventTarget = getEventTarget(bookKeeping.nativeEvent);\n    const topLevelType = ((bookKeeping.topLevelType: any): DOMTopLevelEventType);\n    const nativeEvent = ((bookKeeping.nativeEvent: any): AnyNativeEvent);\n\n    runExtractedPluginEventsInBatch(\n      topLevelType,\n      targetInst,\n      nativeEvent,\n      eventTarget,\n      bookKeeping.eventSystemFlags,\n    );\n  }\n}\n\n// TODO: can we stop exporting these?\nexport let _enabled = true;\n\nexport function setEnabled(enabled: ?boolean) {\n  _enabled = !!enabled;\n}\n\nexport function isEnabled() {\n  return _enabled;\n}\n\nexport function trapBubbledEvent(\n  topLevelType: DOMTopLevelEventType,\n  element: Document | Element | Node,\n): void {\n  trapEventForPluginEventSystem(element, topLevelType, false);\n}\n\nexport function trapCapturedEvent(\n  topLevelType: DOMTopLevelEventType,\n  element: Document | Element | Node,\n): void {\n  trapEventForPluginEventSystem(element, topLevelType, true);\n}\n\nexport function trapEventForResponderEventSystem(\n  element: Document | Element | Node,\n  topLevelType: DOMTopLevelEventType,\n  passive: boolean,\n): void {\n  if (enableFlareAPI) {\n    const rawEventName = getRawEventName(topLevelType);\n    let eventFlags = RESPONDER_EVENT_SYSTEM;\n\n    // If passive option is not supported, then the event will be\n    // active and not passive, but we flag it as using not being\n    // supported too. This way the responder event plugins know,\n    // and can provide polyfills if needed.\n    if (passive) {\n      if (passiveBrowserEventsSupported) {\n        eventFlags |= IS_PASSIVE;\n      } else {\n        eventFlags |= IS_ACTIVE;\n        eventFlags |= PASSIVE_NOT_SUPPORTED;\n        passive = false;\n      }\n    } else {\n      eventFlags |= IS_ACTIVE;\n    }\n    // Check if interactive and wrap in discreteUpdates\n    const listener = dispatchEvent.bind(null, topLevelType, eventFlags);\n    if (passiveBrowserEventsSupported) {\n      addEventCaptureListenerWithPassiveFlag(\n        element,\n        rawEventName,\n        listener,\n        passive,\n      );\n    } else {\n      addEventCaptureListener(element, rawEventName, listener);\n    }\n  }\n}\n\nfunction trapEventForPluginEventSystem(\n  element: Document | Element | Node,\n  topLevelType: DOMTopLevelEventType,\n  capture: boolean,\n): void {\n  let listener;\n  switch (getEventPriority(topLevelType)) {\n    case DiscreteEvent:\n      listener = dispatchDiscreteEvent.bind(\n        null,\n        topLevelType,\n        PLUGIN_EVENT_SYSTEM,\n      );\n      break;\n    case UserBlockingEvent:\n      listener = dispatchUserBlockingUpdate.bind(\n        null,\n        topLevelType,\n        PLUGIN_EVENT_SYSTEM,\n      );\n      break;\n    case ContinuousEvent:\n    default:\n      listener = dispatchEvent.bind(null, topLevelType, PLUGIN_EVENT_SYSTEM);\n      break;\n  }\n\n  const rawEventName = getRawEventName(topLevelType);\n  if (capture) {\n    addEventCaptureListener(element, rawEventName, listener);\n  } else {\n    addEventBubbleListener(element, rawEventName, listener);\n  }\n}\n\nfunction dispatchDiscreteEvent(topLevelType, eventSystemFlags, nativeEvent) {\n  flushDiscreteUpdatesIfNeeded(nativeEvent.timeStamp);\n  discreteUpdates(dispatchEvent, topLevelType, eventSystemFlags, nativeEvent);\n}\n\nfunction dispatchUserBlockingUpdate(\n  topLevelType,\n  eventSystemFlags,\n  nativeEvent,\n) {\n  runWithPriority(\n    UserBlockingPriority,\n    dispatchEvent.bind(null, topLevelType, eventSystemFlags, nativeEvent),\n  );\n}\n\nfunction dispatchEventForPluginEventSystem(\n  topLevelType: DOMTopLevelEventType,\n  eventSystemFlags: EventSystemFlags,\n  nativeEvent: AnyNativeEvent,\n  targetInst: null | Fiber,\n): void {\n  const bookKeeping = getTopLevelCallbackBookKeeping(\n    topLevelType,\n    nativeEvent,\n    targetInst,\n    eventSystemFlags,\n  );\n\n  try {\n    // Event queue being processed in the same cycle allows\n    // `preventDefault`.\n    batchedEventUpdates(handleTopLevel, bookKeeping);\n  } finally {\n    releaseTopLevelCallbackBookKeeping(bookKeeping);\n  }\n}\n\nexport function dispatchEvent(\n  topLevelType: DOMTopLevelEventType,\n  eventSystemFlags: EventSystemFlags,\n  nativeEvent: AnyNativeEvent,\n): void {\n  if (!_enabled) {\n    return;\n  }\n  if (hasQueuedDiscreteEvents() && isReplayableDiscreteEvent(topLevelType)) {\n    // If we already have a queue of discrete events, and this is another discrete\n    // event, then we can't dispatch it regardless of its target, since they\n    // need to dispatch in order.\n    queueDiscreteEvent(\n      null, // Flags that we're not actually blocked on anything as far as we know.\n      topLevelType,\n      eventSystemFlags,\n      nativeEvent,\n    );\n    return;\n  }\n\n  const blockedOn = attemptToDispatchEvent(\n    topLevelType,\n    eventSystemFlags,\n    nativeEvent,\n  );\n\n  if (blockedOn === null) {\n    // We successfully dispatched this event.\n    clearIfContinuousEvent(topLevelType, nativeEvent);\n    return;\n  }\n\n  if (isReplayableDiscreteEvent(topLevelType)) {\n    // This this to be replayed later once the target is available.\n    queueDiscreteEvent(blockedOn, topLevelType, eventSystemFlags, nativeEvent);\n    return;\n  }\n\n  if (\n    queueIfContinuousEvent(\n      blockedOn,\n      topLevelType,\n      eventSystemFlags,\n      nativeEvent,\n    )\n  ) {\n    return;\n  }\n\n  // We need to clear only if we didn't queue because\n  // queueing is accummulative.\n  clearIfContinuousEvent(topLevelType, nativeEvent);\n\n  // This is not replayable so we'll invoke it but without a target,\n  // in case the event system needs to trace it.\n  if (enableFlareAPI) {\n    if (eventSystemFlags & PLUGIN_EVENT_SYSTEM) {\n      dispatchEventForPluginEventSystem(\n        topLevelType,\n        eventSystemFlags,\n        nativeEvent,\n        null,\n      );\n    }\n    if (eventSystemFlags & RESPONDER_EVENT_SYSTEM) {\n      // React Flare event system\n      dispatchEventForResponderEventSystem(\n        (topLevelType: any),\n        null,\n        nativeEvent,\n        getEventTarget(nativeEvent),\n        eventSystemFlags,\n      );\n    }\n  } else {\n    dispatchEventForPluginEventSystem(\n      topLevelType,\n      eventSystemFlags,\n      nativeEvent,\n      null,\n    );\n  }\n}\n\n// Attempt dispatching an event. Returns a SuspenseInstance or Container if it's blocked.\nexport function attemptToDispatchEvent(\n  topLevelType: DOMTopLevelEventType,\n  eventSystemFlags: EventSystemFlags,\n  nativeEvent: AnyNativeEvent,\n): null | Container | SuspenseInstance {\n  // TODO: Warn if _enabled is false.\n\n  const nativeEventTarget = getEventTarget(nativeEvent);\n  let targetInst = getClosestInstanceFromNode(nativeEventTarget);\n\n  if (targetInst !== null) {\n    let nearestMounted = getNearestMountedFiber(targetInst);\n    if (nearestMounted === null) {\n      // This tree has been unmounted already. Dispatch without a target.\n      targetInst = null;\n    } else {\n      const tag = nearestMounted.tag;\n      if (tag === SuspenseComponent) {\n        let instance = getSuspenseInstanceFromFiber(nearestMounted);\n        if (instance !== null) {\n          // Queue the event to be replayed later. Abort dispatching since we\n          // don't want this event dispatched twice through the event system.\n          // TODO: If this is the first discrete event in the queue. Schedule an increased\n          // priority for this boundary.\n          return instance;\n        }\n        // This shouldn't happen, something went wrong but to avoid blocking\n        // the whole system, dispatch the event without a target.\n        // TODO: Warn.\n        targetInst = null;\n      } else if (tag === HostRoot) {\n        const root: FiberRoot = nearestMounted.stateNode;\n        if (root.hydrate) {\n          // If this happens during a replay something went wrong and it might block\n          // the whole system.\n          return getContainerFromFiber(nearestMounted);\n        }\n        targetInst = null;\n      } else if (nearestMounted !== targetInst) {\n        // If we get an event (ex: img onload) before committing that\n        // component's mount, ignore it for now (that is, treat it as if it was an\n        // event on a non-React tree). We might also consider queueing events and\n        // dispatching them after the mount.\n        targetInst = null;\n      }\n    }\n  }\n\n  if (enableFlareAPI) {\n    if (eventSystemFlags & PLUGIN_EVENT_SYSTEM) {\n      dispatchEventForPluginEventSystem(\n        topLevelType,\n        eventSystemFlags,\n        nativeEvent,\n        targetInst,\n      );\n    }\n    if (eventSystemFlags & RESPONDER_EVENT_SYSTEM) {\n      // React Flare event system\n      dispatchEventForResponderEventSystem(\n        (topLevelType: any),\n        targetInst,\n        nativeEvent,\n        nativeEventTarget,\n        eventSystemFlags,\n      );\n    }\n  } else {\n    dispatchEventForPluginEventSystem(\n      topLevelType,\n      eventSystemFlags,\n      nativeEvent,\n      targetInst,\n    );\n  }\n  // We're not blocked on anything.\n  return null;\n}\n"]},"metadata":{},"sourceType":"module"}