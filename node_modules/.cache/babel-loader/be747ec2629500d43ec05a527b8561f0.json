{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n * \n */\nimport invariant from 'shared/invariant';\nimport { injectEventPluginOrder, injectEventPluginsByName, plugins } from './EventPluginRegistry';\nimport { getFiberCurrentPropsFromNode } from './EventPluginUtils';\nimport accumulateInto from './accumulateInto';\nimport { runEventsInBatch } from './EventBatching';\n\nfunction isInteractive(tag) {\n  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';\n}\n\nfunction shouldPreventMouseEvent(name, type, props) {\n  switch (name) {\n    case 'onClick':\n    case 'onClickCapture':\n    case 'onDoubleClick':\n    case 'onDoubleClickCapture':\n    case 'onMouseDown':\n    case 'onMouseDownCapture':\n    case 'onMouseMove':\n    case 'onMouseMoveCapture':\n    case 'onMouseUp':\n    case 'onMouseUpCapture':\n      return !!(props.disabled && isInteractive(type));\n\n    default:\n      return false;\n  }\n}\n/**\n * This is a unified interface for event plugins to be installed and configured.\n *\n * Event plugins can implement the following properties:\n *\n *   `extractEvents` {function(string, DOMEventTarget, string, object): *}\n *     Required. When a top-level event is fired, this method is expected to\n *     extract synthetic events that will in turn be queued and dispatched.\n *\n *   `eventTypes` {object}\n *     Optional, plugins that fire events must publish a mapping of registration\n *     names that are used to register listeners. Values of this mapping must\n *     be objects that contain `registrationName` or `phasedRegistrationNames`.\n *\n *   `executeDispatch` {function(object, function, string)}\n *     Optional, allows plugins to override how an event gets dispatched. By\n *     default, the listener is simply invoked.\n *\n * Each plugin that is injected into `EventsPluginHub` is immediately operable.\n *\n * @public\n */\n\n/**\n * Methods for injecting dependencies.\n */\n\n\nexport const injection = {\n  /**\n   * @param {array} InjectedEventPluginOrder\n   * @public\n   */\n  injectEventPluginOrder,\n\n  /**\n   * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n   */\n  injectEventPluginsByName\n};\n/**\n * @param {object} inst The instance, which is the source of events.\n * @param {string} registrationName Name of listener (e.g. `onClick`).\n * @return {?function} The stored callback.\n */\n\nexport function getListener(inst, registrationName) {\n  let listener; // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not\n  // live here; needs to be moved to a better place soon\n\n  const stateNode = inst.stateNode;\n\n  if (!stateNode) {\n    // Work in progress (ex: onload events in incremental mode).\n    return null;\n  }\n\n  const props = getFiberCurrentPropsFromNode(stateNode);\n\n  if (!props) {\n    // Work in progress.\n    return null;\n  }\n\n  listener = props[registrationName];\n\n  if (shouldPreventMouseEvent(registrationName, inst.type, props)) {\n    return null;\n  }\n\n  invariant(!listener || typeof listener === 'function', 'Expected `%s` listener to be a function, instead got a value of `%s` type.', registrationName, typeof listener);\n  return listener;\n}\n/**\n * Allows registered plugins an opportunity to extract events from top-level\n * native browser events.\n *\n * @return {*} An accumulation of synthetic events.\n * @internal\n */\n\nfunction extractPluginEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags) {\n  let events = null;\n\n  for (let i = 0; i < plugins.length; i++) {\n    // Not every plugin in the ordering may be loaded at runtime.\n    const possiblePlugin = plugins[i];\n\n    if (possiblePlugin) {\n      const extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);\n\n      if (extractedEvents) {\n        events = accumulateInto(events, extractedEvents);\n      }\n    }\n  }\n\n  return events;\n}\n\nexport function runExtractedPluginEventsInBatch(topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags) {\n  const events = extractPluginEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);\n  runEventsInBatch(events);\n}","map":{"version":3,"sources":["/Users/gaoshaoyun/Documents/library/debug-react/src/react/packages/legacy-events/EventPluginHub.js"],"names":["invariant","injectEventPluginOrder","injectEventPluginsByName","plugins","getFiberCurrentPropsFromNode","accumulateInto","runEventsInBatch","isInteractive","tag","shouldPreventMouseEvent","name","type","props","disabled","injection","getListener","inst","registrationName","listener","stateNode","extractPluginEvents","topLevelType","targetInst","nativeEvent","nativeEventTarget","eventSystemFlags","events","i","length","possiblePlugin","extractedEvents","extractEvents","runExtractedPluginEventsInBatch"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n * @flow\n */\n\nimport invariant from 'shared/invariant';\n\nimport {\n  injectEventPluginOrder,\n  injectEventPluginsByName,\n  plugins,\n} from './EventPluginRegistry';\nimport {getFiberCurrentPropsFromNode} from './EventPluginUtils';\nimport accumulateInto from './accumulateInto';\nimport {runEventsInBatch} from './EventBatching';\n\nimport type {PluginModule} from './PluginModuleType';\nimport type {ReactSyntheticEvent} from './ReactSyntheticEventType';\nimport type {Fiber} from 'react-reconciler/src/ReactFiber';\nimport type {AnyNativeEvent} from './PluginModuleType';\nimport type {TopLevelType} from './TopLevelEventTypes';\nimport type {EventSystemFlags} from 'legacy-events/EventSystemFlags';\n\nfunction isInteractive(tag) {\n  return (\n    tag === 'button' ||\n    tag === 'input' ||\n    tag === 'select' ||\n    tag === 'textarea'\n  );\n}\n\nfunction shouldPreventMouseEvent(name, type, props) {\n  switch (name) {\n    case 'onClick':\n    case 'onClickCapture':\n    case 'onDoubleClick':\n    case 'onDoubleClickCapture':\n    case 'onMouseDown':\n    case 'onMouseDownCapture':\n    case 'onMouseMove':\n    case 'onMouseMoveCapture':\n    case 'onMouseUp':\n    case 'onMouseUpCapture':\n      return !!(props.disabled && isInteractive(type));\n    default:\n      return false;\n  }\n}\n\n/**\n * This is a unified interface for event plugins to be installed and configured.\n *\n * Event plugins can implement the following properties:\n *\n *   `extractEvents` {function(string, DOMEventTarget, string, object): *}\n *     Required. When a top-level event is fired, this method is expected to\n *     extract synthetic events that will in turn be queued and dispatched.\n *\n *   `eventTypes` {object}\n *     Optional, plugins that fire events must publish a mapping of registration\n *     names that are used to register listeners. Values of this mapping must\n *     be objects that contain `registrationName` or `phasedRegistrationNames`.\n *\n *   `executeDispatch` {function(object, function, string)}\n *     Optional, allows plugins to override how an event gets dispatched. By\n *     default, the listener is simply invoked.\n *\n * Each plugin that is injected into `EventsPluginHub` is immediately operable.\n *\n * @public\n */\n\n/**\n * Methods for injecting dependencies.\n */\nexport const injection = {\n  /**\n   * @param {array} InjectedEventPluginOrder\n   * @public\n   */\n  injectEventPluginOrder,\n\n  /**\n   * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n   */\n  injectEventPluginsByName,\n};\n\n/**\n * @param {object} inst The instance, which is the source of events.\n * @param {string} registrationName Name of listener (e.g. `onClick`).\n * @return {?function} The stored callback.\n */\nexport function getListener(inst: Fiber, registrationName: string) {\n  let listener;\n\n  // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not\n  // live here; needs to be moved to a better place soon\n  const stateNode = inst.stateNode;\n  if (!stateNode) {\n    // Work in progress (ex: onload events in incremental mode).\n    return null;\n  }\n  const props = getFiberCurrentPropsFromNode(stateNode);\n  if (!props) {\n    // Work in progress.\n    return null;\n  }\n  listener = props[registrationName];\n  if (shouldPreventMouseEvent(registrationName, inst.type, props)) {\n    return null;\n  }\n  invariant(\n    !listener || typeof listener === 'function',\n    'Expected `%s` listener to be a function, instead got a value of `%s` type.',\n    registrationName,\n    typeof listener,\n  );\n  return listener;\n}\n\n/**\n * Allows registered plugins an opportunity to extract events from top-level\n * native browser events.\n *\n * @return {*} An accumulation of synthetic events.\n * @internal\n */\nfunction extractPluginEvents(\n  topLevelType: TopLevelType,\n  targetInst: null | Fiber,\n  nativeEvent: AnyNativeEvent,\n  nativeEventTarget: null | EventTarget,\n  eventSystemFlags: EventSystemFlags,\n): Array<ReactSyntheticEvent> | ReactSyntheticEvent | null {\n  let events = null;\n  for (let i = 0; i < plugins.length; i++) {\n    // Not every plugin in the ordering may be loaded at runtime.\n    const possiblePlugin: PluginModule<AnyNativeEvent> = plugins[i];\n    if (possiblePlugin) {\n      const extractedEvents = possiblePlugin.extractEvents(\n        topLevelType,\n        targetInst,\n        nativeEvent,\n        nativeEventTarget,\n        eventSystemFlags,\n      );\n      if (extractedEvents) {\n        events = accumulateInto(events, extractedEvents);\n      }\n    }\n  }\n  return events;\n}\n\nexport function runExtractedPluginEventsInBatch(\n  topLevelType: TopLevelType,\n  targetInst: null | Fiber,\n  nativeEvent: AnyNativeEvent,\n  nativeEventTarget: null | EventTarget,\n  eventSystemFlags: EventSystemFlags,\n) {\n  const events = extractPluginEvents(\n    topLevelType,\n    targetInst,\n    nativeEvent,\n    nativeEventTarget,\n    eventSystemFlags,\n  );\n  runEventsInBatch(events);\n}\n"]},"metadata":{},"sourceType":"module"}