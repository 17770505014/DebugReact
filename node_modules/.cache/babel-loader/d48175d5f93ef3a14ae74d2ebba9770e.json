{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { warnAboutDeprecatedLifecycles, enableUserTimingAPI, enableSuspenseServerRenderer, replayFailedUnitOfWorkWithInvokeGuardedCallback, enableProfilerTimer, enableSchedulerTracing, warnAboutUnmockedScheduler, flushSuspenseFallbacksInTests, disableSchedulerTimeoutBasedOnReactExpirationTime } from 'shared/ReactFeatureFlags';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport invariant from 'shared/invariant';\nimport warning from 'shared/warning';\nimport { scheduleCallback, cancelCallback, getCurrentPriorityLevel, runWithPriority, shouldYield, requestPaint, now, NoPriority, ImmediatePriority, UserBlockingPriority, NormalPriority, LowPriority, IdlePriority, flushSyncCallbackQueue, scheduleSyncCallback } from './SchedulerWithReactIntegration'; // The scheduler is imported here *only* to detect whether it's been mocked\n\nimport * as Scheduler from 'scheduler';\nimport { __interactionsRef, __subscriberRef } from 'scheduler/tracing';\nimport { prepareForCommit, resetAfterCommit, scheduleTimeout, cancelTimeout, noTimeout, warnsIfNotActing } from './ReactFiberHostConfig';\nimport { createWorkInProgress, assignFiberPropertiesInDEV } from './ReactFiber';\nimport { isRootSuspendedAtTime, markRootSuspendedAtTime, markRootFinishedAtTime, markRootUpdatedAtTime, markRootExpiredAtTime } from './ReactFiberRoot';\nimport { NoMode, StrictMode, ProfileMode, BatchedMode, ConcurrentMode } from './ReactTypeOfMode';\nimport { HostRoot, ClassComponent, SuspenseComponent, SuspenseListComponent, FunctionComponent, ForwardRef, MemoComponent, SimpleMemoComponent } from 'shared/ReactWorkTags';\nimport { NoEffect, PerformedWork, Placement, Update, PlacementAndUpdate, Deletion, Ref, ContentReset, Snapshot, Callback, Passive, Incomplete, HostEffectMask, Hydrating, HydratingAndUpdate } from 'shared/ReactSideEffectTags';\nimport { NoWork, Sync, Never, msToExpirationTime, expirationTimeToMs, computeInteractiveExpiration, computeAsyncExpiration, computeSuspenseExpiration, inferPriorityFromExpirationTime, LOW_PRIORITY_EXPIRATION, Batched, Idle } from './ReactFiberExpirationTime';\nimport { beginWork as originalBeginWork } from './ReactFiberBeginWork';\nimport { completeWork } from './ReactFiberCompleteWork';\nimport { unwindWork, unwindInterruptedWork } from './ReactFiberUnwindWork';\nimport { throwException, createRootErrorUpdate, createClassErrorUpdate } from './ReactFiberThrow';\nimport { commitBeforeMutationLifeCycles as commitBeforeMutationEffectOnFiber, commitLifeCycles as commitLayoutEffectOnFiber, commitPassiveHookEffects, commitPlacement, commitWork, commitDeletion, commitDetachRef, commitAttachRef, commitResetTextContent } from './ReactFiberCommitWork';\nimport { enqueueUpdate } from './ReactUpdateQueue';\nimport { resetContextDependencies } from './ReactFiberNewContext';\nimport { resetHooks, ContextOnlyDispatcher } from './ReactFiberHooks';\nimport { createCapturedValue } from './ReactCapturedValue';\nimport { recordCommitTime, startProfilerTimer, stopProfilerTimerIfRunningAndRecordDelta } from './ReactProfilerTimer'; // DEV stuff\n\nimport warningWithoutStack from 'shared/warningWithoutStack';\nimport getComponentName from 'shared/getComponentName';\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings';\nimport { phase as ReactCurrentDebugFiberPhaseInDEV, resetCurrentFiber as resetCurrentDebugFiberInDEV, setCurrentFiber as setCurrentDebugFiberInDEV, getStackByFiberInDevAndProd } from './ReactCurrentFiber';\nimport { recordEffect, recordScheduleUpdate, startWorkTimer, stopWorkTimer, stopFailedWorkTimer, startWorkLoopTimer, stopWorkLoopTimer, startCommitTimer, stopCommitTimer, startCommitSnapshotEffectsTimer, stopCommitSnapshotEffectsTimer, startCommitHostEffectsTimer, stopCommitHostEffectsTimer, startCommitLifeCyclesTimer, stopCommitLifeCyclesTimer } from './ReactDebugFiberPerf';\nimport { invokeGuardedCallback, hasCaughtError, clearCaughtError } from 'shared/ReactErrorUtils';\nimport { onCommitRoot } from './ReactFiberDevToolsHook';\nconst ceil = Math.ceil;\nconst {\n  ReactCurrentDispatcher,\n  ReactCurrentOwner,\n  IsSomeRendererActing\n} = ReactSharedInternals;\nconst NoContext =\n/*                    */\n0b000000;\nconst BatchedContext =\n/*               */\n0b000001;\nconst EventContext =\n/*                 */\n0b000010;\nconst DiscreteEventContext =\n/*         */\n0b000100;\nconst LegacyUnbatchedContext =\n/*       */\n0b001000;\nconst RenderContext =\n/*                */\n0b010000;\nconst CommitContext =\n/*                */\n0b100000;\nconst RootIncomplete = 0;\nconst RootErrored = 1;\nconst RootSuspended = 2;\nconst RootSuspendedWithDelay = 3;\nconst RootCompleted = 4;\nconst RootLocked = 5;\n// Describes where we are in the React execution stack\nlet executionContext = NoContext; // The root we're working on\n\nlet workInProgressRoot = null; // The fiber we're working on\n\nlet workInProgress = null; // The expiration time we're rendering\n\nlet renderExpirationTime = NoWork; // Whether to root completed, errored, suspended, etc.\n\nlet workInProgressRootExitStatus = RootIncomplete; // Most recent event time among processed updates during this render.\n// This is conceptually a time stamp but expressed in terms of an ExpirationTime\n// because we deal mostly with expiration times in the hot path, so this avoids\n// the conversion happening in the hot path.\n\nlet workInProgressRootLatestProcessedExpirationTime = Sync;\nlet workInProgressRootLatestSuspenseTimeout = Sync;\nlet workInProgressRootCanSuspendUsingConfig = null; // The work left over by components that were visited during this render. Only\n// includes unprocessed updates, not work in bailed out children.\n\nlet workInProgressRootNextUnprocessedUpdateTime = NoWork; // If we're pinged while rendering we don't always restart immediately.\n// This flag determines if it might be worthwhile to restart if an opportunity\n// happens latere.\n\nlet workInProgressRootHasPendingPing = false; // The most recent time we committed a fallback. This lets us ensure a train\n// model where we don't commit new loading states in too quick succession.\n\nlet globalMostRecentFallbackTime = 0;\nconst FALLBACK_THROTTLE_MS = 500;\nlet nextEffect = null;\nlet hasUncaughtError = false;\nlet firstUncaughtError = null;\nlet legacyErrorBoundariesThatAlreadyFailed = null;\nlet rootDoesHavePassiveEffects = false;\nlet rootWithPendingPassiveEffects = null;\nlet pendingPassiveEffectsRenderPriority = NoPriority;\nlet pendingPassiveEffectsExpirationTime = NoWork;\nlet rootsWithPendingDiscreteUpdates = null; // Use these to prevent an infinite loop of nested updates\n\nconst NESTED_UPDATE_LIMIT = 50;\nlet nestedUpdateCount = 0;\nlet rootWithNestedUpdates = null;\nconst NESTED_PASSIVE_UPDATE_LIMIT = 50;\nlet nestedPassiveUpdateCount = 0;\nlet interruptedBy = null; // Marks the need to reschedule pending interactions at these expiration times\n// during the commit phase. This enables them to be traced across components\n// that spawn new work during render. E.g. hidden boundaries, suspended SSR\n// hydration or SuspenseList.\n\nlet spawnedWorkDuringRender = null; // Expiration times are computed by adding to the current time (the start\n// time). However, if two updates are scheduled within the same event, we\n// should treat their start times as simultaneous, even if the actual clock\n// time has advanced between the first and second call.\n// In other words, because expiration times determine how updates are batched,\n// we want all updates of like priority that occur within the same event to\n// receive the same expiration time. Otherwise we get tearing.\n\nlet currentEventTime = NoWork;\nexport function requestCurrentTime() {\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    // We're inside React, so it's fine to read the actual time.\n    return msToExpirationTime(now());\n  } // We're not inside React, so we may be in the middle of a browser event.\n\n\n  if (currentEventTime !== NoWork) {\n    // Use the same start time for all updates until we enter React again.\n    return currentEventTime;\n  } // This is the first update since React yielded. Compute a new start time.\n\n\n  currentEventTime = msToExpirationTime(now());\n  return currentEventTime;\n}\nexport function computeExpirationForFiber(currentTime, fiber, suspenseConfig) {\n  const mode = fiber.mode;\n\n  if ((mode & BatchedMode) === NoMode) {\n    return Sync;\n  }\n\n  const priorityLevel = getCurrentPriorityLevel();\n\n  if ((mode & ConcurrentMode) === NoMode) {\n    return priorityLevel === ImmediatePriority ? Sync : Batched;\n  }\n\n  if ((executionContext & RenderContext) !== NoContext) {\n    // Use whatever time we're already rendering\n    return renderExpirationTime;\n  }\n\n  let expirationTime;\n\n  if (suspenseConfig !== null) {\n    // Compute an expiration time based on the Suspense timeout.\n    expirationTime = computeSuspenseExpiration(currentTime, suspenseConfig.timeoutMs | 0 || LOW_PRIORITY_EXPIRATION);\n  } else {\n    // Compute an expiration time based on the Scheduler priority.\n    switch (priorityLevel) {\n      case ImmediatePriority:\n        expirationTime = Sync;\n        break;\n\n      case UserBlockingPriority:\n        // TODO: Rename this to computeUserBlockingExpiration\n        expirationTime = computeInteractiveExpiration(currentTime);\n        break;\n\n      case NormalPriority:\n      case LowPriority:\n        // TODO: Handle LowPriority\n        // TODO: Rename this to... something better.\n        expirationTime = computeAsyncExpiration(currentTime);\n        break;\n\n      case IdlePriority:\n        expirationTime = Never;\n        break;\n\n      default:\n        invariant(false, 'Expected a valid priority level');\n    }\n  } // If we're in the middle of rendering a tree, do not update at the same\n  // expiration time that is already rendering.\n  // TODO: We shouldn't have to do this if the update is on a different root.\n  // Refactor computeExpirationForFiber + scheduleUpdate so we have access to\n  // the root when we check for this condition.\n\n\n  if (workInProgressRoot !== null && expirationTime === renderExpirationTime) {\n    // This is a trick to move this update into a separate batch\n    expirationTime -= 1;\n  }\n\n  return expirationTime;\n}\nlet lastUniqueAsyncExpiration = NoWork;\nexport function computeUniqueAsyncExpiration() {\n  const currentTime = requestCurrentTime();\n  let result = computeAsyncExpiration(currentTime);\n\n  if (result <= lastUniqueAsyncExpiration) {\n    // Since we assume the current time monotonically increases, we only hit\n    // this branch when computeUniqueAsyncExpiration is fired multiple times\n    // within a 200ms window (or whatever the async bucket size is).\n    result -= 1;\n  }\n\n  lastUniqueAsyncExpiration = result;\n  return result;\n}\nexport function scheduleUpdateOnFiber(fiber, expirationTime) {\n  checkForNestedUpdates();\n  warnAboutInvalidUpdatesOnClassComponentsInDEV(fiber);\n  const root = markUpdateTimeFromFiberToRoot(fiber, expirationTime);\n\n  if (root === null) {\n    warnAboutUpdateOnUnmountedFiberInDEV(fiber);\n    return;\n  }\n\n  checkForInterruption(fiber, expirationTime);\n  recordScheduleUpdate(); // TODO: computeExpirationForFiber also reads the priority. Pass the\n  // priority as an argument to that function and this one.\n\n  const priorityLevel = getCurrentPriorityLevel();\n\n  if (expirationTime === Sync) {\n    if ( // Check if we're inside unbatchedUpdates\n    (executionContext & LegacyUnbatchedContext) !== NoContext && // Check if we're not already rendering\n    (executionContext & (RenderContext | CommitContext)) === NoContext) {\n      // Register pending interactions on the root to avoid losing traced interaction data.\n      schedulePendingInteractions(root, expirationTime); // This is a legacy edge case. The initial mount of a ReactDOM.render-ed\n      // root inside of batchedUpdates should be synchronous, but layout updates\n      // should be deferred until the end of the batch.\n\n      performSyncWorkOnRoot(root);\n    } else {\n      ensureRootIsScheduled(root);\n      schedulePendingInteractions(root, expirationTime);\n\n      if (executionContext === NoContext) {\n        // Flush the synchronous work now, unless we're already working or inside\n        // a batch. This is intentionally inside scheduleUpdateOnFiber instead of\n        // scheduleCallbackForFiber to preserve the ability to schedule a callback\n        // without immediately flushing it. We only do this for user-initiated\n        // updates, to preserve historical behavior of sync mode.\n        flushSyncCallbackQueue();\n      }\n    }\n  } else {\n    ensureRootIsScheduled(root);\n    schedulePendingInteractions(root, expirationTime);\n  }\n\n  if ((executionContext & DiscreteEventContext) !== NoContext && ( // Only updates at user-blocking priority or greater are considered\n  // discrete, even inside a discrete event.\n  priorityLevel === UserBlockingPriority || priorityLevel === ImmediatePriority)) {\n    // This is the result of a discrete event. Track the lowest priority\n    // discrete update per root so we can flush them early, if needed.\n    if (rootsWithPendingDiscreteUpdates === null) {\n      rootsWithPendingDiscreteUpdates = new Map([[root, expirationTime]]);\n    } else {\n      const lastDiscreteTime = rootsWithPendingDiscreteUpdates.get(root);\n\n      if (lastDiscreteTime === undefined || lastDiscreteTime > expirationTime) {\n        rootsWithPendingDiscreteUpdates.set(root, expirationTime);\n      }\n    }\n  }\n}\nexport const scheduleWork = scheduleUpdateOnFiber; // This is split into a separate function so we can mark a fiber with pending\n// work without treating it as a typical update that originates from an event;\n// e.g. retrying a Suspense boundary isn't an update, but it does schedule work\n// on a fiber.\n\nfunction markUpdateTimeFromFiberToRoot(fiber, expirationTime) {\n  // Update the source fiber's expiration time\n  if (fiber.expirationTime < expirationTime) {\n    fiber.expirationTime = expirationTime;\n  }\n\n  let alternate = fiber.alternate;\n\n  if (alternate !== null && alternate.expirationTime < expirationTime) {\n    alternate.expirationTime = expirationTime;\n  } // Walk the parent path to the root and update the child expiration time.\n\n\n  let node = fiber.return;\n  let root = null;\n\n  if (node === null && fiber.tag === HostRoot) {\n    root = fiber.stateNode;\n  } else {\n    while (node !== null) {\n      alternate = node.alternate;\n\n      if (node.childExpirationTime < expirationTime) {\n        node.childExpirationTime = expirationTime;\n\n        if (alternate !== null && alternate.childExpirationTime < expirationTime) {\n          alternate.childExpirationTime = expirationTime;\n        }\n      } else if (alternate !== null && alternate.childExpirationTime < expirationTime) {\n        alternate.childExpirationTime = expirationTime;\n      }\n\n      if (node.return === null && node.tag === HostRoot) {\n        root = node.stateNode;\n        break;\n      }\n\n      node = node.return;\n    }\n  }\n\n  if (root !== null) {\n    if (workInProgressRoot === root) {\n      // Received an update to a tree that's in the middle of rendering. Mark\n      // that's unprocessed work on this root.\n      markUnprocessedUpdateTime(expirationTime);\n\n      if (workInProgressRootExitStatus === RootSuspendedWithDelay) {\n        // The root already suspended with a delay, which means this render\n        // definitely won't finish. Since we have a new update, let's mark it as\n        // suspended now, right before marking the incoming update. This has the\n        // effect of interrupting the current render and switching to the update.\n        // TODO: This happens to work when receiving an update during the render\n        // phase, because of the trick inside computeExpirationForFiber to\n        // subtract 1 from `renderExpirationTime` to move it into a\n        // separate bucket. But we should probably model it with an exception,\n        // using the same mechanism we use to force hydration of a subtree.\n        // TODO: This does not account for low pri updates that were already\n        // scheduled before the root started rendering. Need to track the next\n        // pending expiration time (perhaps by backtracking the return path) and\n        // then trigger a restart in the `renderDidSuspendDelayIfPossible` path.\n        markRootSuspendedAtTime(root, renderExpirationTime);\n      }\n    } // Mark that the root has a pending update.\n\n\n    markRootUpdatedAtTime(root, expirationTime);\n  }\n\n  return root;\n}\n\nfunction getNextRootExpirationTimeToWorkOn(root) {\n  // Determines the next expiration time that the root should render, taking\n  // into account levels that may be suspended, or levels that may have\n  // received a ping.\n  const lastExpiredTime = root.lastExpiredTime;\n\n  if (lastExpiredTime !== NoWork) {\n    return lastExpiredTime;\n  } // \"Pending\" refers to any update that hasn't committed yet, including if it\n  // suspended. The \"suspended\" range is therefore a subset.\n\n\n  const firstPendingTime = root.firstPendingTime;\n\n  if (!isRootSuspendedAtTime(root, firstPendingTime)) {\n    // The highest priority pending time is not suspended. Let's work on that.\n    return firstPendingTime;\n  } // If the first pending time is suspended, check if there's a lower priority\n  // pending level that we know about. Or check if we received a ping. Work\n  // on whichever is higher priority.\n\n\n  const lastPingedTime = root.lastPingedTime;\n  const nextKnownPendingLevel = root.nextKnownPendingLevel;\n  return lastPingedTime > nextKnownPendingLevel ? lastPingedTime : nextKnownPendingLevel;\n} // Use this function to schedule a task for a root. There's only one task per\n// root; if a task was already scheduled, we'll check to make sure the\n// expiration time of the existing task is the same as the expiration time of\n// the next level that the root has work on. This function is called on every\n// update, and right before exiting a task.\n\n\nfunction ensureRootIsScheduled(root) {\n  const lastExpiredTime = root.lastExpiredTime;\n\n  if (lastExpiredTime !== NoWork) {\n    // Special case: Expired work should flush synchronously.\n    root.callbackExpirationTime = Sync;\n    root.callbackPriority = ImmediatePriority;\n    root.callbackNode = scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));\n    return;\n  }\n\n  const expirationTime = getNextRootExpirationTimeToWorkOn(root);\n  const existingCallbackNode = root.callbackNode;\n\n  if (expirationTime === NoWork) {\n    // There's nothing to work on.\n    if (existingCallbackNode !== null) {\n      root.callbackNode = null;\n      root.callbackExpirationTime = NoWork;\n      root.callbackPriority = NoPriority;\n    }\n\n    return;\n  } // TODO: If this is an update, we already read the current time. Pass the\n  // time as an argument.\n\n\n  const currentTime = requestCurrentTime();\n  const priorityLevel = inferPriorityFromExpirationTime(currentTime, expirationTime); // If there's an existing render task, confirm it has the correct priority and\n  // expiration time. Otherwise, we'll cancel it and schedule a new one.\n\n  if (existingCallbackNode !== null) {\n    const existingCallbackPriority = root.callbackPriority;\n    const existingCallbackExpirationTime = root.callbackExpirationTime;\n\n    if ( // Callback must have the exact same expiration time.\n    existingCallbackExpirationTime === expirationTime && // Callback must have greater or equal priority.\n    existingCallbackPriority >= priorityLevel) {\n      // Existing callback is sufficient.\n      return;\n    } // Need to schedule a new task.\n    // TODO: Instead of scheduling a new task, we should be able to change the\n    // priority of the existing one.\n\n\n    cancelCallback(existingCallbackNode);\n  }\n\n  root.callbackExpirationTime = expirationTime;\n  root.callbackPriority = priorityLevel;\n  let callbackNode;\n\n  if (expirationTime === Sync) {\n    // Sync React callbacks are scheduled on a special internal queue\n    callbackNode = scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));\n  } else if (disableSchedulerTimeoutBasedOnReactExpirationTime) {\n    callbackNode = scheduleCallback(priorityLevel, performConcurrentWorkOnRoot.bind(null, root));\n  } else {\n    callbackNode = scheduleCallback(priorityLevel, performConcurrentWorkOnRoot.bind(null, root), // Compute a task timeout based on the expiration time. This also affects\n    // ordering because tasks are processed in timeout order.\n    {\n      timeout: expirationTimeToMs(expirationTime) - now()\n    });\n  }\n\n  root.callbackNode = callbackNode;\n} // This is the entry point for every concurrent task, i.e. anything that\n// goes through Scheduler.\n\n\nfunction performConcurrentWorkOnRoot(root, didTimeout) {\n  // Since we know we're in a React event, we can clear the current\n  // event time. The next update will compute a new event time.\n  currentEventTime = NoWork;\n\n  if (didTimeout) {\n    // The render task took too long to complete. Mark the current time as\n    // expired to synchronously render all expired work in a single batch.\n    const currentTime = requestCurrentTime();\n    markRootExpiredAtTime(root, currentTime); // This will schedule a synchronous callback.\n\n    ensureRootIsScheduled(root);\n    return null;\n  } // Determine the next expiration time to work on, using the fields stored\n  // on the root.\n\n\n  const expirationTime = getNextRootExpirationTimeToWorkOn(root);\n\n  if (expirationTime !== NoWork) {\n    const originalCallbackNode = root.callbackNode;\n\n    try {\n      renderRoot(root, expirationTime, false);\n\n      if (workInProgress !== null) {\n        // There's still work left over. Exit without committing.\n        stopInterruptedWorkLoopTimer();\n      } else {\n        // We now have a consistent tree. The next step is either to commit it,\n        // or, if something suspended, wait to commit it after a timeout.\n        stopFinishedWorkLoopTimer();\n        const finishedWork = root.finishedWork = root.current.alternate;\n        root.finishedExpirationTime = expirationTime;\n        resolveLocksOnRoot(root, expirationTime); // Set this to null to indicate there's no in-progress render.\n\n        workInProgressRoot = null;\n\n        switch (workInProgressRootExitStatus) {\n          case RootIncomplete:\n            {\n              invariant(false, 'Should have a work-in-progress.');\n            }\n          // Flow knows about invariant, so it complains if I add a break\n          // statement, but eslint doesn't know about invariant, so it complains\n          // if I do. eslint-disable-next-line no-fallthrough\n\n          case RootErrored:\n            {\n              if (expirationTime !== Idle) {\n                // If this was an async render, the error may have happened due to\n                // a mutation in a concurrent event. Try rendering one more time,\n                // synchronously, to see if the error goes away. If there are\n                // lower priority updates, let's include those, too, in case they\n                // fix the inconsistency. Render at Idle to include all updates.\n                markRootExpiredAtTime(root, Idle);\n                break;\n              } // Commit the root in its errored state.\n\n\n              commitRoot(root);\n              break;\n            }\n\n          case RootSuspended:\n            {\n              markRootSuspendedAtTime(root, expirationTime);\n              const lastSuspendedTime = root.lastSuspendedTime;\n\n              if (expirationTime === lastSuspendedTime) {\n                root.nextKnownPendingLevel = getRemainingExpirationTime(finishedWork);\n              }\n\n              flushSuspensePriorityWarningInDEV(); // We have an acceptable loading state. We need to figure out if we\n              // should immediately commit it or wait a bit.\n              // If we have processed new updates during this render, we may now\n              // have a new loading state ready. We want to ensure that we commit\n              // that as soon as possible.\n\n              const hasNotProcessedNewUpdates = workInProgressRootLatestProcessedExpirationTime === Sync;\n\n              if (hasNotProcessedNewUpdates && // do not delay if we're inside an act() scope\n              !(__DEV__ && flushSuspenseFallbacksInTests && IsThisRendererActing.current)) {\n                // If we have not processed any new updates during this pass, then\n                // this is either a retry of an existing fallback state or a\n                // hidden tree. Hidden trees shouldn't be batched with other work\n                // and after that's fixed it can only be a retry. We're going to\n                // throttle committing retries so that we don't show too many\n                // loading states too quickly.\n                let msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now(); // Don't bother with a very short suspense time.\n\n                if (msUntilTimeout > 10) {\n                  if (workInProgressRootHasPendingPing) {\n                    const lastPingedTime = root.lastPingedTime;\n\n                    if (lastPingedTime === NoWork || lastPingedTime >= expirationTime) {\n                      // This render was pinged but we didn't get to restart\n                      // earlier so try restarting now instead.\n                      root.lastPingedTime = expirationTime;\n                      prepareFreshStack(root, expirationTime);\n                      break;\n                    }\n                  }\n\n                  const nextTime = getNextRootExpirationTimeToWorkOn(root);\n\n                  if (nextTime !== NoWork && nextTime !== expirationTime) {\n                    // There's additional work on this root.\n                    break;\n                  }\n\n                  if (lastSuspendedTime !== NoWork && lastSuspendedTime !== expirationTime) {\n                    // We should prefer to render the fallback of at the last\n                    // suspended level. Ping the last suspended level to try\n                    // rendering it again.\n                    root.lastPingedTime = lastSuspendedTime;\n                    break;\n                  } // The render is suspended, it hasn't timed out, and there's no\n                  // lower priority work to do. Instead of committing the fallback\n                  // immediately, wait for more data to arrive.\n\n\n                  root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root), msUntilTimeout);\n                  break;\n                }\n              } // The work expired. Commit immediately.\n\n\n              commitRoot(root);\n              break;\n            }\n\n          case RootSuspendedWithDelay:\n            {\n              markRootSuspendedAtTime(root, expirationTime);\n              const lastSuspendedTime = root.lastSuspendedTime;\n\n              if (expirationTime === lastSuspendedTime) {\n                root.nextKnownPendingLevel = getRemainingExpirationTime(finishedWork);\n              }\n\n              flushSuspensePriorityWarningInDEV();\n\n              if ( // do not delay if we're inside an act() scope\n              !(__DEV__ && flushSuspenseFallbacksInTests && IsThisRendererActing.current)) {\n                // We're suspended in a state that should be avoided. We'll try to\n                // avoid committing it for as long as the timeouts let us.\n                if (workInProgressRootHasPendingPing) {\n                  const lastPingedTime = root.lastPingedTime;\n\n                  if (lastPingedTime === NoWork || lastPingedTime >= expirationTime) {\n                    // This render was pinged but we didn't get to restart earlier\n                    // so try restarting now instead.\n                    root.lastPingedTime = expirationTime;\n                    prepareFreshStack(root, expirationTime);\n                    break;\n                  }\n                }\n\n                const nextTime = getNextRootExpirationTimeToWorkOn(root);\n\n                if (nextTime !== NoWork && nextTime !== expirationTime) {\n                  // There's additional work on this root.\n                  break;\n                }\n\n                if (lastSuspendedTime !== NoWork && lastSuspendedTime !== expirationTime) {\n                  // We should prefer to render the fallback of at the last\n                  // suspended level. Ping the last suspended level to try\n                  // rendering it again.\n                  root.lastPingedTime = lastSuspendedTime;\n                  break;\n                }\n\n                let msUntilTimeout;\n\n                if (workInProgressRootLatestSuspenseTimeout !== Sync) {\n                  // We have processed a suspense config whose expiration time we\n                  // can use as the timeout.\n                  msUntilTimeout = expirationTimeToMs(workInProgressRootLatestSuspenseTimeout) - now();\n                } else if (workInProgressRootLatestProcessedExpirationTime === Sync) {\n                  // This should never normally happen because only new updates\n                  // cause delayed states, so we should have processed something.\n                  // However, this could also happen in an offscreen tree.\n                  msUntilTimeout = 0;\n                } else {\n                  // If we don't have a suspense config, we're going to use a\n                  // heuristic to determine how long we can suspend.\n                  const eventTimeMs = inferTimeFromExpirationTime(workInProgressRootLatestProcessedExpirationTime);\n                  const currentTimeMs = now();\n                  const timeUntilExpirationMs = expirationTimeToMs(expirationTime) - currentTimeMs;\n                  let timeElapsed = currentTimeMs - eventTimeMs;\n\n                  if (timeElapsed < 0) {\n                    // We get this wrong some time since we estimate the time.\n                    timeElapsed = 0;\n                  }\n\n                  msUntilTimeout = jnd(timeElapsed) - timeElapsed; // Clamp the timeout to the expiration time. TODO: Once the\n                  // event time is exact instead of inferred from expiration time\n                  // we don't need this.\n\n                  if (timeUntilExpirationMs < msUntilTimeout) {\n                    msUntilTimeout = timeUntilExpirationMs;\n                  }\n                } // Don't bother with a very short suspense time.\n\n\n                if (msUntilTimeout > 10) {\n                  // The render is suspended, it hasn't timed out, and there's no\n                  // lower priority work to do. Instead of committing the fallback\n                  // immediately, wait for more data to arrive.\n                  root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root), msUntilTimeout);\n                  break;\n                }\n              } // The work expired. Commit immediately.\n\n\n              commitRoot(root);\n              break;\n            }\n\n          case RootCompleted:\n            {\n              // The work completed. Ready to commit.\n              if ( // do not delay if we're inside an act() scope\n              !(__DEV__ && flushSuspenseFallbacksInTests && IsThisRendererActing.current) && workInProgressRootLatestProcessedExpirationTime !== Sync && workInProgressRootCanSuspendUsingConfig !== null) {\n                // If we have exceeded the minimum loading delay, which probably\n                // means we have shown a spinner already, we might have to suspend\n                // a bit longer to ensure that the spinner is shown for\n                // enough time.\n                const msUntilTimeout = computeMsUntilSuspenseLoadingDelay(workInProgressRootLatestProcessedExpirationTime, expirationTime, workInProgressRootCanSuspendUsingConfig);\n\n                if (msUntilTimeout > 10) {\n                  markRootSuspendedAtTime(root, expirationTime);\n                  root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root), msUntilTimeout);\n                  break;\n                }\n              }\n\n              commitRoot(root);\n              break;\n            }\n\n          case RootLocked:\n            {\n              // This root has a lock that prevents it from committing. Exit. If\n              // we begin work on the root again, without any intervening updates,\n              // it will finish without doing additional work.\n              markRootSuspendedAtTime(root, expirationTime);\n              break;\n            }\n\n          default:\n            {\n              invariant(false, 'Unknown root exit status.');\n            }\n        }\n      } // Before exiting, make sure there's a callback scheduled for the\n      // pending level. This is intentionally duplicated in the `catch` block,\n      // instead of using `finally`, because it needs to happen before we\n      // possibly return a continuation, and we can't return in the `finally`\n      // block without suppressing a potential error.\n\n\n      ensureRootIsScheduled(root);\n\n      if (root.callbackNode === originalCallbackNode) {\n        // The task node scheduled for this root is the same one that's\n        // currently executed. Need to return a continuation.\n        return performConcurrentWorkOnRoot.bind(null, root);\n      }\n    } catch (error) {\n      ensureRootIsScheduled(root);\n      throw error;\n    }\n  }\n\n  return null;\n} // This is the entry point for synchronous tasks that don't go\n// through Scheduler\n\n\nfunction performSyncWorkOnRoot(root) {\n  // Check if there's expired work on this root. Otherwise, render at Sync.\n  const lastExpiredTime = root.lastExpiredTime;\n  const expirationTime = lastExpiredTime !== NoWork ? lastExpiredTime : Sync;\n\n  try {\n    if (root.finishedExpirationTime === expirationTime) {\n      // There's already a pending commit at this expiration time.\n      // TODO: This is poorly factored. This case only exists for the\n      // batch.commit() API.\n      commitRoot(root);\n    } else {\n      renderRoot(root, expirationTime, true);\n      invariant(workInProgressRootExitStatus !== RootIncomplete, 'Cannot commit an incomplete root. This error is likely caused by a ' + 'bug in React. Please file an issue.'); // We now have a consistent tree. The next step is either to commit it,\n      // or, if something suspended, wait to commit it after a timeout.\n\n      stopFinishedWorkLoopTimer();\n      root.finishedWork = root.current.alternate;\n      root.finishedExpirationTime = expirationTime;\n      resolveLocksOnRoot(root, expirationTime);\n\n      if (workInProgressRootExitStatus === RootLocked) {\n        // This root has a lock that prevents it from committing. Exit. If we\n        // begin work on the root again, without any intervening updates, it\n        // will finish without doing additional work.\n        markRootSuspendedAtTime(root, expirationTime);\n      } else {\n        // Set this to null to indicate there's no in-progress render.\n        workInProgressRoot = null;\n\n        if (__DEV__) {\n          if (workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootSuspendedWithDelay) {\n            flushSuspensePriorityWarningInDEV();\n          }\n        }\n\n        commitRoot(root);\n      }\n    }\n  } finally {\n    // Before exiting, make sure there's a callback scheduled for the\n    // pending level.\n    ensureRootIsScheduled(root);\n  }\n\n  return null;\n}\n\nexport function flushRoot(root, expirationTime) {\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    invariant(false, 'work.commit(): Cannot commit while already rendering. This likely ' + 'means you attempted to commit from inside a lifecycle method.');\n  }\n\n  markRootExpiredAtTime(root, expirationTime);\n  ensureRootIsScheduled(root);\n  flushSyncCallbackQueue();\n}\nexport function flushDiscreteUpdates() {\n  // TODO: Should be able to flush inside batchedUpdates, but not inside `act`.\n  // However, `act` uses `batchedUpdates`, so there's no way to distinguish\n  // those two cases. Need to fix this before exposing flushDiscreteUpdates\n  // as a public API.\n  if ((executionContext & (BatchedContext | RenderContext | CommitContext)) !== NoContext) {\n    if (__DEV__ && (executionContext & RenderContext) !== NoContext) {\n      warning(false, 'unstable_flushDiscreteUpdates: Cannot flush updates when React is ' + 'already rendering.');\n    } // We're already rendering, so we can't synchronously flush pending work.\n    // This is probably a nested event dispatch triggered by a lifecycle/effect,\n    // like `el.focus()`. Exit.\n\n\n    return;\n  }\n\n  flushPendingDiscreteUpdates(); // If the discrete updates scheduled passive effects, flush them now so that\n  // they fire before the next serial event.\n\n  flushPassiveEffects();\n}\n\nfunction resolveLocksOnRoot(root, expirationTime) {\n  const firstBatch = root.firstBatch;\n\n  if (firstBatch !== null && firstBatch._defer && firstBatch._expirationTime >= expirationTime) {\n    scheduleCallback(NormalPriority, () => {\n      firstBatch._onComplete();\n\n      return null;\n    });\n    workInProgressRootExitStatus = RootLocked;\n  }\n}\n\nexport function deferredUpdates(fn) {\n  // TODO: Remove in favor of Scheduler.next\n  return runWithPriority(NormalPriority, fn);\n}\nexport function syncUpdates(fn, a, b, c) {\n  return runWithPriority(ImmediatePriority, fn.bind(null, a, b, c));\n}\n\nfunction flushPendingDiscreteUpdates() {\n  if (rootsWithPendingDiscreteUpdates !== null) {\n    // For each root with pending discrete updates, schedule a callback to\n    // immediately flush them.\n    const roots = rootsWithPendingDiscreteUpdates;\n    rootsWithPendingDiscreteUpdates = null;\n    roots.forEach((expirationTime, root) => {\n      markRootExpiredAtTime(root, expirationTime);\n      ensureRootIsScheduled(root);\n    }); // Now flush the immediate queue.\n\n    flushSyncCallbackQueue();\n  }\n}\n\nexport function batchedUpdates(fn, a) {\n  const prevExecutionContext = executionContext;\n  executionContext |= BatchedContext;\n\n  try {\n    return fn(a);\n  } finally {\n    executionContext = prevExecutionContext;\n\n    if (executionContext === NoContext) {\n      // Flush the immediate callbacks that were scheduled during this batch\n      flushSyncCallbackQueue();\n    }\n  }\n}\nexport function batchedEventUpdates(fn, a) {\n  const prevExecutionContext = executionContext;\n  executionContext |= EventContext;\n\n  try {\n    return fn(a);\n  } finally {\n    executionContext = prevExecutionContext;\n\n    if (executionContext === NoContext) {\n      // Flush the immediate callbacks that were scheduled during this batch\n      flushSyncCallbackQueue();\n    }\n  }\n}\nexport function discreteUpdates(fn, a, b, c) {\n  const prevExecutionContext = executionContext;\n  executionContext |= DiscreteEventContext;\n\n  try {\n    // Should this\n    return runWithPriority(UserBlockingPriority, fn.bind(null, a, b, c));\n  } finally {\n    executionContext = prevExecutionContext;\n\n    if (executionContext === NoContext) {\n      // Flush the immediate callbacks that were scheduled during this batch\n      flushSyncCallbackQueue();\n    }\n  }\n}\nexport function unbatchedUpdates(fn, a) {\n  const prevExecutionContext = executionContext;\n  executionContext &= ~BatchedContext;\n  executionContext |= LegacyUnbatchedContext;\n\n  try {\n    return fn(a);\n  } finally {\n    executionContext = prevExecutionContext;\n\n    if (executionContext === NoContext) {\n      // Flush the immediate callbacks that were scheduled during this batch\n      flushSyncCallbackQueue();\n    }\n  }\n}\nexport function flushSync(fn, a) {\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    invariant(false, 'flushSync was called from inside a lifecycle method. It cannot be ' + 'called when React is already rendering.');\n  }\n\n  const prevExecutionContext = executionContext;\n  executionContext |= BatchedContext;\n\n  try {\n    return runWithPriority(ImmediatePriority, fn.bind(null, a));\n  } finally {\n    executionContext = prevExecutionContext; // Flush the immediate callbacks that were scheduled during this batch.\n    // Note that this will happen even if batchedUpdates is higher up\n    // the stack.\n\n    flushSyncCallbackQueue();\n  }\n}\nexport function flushControlled(fn) {\n  const prevExecutionContext = executionContext;\n  executionContext |= BatchedContext;\n\n  try {\n    runWithPriority(ImmediatePriority, fn);\n  } finally {\n    executionContext = prevExecutionContext;\n\n    if (executionContext === NoContext) {\n      // Flush the immediate callbacks that were scheduled during this batch\n      flushSyncCallbackQueue();\n    }\n  }\n}\n\nfunction prepareFreshStack(root, expirationTime) {\n  root.finishedWork = null;\n  root.finishedExpirationTime = NoWork;\n  const timeoutHandle = root.timeoutHandle;\n\n  if (timeoutHandle !== noTimeout) {\n    // The root previous suspended and scheduled a timeout to commit a fallback\n    // state. Now that we have additional work, cancel the timeout.\n    root.timeoutHandle = noTimeout; // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\n\n    cancelTimeout(timeoutHandle);\n  }\n\n  if (workInProgress !== null) {\n    let interruptedWork = workInProgress.return;\n\n    while (interruptedWork !== null) {\n      unwindInterruptedWork(interruptedWork);\n      interruptedWork = interruptedWork.return;\n    }\n  }\n\n  workInProgressRoot = root;\n  workInProgress = createWorkInProgress(root.current, null, expirationTime);\n  renderExpirationTime = expirationTime;\n  workInProgressRootExitStatus = RootIncomplete;\n  workInProgressRootLatestProcessedExpirationTime = Sync;\n  workInProgressRootLatestSuspenseTimeout = Sync;\n  workInProgressRootCanSuspendUsingConfig = null;\n  workInProgressRootNextUnprocessedUpdateTime = NoWork;\n  workInProgressRootHasPendingPing = false;\n\n  if (enableSchedulerTracing) {\n    spawnedWorkDuringRender = null;\n  }\n\n  if (__DEV__) {\n    ReactStrictModeWarnings.discardPendingWarnings();\n    componentsThatTriggeredHighPriSuspend = null;\n  }\n} // renderRoot should only be called from inside either\n// `performConcurrentWorkOnRoot` or `performSyncWorkOnRoot`.\n\n\nfunction renderRoot(root, expirationTime, isSync) {\n  invariant((executionContext & (RenderContext | CommitContext)) === NoContext, 'Should not already be working.');\n  flushPassiveEffects(); // If the root or expiration time have changed, throw out the existing stack\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\n\n  if (root !== workInProgressRoot || expirationTime !== renderExpirationTime) {\n    prepareFreshStack(root, expirationTime);\n    startWorkOnPendingInteractions(root, expirationTime);\n  } // If we have a work-in-progress fiber, it means there's still work to do\n  // in this root.\n\n\n  if (workInProgress !== null) {\n    const prevExecutionContext = executionContext;\n    executionContext |= RenderContext;\n    let prevDispatcher = ReactCurrentDispatcher.current;\n\n    if (prevDispatcher === null) {\n      // The React isomorphic package does not include a default dispatcher.\n      // Instead the first renderer will lazily attach one, in order to give\n      // nicer error messages.\n      prevDispatcher = ContextOnlyDispatcher;\n    }\n\n    ReactCurrentDispatcher.current = ContextOnlyDispatcher;\n    let prevInteractions = null;\n\n    if (enableSchedulerTracing) {\n      prevInteractions = __interactionsRef.current;\n      __interactionsRef.current = root.memoizedInteractions;\n    }\n\n    startWorkLoopTimer(workInProgress);\n\n    do {\n      try {\n        // TODO: This is now the only place that `isSync` is used. Consider\n        // outlining the contents of `renderRoot`.\n        if (isSync) {\n          workLoopSync();\n        } else {\n          workLoop();\n        }\n\n        break;\n      } catch (thrownValue) {\n        // Reset module-level state that was set during the render phase.\n        resetContextDependencies();\n        resetHooks();\n        const sourceFiber = workInProgress;\n\n        if (sourceFiber === null || sourceFiber.return === null) {\n          // Expected to be working on a non-root fiber. This is a fatal error\n          // because there's no ancestor that can handle it; the root is\n          // supposed to capture all errors that weren't caught by an error\n          // boundary.\n          prepareFreshStack(root, expirationTime);\n          executionContext = prevExecutionContext;\n          markRootSuspendedAtTime(root, expirationTime);\n          throw thrownValue;\n        }\n\n        if (enableProfilerTimer && sourceFiber.mode & ProfileMode) {\n          // Record the time spent rendering before an error was thrown. This\n          // avoids inaccurate Profiler durations in the case of a\n          // suspended render.\n          stopProfilerTimerIfRunningAndRecordDelta(sourceFiber, true);\n        }\n\n        const returnFiber = sourceFiber.return;\n        throwException(root, returnFiber, sourceFiber, thrownValue, renderExpirationTime); // TODO: This is not wrapped in a try-catch, so if the complete phase\n        // throws, we won't capture it.\n\n        workInProgress = completeUnitOfWork(sourceFiber);\n      }\n    } while (true);\n\n    executionContext = prevExecutionContext;\n    resetContextDependencies();\n    ReactCurrentDispatcher.current = prevDispatcher;\n\n    if (enableSchedulerTracing) {\n      __interactionsRef.current = prevInteractions;\n    }\n  }\n}\n\nexport function markCommitTimeOfFallback() {\n  globalMostRecentFallbackTime = now();\n}\nexport function markRenderEventTimeAndConfig(expirationTime, suspenseConfig) {\n  if (expirationTime < workInProgressRootLatestProcessedExpirationTime && expirationTime > Never) {\n    workInProgressRootLatestProcessedExpirationTime = expirationTime;\n  }\n\n  if (suspenseConfig !== null) {\n    if (expirationTime < workInProgressRootLatestSuspenseTimeout && expirationTime > Never) {\n      workInProgressRootLatestSuspenseTimeout = expirationTime; // Most of the time we only have one config and getting wrong is not bad.\n\n      workInProgressRootCanSuspendUsingConfig = suspenseConfig;\n    }\n  }\n}\nexport function markUnprocessedUpdateTime(expirationTime) {\n  if (expirationTime > workInProgressRootNextUnprocessedUpdateTime) {\n    workInProgressRootNextUnprocessedUpdateTime = expirationTime;\n  }\n}\nexport function renderDidSuspend() {\n  if (workInProgressRootExitStatus === RootIncomplete) {\n    workInProgressRootExitStatus = RootSuspended;\n  }\n}\nexport function renderDidSuspendDelayIfPossible() {\n  if (workInProgressRootExitStatus === RootIncomplete || workInProgressRootExitStatus === RootSuspended) {\n    workInProgressRootExitStatus = RootSuspendedWithDelay;\n  } // Check if there's a lower priority update somewhere else in the tree.\n\n\n  if (workInProgressRootNextUnprocessedUpdateTime !== NoWork && workInProgressRoot !== null) {\n    // Mark the current render as suspended, and then mark that there's a\n    // pending update.\n    // TODO: This should immediately interrupt the current render, instead\n    // of waiting until the next time we yield.\n    markRootSuspendedAtTime(workInProgressRoot, renderExpirationTime);\n    markRootUpdatedAtTime(workInProgressRoot, workInProgressRootNextUnprocessedUpdateTime);\n  }\n}\nexport function renderDidError() {\n  if (workInProgressRootExitStatus !== RootCompleted) {\n    workInProgressRootExitStatus = RootErrored;\n  }\n} // Called during render to determine if anything has suspended.\n// Returns false if we're not sure.\n\nexport function renderHasNotSuspendedYet() {\n  // If something errored or completed, we can't really be sure,\n  // so those are false.\n  return workInProgressRootExitStatus === RootIncomplete;\n}\n\nfunction inferTimeFromExpirationTime(expirationTime) {\n  // We don't know exactly when the update was scheduled, but we can infer an\n  // approximate start time from the expiration time.\n  const earliestExpirationTimeMs = expirationTimeToMs(expirationTime);\n  return earliestExpirationTimeMs - LOW_PRIORITY_EXPIRATION;\n}\n\nfunction inferTimeFromExpirationTimeWithSuspenseConfig(expirationTime, suspenseConfig) {\n  // We don't know exactly when the update was scheduled, but we can infer an\n  // approximate start time from the expiration time by subtracting the timeout\n  // that was added to the event time.\n  const earliestExpirationTimeMs = expirationTimeToMs(expirationTime);\n  return earliestExpirationTimeMs - (suspenseConfig.timeoutMs | 0 || LOW_PRIORITY_EXPIRATION);\n}\n\nfunction workLoopSync() {\n  // Already timed out, so perform work without checking if we need to yield.\n  while (workInProgress !== null) {\n    workInProgress = performUnitOfWork(workInProgress);\n  }\n}\n\nfunction workLoop() {\n  // Perform work until Scheduler asks us to yield\n  while (workInProgress !== null && !shouldYield()) {\n    workInProgress = performUnitOfWork(workInProgress);\n  }\n}\n\nfunction performUnitOfWork(unitOfWork) {\n  // The current, flushed, state of this fiber is the alternate. Ideally\n  // nothing should rely on this, but relying on it here means that we don't\n  // need an additional field on the work in progress.\n  const current = unitOfWork.alternate;\n  startWorkTimer(unitOfWork);\n  setCurrentDebugFiberInDEV(unitOfWork);\n  let next;\n\n  if (enableProfilerTimer && (unitOfWork.mode & ProfileMode) !== NoMode) {\n    startProfilerTimer(unitOfWork);\n    next = beginWork(current, unitOfWork, renderExpirationTime);\n    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\n  } else {\n    next = beginWork(current, unitOfWork, renderExpirationTime);\n  }\n\n  resetCurrentDebugFiberInDEV();\n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\n\n  if (next === null) {\n    // If this doesn't spawn new work, complete the current work.\n    next = completeUnitOfWork(unitOfWork);\n  }\n\n  ReactCurrentOwner.current = null;\n  return next;\n}\n\nfunction completeUnitOfWork(unitOfWork) {\n  // Attempt to complete the current unit of work, then move to the next\n  // sibling. If there are no more siblings, return to the parent fiber.\n  workInProgress = unitOfWork;\n\n  do {\n    // The current, flushed, state of this fiber is the alternate. Ideally\n    // nothing should rely on this, but relying on it here means that we don't\n    // need an additional field on the work in progress.\n    const current = workInProgress.alternate;\n    const returnFiber = workInProgress.return; // Check if the work completed or if something threw.\n\n    if ((workInProgress.effectTag & Incomplete) === NoEffect) {\n      setCurrentDebugFiberInDEV(workInProgress);\n      let next;\n\n      if (!enableProfilerTimer || (workInProgress.mode & ProfileMode) === NoMode) {\n        next = completeWork(current, workInProgress, renderExpirationTime);\n      } else {\n        startProfilerTimer(workInProgress);\n        next = completeWork(current, workInProgress, renderExpirationTime); // Update render duration assuming we didn't error.\n\n        stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false);\n      }\n\n      stopWorkTimer(workInProgress);\n      resetCurrentDebugFiberInDEV();\n      resetChildExpirationTime(workInProgress);\n\n      if (next !== null) {\n        // Completing this fiber spawned new work. Work on that next.\n        return next;\n      }\n\n      if (returnFiber !== null && // Do not append effects to parents if a sibling failed to complete\n      (returnFiber.effectTag & Incomplete) === NoEffect) {\n        // Append all the effects of the subtree and this fiber onto the effect\n        // list of the parent. The completion order of the children affects the\n        // side-effect order.\n        if (returnFiber.firstEffect === null) {\n          returnFiber.firstEffect = workInProgress.firstEffect;\n        }\n\n        if (workInProgress.lastEffect !== null) {\n          if (returnFiber.lastEffect !== null) {\n            returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;\n          }\n\n          returnFiber.lastEffect = workInProgress.lastEffect;\n        } // If this fiber had side-effects, we append it AFTER the children's\n        // side-effects. We can perform certain side-effects earlier if needed,\n        // by doing multiple passes over the effect list. We don't want to\n        // schedule our own side-effect on our own list because if end up\n        // reusing children we'll schedule this effect onto itself since we're\n        // at the end.\n\n\n        const effectTag = workInProgress.effectTag; // Skip both NoWork and PerformedWork tags when creating the effect\n        // list. PerformedWork effect is read by React DevTools but shouldn't be\n        // committed.\n\n        if (effectTag > PerformedWork) {\n          if (returnFiber.lastEffect !== null) {\n            returnFiber.lastEffect.nextEffect = workInProgress;\n          } else {\n            returnFiber.firstEffect = workInProgress;\n          }\n\n          returnFiber.lastEffect = workInProgress;\n        }\n      }\n    } else {\n      // This fiber did not complete because something threw. Pop values off\n      // the stack without entering the complete phase. If this is a boundary,\n      // capture values if possible.\n      const next = unwindWork(workInProgress, renderExpirationTime); // Because this fiber did not complete, don't reset its expiration time.\n\n      if (enableProfilerTimer && (workInProgress.mode & ProfileMode) !== NoMode) {\n        // Record the render duration for the fiber that errored.\n        stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false); // Include the time spent working on failed children before continuing.\n\n        let actualDuration = workInProgress.actualDuration;\n        let child = workInProgress.child;\n\n        while (child !== null) {\n          actualDuration += child.actualDuration;\n          child = child.sibling;\n        }\n\n        workInProgress.actualDuration = actualDuration;\n      }\n\n      if (next !== null) {\n        // If completing this work spawned new work, do that next. We'll come\n        // back here again.\n        // Since we're restarting, remove anything that is not a host effect\n        // from the effect tag.\n        // TODO: The name stopFailedWorkTimer is misleading because Suspense\n        // also captures and restarts.\n        stopFailedWorkTimer(workInProgress);\n        next.effectTag &= HostEffectMask;\n        return next;\n      }\n\n      stopWorkTimer(workInProgress);\n\n      if (returnFiber !== null) {\n        // Mark the parent fiber as incomplete and clear its effect list.\n        returnFiber.firstEffect = returnFiber.lastEffect = null;\n        returnFiber.effectTag |= Incomplete;\n      }\n    }\n\n    const siblingFiber = workInProgress.sibling;\n\n    if (siblingFiber !== null) {\n      // If there is more work to do in this returnFiber, do that next.\n      return siblingFiber;\n    } // Otherwise, return to the parent\n\n\n    workInProgress = returnFiber;\n  } while (workInProgress !== null); // We've reached the root.\n\n\n  if (workInProgressRootExitStatus === RootIncomplete) {\n    workInProgressRootExitStatus = RootCompleted;\n  }\n\n  return null;\n}\n\nfunction getRemainingExpirationTime(fiber) {\n  const updateExpirationTime = fiber.expirationTime;\n  const childExpirationTime = fiber.childExpirationTime;\n  return updateExpirationTime > childExpirationTime ? updateExpirationTime : childExpirationTime;\n}\n\nfunction resetChildExpirationTime(completedWork) {\n  if (renderExpirationTime !== Never && completedWork.childExpirationTime === Never) {\n    // The children of this component are hidden. Don't bubble their\n    // expiration times.\n    return;\n  }\n\n  let newChildExpirationTime = NoWork; // Bubble up the earliest expiration time.\n\n  if (enableProfilerTimer && (completedWork.mode & ProfileMode) !== NoMode) {\n    // In profiling mode, resetChildExpirationTime is also used to reset\n    // profiler durations.\n    let actualDuration = completedWork.actualDuration;\n    let treeBaseDuration = completedWork.selfBaseDuration; // When a fiber is cloned, its actualDuration is reset to 0. This value will\n    // only be updated if work is done on the fiber (i.e. it doesn't bailout).\n    // When work is done, it should bubble to the parent's actualDuration. If\n    // the fiber has not been cloned though, (meaning no work was done), then\n    // this value will reflect the amount of time spent working on a previous\n    // render. In that case it should not bubble. We determine whether it was\n    // cloned by comparing the child pointer.\n\n    const shouldBubbleActualDurations = completedWork.alternate === null || completedWork.child !== completedWork.alternate.child;\n    let child = completedWork.child;\n\n    while (child !== null) {\n      const childUpdateExpirationTime = child.expirationTime;\n      const childChildExpirationTime = child.childExpirationTime;\n\n      if (childUpdateExpirationTime > newChildExpirationTime) {\n        newChildExpirationTime = childUpdateExpirationTime;\n      }\n\n      if (childChildExpirationTime > newChildExpirationTime) {\n        newChildExpirationTime = childChildExpirationTime;\n      }\n\n      if (shouldBubbleActualDurations) {\n        actualDuration += child.actualDuration;\n      }\n\n      treeBaseDuration += child.treeBaseDuration;\n      child = child.sibling;\n    }\n\n    completedWork.actualDuration = actualDuration;\n    completedWork.treeBaseDuration = treeBaseDuration;\n  } else {\n    let child = completedWork.child;\n\n    while (child !== null) {\n      const childUpdateExpirationTime = child.expirationTime;\n      const childChildExpirationTime = child.childExpirationTime;\n\n      if (childUpdateExpirationTime > newChildExpirationTime) {\n        newChildExpirationTime = childUpdateExpirationTime;\n      }\n\n      if (childChildExpirationTime > newChildExpirationTime) {\n        newChildExpirationTime = childChildExpirationTime;\n      }\n\n      child = child.sibling;\n    }\n  }\n\n  completedWork.childExpirationTime = newChildExpirationTime;\n}\n\nfunction commitRoot(root) {\n  const renderPriorityLevel = getCurrentPriorityLevel();\n  runWithPriority(ImmediatePriority, commitRootImpl.bind(null, root, renderPriorityLevel));\n  return null;\n}\n\nfunction commitRootImpl(root, renderPriorityLevel) {\n  flushPassiveEffects();\n  flushRenderPhaseStrictModeWarningsInDEV();\n  invariant((executionContext & (RenderContext | CommitContext)) === NoContext, 'Should not already be working.');\n  const finishedWork = root.finishedWork;\n  const expirationTime = root.finishedExpirationTime;\n\n  if (finishedWork === null) {\n    return null;\n  }\n\n  root.finishedWork = null;\n  root.finishedExpirationTime = NoWork;\n  invariant(finishedWork !== root.current, 'Cannot commit the same tree as before. This error is likely caused by ' + 'a bug in React. Please file an issue.'); // commitRoot never returns a continuation; it always finishes synchronously.\n  // So we can clear these now to allow a new callback to be scheduled.\n\n  root.callbackNode = null;\n  root.callbackExpirationTime = NoWork;\n  root.callbackPriority = NoPriority;\n  root.nextKnownPendingLevel = NoWork;\n  startCommitTimer(); // Update the first and last pending times on this root. The new first\n  // pending time is whatever is left on the root fiber.\n\n  const remainingExpirationTimeBeforeCommit = getRemainingExpirationTime(finishedWork);\n  markRootFinishedAtTime(root, expirationTime, remainingExpirationTimeBeforeCommit);\n\n  if (root === workInProgressRoot) {\n    // We can reset these now that they are finished.\n    workInProgressRoot = null;\n    workInProgress = null;\n    renderExpirationTime = NoWork;\n  } else {} // This indicates that the last root we worked on is not the same one that\n  // we're committing now. This most commonly happens when a suspended root\n  // times out.\n  // Get the list of effects.\n\n\n  let firstEffect;\n\n  if (finishedWork.effectTag > PerformedWork) {\n    // A fiber's effect list consists only of its children, not itself. So if\n    // the root has an effect, we need to add it to the end of the list. The\n    // resulting list is the set that would belong to the root's parent, if it\n    // had one; that is, all the effects in the tree including the root.\n    if (finishedWork.lastEffect !== null) {\n      finishedWork.lastEffect.nextEffect = finishedWork;\n      firstEffect = finishedWork.firstEffect;\n    } else {\n      firstEffect = finishedWork;\n    }\n  } else {\n    // There is no effect on the root.\n    firstEffect = finishedWork.firstEffect;\n  }\n\n  if (firstEffect !== null) {\n    const prevExecutionContext = executionContext;\n    executionContext |= CommitContext;\n    let prevInteractions = null;\n\n    if (enableSchedulerTracing) {\n      prevInteractions = __interactionsRef.current;\n      __interactionsRef.current = root.memoizedInteractions;\n    } // Reset this to null before calling lifecycles\n\n\n    ReactCurrentOwner.current = null; // The commit phase is broken into several sub-phases. We do a separate pass\n    // of the effect list for each phase: all mutation effects come before all\n    // layout effects, and so on.\n    // The first phase a \"before mutation\" phase. We use this phase to read the\n    // state of the host tree right before we mutate it. This is where\n    // getSnapshotBeforeUpdate is called.\n\n    startCommitSnapshotEffectsTimer();\n    prepareForCommit(root.containerInfo);\n    nextEffect = firstEffect;\n\n    do {\n      if (__DEV__) {\n        invokeGuardedCallback(null, commitBeforeMutationEffects, null);\n\n        if (hasCaughtError()) {\n          invariant(nextEffect !== null, 'Should be working on an effect.');\n          const error = clearCaughtError();\n          captureCommitPhaseError(nextEffect, error);\n          nextEffect = nextEffect.nextEffect;\n        }\n      } else {\n        try {\n          commitBeforeMutationEffects();\n        } catch (error) {\n          invariant(nextEffect !== null, 'Should be working on an effect.');\n          captureCommitPhaseError(nextEffect, error);\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    } while (nextEffect !== null);\n\n    stopCommitSnapshotEffectsTimer();\n\n    if (enableProfilerTimer) {\n      // Mark the current commit time to be shared by all Profilers in this\n      // batch. This enables them to be grouped later.\n      recordCommitTime();\n    } // The next phase is the mutation phase, where we mutate the host tree.\n\n\n    startCommitHostEffectsTimer();\n    nextEffect = firstEffect;\n\n    do {\n      if (__DEV__) {\n        invokeGuardedCallback(null, commitMutationEffects, null, root, renderPriorityLevel);\n\n        if (hasCaughtError()) {\n          invariant(nextEffect !== null, 'Should be working on an effect.');\n          const error = clearCaughtError();\n          captureCommitPhaseError(nextEffect, error);\n          nextEffect = nextEffect.nextEffect;\n        }\n      } else {\n        try {\n          commitMutationEffects(root, renderPriorityLevel);\n        } catch (error) {\n          invariant(nextEffect !== null, 'Should be working on an effect.');\n          captureCommitPhaseError(nextEffect, error);\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    } while (nextEffect !== null);\n\n    stopCommitHostEffectsTimer();\n    resetAfterCommit(root.containerInfo); // The work-in-progress tree is now the current tree. This must come after\n    // the mutation phase, so that the previous tree is still current during\n    // componentWillUnmount, but before the layout phase, so that the finished\n    // work is current during componentDidMount/Update.\n\n    root.current = finishedWork; // The next phase is the layout phase, where we call effects that read\n    // the host tree after it's been mutated. The idiomatic use case for this is\n    // layout, but class component lifecycles also fire here for legacy reasons.\n\n    startCommitLifeCyclesTimer();\n    nextEffect = firstEffect;\n\n    do {\n      if (__DEV__) {\n        invokeGuardedCallback(null, commitLayoutEffects, null, root, expirationTime);\n\n        if (hasCaughtError()) {\n          invariant(nextEffect !== null, 'Should be working on an effect.');\n          const error = clearCaughtError();\n          captureCommitPhaseError(nextEffect, error);\n          nextEffect = nextEffect.nextEffect;\n        }\n      } else {\n        try {\n          commitLayoutEffects(root, expirationTime);\n        } catch (error) {\n          invariant(nextEffect !== null, 'Should be working on an effect.');\n          captureCommitPhaseError(nextEffect, error);\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    } while (nextEffect !== null);\n\n    stopCommitLifeCyclesTimer();\n    nextEffect = null; // Tell Scheduler to yield at the end of the frame, so the browser has an\n    // opportunity to paint.\n\n    requestPaint();\n\n    if (enableSchedulerTracing) {\n      __interactionsRef.current = prevInteractions;\n    }\n\n    executionContext = prevExecutionContext;\n  } else {\n    // No effects.\n    root.current = finishedWork; // Measure these anyway so the flamegraph explicitly shows that there were\n    // no effects.\n    // TODO: Maybe there's a better way to report this.\n\n    startCommitSnapshotEffectsTimer();\n    stopCommitSnapshotEffectsTimer();\n\n    if (enableProfilerTimer) {\n      recordCommitTime();\n    }\n\n    startCommitHostEffectsTimer();\n    stopCommitHostEffectsTimer();\n    startCommitLifeCyclesTimer();\n    stopCommitLifeCyclesTimer();\n  }\n\n  stopCommitTimer();\n  const rootDidHavePassiveEffects = rootDoesHavePassiveEffects;\n\n  if (rootDoesHavePassiveEffects) {\n    // This commit has passive effects. Stash a reference to them. But don't\n    // schedule a callback until after flushing layout work.\n    rootDoesHavePassiveEffects = false;\n    rootWithPendingPassiveEffects = root;\n    pendingPassiveEffectsExpirationTime = expirationTime;\n    pendingPassiveEffectsRenderPriority = renderPriorityLevel;\n  } else {\n    // We are done with the effect chain at this point so let's clear the\n    // nextEffect pointers to assist with GC. If we have passive effects, we'll\n    // clear this in flushPassiveEffects.\n    nextEffect = firstEffect;\n\n    while (nextEffect !== null) {\n      const nextNextEffect = nextEffect.nextEffect;\n      nextEffect.nextEffect = null;\n      nextEffect = nextNextEffect;\n    }\n  } // Check if there's remaining work on this root\n\n\n  const remainingExpirationTime = root.firstPendingTime;\n\n  if (remainingExpirationTime !== NoWork) {\n    if (enableSchedulerTracing) {\n      if (spawnedWorkDuringRender !== null) {\n        const expirationTimes = spawnedWorkDuringRender;\n        spawnedWorkDuringRender = null;\n\n        for (let i = 0; i < expirationTimes.length; i++) {\n          scheduleInteractions(root, expirationTimes[i], root.memoizedInteractions);\n        }\n      }\n\n      schedulePendingInteractions(root, remainingExpirationTime);\n    }\n  } else {\n    // If there's no remaining work, we can clear the set of already failed\n    // error boundaries.\n    legacyErrorBoundariesThatAlreadyFailed = null;\n  }\n\n  if (enableSchedulerTracing) {\n    if (!rootDidHavePassiveEffects) {\n      // If there are no passive effects, then we can complete the pending interactions.\n      // Otherwise, we'll wait until after the passive effects are flushed.\n      // Wait to do this until after remaining work has been scheduled,\n      // so that we don't prematurely signal complete for interactions when there's e.g. hidden work.\n      finishPendingInteractions(root, expirationTime);\n    }\n  }\n\n  if (remainingExpirationTime === Sync) {\n    // Count the number of times the root synchronously re-renders without\n    // finishing. If there are too many, it indicates an infinite update loop.\n    if (root === rootWithNestedUpdates) {\n      nestedUpdateCount++;\n    } else {\n      nestedUpdateCount = 0;\n      rootWithNestedUpdates = root;\n    }\n  } else {\n    nestedUpdateCount = 0;\n  }\n\n  onCommitRoot(finishedWork.stateNode, expirationTime); // Always call this before exiting `commitRoot`, to ensure that any\n  // additional work on this root is scheduled.\n\n  ensureRootIsScheduled(root);\n\n  if (hasUncaughtError) {\n    hasUncaughtError = false;\n    const error = firstUncaughtError;\n    firstUncaughtError = null;\n    throw error;\n  }\n\n  if ((executionContext & LegacyUnbatchedContext) !== NoContext) {\n    // This is a legacy edge case. We just committed the initial mount of\n    // a ReactDOM.render-ed root inside of batchedUpdates. The commit fired\n    // synchronously, but layout updates should be deferred until the end\n    // of the batch.\n    return null;\n  } // If layout work was scheduled, flush it now.\n\n\n  flushSyncCallbackQueue();\n  return null;\n}\n\nfunction commitBeforeMutationEffects() {\n  while (nextEffect !== null) {\n    const effectTag = nextEffect.effectTag;\n\n    if ((effectTag & Snapshot) !== NoEffect) {\n      setCurrentDebugFiberInDEV(nextEffect);\n      recordEffect();\n      const current = nextEffect.alternate;\n      commitBeforeMutationEffectOnFiber(current, nextEffect);\n      resetCurrentDebugFiberInDEV();\n    }\n\n    if ((effectTag & Passive) !== NoEffect) {\n      // If there are passive effects, schedule a callback to flush at\n      // the earliest opportunity.\n      if (!rootDoesHavePassiveEffects) {\n        rootDoesHavePassiveEffects = true;\n        scheduleCallback(NormalPriority, () => {\n          flushPassiveEffects();\n          return null;\n        });\n      }\n    }\n\n    nextEffect = nextEffect.nextEffect;\n  }\n}\n\nfunction commitMutationEffects(root, renderPriorityLevel) {\n  // TODO: Should probably move the bulk of this function to commitWork.\n  while (nextEffect !== null) {\n    setCurrentDebugFiberInDEV(nextEffect);\n    const effectTag = nextEffect.effectTag;\n\n    if (effectTag & ContentReset) {\n      commitResetTextContent(nextEffect);\n    }\n\n    if (effectTag & Ref) {\n      const current = nextEffect.alternate;\n\n      if (current !== null) {\n        commitDetachRef(current);\n      }\n    } // The following switch statement is only concerned about placement,\n    // updates, and deletions. To avoid needing to add a case for every possible\n    // bitmap value, we remove the secondary effects from the effect tag and\n    // switch on that value.\n\n\n    let primaryEffectTag = effectTag & (Placement | Update | Deletion | Hydrating);\n\n    switch (primaryEffectTag) {\n      case Placement:\n        {\n          commitPlacement(nextEffect); // Clear the \"placement\" from effect tag so that we know that this is\n          // inserted, before any life-cycles like componentDidMount gets called.\n          // TODO: findDOMNode doesn't rely on this any more but isMounted does\n          // and isMounted is deprecated anyway so we should be able to kill this.\n\n          nextEffect.effectTag &= ~Placement;\n          break;\n        }\n\n      case PlacementAndUpdate:\n        {\n          // Placement\n          commitPlacement(nextEffect); // Clear the \"placement\" from effect tag so that we know that this is\n          // inserted, before any life-cycles like componentDidMount gets called.\n\n          nextEffect.effectTag &= ~Placement; // Update\n\n          const current = nextEffect.alternate;\n          commitWork(current, nextEffect);\n          break;\n        }\n\n      case Hydrating:\n        {\n          nextEffect.effectTag &= ~Hydrating;\n          break;\n        }\n\n      case HydratingAndUpdate:\n        {\n          nextEffect.effectTag &= ~Hydrating; // Update\n\n          const current = nextEffect.alternate;\n          commitWork(current, nextEffect);\n          break;\n        }\n\n      case Update:\n        {\n          const current = nextEffect.alternate;\n          commitWork(current, nextEffect);\n          break;\n        }\n\n      case Deletion:\n        {\n          commitDeletion(root, nextEffect, renderPriorityLevel);\n          break;\n        }\n    } // TODO: Only record a mutation effect if primaryEffectTag is non-zero.\n\n\n    recordEffect();\n    resetCurrentDebugFiberInDEV();\n    nextEffect = nextEffect.nextEffect;\n  }\n}\n\nfunction commitLayoutEffects(root, committedExpirationTime) {\n  // TODO: Should probably move the bulk of this function to commitWork.\n  while (nextEffect !== null) {\n    setCurrentDebugFiberInDEV(nextEffect);\n    const effectTag = nextEffect.effectTag;\n\n    if (effectTag & (Update | Callback)) {\n      recordEffect();\n      const current = nextEffect.alternate;\n      commitLayoutEffectOnFiber(root, current, nextEffect, committedExpirationTime);\n    }\n\n    if (effectTag & Ref) {\n      recordEffect();\n      commitAttachRef(nextEffect);\n    }\n\n    resetCurrentDebugFiberInDEV();\n    nextEffect = nextEffect.nextEffect;\n  }\n}\n\nexport function flushPassiveEffects() {\n  if (rootWithPendingPassiveEffects === null) {\n    return false;\n  }\n\n  const root = rootWithPendingPassiveEffects;\n  const expirationTime = pendingPassiveEffectsExpirationTime;\n  const renderPriorityLevel = pendingPassiveEffectsRenderPriority;\n  rootWithPendingPassiveEffects = null;\n  pendingPassiveEffectsExpirationTime = NoWork;\n  pendingPassiveEffectsRenderPriority = NoPriority;\n  const priorityLevel = renderPriorityLevel > NormalPriority ? NormalPriority : renderPriorityLevel;\n  return runWithPriority(priorityLevel, flushPassiveEffectsImpl.bind(null, root, expirationTime));\n}\n\nfunction flushPassiveEffectsImpl(root, expirationTime) {\n  let prevInteractions = null;\n\n  if (enableSchedulerTracing) {\n    prevInteractions = __interactionsRef.current;\n    __interactionsRef.current = root.memoizedInteractions;\n  }\n\n  invariant((executionContext & (RenderContext | CommitContext)) === NoContext, 'Cannot flush passive effects while already rendering.');\n  const prevExecutionContext = executionContext;\n  executionContext |= CommitContext; // Note: This currently assumes there are no passive effects on the root\n  // fiber, because the root is not part of its own effect list. This could\n  // change in the future.\n\n  let effect = root.current.firstEffect;\n\n  while (effect !== null) {\n    if (__DEV__) {\n      setCurrentDebugFiberInDEV(effect);\n      invokeGuardedCallback(null, commitPassiveHookEffects, null, effect);\n\n      if (hasCaughtError()) {\n        invariant(effect !== null, 'Should be working on an effect.');\n        const error = clearCaughtError();\n        captureCommitPhaseError(effect, error);\n      }\n\n      resetCurrentDebugFiberInDEV();\n    } else {\n      try {\n        commitPassiveHookEffects(effect);\n      } catch (error) {\n        invariant(effect !== null, 'Should be working on an effect.');\n        captureCommitPhaseError(effect, error);\n      }\n    }\n\n    const nextNextEffect = effect.nextEffect; // Remove nextEffect pointer to assist GC\n\n    effect.nextEffect = null;\n    effect = nextNextEffect;\n  }\n\n  if (enableSchedulerTracing) {\n    __interactionsRef.current = prevInteractions;\n    finishPendingInteractions(root, expirationTime);\n  }\n\n  executionContext = prevExecutionContext;\n  flushSyncCallbackQueue(); // If additional passive effects were scheduled, increment a counter. If this\n  // exceeds the limit, we'll fire a warning.\n\n  nestedPassiveUpdateCount = rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1;\n  return true;\n}\n\nexport function isAlreadyFailedLegacyErrorBoundary(instance) {\n  return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);\n}\nexport function markLegacyErrorBoundaryAsFailed(instance) {\n  if (legacyErrorBoundariesThatAlreadyFailed === null) {\n    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);\n  } else {\n    legacyErrorBoundariesThatAlreadyFailed.add(instance);\n  }\n}\n\nfunction prepareToThrowUncaughtError(error) {\n  if (!hasUncaughtError) {\n    hasUncaughtError = true;\n    firstUncaughtError = error;\n  }\n}\n\nexport const onUncaughtError = prepareToThrowUncaughtError;\n\nfunction captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {\n  const errorInfo = createCapturedValue(error, sourceFiber);\n  const update = createRootErrorUpdate(rootFiber, errorInfo, Sync);\n  enqueueUpdate(rootFiber, update);\n  const root = markUpdateTimeFromFiberToRoot(rootFiber, Sync);\n\n  if (root !== null) {\n    ensureRootIsScheduled(root);\n    schedulePendingInteractions(root, Sync);\n  }\n}\n\nexport function captureCommitPhaseError(sourceFiber, error) {\n  if (sourceFiber.tag === HostRoot) {\n    // Error was thrown at the root. There is no parent, so the root\n    // itself should capture it.\n    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);\n    return;\n  }\n\n  let fiber = sourceFiber.return;\n\n  while (fiber !== null) {\n    if (fiber.tag === HostRoot) {\n      captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error);\n      return;\n    } else if (fiber.tag === ClassComponent) {\n      const ctor = fiber.type;\n      const instance = fiber.stateNode;\n\n      if (typeof ctor.getDerivedStateFromError === 'function' || typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance)) {\n        const errorInfo = createCapturedValue(error, sourceFiber);\n        const update = createClassErrorUpdate(fiber, errorInfo, // TODO: This is always sync\n        Sync);\n        enqueueUpdate(fiber, update);\n        const root = markUpdateTimeFromFiberToRoot(fiber, Sync);\n\n        if (root !== null) {\n          ensureRootIsScheduled(root);\n          schedulePendingInteractions(root, Sync);\n        }\n\n        return;\n      }\n    }\n\n    fiber = fiber.return;\n  }\n}\nexport function pingSuspendedRoot(root, thenable, suspendedTime) {\n  const pingCache = root.pingCache;\n\n  if (pingCache !== null) {\n    // The thenable resolved, so we no longer need to memoize, because it will\n    // never be thrown again.\n    pingCache.delete(thenable);\n  }\n\n  if (workInProgressRoot === root && renderExpirationTime === suspendedTime) {\n    // Received a ping at the same priority level at which we're currently\n    // rendering. We might want to restart this render. This should mirror\n    // the logic of whether or not a root suspends once it completes.\n    // TODO: If we're rendering sync either due to Sync, Batched or expired,\n    // we should probably never restart.\n    // If we're suspended with delay, we'll always suspend so we can always\n    // restart. If we're suspended without any updates, it might be a retry.\n    // If it's early in the retry we can restart. We can't know for sure\n    // whether we'll eventually process an update during this render pass,\n    // but it's somewhat unlikely that we get to a ping before that, since\n    // getting to the root most update is usually very fast.\n    if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && workInProgressRootLatestProcessedExpirationTime === Sync && now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {\n      // Restart from the root. Don't need to schedule a ping because\n      // we're already working on this tree.\n      prepareFreshStack(root, renderExpirationTime);\n    } else {\n      // Even though we can't restart right now, we might get an\n      // opportunity later. So we mark this render as having a ping.\n      workInProgressRootHasPendingPing = true;\n    }\n\n    return;\n  }\n\n  if (!isRootSuspendedAtTime(root, suspendedTime)) {\n    // The root is no longer suspended at this time.\n    return;\n  }\n\n  const lastPingedTime = root.lastPingedTime;\n\n  if (lastPingedTime !== NoWork && lastPingedTime < suspendedTime) {\n    // There's already a lower priority ping scheduled.\n    return;\n  } // Mark the time at which this ping was scheduled.\n\n\n  root.lastPingedTime = suspendedTime;\n\n  if (root.finishedExpirationTime === suspendedTime) {\n    // If there's a pending fallback waiting to commit, throw it away.\n    root.finishedExpirationTime = NoWork;\n    root.finishedWork = null;\n  }\n\n  ensureRootIsScheduled(root);\n  schedulePendingInteractions(root, suspendedTime);\n}\n\nfunction retryTimedOutBoundary(boundaryFiber, retryTime) {\n  // The boundary fiber (a Suspense component or SuspenseList component)\n  // previously was rendered in its fallback state. One of the promises that\n  // suspended it has resolved, which means at least part of the tree was\n  // likely unblocked. Try rendering again, at a new expiration time.\n  if (retryTime === Never) {\n    const suspenseConfig = null; // Retries don't carry over the already committed update.\n\n    const currentTime = requestCurrentTime();\n    retryTime = computeExpirationForFiber(currentTime, boundaryFiber, suspenseConfig);\n  } // TODO: Special case idle priority?\n\n\n  const root = markUpdateTimeFromFiberToRoot(boundaryFiber, retryTime);\n\n  if (root !== null) {\n    ensureRootIsScheduled(root);\n    schedulePendingInteractions(root, retryTime);\n  }\n}\n\nexport function retryDehydratedSuspenseBoundary(boundaryFiber) {\n  const suspenseState = boundaryFiber.memoizedState;\n  let retryTime = Never;\n\n  if (suspenseState !== null) {\n    retryTime = suspenseState.retryTime;\n  }\n\n  retryTimedOutBoundary(boundaryFiber, retryTime);\n}\nexport function resolveRetryThenable(boundaryFiber, thenable) {\n  let retryTime = Never; // Default\n\n  let retryCache;\n\n  if (enableSuspenseServerRenderer) {\n    switch (boundaryFiber.tag) {\n      case SuspenseComponent:\n        retryCache = boundaryFiber.stateNode;\n        const suspenseState = boundaryFiber.memoizedState;\n\n        if (suspenseState !== null) {\n          retryTime = suspenseState.retryTime;\n        }\n\n        break;\n\n      case SuspenseListComponent:\n        retryCache = boundaryFiber.stateNode;\n        break;\n\n      default:\n        invariant(false, 'Pinged unknown suspense boundary type. ' + 'This is probably a bug in React.');\n    }\n  } else {\n    retryCache = boundaryFiber.stateNode;\n  }\n\n  if (retryCache !== null) {\n    // The thenable resolved, so we no longer need to memoize, because it will\n    // never be thrown again.\n    retryCache.delete(thenable);\n  }\n\n  retryTimedOutBoundary(boundaryFiber, retryTime);\n} // Computes the next Just Noticeable Difference (JND) boundary.\n// The theory is that a person can't tell the difference between small differences in time.\n// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable\n// difference in the experience. However, waiting for longer might mean that we can avoid\n// showing an intermediate loading state. The longer we have already waited, the harder it\n// is to tell small differences in time. Therefore, the longer we've already waited,\n// the longer we can wait additionally. At some point we have to give up though.\n// We pick a train model where the next boundary commits at a consistent schedule.\n// These particular numbers are vague estimates. We expect to adjust them based on research.\n\nfunction jnd(timeElapsed) {\n  return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3000 ? 3000 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;\n}\n\nfunction computeMsUntilSuspenseLoadingDelay(mostRecentEventTime, committedExpirationTime, suspenseConfig) {\n  const busyMinDurationMs = suspenseConfig.busyMinDurationMs | 0;\n\n  if (busyMinDurationMs <= 0) {\n    return 0;\n  }\n\n  const busyDelayMs = suspenseConfig.busyDelayMs | 0; // Compute the time until this render pass would expire.\n\n  const currentTimeMs = now();\n  const eventTimeMs = inferTimeFromExpirationTimeWithSuspenseConfig(mostRecentEventTime, suspenseConfig);\n  const timeElapsed = currentTimeMs - eventTimeMs;\n\n  if (timeElapsed <= busyDelayMs) {\n    // If we haven't yet waited longer than the initial delay, we don't\n    // have to wait any additional time.\n    return 0;\n  }\n\n  const msUntilTimeout = busyDelayMs + busyMinDurationMs - timeElapsed; // This is the value that is passed to `setTimeout`.\n\n  return msUntilTimeout;\n}\n\nfunction checkForNestedUpdates() {\n  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n    nestedUpdateCount = 0;\n    rootWithNestedUpdates = null;\n    invariant(false, 'Maximum update depth exceeded. This can happen when a component ' + 'repeatedly calls setState inside componentWillUpdate or ' + 'componentDidUpdate. React limits the number of nested updates to ' + 'prevent infinite loops.');\n  }\n\n  if (__DEV__) {\n    if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {\n      nestedPassiveUpdateCount = 0;\n      warning(false, 'Maximum update depth exceeded. This can happen when a component ' + \"calls setState inside useEffect, but useEffect either doesn't \" + 'have a dependency array, or one of the dependencies changes on ' + 'every render.');\n    }\n  }\n}\n\nfunction flushRenderPhaseStrictModeWarningsInDEV() {\n  if (__DEV__) {\n    ReactStrictModeWarnings.flushLegacyContextWarning();\n\n    if (warnAboutDeprecatedLifecycles) {\n      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\n    }\n  }\n}\n\nfunction stopFinishedWorkLoopTimer() {\n  const didCompleteRoot = true;\n  stopWorkLoopTimer(interruptedBy, didCompleteRoot);\n  interruptedBy = null;\n}\n\nfunction stopInterruptedWorkLoopTimer() {\n  // TODO: Track which fiber caused the interruption.\n  const didCompleteRoot = false;\n  stopWorkLoopTimer(interruptedBy, didCompleteRoot);\n  interruptedBy = null;\n}\n\nfunction checkForInterruption(fiberThatReceivedUpdate, updateExpirationTime) {\n  if (enableUserTimingAPI && workInProgressRoot !== null && updateExpirationTime > renderExpirationTime) {\n    interruptedBy = fiberThatReceivedUpdate;\n  }\n}\n\nlet didWarnStateUpdateForUnmountedComponent = null;\n\nfunction warnAboutUpdateOnUnmountedFiberInDEV(fiber) {\n  if (__DEV__) {\n    const tag = fiber.tag;\n\n    if (tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent) {\n      // Only warn for user-defined components, not internal ones like Suspense.\n      return;\n    } // We show the whole stack but dedupe on the top component's name because\n    // the problematic code almost always lies inside that component.\n\n\n    const componentName = getComponentName(fiber.type) || 'ReactComponent';\n\n    if (didWarnStateUpdateForUnmountedComponent !== null) {\n      if (didWarnStateUpdateForUnmountedComponent.has(componentName)) {\n        return;\n      }\n\n      didWarnStateUpdateForUnmountedComponent.add(componentName);\n    } else {\n      didWarnStateUpdateForUnmountedComponent = new Set([componentName]);\n    }\n\n    warningWithoutStack(false, \"Can't perform a React state update on an unmounted component. This \" + 'is a no-op, but it indicates a memory leak in your application. To ' + 'fix, cancel all subscriptions and asynchronous tasks in %s.%s', tag === ClassComponent ? 'the componentWillUnmount method' : 'a useEffect cleanup function', getStackByFiberInDevAndProd(fiber));\n  }\n}\n\nlet beginWork;\n\nif (__DEV__ && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n  let dummyFiber = null;\n\n  beginWork = (current, unitOfWork, expirationTime) => {\n    // If a component throws an error, we replay it again in a synchronously\n    // dispatched event, so that the debugger will treat it as an uncaught\n    // error See ReactErrorUtils for more information.\n    // Before entering the begin phase, copy the work-in-progress onto a dummy\n    // fiber. If beginWork throws, we'll use this to reset the state.\n    const originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);\n\n    try {\n      return originalBeginWork(current, unitOfWork, expirationTime);\n    } catch (originalError) {\n      if (originalError !== null && typeof originalError === 'object' && typeof originalError.then === 'function') {\n        // Don't replay promises. Treat everything else like an error.\n        throw originalError;\n      } // Keep this code in sync with renderRoot; any changes here must have\n      // corresponding changes there.\n\n\n      resetContextDependencies();\n      resetHooks(); // Unwind the failed stack frame\n\n      unwindInterruptedWork(unitOfWork); // Restore the original properties of the fiber.\n\n      assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);\n\n      if (enableProfilerTimer && unitOfWork.mode & ProfileMode) {\n        // Reset the profiler timer.\n        startProfilerTimer(unitOfWork);\n      } // Run beginWork again.\n\n\n      invokeGuardedCallback(null, originalBeginWork, null, current, unitOfWork, expirationTime);\n\n      if (hasCaughtError()) {\n        const replayError = clearCaughtError(); // `invokeGuardedCallback` sometimes sets an expando `_suppressLogging`.\n        // Rethrow this error instead of the original one.\n\n        throw replayError;\n      } else {\n        // This branch is reachable if the render phase is impure.\n        throw originalError;\n      }\n    }\n  };\n} else {\n  beginWork = originalBeginWork;\n}\n\nlet didWarnAboutUpdateInRender = false;\nlet didWarnAboutUpdateInGetChildContext = false;\n\nfunction warnAboutInvalidUpdatesOnClassComponentsInDEV(fiber) {\n  if (__DEV__) {\n    if (fiber.tag === ClassComponent) {\n      switch (ReactCurrentDebugFiberPhaseInDEV) {\n        case 'getChildContext':\n          if (didWarnAboutUpdateInGetChildContext) {\n            return;\n          }\n\n          warningWithoutStack(false, 'setState(...): Cannot call setState() inside getChildContext()');\n          didWarnAboutUpdateInGetChildContext = true;\n          break;\n\n        case 'render':\n          if (didWarnAboutUpdateInRender) {\n            return;\n          }\n\n          warningWithoutStack(false, 'Cannot update during an existing state transition (such as ' + 'within `render`). Render methods should be a pure function of ' + 'props and state.');\n          didWarnAboutUpdateInRender = true;\n          break;\n      }\n    }\n  }\n} // a 'shared' variable that changes when act() opens/closes in tests.\n\n\nexport const IsThisRendererActing = {\n  current: false\n};\nexport function warnIfNotScopedWithMatchingAct(fiber) {\n  if (__DEV__) {\n    if (warnsIfNotActing === true && IsSomeRendererActing.current === true && IsThisRendererActing.current !== true) {\n      warningWithoutStack(false, \"It looks like you're using the wrong act() around your test interactions.\\n\" + 'Be sure to use the matching version of act() corresponding to your renderer:\\n\\n' + '// for react-dom:\\n' + \"import {act} from 'react-dom/test-utils';\\n\" + '// ...\\n' + 'act(() => ...);\\n\\n' + '// for react-test-renderer:\\n' + \"import TestRenderer from 'react-test-renderer';\\n\" + 'const {act} = TestRenderer;\\n' + '// ...\\n' + 'act(() => ...);' + '%s', getStackByFiberInDevAndProd(fiber));\n    }\n  }\n}\nexport function warnIfNotCurrentlyActingEffectsInDEV(fiber) {\n  if (__DEV__) {\n    if (warnsIfNotActing === true && (fiber.mode & StrictMode) !== NoMode && IsSomeRendererActing.current === false && IsThisRendererActing.current === false) {\n      warningWithoutStack(false, 'An update to %s ran an effect, but was not wrapped in act(...).\\n\\n' + 'When testing, code that causes React state updates should be ' + 'wrapped into act(...):\\n\\n' + 'act(() => {\\n' + '  /* fire events that update state */\\n' + '});\\n' + '/* assert on the output */\\n\\n' + \"This ensures that you're testing the behavior the user would see \" + 'in the browser.' + ' Learn more at https://fb.me/react-wrap-tests-with-act' + '%s', getComponentName(fiber.type), getStackByFiberInDevAndProd(fiber));\n    }\n  }\n}\n\nfunction warnIfNotCurrentlyActingUpdatesInDEV(fiber) {\n  if (__DEV__) {\n    if (warnsIfNotActing === true && executionContext === NoContext && IsSomeRendererActing.current === false && IsThisRendererActing.current === false) {\n      warningWithoutStack(false, 'An update to %s inside a test was not wrapped in act(...).\\n\\n' + 'When testing, code that causes React state updates should be ' + 'wrapped into act(...):\\n\\n' + 'act(() => {\\n' + '  /* fire events that update state */\\n' + '});\\n' + '/* assert on the output */\\n\\n' + \"This ensures that you're testing the behavior the user would see \" + 'in the browser.' + ' Learn more at https://fb.me/react-wrap-tests-with-act' + '%s', getComponentName(fiber.type), getStackByFiberInDevAndProd(fiber));\n    }\n  }\n}\n\nexport const warnIfNotCurrentlyActingUpdatesInDev = warnIfNotCurrentlyActingUpdatesInDEV; // In tests, we want to enforce a mocked scheduler.\n\nlet didWarnAboutUnmockedScheduler = false; // TODO Before we release concurrent mode, revisit this and decide whether a mocked\n// scheduler is the actual recommendation. The alternative could be a testing build,\n// a new lib, or whatever; we dunno just yet. This message is for early adopters\n// to get their tests right.\n\nexport function warnIfUnmockedScheduler(fiber) {\n  if (__DEV__) {\n    if (didWarnAboutUnmockedScheduler === false && Scheduler.unstable_flushAllWithoutAsserting === undefined) {\n      if (fiber.mode & BatchedMode || fiber.mode & ConcurrentMode) {\n        didWarnAboutUnmockedScheduler = true;\n        warningWithoutStack(false, 'In Concurrent or Sync modes, the \"scheduler\" module needs to be mocked ' + 'to guarantee consistent behaviour across tests and browsers. ' + 'For example, with jest: \\n' + \"jest.mock('scheduler', () => require('scheduler/unstable_mock'));\\n\\n\" + 'For more info, visit https://fb.me/react-mock-scheduler');\n      } else if (warnAboutUnmockedScheduler === true) {\n        didWarnAboutUnmockedScheduler = true;\n        warningWithoutStack(false, 'Starting from React v17, the \"scheduler\" module will need to be mocked ' + 'to guarantee consistent behaviour across tests and browsers. ' + 'For example, with jest: \\n' + \"jest.mock('scheduler', () => require('scheduler/unstable_mock'));\\n\\n\" + 'For more info, visit https://fb.me/react-mock-scheduler');\n      }\n    }\n  }\n}\nlet componentsThatTriggeredHighPriSuspend = null;\nexport function checkForWrongSuspensePriorityInDEV(sourceFiber) {\n  if (__DEV__) {\n    const currentPriorityLevel = getCurrentPriorityLevel();\n\n    if ((sourceFiber.mode & ConcurrentMode) !== NoEffect && (currentPriorityLevel === UserBlockingPriority || currentPriorityLevel === ImmediatePriority)) {\n      let workInProgressNode = sourceFiber;\n\n      while (workInProgressNode !== null) {\n        // Add the component that triggered the suspense\n        const current = workInProgressNode.alternate;\n\n        if (current !== null) {\n          // TODO: warn component that triggers the high priority\n          // suspend is the HostRoot\n          switch (workInProgressNode.tag) {\n            case ClassComponent:\n              // Loop through the component's update queue and see whether the component\n              // has triggered any high priority updates\n              const updateQueue = current.updateQueue;\n\n              if (updateQueue !== null) {\n                let update = updateQueue.firstUpdate;\n\n                while (update !== null) {\n                  const priorityLevel = update.priority;\n\n                  if (priorityLevel === UserBlockingPriority || priorityLevel === ImmediatePriority) {\n                    if (componentsThatTriggeredHighPriSuspend === null) {\n                      componentsThatTriggeredHighPriSuspend = new Set([getComponentName(workInProgressNode.type)]);\n                    } else {\n                      componentsThatTriggeredHighPriSuspend.add(getComponentName(workInProgressNode.type));\n                    }\n\n                    break;\n                  }\n\n                  update = update.next;\n                }\n              }\n\n              break;\n\n            case FunctionComponent:\n            case ForwardRef:\n            case SimpleMemoComponent:\n              if (workInProgressNode.memoizedState !== null && workInProgressNode.memoizedState.baseUpdate !== null) {\n                let update = workInProgressNode.memoizedState.baseUpdate; // Loop through the functional component's memoized state to see whether\n                // the component has triggered any high pri updates\n\n                while (update !== null) {\n                  const priority = update.priority;\n\n                  if (priority === UserBlockingPriority || priority === ImmediatePriority) {\n                    if (componentsThatTriggeredHighPriSuspend === null) {\n                      componentsThatTriggeredHighPriSuspend = new Set([getComponentName(workInProgressNode.type)]);\n                    } else {\n                      componentsThatTriggeredHighPriSuspend.add(getComponentName(workInProgressNode.type));\n                    }\n\n                    break;\n                  }\n\n                  if (update.next === workInProgressNode.memoizedState.baseUpdate) {\n                    break;\n                  }\n\n                  update = update.next;\n                }\n              }\n\n              break;\n\n            default:\n              break;\n          }\n        }\n\n        workInProgressNode = workInProgressNode.return;\n      }\n    }\n  }\n}\n\nfunction flushSuspensePriorityWarningInDEV() {\n  if (__DEV__) {\n    if (componentsThatTriggeredHighPriSuspend !== null) {\n      const componentNames = [];\n      componentsThatTriggeredHighPriSuspend.forEach(name => componentNames.push(name));\n      componentsThatTriggeredHighPriSuspend = null;\n\n      if (componentNames.length > 0) {\n        warningWithoutStack(false, '%s triggered a user-blocking update that suspended.' + '\\n\\n' + 'The fix is to split the update into multiple parts: a user-blocking ' + 'update to provide immediate feedback, and another update that ' + 'triggers the bulk of the changes.' + '\\n\\n' + 'Refer to the documentation for useSuspenseTransition to learn how ' + 'to implement this pattern.', // TODO: Add link to React docs with more information, once it exists\n        componentNames.sort().join(', '));\n      }\n    }\n  }\n}\n\nfunction computeThreadID(root, expirationTime) {\n  // Interaction threads are unique per root and expiration time.\n  return expirationTime * 1000 + root.interactionThreadID;\n}\n\nexport function markSpawnedWork(expirationTime) {\n  if (!enableSchedulerTracing) {\n    return;\n  }\n\n  if (spawnedWorkDuringRender === null) {\n    spawnedWorkDuringRender = [expirationTime];\n  } else {\n    spawnedWorkDuringRender.push(expirationTime);\n  }\n}\n\nfunction scheduleInteractions(root, expirationTime, interactions) {\n  if (!enableSchedulerTracing) {\n    return;\n  }\n\n  if (interactions.size > 0) {\n    const pendingInteractionMap = root.pendingInteractionMap;\n    const pendingInteractions = pendingInteractionMap.get(expirationTime);\n\n    if (pendingInteractions != null) {\n      interactions.forEach(interaction => {\n        if (!pendingInteractions.has(interaction)) {\n          // Update the pending async work count for previously unscheduled interaction.\n          interaction.__count++;\n        }\n\n        pendingInteractions.add(interaction);\n      });\n    } else {\n      pendingInteractionMap.set(expirationTime, new Set(interactions)); // Update the pending async work count for the current interactions.\n\n      interactions.forEach(interaction => {\n        interaction.__count++;\n      });\n    }\n\n    const subscriber = __subscriberRef.current;\n\n    if (subscriber !== null) {\n      const threadID = computeThreadID(root, expirationTime);\n      subscriber.onWorkScheduled(interactions, threadID);\n    }\n  }\n}\n\nfunction schedulePendingInteractions(root, expirationTime) {\n  // This is called when work is scheduled on a root.\n  // It associates the current interactions with the newly-scheduled expiration.\n  // They will be restored when that expiration is later committed.\n  if (!enableSchedulerTracing) {\n    return;\n  }\n\n  scheduleInteractions(root, expirationTime, __interactionsRef.current);\n}\n\nfunction startWorkOnPendingInteractions(root, expirationTime) {\n  // This is called when new work is started on a root.\n  if (!enableSchedulerTracing) {\n    return;\n  } // Determine which interactions this batch of work currently includes, So that\n  // we can accurately attribute time spent working on it, And so that cascading\n  // work triggered during the render phase will be associated with it.\n\n\n  const interactions = new Set();\n  root.pendingInteractionMap.forEach((scheduledInteractions, scheduledExpirationTime) => {\n    if (scheduledExpirationTime >= expirationTime) {\n      scheduledInteractions.forEach(interaction => interactions.add(interaction));\n    }\n  }); // Store the current set of interactions on the FiberRoot for a few reasons:\n  // We can re-use it in hot functions like renderRoot() without having to\n  // recalculate it. We will also use it in commitWork() to pass to any Profiler\n  // onRender() hooks. This also provides DevTools with a way to access it when\n  // the onCommitRoot() hook is called.\n\n  root.memoizedInteractions = interactions;\n\n  if (interactions.size > 0) {\n    const subscriber = __subscriberRef.current;\n\n    if (subscriber !== null) {\n      const threadID = computeThreadID(root, expirationTime);\n\n      try {\n        subscriber.onWorkStarted(interactions, threadID);\n      } catch (error) {\n        // If the subscriber throws, rethrow it in a separate task\n        scheduleCallback(ImmediatePriority, () => {\n          throw error;\n        });\n      }\n    }\n  }\n}\n\nfunction finishPendingInteractions(root, committedExpirationTime) {\n  if (!enableSchedulerTracing) {\n    return;\n  }\n\n  const earliestRemainingTimeAfterCommit = root.firstPendingTime;\n  let subscriber;\n\n  try {\n    subscriber = __subscriberRef.current;\n\n    if (subscriber !== null && root.memoizedInteractions.size > 0) {\n      const threadID = computeThreadID(root, committedExpirationTime);\n      subscriber.onWorkStopped(root.memoizedInteractions, threadID);\n    }\n  } catch (error) {\n    // If the subscriber throws, rethrow it in a separate task\n    scheduleCallback(ImmediatePriority, () => {\n      throw error;\n    });\n  } finally {\n    // Clear completed interactions from the pending Map.\n    // Unless the render was suspended or cascading work was scheduled,\n    // In which case– leave pending interactions until the subsequent render.\n    const pendingInteractionMap = root.pendingInteractionMap;\n    pendingInteractionMap.forEach((scheduledInteractions, scheduledExpirationTime) => {\n      // Only decrement the pending interaction count if we're done.\n      // If there's still work at the current priority,\n      // That indicates that we are waiting for suspense data.\n      if (scheduledExpirationTime > earliestRemainingTimeAfterCommit) {\n        pendingInteractionMap.delete(scheduledExpirationTime);\n        scheduledInteractions.forEach(interaction => {\n          interaction.__count--;\n\n          if (subscriber !== null && interaction.__count === 0) {\n            try {\n              subscriber.onInteractionScheduledWorkCompleted(interaction);\n            } catch (error) {\n              // If the subscriber throws, rethrow it in a separate task\n              scheduleCallback(ImmediatePriority, () => {\n                throw error;\n              });\n            }\n          }\n        });\n      }\n    });\n  }\n}","map":{"version":3,"sources":["/Users/gaoshaoyun/Documents/library/debug-react/src/react/packages/react-reconciler/src/ReactFiberWorkLoop.js"],"names":["warnAboutDeprecatedLifecycles","enableUserTimingAPI","enableSuspenseServerRenderer","replayFailedUnitOfWorkWithInvokeGuardedCallback","enableProfilerTimer","enableSchedulerTracing","warnAboutUnmockedScheduler","flushSuspenseFallbacksInTests","disableSchedulerTimeoutBasedOnReactExpirationTime","ReactSharedInternals","invariant","warning","scheduleCallback","cancelCallback","getCurrentPriorityLevel","runWithPriority","shouldYield","requestPaint","now","NoPriority","ImmediatePriority","UserBlockingPriority","NormalPriority","LowPriority","IdlePriority","flushSyncCallbackQueue","scheduleSyncCallback","Scheduler","__interactionsRef","__subscriberRef","prepareForCommit","resetAfterCommit","scheduleTimeout","cancelTimeout","noTimeout","warnsIfNotActing","createWorkInProgress","assignFiberPropertiesInDEV","isRootSuspendedAtTime","markRootSuspendedAtTime","markRootFinishedAtTime","markRootUpdatedAtTime","markRootExpiredAtTime","NoMode","StrictMode","ProfileMode","BatchedMode","ConcurrentMode","HostRoot","ClassComponent","SuspenseComponent","SuspenseListComponent","FunctionComponent","ForwardRef","MemoComponent","SimpleMemoComponent","NoEffect","PerformedWork","Placement","Update","PlacementAndUpdate","Deletion","Ref","ContentReset","Snapshot","Callback","Passive","Incomplete","HostEffectMask","Hydrating","HydratingAndUpdate","NoWork","Sync","Never","msToExpirationTime","expirationTimeToMs","computeInteractiveExpiration","computeAsyncExpiration","computeSuspenseExpiration","inferPriorityFromExpirationTime","LOW_PRIORITY_EXPIRATION","Batched","Idle","beginWork","originalBeginWork","completeWork","unwindWork","unwindInterruptedWork","throwException","createRootErrorUpdate","createClassErrorUpdate","commitBeforeMutationLifeCycles","commitBeforeMutationEffectOnFiber","commitLifeCycles","commitLayoutEffectOnFiber","commitPassiveHookEffects","commitPlacement","commitWork","commitDeletion","commitDetachRef","commitAttachRef","commitResetTextContent","enqueueUpdate","resetContextDependencies","resetHooks","ContextOnlyDispatcher","createCapturedValue","recordCommitTime","startProfilerTimer","stopProfilerTimerIfRunningAndRecordDelta","warningWithoutStack","getComponentName","ReactStrictModeWarnings","phase","ReactCurrentDebugFiberPhaseInDEV","resetCurrentFiber","resetCurrentDebugFiberInDEV","setCurrentFiber","setCurrentDebugFiberInDEV","getStackByFiberInDevAndProd","recordEffect","recordScheduleUpdate","startWorkTimer","stopWorkTimer","stopFailedWorkTimer","startWorkLoopTimer","stopWorkLoopTimer","startCommitTimer","stopCommitTimer","startCommitSnapshotEffectsTimer","stopCommitSnapshotEffectsTimer","startCommitHostEffectsTimer","stopCommitHostEffectsTimer","startCommitLifeCyclesTimer","stopCommitLifeCyclesTimer","invokeGuardedCallback","hasCaughtError","clearCaughtError","onCommitRoot","ceil","Math","ReactCurrentDispatcher","ReactCurrentOwner","IsSomeRendererActing","NoContext","BatchedContext","EventContext","DiscreteEventContext","LegacyUnbatchedContext","RenderContext","CommitContext","RootIncomplete","RootErrored","RootSuspended","RootSuspendedWithDelay","RootCompleted","RootLocked","executionContext","workInProgressRoot","workInProgress","renderExpirationTime","workInProgressRootExitStatus","workInProgressRootLatestProcessedExpirationTime","workInProgressRootLatestSuspenseTimeout","workInProgressRootCanSuspendUsingConfig","workInProgressRootNextUnprocessedUpdateTime","workInProgressRootHasPendingPing","globalMostRecentFallbackTime","FALLBACK_THROTTLE_MS","nextEffect","hasUncaughtError","firstUncaughtError","legacyErrorBoundariesThatAlreadyFailed","rootDoesHavePassiveEffects","rootWithPendingPassiveEffects","pendingPassiveEffectsRenderPriority","pendingPassiveEffectsExpirationTime","rootsWithPendingDiscreteUpdates","NESTED_UPDATE_LIMIT","nestedUpdateCount","rootWithNestedUpdates","NESTED_PASSIVE_UPDATE_LIMIT","nestedPassiveUpdateCount","interruptedBy","spawnedWorkDuringRender","currentEventTime","requestCurrentTime","computeExpirationForFiber","currentTime","fiber","suspenseConfig","mode","priorityLevel","expirationTime","timeoutMs","lastUniqueAsyncExpiration","computeUniqueAsyncExpiration","result","scheduleUpdateOnFiber","checkForNestedUpdates","warnAboutInvalidUpdatesOnClassComponentsInDEV","root","markUpdateTimeFromFiberToRoot","warnAboutUpdateOnUnmountedFiberInDEV","checkForInterruption","schedulePendingInteractions","performSyncWorkOnRoot","ensureRootIsScheduled","Map","lastDiscreteTime","get","undefined","set","scheduleWork","alternate","node","return","tag","stateNode","childExpirationTime","markUnprocessedUpdateTime","getNextRootExpirationTimeToWorkOn","lastExpiredTime","firstPendingTime","lastPingedTime","nextKnownPendingLevel","callbackExpirationTime","callbackPriority","callbackNode","bind","existingCallbackNode","existingCallbackPriority","existingCallbackExpirationTime","performConcurrentWorkOnRoot","timeout","didTimeout","originalCallbackNode","renderRoot","stopInterruptedWorkLoopTimer","stopFinishedWorkLoopTimer","finishedWork","current","finishedExpirationTime","resolveLocksOnRoot","commitRoot","lastSuspendedTime","getRemainingExpirationTime","flushSuspensePriorityWarningInDEV","hasNotProcessedNewUpdates","__DEV__","IsThisRendererActing","msUntilTimeout","prepareFreshStack","nextTime","timeoutHandle","eventTimeMs","inferTimeFromExpirationTime","currentTimeMs","timeUntilExpirationMs","timeElapsed","jnd","computeMsUntilSuspenseLoadingDelay","error","flushRoot","flushDiscreteUpdates","flushPendingDiscreteUpdates","flushPassiveEffects","firstBatch","_defer","_expirationTime","_onComplete","deferredUpdates","fn","syncUpdates","a","b","c","roots","forEach","batchedUpdates","prevExecutionContext","batchedEventUpdates","discreteUpdates","unbatchedUpdates","flushSync","flushControlled","interruptedWork","discardPendingWarnings","componentsThatTriggeredHighPriSuspend","isSync","startWorkOnPendingInteractions","prevDispatcher","prevInteractions","memoizedInteractions","workLoopSync","workLoop","thrownValue","sourceFiber","returnFiber","completeUnitOfWork","markCommitTimeOfFallback","markRenderEventTimeAndConfig","renderDidSuspend","renderDidSuspendDelayIfPossible","renderDidError","renderHasNotSuspendedYet","earliestExpirationTimeMs","inferTimeFromExpirationTimeWithSuspenseConfig","performUnitOfWork","unitOfWork","next","memoizedProps","pendingProps","effectTag","resetChildExpirationTime","firstEffect","lastEffect","actualDuration","child","sibling","siblingFiber","updateExpirationTime","completedWork","newChildExpirationTime","treeBaseDuration","selfBaseDuration","shouldBubbleActualDurations","childUpdateExpirationTime","childChildExpirationTime","renderPriorityLevel","commitRootImpl","flushRenderPhaseStrictModeWarningsInDEV","remainingExpirationTimeBeforeCommit","containerInfo","commitBeforeMutationEffects","captureCommitPhaseError","commitMutationEffects","commitLayoutEffects","rootDidHavePassiveEffects","nextNextEffect","remainingExpirationTime","expirationTimes","i","length","scheduleInteractions","finishPendingInteractions","primaryEffectTag","committedExpirationTime","flushPassiveEffectsImpl","effect","isAlreadyFailedLegacyErrorBoundary","instance","has","markLegacyErrorBoundaryAsFailed","Set","add","prepareToThrowUncaughtError","onUncaughtError","captureCommitPhaseErrorOnRoot","rootFiber","errorInfo","update","ctor","type","getDerivedStateFromError","componentDidCatch","pingSuspendedRoot","thenable","suspendedTime","pingCache","delete","retryTimedOutBoundary","boundaryFiber","retryTime","retryDehydratedSuspenseBoundary","suspenseState","memoizedState","resolveRetryThenable","retryCache","mostRecentEventTime","busyMinDurationMs","busyDelayMs","flushLegacyContextWarning","flushPendingUnsafeLifecycleWarnings","didCompleteRoot","fiberThatReceivedUpdate","didWarnStateUpdateForUnmountedComponent","componentName","dummyFiber","originalWorkInProgressCopy","originalError","then","replayError","didWarnAboutUpdateInRender","didWarnAboutUpdateInGetChildContext","warnIfNotScopedWithMatchingAct","warnIfNotCurrentlyActingEffectsInDEV","warnIfNotCurrentlyActingUpdatesInDEV","warnIfNotCurrentlyActingUpdatesInDev","didWarnAboutUnmockedScheduler","warnIfUnmockedScheduler","unstable_flushAllWithoutAsserting","checkForWrongSuspensePriorityInDEV","currentPriorityLevel","workInProgressNode","updateQueue","firstUpdate","priority","baseUpdate","componentNames","name","push","sort","join","computeThreadID","interactionThreadID","markSpawnedWork","interactions","size","pendingInteractionMap","pendingInteractions","interaction","__count","subscriber","threadID","onWorkScheduled","scheduledInteractions","scheduledExpirationTime","onWorkStarted","earliestRemainingTimeAfterCommit","onWorkStopped","onInteractionScheduledWorkCompleted"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber} from './ReactFiber';\nimport type {FiberRoot} from './ReactFiberRoot';\nimport type {ExpirationTime} from './ReactFiberExpirationTime';\nimport type {ReactPriorityLevel} from './SchedulerWithReactIntegration';\nimport type {Interaction} from 'scheduler/src/Tracing';\nimport type {SuspenseConfig} from './ReactFiberSuspenseConfig';\nimport type {SuspenseState} from './ReactFiberSuspenseComponent';\n\nimport {\n  warnAboutDeprecatedLifecycles,\n  enableUserTimingAPI,\n  enableSuspenseServerRenderer,\n  replayFailedUnitOfWorkWithInvokeGuardedCallback,\n  enableProfilerTimer,\n  enableSchedulerTracing,\n  warnAboutUnmockedScheduler,\n  flushSuspenseFallbacksInTests,\n  disableSchedulerTimeoutBasedOnReactExpirationTime,\n} from 'shared/ReactFeatureFlags';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport invariant from 'shared/invariant';\nimport warning from 'shared/warning';\n\nimport {\n  scheduleCallback,\n  cancelCallback,\n  getCurrentPriorityLevel,\n  runWithPriority,\n  shouldYield,\n  requestPaint,\n  now,\n  NoPriority,\n  ImmediatePriority,\n  UserBlockingPriority,\n  NormalPriority,\n  LowPriority,\n  IdlePriority,\n  flushSyncCallbackQueue,\n  scheduleSyncCallback,\n} from './SchedulerWithReactIntegration';\n\n// The scheduler is imported here *only* to detect whether it's been mocked\nimport * as Scheduler from 'scheduler';\n\nimport {__interactionsRef, __subscriberRef} from 'scheduler/tracing';\n\nimport {\n  prepareForCommit,\n  resetAfterCommit,\n  scheduleTimeout,\n  cancelTimeout,\n  noTimeout,\n  warnsIfNotActing,\n} from './ReactFiberHostConfig';\n\nimport {createWorkInProgress, assignFiberPropertiesInDEV} from './ReactFiber';\nimport {\n  isRootSuspendedAtTime,\n  markRootSuspendedAtTime,\n  markRootFinishedAtTime,\n  markRootUpdatedAtTime,\n  markRootExpiredAtTime,\n} from './ReactFiberRoot';\nimport {\n  NoMode,\n  StrictMode,\n  ProfileMode,\n  BatchedMode,\n  ConcurrentMode,\n} from './ReactTypeOfMode';\nimport {\n  HostRoot,\n  ClassComponent,\n  SuspenseComponent,\n  SuspenseListComponent,\n  FunctionComponent,\n  ForwardRef,\n  MemoComponent,\n  SimpleMemoComponent,\n} from 'shared/ReactWorkTags';\nimport {\n  NoEffect,\n  PerformedWork,\n  Placement,\n  Update,\n  PlacementAndUpdate,\n  Deletion,\n  Ref,\n  ContentReset,\n  Snapshot,\n  Callback,\n  Passive,\n  Incomplete,\n  HostEffectMask,\n  Hydrating,\n  HydratingAndUpdate,\n} from 'shared/ReactSideEffectTags';\nimport {\n  NoWork,\n  Sync,\n  Never,\n  msToExpirationTime,\n  expirationTimeToMs,\n  computeInteractiveExpiration,\n  computeAsyncExpiration,\n  computeSuspenseExpiration,\n  inferPriorityFromExpirationTime,\n  LOW_PRIORITY_EXPIRATION,\n  Batched,\n  Idle,\n} from './ReactFiberExpirationTime';\nimport {beginWork as originalBeginWork} from './ReactFiberBeginWork';\nimport {completeWork} from './ReactFiberCompleteWork';\nimport {unwindWork, unwindInterruptedWork} from './ReactFiberUnwindWork';\nimport {\n  throwException,\n  createRootErrorUpdate,\n  createClassErrorUpdate,\n} from './ReactFiberThrow';\nimport {\n  commitBeforeMutationLifeCycles as commitBeforeMutationEffectOnFiber,\n  commitLifeCycles as commitLayoutEffectOnFiber,\n  commitPassiveHookEffects,\n  commitPlacement,\n  commitWork,\n  commitDeletion,\n  commitDetachRef,\n  commitAttachRef,\n  commitResetTextContent,\n} from './ReactFiberCommitWork';\nimport {enqueueUpdate} from './ReactUpdateQueue';\nimport {resetContextDependencies} from './ReactFiberNewContext';\nimport {resetHooks, ContextOnlyDispatcher} from './ReactFiberHooks';\nimport {createCapturedValue} from './ReactCapturedValue';\n\nimport {\n  recordCommitTime,\n  startProfilerTimer,\n  stopProfilerTimerIfRunningAndRecordDelta,\n} from './ReactProfilerTimer';\n\n// DEV stuff\nimport warningWithoutStack from 'shared/warningWithoutStack';\nimport getComponentName from 'shared/getComponentName';\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings';\nimport {\n  phase as ReactCurrentDebugFiberPhaseInDEV,\n  resetCurrentFiber as resetCurrentDebugFiberInDEV,\n  setCurrentFiber as setCurrentDebugFiberInDEV,\n  getStackByFiberInDevAndProd,\n} from './ReactCurrentFiber';\nimport {\n  recordEffect,\n  recordScheduleUpdate,\n  startWorkTimer,\n  stopWorkTimer,\n  stopFailedWorkTimer,\n  startWorkLoopTimer,\n  stopWorkLoopTimer,\n  startCommitTimer,\n  stopCommitTimer,\n  startCommitSnapshotEffectsTimer,\n  stopCommitSnapshotEffectsTimer,\n  startCommitHostEffectsTimer,\n  stopCommitHostEffectsTimer,\n  startCommitLifeCyclesTimer,\n  stopCommitLifeCyclesTimer,\n} from './ReactDebugFiberPerf';\nimport {\n  invokeGuardedCallback,\n  hasCaughtError,\n  clearCaughtError,\n} from 'shared/ReactErrorUtils';\nimport {onCommitRoot} from './ReactFiberDevToolsHook';\n\nconst ceil = Math.ceil;\n\nconst {\n  ReactCurrentDispatcher,\n  ReactCurrentOwner,\n  IsSomeRendererActing,\n} = ReactSharedInternals;\n\ntype ExecutionContext = number;\n\nconst NoContext = /*                    */ 0b000000;\nconst BatchedContext = /*               */ 0b000001;\nconst EventContext = /*                 */ 0b000010;\nconst DiscreteEventContext = /*         */ 0b000100;\nconst LegacyUnbatchedContext = /*       */ 0b001000;\nconst RenderContext = /*                */ 0b010000;\nconst CommitContext = /*                */ 0b100000;\n\ntype RootExitStatus = 0 | 1 | 2 | 3 | 4 | 5;\nconst RootIncomplete = 0;\nconst RootErrored = 1;\nconst RootSuspended = 2;\nconst RootSuspendedWithDelay = 3;\nconst RootCompleted = 4;\nconst RootLocked = 5;\n\nexport type Thenable = {\n  then(resolve: () => mixed, reject?: () => mixed): Thenable | void,\n\n  // Special flag to opt out of tracing interactions across a Suspense boundary.\n  __reactDoNotTraceInteractions?: boolean,\n};\n\n// Describes where we are in the React execution stack\nlet executionContext: ExecutionContext = NoContext;\n// The root we're working on\nlet workInProgressRoot: FiberRoot | null = null;\n// The fiber we're working on\nlet workInProgress: Fiber | null = null;\n// The expiration time we're rendering\nlet renderExpirationTime: ExpirationTime = NoWork;\n// Whether to root completed, errored, suspended, etc.\nlet workInProgressRootExitStatus: RootExitStatus = RootIncomplete;\n// Most recent event time among processed updates during this render.\n// This is conceptually a time stamp but expressed in terms of an ExpirationTime\n// because we deal mostly with expiration times in the hot path, so this avoids\n// the conversion happening in the hot path.\nlet workInProgressRootLatestProcessedExpirationTime: ExpirationTime = Sync;\nlet workInProgressRootLatestSuspenseTimeout: ExpirationTime = Sync;\nlet workInProgressRootCanSuspendUsingConfig: null | SuspenseConfig = null;\n// The work left over by components that were visited during this render. Only\n// includes unprocessed updates, not work in bailed out children.\nlet workInProgressRootNextUnprocessedUpdateTime: ExpirationTime = NoWork;\n\n// If we're pinged while rendering we don't always restart immediately.\n// This flag determines if it might be worthwhile to restart if an opportunity\n// happens latere.\nlet workInProgressRootHasPendingPing: boolean = false;\n// The most recent time we committed a fallback. This lets us ensure a train\n// model where we don't commit new loading states in too quick succession.\nlet globalMostRecentFallbackTime: number = 0;\nconst FALLBACK_THROTTLE_MS: number = 500;\n\nlet nextEffect: Fiber | null = null;\nlet hasUncaughtError = false;\nlet firstUncaughtError = null;\nlet legacyErrorBoundariesThatAlreadyFailed: Set<mixed> | null = null;\n\nlet rootDoesHavePassiveEffects: boolean = false;\nlet rootWithPendingPassiveEffects: FiberRoot | null = null;\nlet pendingPassiveEffectsRenderPriority: ReactPriorityLevel = NoPriority;\nlet pendingPassiveEffectsExpirationTime: ExpirationTime = NoWork;\n\nlet rootsWithPendingDiscreteUpdates: Map<\n  FiberRoot,\n  ExpirationTime,\n> | null = null;\n\n// Use these to prevent an infinite loop of nested updates\nconst NESTED_UPDATE_LIMIT = 50;\nlet nestedUpdateCount: number = 0;\nlet rootWithNestedUpdates: FiberRoot | null = null;\n\nconst NESTED_PASSIVE_UPDATE_LIMIT = 50;\nlet nestedPassiveUpdateCount: number = 0;\n\nlet interruptedBy: Fiber | null = null;\n\n// Marks the need to reschedule pending interactions at these expiration times\n// during the commit phase. This enables them to be traced across components\n// that spawn new work during render. E.g. hidden boundaries, suspended SSR\n// hydration or SuspenseList.\nlet spawnedWorkDuringRender: null | Array<ExpirationTime> = null;\n\n// Expiration times are computed by adding to the current time (the start\n// time). However, if two updates are scheduled within the same event, we\n// should treat their start times as simultaneous, even if the actual clock\n// time has advanced between the first and second call.\n\n// In other words, because expiration times determine how updates are batched,\n// we want all updates of like priority that occur within the same event to\n// receive the same expiration time. Otherwise we get tearing.\nlet currentEventTime: ExpirationTime = NoWork;\n\nexport function requestCurrentTime() {\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    // We're inside React, so it's fine to read the actual time.\n    return msToExpirationTime(now());\n  }\n  // We're not inside React, so we may be in the middle of a browser event.\n  if (currentEventTime !== NoWork) {\n    // Use the same start time for all updates until we enter React again.\n    return currentEventTime;\n  }\n  // This is the first update since React yielded. Compute a new start time.\n  currentEventTime = msToExpirationTime(now());\n  return currentEventTime;\n}\n\nexport function computeExpirationForFiber(\n  currentTime: ExpirationTime,\n  fiber: Fiber,\n  suspenseConfig: null | SuspenseConfig,\n): ExpirationTime {\n  const mode = fiber.mode;\n  if ((mode & BatchedMode) === NoMode) {\n    return Sync;\n  }\n\n  const priorityLevel = getCurrentPriorityLevel();\n  if ((mode & ConcurrentMode) === NoMode) {\n    return priorityLevel === ImmediatePriority ? Sync : Batched;\n  }\n\n  if ((executionContext & RenderContext) !== NoContext) {\n    // Use whatever time we're already rendering\n    return renderExpirationTime;\n  }\n\n  let expirationTime;\n  if (suspenseConfig !== null) {\n    // Compute an expiration time based on the Suspense timeout.\n    expirationTime = computeSuspenseExpiration(\n      currentTime,\n      suspenseConfig.timeoutMs | 0 || LOW_PRIORITY_EXPIRATION,\n    );\n  } else {\n    // Compute an expiration time based on the Scheduler priority.\n    switch (priorityLevel) {\n      case ImmediatePriority:\n        expirationTime = Sync;\n        break;\n      case UserBlockingPriority:\n        // TODO: Rename this to computeUserBlockingExpiration\n        expirationTime = computeInteractiveExpiration(currentTime);\n        break;\n      case NormalPriority:\n      case LowPriority: // TODO: Handle LowPriority\n        // TODO: Rename this to... something better.\n        expirationTime = computeAsyncExpiration(currentTime);\n        break;\n      case IdlePriority:\n        expirationTime = Never;\n        break;\n      default:\n        invariant(false, 'Expected a valid priority level');\n    }\n  }\n\n  // If we're in the middle of rendering a tree, do not update at the same\n  // expiration time that is already rendering.\n  // TODO: We shouldn't have to do this if the update is on a different root.\n  // Refactor computeExpirationForFiber + scheduleUpdate so we have access to\n  // the root when we check for this condition.\n  if (workInProgressRoot !== null && expirationTime === renderExpirationTime) {\n    // This is a trick to move this update into a separate batch\n    expirationTime -= 1;\n  }\n\n  return expirationTime;\n}\n\nlet lastUniqueAsyncExpiration = NoWork;\nexport function computeUniqueAsyncExpiration(): ExpirationTime {\n  const currentTime = requestCurrentTime();\n  let result = computeAsyncExpiration(currentTime);\n  if (result <= lastUniqueAsyncExpiration) {\n    // Since we assume the current time monotonically increases, we only hit\n    // this branch when computeUniqueAsyncExpiration is fired multiple times\n    // within a 200ms window (or whatever the async bucket size is).\n    result -= 1;\n  }\n  lastUniqueAsyncExpiration = result;\n  return result;\n}\n\nexport function scheduleUpdateOnFiber(\n  fiber: Fiber,\n  expirationTime: ExpirationTime,\n) {\n  checkForNestedUpdates();\n  warnAboutInvalidUpdatesOnClassComponentsInDEV(fiber);\n\n  const root = markUpdateTimeFromFiberToRoot(fiber, expirationTime);\n  if (root === null) {\n    warnAboutUpdateOnUnmountedFiberInDEV(fiber);\n    return;\n  }\n\n  checkForInterruption(fiber, expirationTime);\n  recordScheduleUpdate();\n\n  // TODO: computeExpirationForFiber also reads the priority. Pass the\n  // priority as an argument to that function and this one.\n  const priorityLevel = getCurrentPriorityLevel();\n\n  if (expirationTime === Sync) {\n    if (\n      // Check if we're inside unbatchedUpdates\n      (executionContext & LegacyUnbatchedContext) !== NoContext &&\n      // Check if we're not already rendering\n      (executionContext & (RenderContext | CommitContext)) === NoContext\n    ) {\n      // Register pending interactions on the root to avoid losing traced interaction data.\n      schedulePendingInteractions(root, expirationTime);\n\n      // This is a legacy edge case. The initial mount of a ReactDOM.render-ed\n      // root inside of batchedUpdates should be synchronous, but layout updates\n      // should be deferred until the end of the batch.\n      performSyncWorkOnRoot(root);\n    } else {\n      ensureRootIsScheduled(root);\n      schedulePendingInteractions(root, expirationTime);\n      if (executionContext === NoContext) {\n        // Flush the synchronous work now, unless we're already working or inside\n        // a batch. This is intentionally inside scheduleUpdateOnFiber instead of\n        // scheduleCallbackForFiber to preserve the ability to schedule a callback\n        // without immediately flushing it. We only do this for user-initiated\n        // updates, to preserve historical behavior of sync mode.\n        flushSyncCallbackQueue();\n      }\n    }\n  } else {\n    ensureRootIsScheduled(root);\n    schedulePendingInteractions(root, expirationTime);\n  }\n\n  if (\n    (executionContext & DiscreteEventContext) !== NoContext &&\n    // Only updates at user-blocking priority or greater are considered\n    // discrete, even inside a discrete event.\n    (priorityLevel === UserBlockingPriority ||\n      priorityLevel === ImmediatePriority)\n  ) {\n    // This is the result of a discrete event. Track the lowest priority\n    // discrete update per root so we can flush them early, if needed.\n    if (rootsWithPendingDiscreteUpdates === null) {\n      rootsWithPendingDiscreteUpdates = new Map([[root, expirationTime]]);\n    } else {\n      const lastDiscreteTime = rootsWithPendingDiscreteUpdates.get(root);\n      if (lastDiscreteTime === undefined || lastDiscreteTime > expirationTime) {\n        rootsWithPendingDiscreteUpdates.set(root, expirationTime);\n      }\n    }\n  }\n}\nexport const scheduleWork = scheduleUpdateOnFiber;\n\n// This is split into a separate function so we can mark a fiber with pending\n// work without treating it as a typical update that originates from an event;\n// e.g. retrying a Suspense boundary isn't an update, but it does schedule work\n// on a fiber.\nfunction markUpdateTimeFromFiberToRoot(fiber, expirationTime) {\n  // Update the source fiber's expiration time\n  if (fiber.expirationTime < expirationTime) {\n    fiber.expirationTime = expirationTime;\n  }\n  let alternate = fiber.alternate;\n  if (alternate !== null && alternate.expirationTime < expirationTime) {\n    alternate.expirationTime = expirationTime;\n  }\n  // Walk the parent path to the root and update the child expiration time.\n  let node = fiber.return;\n  let root = null;\n  if (node === null && fiber.tag === HostRoot) {\n    root = fiber.stateNode;\n  } else {\n    while (node !== null) {\n      alternate = node.alternate;\n      if (node.childExpirationTime < expirationTime) {\n        node.childExpirationTime = expirationTime;\n        if (\n          alternate !== null &&\n          alternate.childExpirationTime < expirationTime\n        ) {\n          alternate.childExpirationTime = expirationTime;\n        }\n      } else if (\n        alternate !== null &&\n        alternate.childExpirationTime < expirationTime\n      ) {\n        alternate.childExpirationTime = expirationTime;\n      }\n      if (node.return === null && node.tag === HostRoot) {\n        root = node.stateNode;\n        break;\n      }\n      node = node.return;\n    }\n  }\n\n  if (root !== null) {\n    if (workInProgressRoot === root) {\n      // Received an update to a tree that's in the middle of rendering. Mark\n      // that's unprocessed work on this root.\n      markUnprocessedUpdateTime(expirationTime);\n\n      if (workInProgressRootExitStatus === RootSuspendedWithDelay) {\n        // The root already suspended with a delay, which means this render\n        // definitely won't finish. Since we have a new update, let's mark it as\n        // suspended now, right before marking the incoming update. This has the\n        // effect of interrupting the current render and switching to the update.\n        // TODO: This happens to work when receiving an update during the render\n        // phase, because of the trick inside computeExpirationForFiber to\n        // subtract 1 from `renderExpirationTime` to move it into a\n        // separate bucket. But we should probably model it with an exception,\n        // using the same mechanism we use to force hydration of a subtree.\n        // TODO: This does not account for low pri updates that were already\n        // scheduled before the root started rendering. Need to track the next\n        // pending expiration time (perhaps by backtracking the return path) and\n        // then trigger a restart in the `renderDidSuspendDelayIfPossible` path.\n        markRootSuspendedAtTime(root, renderExpirationTime);\n      }\n    }\n    // Mark that the root has a pending update.\n    markRootUpdatedAtTime(root, expirationTime);\n  }\n\n  return root;\n}\n\nfunction getNextRootExpirationTimeToWorkOn(root: FiberRoot): ExpirationTime {\n  // Determines the next expiration time that the root should render, taking\n  // into account levels that may be suspended, or levels that may have\n  // received a ping.\n\n  const lastExpiredTime = root.lastExpiredTime;\n  if (lastExpiredTime !== NoWork) {\n    return lastExpiredTime;\n  }\n\n  // \"Pending\" refers to any update that hasn't committed yet, including if it\n  // suspended. The \"suspended\" range is therefore a subset.\n  const firstPendingTime = root.firstPendingTime;\n  if (!isRootSuspendedAtTime(root, firstPendingTime)) {\n    // The highest priority pending time is not suspended. Let's work on that.\n    return firstPendingTime;\n  }\n\n  // If the first pending time is suspended, check if there's a lower priority\n  // pending level that we know about. Or check if we received a ping. Work\n  // on whichever is higher priority.\n  const lastPingedTime = root.lastPingedTime;\n  const nextKnownPendingLevel = root.nextKnownPendingLevel;\n  return lastPingedTime > nextKnownPendingLevel\n    ? lastPingedTime\n    : nextKnownPendingLevel;\n}\n\n// Use this function to schedule a task for a root. There's only one task per\n// root; if a task was already scheduled, we'll check to make sure the\n// expiration time of the existing task is the same as the expiration time of\n// the next level that the root has work on. This function is called on every\n// update, and right before exiting a task.\nfunction ensureRootIsScheduled(root: FiberRoot) {\n  const lastExpiredTime = root.lastExpiredTime;\n  if (lastExpiredTime !== NoWork) {\n    // Special case: Expired work should flush synchronously.\n    root.callbackExpirationTime = Sync;\n    root.callbackPriority = ImmediatePriority;\n    root.callbackNode = scheduleSyncCallback(\n      performSyncWorkOnRoot.bind(null, root),\n    );\n    return;\n  }\n\n  const expirationTime = getNextRootExpirationTimeToWorkOn(root);\n  const existingCallbackNode = root.callbackNode;\n  if (expirationTime === NoWork) {\n    // There's nothing to work on.\n    if (existingCallbackNode !== null) {\n      root.callbackNode = null;\n      root.callbackExpirationTime = NoWork;\n      root.callbackPriority = NoPriority;\n    }\n    return;\n  }\n\n  // TODO: If this is an update, we already read the current time. Pass the\n  // time as an argument.\n  const currentTime = requestCurrentTime();\n  const priorityLevel = inferPriorityFromExpirationTime(\n    currentTime,\n    expirationTime,\n  );\n\n  // If there's an existing render task, confirm it has the correct priority and\n  // expiration time. Otherwise, we'll cancel it and schedule a new one.\n  if (existingCallbackNode !== null) {\n    const existingCallbackPriority = root.callbackPriority;\n    const existingCallbackExpirationTime = root.callbackExpirationTime;\n    if (\n      // Callback must have the exact same expiration time.\n      existingCallbackExpirationTime === expirationTime &&\n      // Callback must have greater or equal priority.\n      existingCallbackPriority >= priorityLevel\n    ) {\n      // Existing callback is sufficient.\n      return;\n    }\n    // Need to schedule a new task.\n    // TODO: Instead of scheduling a new task, we should be able to change the\n    // priority of the existing one.\n    cancelCallback(existingCallbackNode);\n  }\n\n  root.callbackExpirationTime = expirationTime;\n  root.callbackPriority = priorityLevel;\n\n  let callbackNode;\n  if (expirationTime === Sync) {\n    // Sync React callbacks are scheduled on a special internal queue\n    callbackNode = scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));\n  } else if (disableSchedulerTimeoutBasedOnReactExpirationTime) {\n    callbackNode = scheduleCallback(\n      priorityLevel,\n      performConcurrentWorkOnRoot.bind(null, root),\n    );\n  } else {\n    callbackNode = scheduleCallback(\n      priorityLevel,\n      performConcurrentWorkOnRoot.bind(null, root),\n      // Compute a task timeout based on the expiration time. This also affects\n      // ordering because tasks are processed in timeout order.\n      {timeout: expirationTimeToMs(expirationTime) - now()},\n    );\n  }\n\n  root.callbackNode = callbackNode;\n}\n\n// This is the entry point for every concurrent task, i.e. anything that\n// goes through Scheduler.\nfunction performConcurrentWorkOnRoot(root, didTimeout) {\n  // Since we know we're in a React event, we can clear the current\n  // event time. The next update will compute a new event time.\n  currentEventTime = NoWork;\n\n  if (didTimeout) {\n    // The render task took too long to complete. Mark the current time as\n    // expired to synchronously render all expired work in a single batch.\n    const currentTime = requestCurrentTime();\n    markRootExpiredAtTime(root, currentTime);\n    // This will schedule a synchronous callback.\n    ensureRootIsScheduled(root);\n    return null;\n  }\n\n  // Determine the next expiration time to work on, using the fields stored\n  // on the root.\n  const expirationTime = getNextRootExpirationTimeToWorkOn(root);\n  if (expirationTime !== NoWork) {\n    const originalCallbackNode = root.callbackNode;\n    try {\n      renderRoot(root, expirationTime, false);\n      if (workInProgress !== null) {\n        // There's still work left over. Exit without committing.\n        stopInterruptedWorkLoopTimer();\n      } else {\n        // We now have a consistent tree. The next step is either to commit it,\n        // or, if something suspended, wait to commit it after a timeout.\n        stopFinishedWorkLoopTimer();\n\n        const finishedWork: Fiber = ((root.finishedWork =\n          root.current.alternate): any);\n        root.finishedExpirationTime = expirationTime;\n\n        resolveLocksOnRoot(root, expirationTime);\n\n        // Set this to null to indicate there's no in-progress render.\n        workInProgressRoot = null;\n\n        switch (workInProgressRootExitStatus) {\n          case RootIncomplete: {\n            invariant(false, 'Should have a work-in-progress.');\n          }\n          // Flow knows about invariant, so it complains if I add a break\n          // statement, but eslint doesn't know about invariant, so it complains\n          // if I do. eslint-disable-next-line no-fallthrough\n          case RootErrored: {\n            if (expirationTime !== Idle) {\n              // If this was an async render, the error may have happened due to\n              // a mutation in a concurrent event. Try rendering one more time,\n              // synchronously, to see if the error goes away. If there are\n              // lower priority updates, let's include those, too, in case they\n              // fix the inconsistency. Render at Idle to include all updates.\n              markRootExpiredAtTime(root, Idle);\n              break;\n            }\n            // Commit the root in its errored state.\n            commitRoot(root);\n            break;\n          }\n          case RootSuspended: {\n            markRootSuspendedAtTime(root, expirationTime);\n            const lastSuspendedTime = root.lastSuspendedTime;\n            if (expirationTime === lastSuspendedTime) {\n              root.nextKnownPendingLevel = getRemainingExpirationTime(\n                finishedWork,\n              );\n            }\n            flushSuspensePriorityWarningInDEV();\n\n            // We have an acceptable loading state. We need to figure out if we\n            // should immediately commit it or wait a bit.\n\n            // If we have processed new updates during this render, we may now\n            // have a new loading state ready. We want to ensure that we commit\n            // that as soon as possible.\n            const hasNotProcessedNewUpdates =\n              workInProgressRootLatestProcessedExpirationTime === Sync;\n            if (\n              hasNotProcessedNewUpdates &&\n              // do not delay if we're inside an act() scope\n              !(\n                __DEV__ &&\n                flushSuspenseFallbacksInTests &&\n                IsThisRendererActing.current\n              )\n            ) {\n              // If we have not processed any new updates during this pass, then\n              // this is either a retry of an existing fallback state or a\n              // hidden tree. Hidden trees shouldn't be batched with other work\n              // and after that's fixed it can only be a retry. We're going to\n              // throttle committing retries so that we don't show too many\n              // loading states too quickly.\n              let msUntilTimeout =\n                globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now();\n              // Don't bother with a very short suspense time.\n              if (msUntilTimeout > 10) {\n                if (workInProgressRootHasPendingPing) {\n                  const lastPingedTime = root.lastPingedTime;\n                  if (\n                    lastPingedTime === NoWork ||\n                    lastPingedTime >= expirationTime\n                  ) {\n                    // This render was pinged but we didn't get to restart\n                    // earlier so try restarting now instead.\n                    root.lastPingedTime = expirationTime;\n                    prepareFreshStack(root, expirationTime);\n                    break;\n                  }\n                }\n\n                const nextTime = getNextRootExpirationTimeToWorkOn(root);\n                if (nextTime !== NoWork && nextTime !== expirationTime) {\n                  // There's additional work on this root.\n                  break;\n                }\n                if (\n                  lastSuspendedTime !== NoWork &&\n                  lastSuspendedTime !== expirationTime\n                ) {\n                  // We should prefer to render the fallback of at the last\n                  // suspended level. Ping the last suspended level to try\n                  // rendering it again.\n                  root.lastPingedTime = lastSuspendedTime;\n                  break;\n                }\n\n                // The render is suspended, it hasn't timed out, and there's no\n                // lower priority work to do. Instead of committing the fallback\n                // immediately, wait for more data to arrive.\n                root.timeoutHandle = scheduleTimeout(\n                  commitRoot.bind(null, root),\n                  msUntilTimeout,\n                );\n                break;\n              }\n            }\n            // The work expired. Commit immediately.\n            commitRoot(root);\n            break;\n          }\n          case RootSuspendedWithDelay: {\n            markRootSuspendedAtTime(root, expirationTime);\n            const lastSuspendedTime = root.lastSuspendedTime;\n            if (expirationTime === lastSuspendedTime) {\n              root.nextKnownPendingLevel = getRemainingExpirationTime(\n                finishedWork,\n              );\n            }\n            flushSuspensePriorityWarningInDEV();\n\n            if (\n              // do not delay if we're inside an act() scope\n              !(\n                __DEV__ &&\n                flushSuspenseFallbacksInTests &&\n                IsThisRendererActing.current\n              )\n            ) {\n              // We're suspended in a state that should be avoided. We'll try to\n              // avoid committing it for as long as the timeouts let us.\n              if (workInProgressRootHasPendingPing) {\n                const lastPingedTime = root.lastPingedTime;\n                if (\n                  lastPingedTime === NoWork ||\n                  lastPingedTime >= expirationTime\n                ) {\n                  // This render was pinged but we didn't get to restart earlier\n                  // so try restarting now instead.\n                  root.lastPingedTime = expirationTime;\n                  prepareFreshStack(root, expirationTime);\n                  break;\n                }\n              }\n\n              const nextTime = getNextRootExpirationTimeToWorkOn(root);\n              if (nextTime !== NoWork && nextTime !== expirationTime) {\n                // There's additional work on this root.\n                break;\n              }\n              if (\n                lastSuspendedTime !== NoWork &&\n                lastSuspendedTime !== expirationTime\n              ) {\n                // We should prefer to render the fallback of at the last\n                // suspended level. Ping the last suspended level to try\n                // rendering it again.\n                root.lastPingedTime = lastSuspendedTime;\n                break;\n              }\n\n              let msUntilTimeout;\n              if (workInProgressRootLatestSuspenseTimeout !== Sync) {\n                // We have processed a suspense config whose expiration time we\n                // can use as the timeout.\n                msUntilTimeout =\n                  expirationTimeToMs(workInProgressRootLatestSuspenseTimeout) -\n                  now();\n              } else if (\n                workInProgressRootLatestProcessedExpirationTime === Sync\n              ) {\n                // This should never normally happen because only new updates\n                // cause delayed states, so we should have processed something.\n                // However, this could also happen in an offscreen tree.\n                msUntilTimeout = 0;\n              } else {\n                // If we don't have a suspense config, we're going to use a\n                // heuristic to determine how long we can suspend.\n                const eventTimeMs: number = inferTimeFromExpirationTime(\n                  workInProgressRootLatestProcessedExpirationTime,\n                );\n                const currentTimeMs = now();\n                const timeUntilExpirationMs =\n                  expirationTimeToMs(expirationTime) - currentTimeMs;\n                let timeElapsed = currentTimeMs - eventTimeMs;\n                if (timeElapsed < 0) {\n                  // We get this wrong some time since we estimate the time.\n                  timeElapsed = 0;\n                }\n\n                msUntilTimeout = jnd(timeElapsed) - timeElapsed;\n\n                // Clamp the timeout to the expiration time. TODO: Once the\n                // event time is exact instead of inferred from expiration time\n                // we don't need this.\n                if (timeUntilExpirationMs < msUntilTimeout) {\n                  msUntilTimeout = timeUntilExpirationMs;\n                }\n              }\n\n              // Don't bother with a very short suspense time.\n              if (msUntilTimeout > 10) {\n                // The render is suspended, it hasn't timed out, and there's no\n                // lower priority work to do. Instead of committing the fallback\n                // immediately, wait for more data to arrive.\n                root.timeoutHandle = scheduleTimeout(\n                  commitRoot.bind(null, root),\n                  msUntilTimeout,\n                );\n                break;\n              }\n            }\n            // The work expired. Commit immediately.\n            commitRoot(root);\n            break;\n          }\n          case RootCompleted: {\n            // The work completed. Ready to commit.\n            if (\n              // do not delay if we're inside an act() scope\n              !(\n                __DEV__ &&\n                flushSuspenseFallbacksInTests &&\n                IsThisRendererActing.current\n              ) &&\n              workInProgressRootLatestProcessedExpirationTime !== Sync &&\n              workInProgressRootCanSuspendUsingConfig !== null\n            ) {\n              // If we have exceeded the minimum loading delay, which probably\n              // means we have shown a spinner already, we might have to suspend\n              // a bit longer to ensure that the spinner is shown for\n              // enough time.\n              const msUntilTimeout = computeMsUntilSuspenseLoadingDelay(\n                workInProgressRootLatestProcessedExpirationTime,\n                expirationTime,\n                workInProgressRootCanSuspendUsingConfig,\n              );\n              if (msUntilTimeout > 10) {\n                markRootSuspendedAtTime(root, expirationTime);\n                root.timeoutHandle = scheduleTimeout(\n                  commitRoot.bind(null, root),\n                  msUntilTimeout,\n                );\n                break;\n              }\n            }\n            commitRoot(root);\n            break;\n          }\n          case RootLocked: {\n            // This root has a lock that prevents it from committing. Exit. If\n            // we begin work on the root again, without any intervening updates,\n            // it will finish without doing additional work.\n            markRootSuspendedAtTime(root, expirationTime);\n            break;\n          }\n          default: {\n            invariant(false, 'Unknown root exit status.');\n          }\n        }\n      }\n      // Before exiting, make sure there's a callback scheduled for the\n      // pending level. This is intentionally duplicated in the `catch` block,\n      // instead of using `finally`, because it needs to happen before we\n      // possibly return a continuation, and we can't return in the `finally`\n      // block without suppressing a potential error.\n      ensureRootIsScheduled(root);\n      if (root.callbackNode === originalCallbackNode) {\n        // The task node scheduled for this root is the same one that's\n        // currently executed. Need to return a continuation.\n        return performConcurrentWorkOnRoot.bind(null, root);\n      }\n    } catch (error) {\n      ensureRootIsScheduled(root);\n      throw error;\n    }\n  }\n  return null;\n}\n\n// This is the entry point for synchronous tasks that don't go\n// through Scheduler\nfunction performSyncWorkOnRoot(root) {\n  // Check if there's expired work on this root. Otherwise, render at Sync.\n  const lastExpiredTime = root.lastExpiredTime;\n  const expirationTime = lastExpiredTime !== NoWork ? lastExpiredTime : Sync;\n  try {\n    if (root.finishedExpirationTime === expirationTime) {\n      // There's already a pending commit at this expiration time.\n      // TODO: This is poorly factored. This case only exists for the\n      // batch.commit() API.\n      commitRoot(root);\n    } else {\n      renderRoot(root, expirationTime, true);\n      invariant(\n        workInProgressRootExitStatus !== RootIncomplete,\n        'Cannot commit an incomplete root. This error is likely caused by a ' +\n          'bug in React. Please file an issue.',\n      );\n\n      // We now have a consistent tree. The next step is either to commit it,\n      // or, if something suspended, wait to commit it after a timeout.\n      stopFinishedWorkLoopTimer();\n\n      root.finishedWork = ((root.current.alternate: any): Fiber);\n      root.finishedExpirationTime = expirationTime;\n\n      resolveLocksOnRoot(root, expirationTime);\n      if (workInProgressRootExitStatus === RootLocked) {\n        // This root has a lock that prevents it from committing. Exit. If we\n        // begin work on the root again, without any intervening updates, it\n        // will finish without doing additional work.\n        markRootSuspendedAtTime(root, expirationTime);\n      } else {\n        // Set this to null to indicate there's no in-progress render.\n        workInProgressRoot = null;\n\n        if (__DEV__) {\n          if (\n            workInProgressRootExitStatus === RootSuspended ||\n            workInProgressRootExitStatus === RootSuspendedWithDelay\n          ) {\n            flushSuspensePriorityWarningInDEV();\n          }\n        }\n        commitRoot(root);\n      }\n    }\n  } finally {\n    // Before exiting, make sure there's a callback scheduled for the\n    // pending level.\n    ensureRootIsScheduled(root);\n  }\n  return null;\n}\n\nexport function flushRoot(root: FiberRoot, expirationTime: ExpirationTime) {\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    invariant(\n      false,\n      'work.commit(): Cannot commit while already rendering. This likely ' +\n        'means you attempted to commit from inside a lifecycle method.',\n    );\n  }\n  markRootExpiredAtTime(root, expirationTime);\n  ensureRootIsScheduled(root);\n  flushSyncCallbackQueue();\n}\n\nexport function flushDiscreteUpdates() {\n  // TODO: Should be able to flush inside batchedUpdates, but not inside `act`.\n  // However, `act` uses `batchedUpdates`, so there's no way to distinguish\n  // those two cases. Need to fix this before exposing flushDiscreteUpdates\n  // as a public API.\n  if (\n    (executionContext & (BatchedContext | RenderContext | CommitContext)) !==\n    NoContext\n  ) {\n    if (__DEV__ && (executionContext & RenderContext) !== NoContext) {\n      warning(\n        false,\n        'unstable_flushDiscreteUpdates: Cannot flush updates when React is ' +\n          'already rendering.',\n      );\n    }\n    // We're already rendering, so we can't synchronously flush pending work.\n    // This is probably a nested event dispatch triggered by a lifecycle/effect,\n    // like `el.focus()`. Exit.\n    return;\n  }\n  flushPendingDiscreteUpdates();\n  // If the discrete updates scheduled passive effects, flush them now so that\n  // they fire before the next serial event.\n  flushPassiveEffects();\n}\n\nfunction resolveLocksOnRoot(root: FiberRoot, expirationTime: ExpirationTime) {\n  const firstBatch = root.firstBatch;\n  if (\n    firstBatch !== null &&\n    firstBatch._defer &&\n    firstBatch._expirationTime >= expirationTime\n  ) {\n    scheduleCallback(NormalPriority, () => {\n      firstBatch._onComplete();\n      return null;\n    });\n    workInProgressRootExitStatus = RootLocked;\n  }\n}\n\nexport function deferredUpdates<A>(fn: () => A): A {\n  // TODO: Remove in favor of Scheduler.next\n  return runWithPriority(NormalPriority, fn);\n}\n\nexport function syncUpdates<A, B, C, R>(\n  fn: (A, B, C) => R,\n  a: A,\n  b: B,\n  c: C,\n): R {\n  return runWithPriority(ImmediatePriority, fn.bind(null, a, b, c));\n}\n\nfunction flushPendingDiscreteUpdates() {\n  if (rootsWithPendingDiscreteUpdates !== null) {\n    // For each root with pending discrete updates, schedule a callback to\n    // immediately flush them.\n    const roots = rootsWithPendingDiscreteUpdates;\n    rootsWithPendingDiscreteUpdates = null;\n    roots.forEach((expirationTime, root) => {\n      markRootExpiredAtTime(root, expirationTime);\n      ensureRootIsScheduled(root);\n    });\n    // Now flush the immediate queue.\n    flushSyncCallbackQueue();\n  }\n}\n\nexport function batchedUpdates<A, R>(fn: A => R, a: A): R {\n  const prevExecutionContext = executionContext;\n  executionContext |= BatchedContext;\n  try {\n    return fn(a);\n  } finally {\n    executionContext = prevExecutionContext;\n    if (executionContext === NoContext) {\n      // Flush the immediate callbacks that were scheduled during this batch\n      flushSyncCallbackQueue();\n    }\n  }\n}\n\nexport function batchedEventUpdates<A, R>(fn: A => R, a: A): R {\n  const prevExecutionContext = executionContext;\n  executionContext |= EventContext;\n  try {\n    return fn(a);\n  } finally {\n    executionContext = prevExecutionContext;\n    if (executionContext === NoContext) {\n      // Flush the immediate callbacks that were scheduled during this batch\n      flushSyncCallbackQueue();\n    }\n  }\n}\n\nexport function discreteUpdates<A, B, C, R>(\n  fn: (A, B, C) => R,\n  a: A,\n  b: B,\n  c: C,\n): R {\n  const prevExecutionContext = executionContext;\n  executionContext |= DiscreteEventContext;\n  try {\n    // Should this\n    return runWithPriority(UserBlockingPriority, fn.bind(null, a, b, c));\n  } finally {\n    executionContext = prevExecutionContext;\n    if (executionContext === NoContext) {\n      // Flush the immediate callbacks that were scheduled during this batch\n      flushSyncCallbackQueue();\n    }\n  }\n}\n\nexport function unbatchedUpdates<A, R>(fn: (a: A) => R, a: A): R {\n  const prevExecutionContext = executionContext;\n  executionContext &= ~BatchedContext;\n  executionContext |= LegacyUnbatchedContext;\n  try {\n    return fn(a);\n  } finally {\n    executionContext = prevExecutionContext;\n    if (executionContext === NoContext) {\n      // Flush the immediate callbacks that were scheduled during this batch\n      flushSyncCallbackQueue();\n    }\n  }\n}\n\nexport function flushSync<A, R>(fn: A => R, a: A): R {\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    invariant(\n      false,\n      'flushSync was called from inside a lifecycle method. It cannot be ' +\n        'called when React is already rendering.',\n    );\n  }\n  const prevExecutionContext = executionContext;\n  executionContext |= BatchedContext;\n  try {\n    return runWithPriority(ImmediatePriority, fn.bind(null, a));\n  } finally {\n    executionContext = prevExecutionContext;\n    // Flush the immediate callbacks that were scheduled during this batch.\n    // Note that this will happen even if batchedUpdates is higher up\n    // the stack.\n    flushSyncCallbackQueue();\n  }\n}\n\nexport function flushControlled(fn: () => mixed): void {\n  const prevExecutionContext = executionContext;\n  executionContext |= BatchedContext;\n  try {\n    runWithPriority(ImmediatePriority, fn);\n  } finally {\n    executionContext = prevExecutionContext;\n    if (executionContext === NoContext) {\n      // Flush the immediate callbacks that were scheduled during this batch\n      flushSyncCallbackQueue();\n    }\n  }\n}\n\nfunction prepareFreshStack(root, expirationTime) {\n  root.finishedWork = null;\n  root.finishedExpirationTime = NoWork;\n\n  const timeoutHandle = root.timeoutHandle;\n  if (timeoutHandle !== noTimeout) {\n    // The root previous suspended and scheduled a timeout to commit a fallback\n    // state. Now that we have additional work, cancel the timeout.\n    root.timeoutHandle = noTimeout;\n    // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\n    cancelTimeout(timeoutHandle);\n  }\n\n  if (workInProgress !== null) {\n    let interruptedWork = workInProgress.return;\n    while (interruptedWork !== null) {\n      unwindInterruptedWork(interruptedWork);\n      interruptedWork = interruptedWork.return;\n    }\n  }\n  workInProgressRoot = root;\n  workInProgress = createWorkInProgress(root.current, null, expirationTime);\n  renderExpirationTime = expirationTime;\n  workInProgressRootExitStatus = RootIncomplete;\n  workInProgressRootLatestProcessedExpirationTime = Sync;\n  workInProgressRootLatestSuspenseTimeout = Sync;\n  workInProgressRootCanSuspendUsingConfig = null;\n  workInProgressRootNextUnprocessedUpdateTime = NoWork;\n  workInProgressRootHasPendingPing = false;\n\n  if (enableSchedulerTracing) {\n    spawnedWorkDuringRender = null;\n  }\n\n  if (__DEV__) {\n    ReactStrictModeWarnings.discardPendingWarnings();\n    componentsThatTriggeredHighPriSuspend = null;\n  }\n}\n\n// renderRoot should only be called from inside either\n// `performConcurrentWorkOnRoot` or `performSyncWorkOnRoot`.\nfunction renderRoot(\n  root: FiberRoot,\n  expirationTime: ExpirationTime,\n  isSync: boolean,\n): void {\n  invariant(\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\n    'Should not already be working.',\n  );\n\n  flushPassiveEffects();\n\n  // If the root or expiration time have changed, throw out the existing stack\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\n  if (root !== workInProgressRoot || expirationTime !== renderExpirationTime) {\n    prepareFreshStack(root, expirationTime);\n    startWorkOnPendingInteractions(root, expirationTime);\n  }\n\n  // If we have a work-in-progress fiber, it means there's still work to do\n  // in this root.\n  if (workInProgress !== null) {\n    const prevExecutionContext = executionContext;\n    executionContext |= RenderContext;\n    let prevDispatcher = ReactCurrentDispatcher.current;\n    if (prevDispatcher === null) {\n      // The React isomorphic package does not include a default dispatcher.\n      // Instead the first renderer will lazily attach one, in order to give\n      // nicer error messages.\n      prevDispatcher = ContextOnlyDispatcher;\n    }\n    ReactCurrentDispatcher.current = ContextOnlyDispatcher;\n    let prevInteractions: Set<Interaction> | null = null;\n    if (enableSchedulerTracing) {\n      prevInteractions = __interactionsRef.current;\n      __interactionsRef.current = root.memoizedInteractions;\n    }\n\n    startWorkLoopTimer(workInProgress);\n\n    do {\n      try {\n        // TODO: This is now the only place that `isSync` is used. Consider\n        // outlining the contents of `renderRoot`.\n        if (isSync) {\n          workLoopSync();\n        } else {\n          workLoop();\n        }\n        break;\n      } catch (thrownValue) {\n        // Reset module-level state that was set during the render phase.\n        resetContextDependencies();\n        resetHooks();\n\n        const sourceFiber = workInProgress;\n        if (sourceFiber === null || sourceFiber.return === null) {\n          // Expected to be working on a non-root fiber. This is a fatal error\n          // because there's no ancestor that can handle it; the root is\n          // supposed to capture all errors that weren't caught by an error\n          // boundary.\n          prepareFreshStack(root, expirationTime);\n          executionContext = prevExecutionContext;\n          markRootSuspendedAtTime(root, expirationTime);\n          throw thrownValue;\n        }\n\n        if (enableProfilerTimer && sourceFiber.mode & ProfileMode) {\n          // Record the time spent rendering before an error was thrown. This\n          // avoids inaccurate Profiler durations in the case of a\n          // suspended render.\n          stopProfilerTimerIfRunningAndRecordDelta(sourceFiber, true);\n        }\n\n        const returnFiber = sourceFiber.return;\n        throwException(\n          root,\n          returnFiber,\n          sourceFiber,\n          thrownValue,\n          renderExpirationTime,\n        );\n        // TODO: This is not wrapped in a try-catch, so if the complete phase\n        // throws, we won't capture it.\n        workInProgress = completeUnitOfWork(sourceFiber);\n      }\n    } while (true);\n\n    executionContext = prevExecutionContext;\n    resetContextDependencies();\n    ReactCurrentDispatcher.current = prevDispatcher;\n    if (enableSchedulerTracing) {\n      __interactionsRef.current = ((prevInteractions: any): Set<Interaction>);\n    }\n  }\n}\n\nexport function markCommitTimeOfFallback() {\n  globalMostRecentFallbackTime = now();\n}\n\nexport function markRenderEventTimeAndConfig(\n  expirationTime: ExpirationTime,\n  suspenseConfig: null | SuspenseConfig,\n): void {\n  if (\n    expirationTime < workInProgressRootLatestProcessedExpirationTime &&\n    expirationTime > Never\n  ) {\n    workInProgressRootLatestProcessedExpirationTime = expirationTime;\n  }\n  if (suspenseConfig !== null) {\n    if (\n      expirationTime < workInProgressRootLatestSuspenseTimeout &&\n      expirationTime > Never\n    ) {\n      workInProgressRootLatestSuspenseTimeout = expirationTime;\n      // Most of the time we only have one config and getting wrong is not bad.\n      workInProgressRootCanSuspendUsingConfig = suspenseConfig;\n    }\n  }\n}\n\nexport function markUnprocessedUpdateTime(\n  expirationTime: ExpirationTime,\n): void {\n  if (expirationTime > workInProgressRootNextUnprocessedUpdateTime) {\n    workInProgressRootNextUnprocessedUpdateTime = expirationTime;\n  }\n}\n\nexport function renderDidSuspend(): void {\n  if (workInProgressRootExitStatus === RootIncomplete) {\n    workInProgressRootExitStatus = RootSuspended;\n  }\n}\n\nexport function renderDidSuspendDelayIfPossible(): void {\n  if (\n    workInProgressRootExitStatus === RootIncomplete ||\n    workInProgressRootExitStatus === RootSuspended\n  ) {\n    workInProgressRootExitStatus = RootSuspendedWithDelay;\n  }\n\n  // Check if there's a lower priority update somewhere else in the tree.\n  if (\n    workInProgressRootNextUnprocessedUpdateTime !== NoWork &&\n    workInProgressRoot !== null\n  ) {\n    // Mark the current render as suspended, and then mark that there's a\n    // pending update.\n    // TODO: This should immediately interrupt the current render, instead\n    // of waiting until the next time we yield.\n    markRootSuspendedAtTime(workInProgressRoot, renderExpirationTime);\n    markRootUpdatedAtTime(\n      workInProgressRoot,\n      workInProgressRootNextUnprocessedUpdateTime,\n    );\n  }\n}\n\nexport function renderDidError() {\n  if (workInProgressRootExitStatus !== RootCompleted) {\n    workInProgressRootExitStatus = RootErrored;\n  }\n}\n\n// Called during render to determine if anything has suspended.\n// Returns false if we're not sure.\nexport function renderHasNotSuspendedYet(): boolean {\n  // If something errored or completed, we can't really be sure,\n  // so those are false.\n  return workInProgressRootExitStatus === RootIncomplete;\n}\n\nfunction inferTimeFromExpirationTime(expirationTime: ExpirationTime): number {\n  // We don't know exactly when the update was scheduled, but we can infer an\n  // approximate start time from the expiration time.\n  const earliestExpirationTimeMs = expirationTimeToMs(expirationTime);\n  return earliestExpirationTimeMs - LOW_PRIORITY_EXPIRATION;\n}\n\nfunction inferTimeFromExpirationTimeWithSuspenseConfig(\n  expirationTime: ExpirationTime,\n  suspenseConfig: SuspenseConfig,\n): number {\n  // We don't know exactly when the update was scheduled, but we can infer an\n  // approximate start time from the expiration time by subtracting the timeout\n  // that was added to the event time.\n  const earliestExpirationTimeMs = expirationTimeToMs(expirationTime);\n  return (\n    earliestExpirationTimeMs -\n    (suspenseConfig.timeoutMs | 0 || LOW_PRIORITY_EXPIRATION)\n  );\n}\n\nfunction workLoopSync() {\n  // Already timed out, so perform work without checking if we need to yield.\n  while (workInProgress !== null) {\n    workInProgress = performUnitOfWork(workInProgress);\n  }\n}\n\nfunction workLoop() {\n  // Perform work until Scheduler asks us to yield\n  while (workInProgress !== null && !shouldYield()) {\n    workInProgress = performUnitOfWork(workInProgress);\n  }\n}\n\nfunction performUnitOfWork(unitOfWork: Fiber): Fiber | null {\n  // The current, flushed, state of this fiber is the alternate. Ideally\n  // nothing should rely on this, but relying on it here means that we don't\n  // need an additional field on the work in progress.\n  const current = unitOfWork.alternate;\n\n  startWorkTimer(unitOfWork);\n  setCurrentDebugFiberInDEV(unitOfWork);\n\n  let next;\n  if (enableProfilerTimer && (unitOfWork.mode & ProfileMode) !== NoMode) {\n    startProfilerTimer(unitOfWork);\n    next = beginWork(current, unitOfWork, renderExpirationTime);\n    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\n  } else {\n    next = beginWork(current, unitOfWork, renderExpirationTime);\n  }\n\n  resetCurrentDebugFiberInDEV();\n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\n  if (next === null) {\n    // If this doesn't spawn new work, complete the current work.\n    next = completeUnitOfWork(unitOfWork);\n  }\n\n  ReactCurrentOwner.current = null;\n  return next;\n}\n\nfunction completeUnitOfWork(unitOfWork: Fiber): Fiber | null {\n  // Attempt to complete the current unit of work, then move to the next\n  // sibling. If there are no more siblings, return to the parent fiber.\n  workInProgress = unitOfWork;\n  do {\n    // The current, flushed, state of this fiber is the alternate. Ideally\n    // nothing should rely on this, but relying on it here means that we don't\n    // need an additional field on the work in progress.\n    const current = workInProgress.alternate;\n    const returnFiber = workInProgress.return;\n\n    // Check if the work completed or if something threw.\n    if ((workInProgress.effectTag & Incomplete) === NoEffect) {\n      setCurrentDebugFiberInDEV(workInProgress);\n      let next;\n      if (\n        !enableProfilerTimer ||\n        (workInProgress.mode & ProfileMode) === NoMode\n      ) {\n        next = completeWork(current, workInProgress, renderExpirationTime);\n      } else {\n        startProfilerTimer(workInProgress);\n        next = completeWork(current, workInProgress, renderExpirationTime);\n        // Update render duration assuming we didn't error.\n        stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false);\n      }\n      stopWorkTimer(workInProgress);\n      resetCurrentDebugFiberInDEV();\n      resetChildExpirationTime(workInProgress);\n\n      if (next !== null) {\n        // Completing this fiber spawned new work. Work on that next.\n        return next;\n      }\n\n      if (\n        returnFiber !== null &&\n        // Do not append effects to parents if a sibling failed to complete\n        (returnFiber.effectTag & Incomplete) === NoEffect\n      ) {\n        // Append all the effects of the subtree and this fiber onto the effect\n        // list of the parent. The completion order of the children affects the\n        // side-effect order.\n        if (returnFiber.firstEffect === null) {\n          returnFiber.firstEffect = workInProgress.firstEffect;\n        }\n        if (workInProgress.lastEffect !== null) {\n          if (returnFiber.lastEffect !== null) {\n            returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;\n          }\n          returnFiber.lastEffect = workInProgress.lastEffect;\n        }\n\n        // If this fiber had side-effects, we append it AFTER the children's\n        // side-effects. We can perform certain side-effects earlier if needed,\n        // by doing multiple passes over the effect list. We don't want to\n        // schedule our own side-effect on our own list because if end up\n        // reusing children we'll schedule this effect onto itself since we're\n        // at the end.\n        const effectTag = workInProgress.effectTag;\n\n        // Skip both NoWork and PerformedWork tags when creating the effect\n        // list. PerformedWork effect is read by React DevTools but shouldn't be\n        // committed.\n        if (effectTag > PerformedWork) {\n          if (returnFiber.lastEffect !== null) {\n            returnFiber.lastEffect.nextEffect = workInProgress;\n          } else {\n            returnFiber.firstEffect = workInProgress;\n          }\n          returnFiber.lastEffect = workInProgress;\n        }\n      }\n    } else {\n      // This fiber did not complete because something threw. Pop values off\n      // the stack without entering the complete phase. If this is a boundary,\n      // capture values if possible.\n      const next = unwindWork(workInProgress, renderExpirationTime);\n\n      // Because this fiber did not complete, don't reset its expiration time.\n\n      if (\n        enableProfilerTimer &&\n        (workInProgress.mode & ProfileMode) !== NoMode\n      ) {\n        // Record the render duration for the fiber that errored.\n        stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false);\n\n        // Include the time spent working on failed children before continuing.\n        let actualDuration = workInProgress.actualDuration;\n        let child = workInProgress.child;\n        while (child !== null) {\n          actualDuration += child.actualDuration;\n          child = child.sibling;\n        }\n        workInProgress.actualDuration = actualDuration;\n      }\n\n      if (next !== null) {\n        // If completing this work spawned new work, do that next. We'll come\n        // back here again.\n        // Since we're restarting, remove anything that is not a host effect\n        // from the effect tag.\n        // TODO: The name stopFailedWorkTimer is misleading because Suspense\n        // also captures and restarts.\n        stopFailedWorkTimer(workInProgress);\n        next.effectTag &= HostEffectMask;\n        return next;\n      }\n      stopWorkTimer(workInProgress);\n\n      if (returnFiber !== null) {\n        // Mark the parent fiber as incomplete and clear its effect list.\n        returnFiber.firstEffect = returnFiber.lastEffect = null;\n        returnFiber.effectTag |= Incomplete;\n      }\n    }\n\n    const siblingFiber = workInProgress.sibling;\n    if (siblingFiber !== null) {\n      // If there is more work to do in this returnFiber, do that next.\n      return siblingFiber;\n    }\n    // Otherwise, return to the parent\n    workInProgress = returnFiber;\n  } while (workInProgress !== null);\n\n  // We've reached the root.\n  if (workInProgressRootExitStatus === RootIncomplete) {\n    workInProgressRootExitStatus = RootCompleted;\n  }\n  return null;\n}\n\nfunction getRemainingExpirationTime(fiber: Fiber) {\n  const updateExpirationTime = fiber.expirationTime;\n  const childExpirationTime = fiber.childExpirationTime;\n  return updateExpirationTime > childExpirationTime\n    ? updateExpirationTime\n    : childExpirationTime;\n}\n\nfunction resetChildExpirationTime(completedWork: Fiber) {\n  if (\n    renderExpirationTime !== Never &&\n    completedWork.childExpirationTime === Never\n  ) {\n    // The children of this component are hidden. Don't bubble their\n    // expiration times.\n    return;\n  }\n\n  let newChildExpirationTime = NoWork;\n\n  // Bubble up the earliest expiration time.\n  if (enableProfilerTimer && (completedWork.mode & ProfileMode) !== NoMode) {\n    // In profiling mode, resetChildExpirationTime is also used to reset\n    // profiler durations.\n    let actualDuration = completedWork.actualDuration;\n    let treeBaseDuration = completedWork.selfBaseDuration;\n\n    // When a fiber is cloned, its actualDuration is reset to 0. This value will\n    // only be updated if work is done on the fiber (i.e. it doesn't bailout).\n    // When work is done, it should bubble to the parent's actualDuration. If\n    // the fiber has not been cloned though, (meaning no work was done), then\n    // this value will reflect the amount of time spent working on a previous\n    // render. In that case it should not bubble. We determine whether it was\n    // cloned by comparing the child pointer.\n    const shouldBubbleActualDurations =\n      completedWork.alternate === null ||\n      completedWork.child !== completedWork.alternate.child;\n\n    let child = completedWork.child;\n    while (child !== null) {\n      const childUpdateExpirationTime = child.expirationTime;\n      const childChildExpirationTime = child.childExpirationTime;\n      if (childUpdateExpirationTime > newChildExpirationTime) {\n        newChildExpirationTime = childUpdateExpirationTime;\n      }\n      if (childChildExpirationTime > newChildExpirationTime) {\n        newChildExpirationTime = childChildExpirationTime;\n      }\n      if (shouldBubbleActualDurations) {\n        actualDuration += child.actualDuration;\n      }\n      treeBaseDuration += child.treeBaseDuration;\n      child = child.sibling;\n    }\n    completedWork.actualDuration = actualDuration;\n    completedWork.treeBaseDuration = treeBaseDuration;\n  } else {\n    let child = completedWork.child;\n    while (child !== null) {\n      const childUpdateExpirationTime = child.expirationTime;\n      const childChildExpirationTime = child.childExpirationTime;\n      if (childUpdateExpirationTime > newChildExpirationTime) {\n        newChildExpirationTime = childUpdateExpirationTime;\n      }\n      if (childChildExpirationTime > newChildExpirationTime) {\n        newChildExpirationTime = childChildExpirationTime;\n      }\n      child = child.sibling;\n    }\n  }\n\n  completedWork.childExpirationTime = newChildExpirationTime;\n}\n\nfunction commitRoot(root) {\n  const renderPriorityLevel = getCurrentPriorityLevel();\n  runWithPriority(\n    ImmediatePriority,\n    commitRootImpl.bind(null, root, renderPriorityLevel),\n  );\n  return null;\n}\n\nfunction commitRootImpl(root, renderPriorityLevel) {\n  flushPassiveEffects();\n  flushRenderPhaseStrictModeWarningsInDEV();\n\n  invariant(\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\n    'Should not already be working.',\n  );\n\n  const finishedWork = root.finishedWork;\n  const expirationTime = root.finishedExpirationTime;\n  if (finishedWork === null) {\n    return null;\n  }\n  root.finishedWork = null;\n  root.finishedExpirationTime = NoWork;\n\n  invariant(\n    finishedWork !== root.current,\n    'Cannot commit the same tree as before. This error is likely caused by ' +\n      'a bug in React. Please file an issue.',\n  );\n\n  // commitRoot never returns a continuation; it always finishes synchronously.\n  // So we can clear these now to allow a new callback to be scheduled.\n  root.callbackNode = null;\n  root.callbackExpirationTime = NoWork;\n  root.callbackPriority = NoPriority;\n  root.nextKnownPendingLevel = NoWork;\n\n  startCommitTimer();\n\n  // Update the first and last pending times on this root. The new first\n  // pending time is whatever is left on the root fiber.\n  const remainingExpirationTimeBeforeCommit = getRemainingExpirationTime(\n    finishedWork,\n  );\n  markRootFinishedAtTime(\n    root,\n    expirationTime,\n    remainingExpirationTimeBeforeCommit,\n  );\n\n  if (root === workInProgressRoot) {\n    // We can reset these now that they are finished.\n    workInProgressRoot = null;\n    workInProgress = null;\n    renderExpirationTime = NoWork;\n  } else {\n    // This indicates that the last root we worked on is not the same one that\n    // we're committing now. This most commonly happens when a suspended root\n    // times out.\n  }\n\n  // Get the list of effects.\n  let firstEffect;\n  if (finishedWork.effectTag > PerformedWork) {\n    // A fiber's effect list consists only of its children, not itself. So if\n    // the root has an effect, we need to add it to the end of the list. The\n    // resulting list is the set that would belong to the root's parent, if it\n    // had one; that is, all the effects in the tree including the root.\n    if (finishedWork.lastEffect !== null) {\n      finishedWork.lastEffect.nextEffect = finishedWork;\n      firstEffect = finishedWork.firstEffect;\n    } else {\n      firstEffect = finishedWork;\n    }\n  } else {\n    // There is no effect on the root.\n    firstEffect = finishedWork.firstEffect;\n  }\n\n  if (firstEffect !== null) {\n    const prevExecutionContext = executionContext;\n    executionContext |= CommitContext;\n    let prevInteractions: Set<Interaction> | null = null;\n    if (enableSchedulerTracing) {\n      prevInteractions = __interactionsRef.current;\n      __interactionsRef.current = root.memoizedInteractions;\n    }\n\n    // Reset this to null before calling lifecycles\n    ReactCurrentOwner.current = null;\n\n    // The commit phase is broken into several sub-phases. We do a separate pass\n    // of the effect list for each phase: all mutation effects come before all\n    // layout effects, and so on.\n\n    // The first phase a \"before mutation\" phase. We use this phase to read the\n    // state of the host tree right before we mutate it. This is where\n    // getSnapshotBeforeUpdate is called.\n    startCommitSnapshotEffectsTimer();\n    prepareForCommit(root.containerInfo);\n    nextEffect = firstEffect;\n    do {\n      if (__DEV__) {\n        invokeGuardedCallback(null, commitBeforeMutationEffects, null);\n        if (hasCaughtError()) {\n          invariant(nextEffect !== null, 'Should be working on an effect.');\n          const error = clearCaughtError();\n          captureCommitPhaseError(nextEffect, error);\n          nextEffect = nextEffect.nextEffect;\n        }\n      } else {\n        try {\n          commitBeforeMutationEffects();\n        } catch (error) {\n          invariant(nextEffect !== null, 'Should be working on an effect.');\n          captureCommitPhaseError(nextEffect, error);\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    } while (nextEffect !== null);\n    stopCommitSnapshotEffectsTimer();\n\n    if (enableProfilerTimer) {\n      // Mark the current commit time to be shared by all Profilers in this\n      // batch. This enables them to be grouped later.\n      recordCommitTime();\n    }\n\n    // The next phase is the mutation phase, where we mutate the host tree.\n    startCommitHostEffectsTimer();\n    nextEffect = firstEffect;\n    do {\n      if (__DEV__) {\n        invokeGuardedCallback(\n          null,\n          commitMutationEffects,\n          null,\n          root,\n          renderPriorityLevel,\n        );\n        if (hasCaughtError()) {\n          invariant(nextEffect !== null, 'Should be working on an effect.');\n          const error = clearCaughtError();\n          captureCommitPhaseError(nextEffect, error);\n          nextEffect = nextEffect.nextEffect;\n        }\n      } else {\n        try {\n          commitMutationEffects(root, renderPriorityLevel);\n        } catch (error) {\n          invariant(nextEffect !== null, 'Should be working on an effect.');\n          captureCommitPhaseError(nextEffect, error);\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    } while (nextEffect !== null);\n    stopCommitHostEffectsTimer();\n    resetAfterCommit(root.containerInfo);\n\n    // The work-in-progress tree is now the current tree. This must come after\n    // the mutation phase, so that the previous tree is still current during\n    // componentWillUnmount, but before the layout phase, so that the finished\n    // work is current during componentDidMount/Update.\n    root.current = finishedWork;\n\n    // The next phase is the layout phase, where we call effects that read\n    // the host tree after it's been mutated. The idiomatic use case for this is\n    // layout, but class component lifecycles also fire here for legacy reasons.\n    startCommitLifeCyclesTimer();\n    nextEffect = firstEffect;\n    do {\n      if (__DEV__) {\n        invokeGuardedCallback(\n          null,\n          commitLayoutEffects,\n          null,\n          root,\n          expirationTime,\n        );\n        if (hasCaughtError()) {\n          invariant(nextEffect !== null, 'Should be working on an effect.');\n          const error = clearCaughtError();\n          captureCommitPhaseError(nextEffect, error);\n          nextEffect = nextEffect.nextEffect;\n        }\n      } else {\n        try {\n          commitLayoutEffects(root, expirationTime);\n        } catch (error) {\n          invariant(nextEffect !== null, 'Should be working on an effect.');\n          captureCommitPhaseError(nextEffect, error);\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    } while (nextEffect !== null);\n    stopCommitLifeCyclesTimer();\n\n    nextEffect = null;\n\n    // Tell Scheduler to yield at the end of the frame, so the browser has an\n    // opportunity to paint.\n    requestPaint();\n\n    if (enableSchedulerTracing) {\n      __interactionsRef.current = ((prevInteractions: any): Set<Interaction>);\n    }\n    executionContext = prevExecutionContext;\n  } else {\n    // No effects.\n    root.current = finishedWork;\n    // Measure these anyway so the flamegraph explicitly shows that there were\n    // no effects.\n    // TODO: Maybe there's a better way to report this.\n    startCommitSnapshotEffectsTimer();\n    stopCommitSnapshotEffectsTimer();\n    if (enableProfilerTimer) {\n      recordCommitTime();\n    }\n    startCommitHostEffectsTimer();\n    stopCommitHostEffectsTimer();\n    startCommitLifeCyclesTimer();\n    stopCommitLifeCyclesTimer();\n  }\n\n  stopCommitTimer();\n\n  const rootDidHavePassiveEffects = rootDoesHavePassiveEffects;\n\n  if (rootDoesHavePassiveEffects) {\n    // This commit has passive effects. Stash a reference to them. But don't\n    // schedule a callback until after flushing layout work.\n    rootDoesHavePassiveEffects = false;\n    rootWithPendingPassiveEffects = root;\n    pendingPassiveEffectsExpirationTime = expirationTime;\n    pendingPassiveEffectsRenderPriority = renderPriorityLevel;\n  } else {\n    // We are done with the effect chain at this point so let's clear the\n    // nextEffect pointers to assist with GC. If we have passive effects, we'll\n    // clear this in flushPassiveEffects.\n    nextEffect = firstEffect;\n    while (nextEffect !== null) {\n      const nextNextEffect = nextEffect.nextEffect;\n      nextEffect.nextEffect = null;\n      nextEffect = nextNextEffect;\n    }\n  }\n\n  // Check if there's remaining work on this root\n  const remainingExpirationTime = root.firstPendingTime;\n  if (remainingExpirationTime !== NoWork) {\n    if (enableSchedulerTracing) {\n      if (spawnedWorkDuringRender !== null) {\n        const expirationTimes = spawnedWorkDuringRender;\n        spawnedWorkDuringRender = null;\n        for (let i = 0; i < expirationTimes.length; i++) {\n          scheduleInteractions(\n            root,\n            expirationTimes[i],\n            root.memoizedInteractions,\n          );\n        }\n      }\n      schedulePendingInteractions(root, remainingExpirationTime);\n    }\n  } else {\n    // If there's no remaining work, we can clear the set of already failed\n    // error boundaries.\n    legacyErrorBoundariesThatAlreadyFailed = null;\n  }\n\n  if (enableSchedulerTracing) {\n    if (!rootDidHavePassiveEffects) {\n      // If there are no passive effects, then we can complete the pending interactions.\n      // Otherwise, we'll wait until after the passive effects are flushed.\n      // Wait to do this until after remaining work has been scheduled,\n      // so that we don't prematurely signal complete for interactions when there's e.g. hidden work.\n      finishPendingInteractions(root, expirationTime);\n    }\n  }\n\n  if (remainingExpirationTime === Sync) {\n    // Count the number of times the root synchronously re-renders without\n    // finishing. If there are too many, it indicates an infinite update loop.\n    if (root === rootWithNestedUpdates) {\n      nestedUpdateCount++;\n    } else {\n      nestedUpdateCount = 0;\n      rootWithNestedUpdates = root;\n    }\n  } else {\n    nestedUpdateCount = 0;\n  }\n\n  onCommitRoot(finishedWork.stateNode, expirationTime);\n\n  // Always call this before exiting `commitRoot`, to ensure that any\n  // additional work on this root is scheduled.\n  ensureRootIsScheduled(root);\n\n  if (hasUncaughtError) {\n    hasUncaughtError = false;\n    const error = firstUncaughtError;\n    firstUncaughtError = null;\n    throw error;\n  }\n\n  if ((executionContext & LegacyUnbatchedContext) !== NoContext) {\n    // This is a legacy edge case. We just committed the initial mount of\n    // a ReactDOM.render-ed root inside of batchedUpdates. The commit fired\n    // synchronously, but layout updates should be deferred until the end\n    // of the batch.\n    return null;\n  }\n\n  // If layout work was scheduled, flush it now.\n  flushSyncCallbackQueue();\n  return null;\n}\n\nfunction commitBeforeMutationEffects() {\n  while (nextEffect !== null) {\n    const effectTag = nextEffect.effectTag;\n    if ((effectTag & Snapshot) !== NoEffect) {\n      setCurrentDebugFiberInDEV(nextEffect);\n      recordEffect();\n\n      const current = nextEffect.alternate;\n      commitBeforeMutationEffectOnFiber(current, nextEffect);\n\n      resetCurrentDebugFiberInDEV();\n    }\n    if ((effectTag & Passive) !== NoEffect) {\n      // If there are passive effects, schedule a callback to flush at\n      // the earliest opportunity.\n      if (!rootDoesHavePassiveEffects) {\n        rootDoesHavePassiveEffects = true;\n        scheduleCallback(NormalPriority, () => {\n          flushPassiveEffects();\n          return null;\n        });\n      }\n    }\n    nextEffect = nextEffect.nextEffect;\n  }\n}\n\nfunction commitMutationEffects(root: FiberRoot, renderPriorityLevel) {\n  // TODO: Should probably move the bulk of this function to commitWork.\n  while (nextEffect !== null) {\n    setCurrentDebugFiberInDEV(nextEffect);\n\n    const effectTag = nextEffect.effectTag;\n\n    if (effectTag & ContentReset) {\n      commitResetTextContent(nextEffect);\n    }\n\n    if (effectTag & Ref) {\n      const current = nextEffect.alternate;\n      if (current !== null) {\n        commitDetachRef(current);\n      }\n    }\n\n    // The following switch statement is only concerned about placement,\n    // updates, and deletions. To avoid needing to add a case for every possible\n    // bitmap value, we remove the secondary effects from the effect tag and\n    // switch on that value.\n    let primaryEffectTag =\n      effectTag & (Placement | Update | Deletion | Hydrating);\n    switch (primaryEffectTag) {\n      case Placement: {\n        commitPlacement(nextEffect);\n        // Clear the \"placement\" from effect tag so that we know that this is\n        // inserted, before any life-cycles like componentDidMount gets called.\n        // TODO: findDOMNode doesn't rely on this any more but isMounted does\n        // and isMounted is deprecated anyway so we should be able to kill this.\n        nextEffect.effectTag &= ~Placement;\n        break;\n      }\n      case PlacementAndUpdate: {\n        // Placement\n        commitPlacement(nextEffect);\n        // Clear the \"placement\" from effect tag so that we know that this is\n        // inserted, before any life-cycles like componentDidMount gets called.\n        nextEffect.effectTag &= ~Placement;\n\n        // Update\n        const current = nextEffect.alternate;\n        commitWork(current, nextEffect);\n        break;\n      }\n      case Hydrating: {\n        nextEffect.effectTag &= ~Hydrating;\n        break;\n      }\n      case HydratingAndUpdate: {\n        nextEffect.effectTag &= ~Hydrating;\n\n        // Update\n        const current = nextEffect.alternate;\n        commitWork(current, nextEffect);\n        break;\n      }\n      case Update: {\n        const current = nextEffect.alternate;\n        commitWork(current, nextEffect);\n        break;\n      }\n      case Deletion: {\n        commitDeletion(root, nextEffect, renderPriorityLevel);\n        break;\n      }\n    }\n\n    // TODO: Only record a mutation effect if primaryEffectTag is non-zero.\n    recordEffect();\n\n    resetCurrentDebugFiberInDEV();\n    nextEffect = nextEffect.nextEffect;\n  }\n}\n\nfunction commitLayoutEffects(\n  root: FiberRoot,\n  committedExpirationTime: ExpirationTime,\n) {\n  // TODO: Should probably move the bulk of this function to commitWork.\n  while (nextEffect !== null) {\n    setCurrentDebugFiberInDEV(nextEffect);\n\n    const effectTag = nextEffect.effectTag;\n\n    if (effectTag & (Update | Callback)) {\n      recordEffect();\n      const current = nextEffect.alternate;\n      commitLayoutEffectOnFiber(\n        root,\n        current,\n        nextEffect,\n        committedExpirationTime,\n      );\n    }\n\n    if (effectTag & Ref) {\n      recordEffect();\n      commitAttachRef(nextEffect);\n    }\n\n    resetCurrentDebugFiberInDEV();\n    nextEffect = nextEffect.nextEffect;\n  }\n}\n\nexport function flushPassiveEffects() {\n  if (rootWithPendingPassiveEffects === null) {\n    return false;\n  }\n  const root = rootWithPendingPassiveEffects;\n  const expirationTime = pendingPassiveEffectsExpirationTime;\n  const renderPriorityLevel = pendingPassiveEffectsRenderPriority;\n  rootWithPendingPassiveEffects = null;\n  pendingPassiveEffectsExpirationTime = NoWork;\n  pendingPassiveEffectsRenderPriority = NoPriority;\n  const priorityLevel =\n    renderPriorityLevel > NormalPriority ? NormalPriority : renderPriorityLevel;\n  return runWithPriority(\n    priorityLevel,\n    flushPassiveEffectsImpl.bind(null, root, expirationTime),\n  );\n}\n\nfunction flushPassiveEffectsImpl(root, expirationTime) {\n  let prevInteractions: Set<Interaction> | null = null;\n  if (enableSchedulerTracing) {\n    prevInteractions = __interactionsRef.current;\n    __interactionsRef.current = root.memoizedInteractions;\n  }\n\n  invariant(\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\n    'Cannot flush passive effects while already rendering.',\n  );\n  const prevExecutionContext = executionContext;\n  executionContext |= CommitContext;\n\n  // Note: This currently assumes there are no passive effects on the root\n  // fiber, because the root is not part of its own effect list. This could\n  // change in the future.\n  let effect = root.current.firstEffect;\n  while (effect !== null) {\n    if (__DEV__) {\n      setCurrentDebugFiberInDEV(effect);\n      invokeGuardedCallback(null, commitPassiveHookEffects, null, effect);\n      if (hasCaughtError()) {\n        invariant(effect !== null, 'Should be working on an effect.');\n        const error = clearCaughtError();\n        captureCommitPhaseError(effect, error);\n      }\n      resetCurrentDebugFiberInDEV();\n    } else {\n      try {\n        commitPassiveHookEffects(effect);\n      } catch (error) {\n        invariant(effect !== null, 'Should be working on an effect.');\n        captureCommitPhaseError(effect, error);\n      }\n    }\n    const nextNextEffect = effect.nextEffect;\n    // Remove nextEffect pointer to assist GC\n    effect.nextEffect = null;\n    effect = nextNextEffect;\n  }\n\n  if (enableSchedulerTracing) {\n    __interactionsRef.current = ((prevInteractions: any): Set<Interaction>);\n    finishPendingInteractions(root, expirationTime);\n  }\n\n  executionContext = prevExecutionContext;\n  flushSyncCallbackQueue();\n\n  // If additional passive effects were scheduled, increment a counter. If this\n  // exceeds the limit, we'll fire a warning.\n  nestedPassiveUpdateCount =\n    rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1;\n\n  return true;\n}\n\nexport function isAlreadyFailedLegacyErrorBoundary(instance: mixed): boolean {\n  return (\n    legacyErrorBoundariesThatAlreadyFailed !== null &&\n    legacyErrorBoundariesThatAlreadyFailed.has(instance)\n  );\n}\n\nexport function markLegacyErrorBoundaryAsFailed(instance: mixed) {\n  if (legacyErrorBoundariesThatAlreadyFailed === null) {\n    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);\n  } else {\n    legacyErrorBoundariesThatAlreadyFailed.add(instance);\n  }\n}\n\nfunction prepareToThrowUncaughtError(error: mixed) {\n  if (!hasUncaughtError) {\n    hasUncaughtError = true;\n    firstUncaughtError = error;\n  }\n}\nexport const onUncaughtError = prepareToThrowUncaughtError;\n\nfunction captureCommitPhaseErrorOnRoot(\n  rootFiber: Fiber,\n  sourceFiber: Fiber,\n  error: mixed,\n) {\n  const errorInfo = createCapturedValue(error, sourceFiber);\n  const update = createRootErrorUpdate(rootFiber, errorInfo, Sync);\n  enqueueUpdate(rootFiber, update);\n  const root = markUpdateTimeFromFiberToRoot(rootFiber, Sync);\n  if (root !== null) {\n    ensureRootIsScheduled(root);\n    schedulePendingInteractions(root, Sync);\n  }\n}\n\nexport function captureCommitPhaseError(sourceFiber: Fiber, error: mixed) {\n  if (sourceFiber.tag === HostRoot) {\n    // Error was thrown at the root. There is no parent, so the root\n    // itself should capture it.\n    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);\n    return;\n  }\n\n  let fiber = sourceFiber.return;\n  while (fiber !== null) {\n    if (fiber.tag === HostRoot) {\n      captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error);\n      return;\n    } else if (fiber.tag === ClassComponent) {\n      const ctor = fiber.type;\n      const instance = fiber.stateNode;\n      if (\n        typeof ctor.getDerivedStateFromError === 'function' ||\n        (typeof instance.componentDidCatch === 'function' &&\n          !isAlreadyFailedLegacyErrorBoundary(instance))\n      ) {\n        const errorInfo = createCapturedValue(error, sourceFiber);\n        const update = createClassErrorUpdate(\n          fiber,\n          errorInfo,\n          // TODO: This is always sync\n          Sync,\n        );\n        enqueueUpdate(fiber, update);\n        const root = markUpdateTimeFromFiberToRoot(fiber, Sync);\n        if (root !== null) {\n          ensureRootIsScheduled(root);\n          schedulePendingInteractions(root, Sync);\n        }\n        return;\n      }\n    }\n    fiber = fiber.return;\n  }\n}\n\nexport function pingSuspendedRoot(\n  root: FiberRoot,\n  thenable: Thenable,\n  suspendedTime: ExpirationTime,\n) {\n  const pingCache = root.pingCache;\n  if (pingCache !== null) {\n    // The thenable resolved, so we no longer need to memoize, because it will\n    // never be thrown again.\n    pingCache.delete(thenable);\n  }\n\n  if (workInProgressRoot === root && renderExpirationTime === suspendedTime) {\n    // Received a ping at the same priority level at which we're currently\n    // rendering. We might want to restart this render. This should mirror\n    // the logic of whether or not a root suspends once it completes.\n\n    // TODO: If we're rendering sync either due to Sync, Batched or expired,\n    // we should probably never restart.\n\n    // If we're suspended with delay, we'll always suspend so we can always\n    // restart. If we're suspended without any updates, it might be a retry.\n    // If it's early in the retry we can restart. We can't know for sure\n    // whether we'll eventually process an update during this render pass,\n    // but it's somewhat unlikely that we get to a ping before that, since\n    // getting to the root most update is usually very fast.\n    if (\n      workInProgressRootExitStatus === RootSuspendedWithDelay ||\n      (workInProgressRootExitStatus === RootSuspended &&\n        workInProgressRootLatestProcessedExpirationTime === Sync &&\n        now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS)\n    ) {\n      // Restart from the root. Don't need to schedule a ping because\n      // we're already working on this tree.\n      prepareFreshStack(root, renderExpirationTime);\n    } else {\n      // Even though we can't restart right now, we might get an\n      // opportunity later. So we mark this render as having a ping.\n      workInProgressRootHasPendingPing = true;\n    }\n    return;\n  }\n\n  if (!isRootSuspendedAtTime(root, suspendedTime)) {\n    // The root is no longer suspended at this time.\n    return;\n  }\n\n  const lastPingedTime = root.lastPingedTime;\n  if (lastPingedTime !== NoWork && lastPingedTime < suspendedTime) {\n    // There's already a lower priority ping scheduled.\n    return;\n  }\n\n  // Mark the time at which this ping was scheduled.\n  root.lastPingedTime = suspendedTime;\n\n  if (root.finishedExpirationTime === suspendedTime) {\n    // If there's a pending fallback waiting to commit, throw it away.\n    root.finishedExpirationTime = NoWork;\n    root.finishedWork = null;\n  }\n\n  ensureRootIsScheduled(root);\n  schedulePendingInteractions(root, suspendedTime);\n}\n\nfunction retryTimedOutBoundary(\n  boundaryFiber: Fiber,\n  retryTime: ExpirationTime,\n) {\n  // The boundary fiber (a Suspense component or SuspenseList component)\n  // previously was rendered in its fallback state. One of the promises that\n  // suspended it has resolved, which means at least part of the tree was\n  // likely unblocked. Try rendering again, at a new expiration time.\n  if (retryTime === Never) {\n    const suspenseConfig = null; // Retries don't carry over the already committed update.\n    const currentTime = requestCurrentTime();\n    retryTime = computeExpirationForFiber(\n      currentTime,\n      boundaryFiber,\n      suspenseConfig,\n    );\n  }\n  // TODO: Special case idle priority?\n  const root = markUpdateTimeFromFiberToRoot(boundaryFiber, retryTime);\n  if (root !== null) {\n    ensureRootIsScheduled(root);\n    schedulePendingInteractions(root, retryTime);\n  }\n}\n\nexport function retryDehydratedSuspenseBoundary(boundaryFiber: Fiber) {\n  const suspenseState: null | SuspenseState = boundaryFiber.memoizedState;\n  let retryTime = Never;\n  if (suspenseState !== null) {\n    retryTime = suspenseState.retryTime;\n  }\n  retryTimedOutBoundary(boundaryFiber, retryTime);\n}\n\nexport function resolveRetryThenable(boundaryFiber: Fiber, thenable: Thenable) {\n  let retryTime = Never; // Default\n  let retryCache: WeakSet<Thenable> | Set<Thenable> | null;\n  if (enableSuspenseServerRenderer) {\n    switch (boundaryFiber.tag) {\n      case SuspenseComponent:\n        retryCache = boundaryFiber.stateNode;\n        const suspenseState: null | SuspenseState = boundaryFiber.memoizedState;\n        if (suspenseState !== null) {\n          retryTime = suspenseState.retryTime;\n        }\n        break;\n      case SuspenseListComponent:\n        retryCache = boundaryFiber.stateNode;\n        break;\n      default:\n        invariant(\n          false,\n          'Pinged unknown suspense boundary type. ' +\n            'This is probably a bug in React.',\n        );\n    }\n  } else {\n    retryCache = boundaryFiber.stateNode;\n  }\n\n  if (retryCache !== null) {\n    // The thenable resolved, so we no longer need to memoize, because it will\n    // never be thrown again.\n    retryCache.delete(thenable);\n  }\n\n  retryTimedOutBoundary(boundaryFiber, retryTime);\n}\n\n// Computes the next Just Noticeable Difference (JND) boundary.\n// The theory is that a person can't tell the difference between small differences in time.\n// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable\n// difference in the experience. However, waiting for longer might mean that we can avoid\n// showing an intermediate loading state. The longer we have already waited, the harder it\n// is to tell small differences in time. Therefore, the longer we've already waited,\n// the longer we can wait additionally. At some point we have to give up though.\n// We pick a train model where the next boundary commits at a consistent schedule.\n// These particular numbers are vague estimates. We expect to adjust them based on research.\nfunction jnd(timeElapsed: number) {\n  return timeElapsed < 120\n    ? 120\n    : timeElapsed < 480\n      ? 480\n      : timeElapsed < 1080\n        ? 1080\n        : timeElapsed < 1920\n          ? 1920\n          : timeElapsed < 3000\n            ? 3000\n            : timeElapsed < 4320\n              ? 4320\n              : ceil(timeElapsed / 1960) * 1960;\n}\n\nfunction computeMsUntilSuspenseLoadingDelay(\n  mostRecentEventTime: ExpirationTime,\n  committedExpirationTime: ExpirationTime,\n  suspenseConfig: SuspenseConfig,\n) {\n  const busyMinDurationMs = (suspenseConfig.busyMinDurationMs: any) | 0;\n  if (busyMinDurationMs <= 0) {\n    return 0;\n  }\n  const busyDelayMs = (suspenseConfig.busyDelayMs: any) | 0;\n\n  // Compute the time until this render pass would expire.\n  const currentTimeMs: number = now();\n  const eventTimeMs: number = inferTimeFromExpirationTimeWithSuspenseConfig(\n    mostRecentEventTime,\n    suspenseConfig,\n  );\n  const timeElapsed = currentTimeMs - eventTimeMs;\n  if (timeElapsed <= busyDelayMs) {\n    // If we haven't yet waited longer than the initial delay, we don't\n    // have to wait any additional time.\n    return 0;\n  }\n  const msUntilTimeout = busyDelayMs + busyMinDurationMs - timeElapsed;\n  // This is the value that is passed to `setTimeout`.\n  return msUntilTimeout;\n}\n\nfunction checkForNestedUpdates() {\n  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n    nestedUpdateCount = 0;\n    rootWithNestedUpdates = null;\n    invariant(\n      false,\n      'Maximum update depth exceeded. This can happen when a component ' +\n        'repeatedly calls setState inside componentWillUpdate or ' +\n        'componentDidUpdate. React limits the number of nested updates to ' +\n        'prevent infinite loops.',\n    );\n  }\n\n  if (__DEV__) {\n    if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {\n      nestedPassiveUpdateCount = 0;\n      warning(\n        false,\n        'Maximum update depth exceeded. This can happen when a component ' +\n          \"calls setState inside useEffect, but useEffect either doesn't \" +\n          'have a dependency array, or one of the dependencies changes on ' +\n          'every render.',\n      );\n    }\n  }\n}\n\nfunction flushRenderPhaseStrictModeWarningsInDEV() {\n  if (__DEV__) {\n    ReactStrictModeWarnings.flushLegacyContextWarning();\n\n    if (warnAboutDeprecatedLifecycles) {\n      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\n    }\n  }\n}\n\nfunction stopFinishedWorkLoopTimer() {\n  const didCompleteRoot = true;\n  stopWorkLoopTimer(interruptedBy, didCompleteRoot);\n  interruptedBy = null;\n}\n\nfunction stopInterruptedWorkLoopTimer() {\n  // TODO: Track which fiber caused the interruption.\n  const didCompleteRoot = false;\n  stopWorkLoopTimer(interruptedBy, didCompleteRoot);\n  interruptedBy = null;\n}\n\nfunction checkForInterruption(\n  fiberThatReceivedUpdate: Fiber,\n  updateExpirationTime: ExpirationTime,\n) {\n  if (\n    enableUserTimingAPI &&\n    workInProgressRoot !== null &&\n    updateExpirationTime > renderExpirationTime\n  ) {\n    interruptedBy = fiberThatReceivedUpdate;\n  }\n}\n\nlet didWarnStateUpdateForUnmountedComponent: Set<string> | null = null;\nfunction warnAboutUpdateOnUnmountedFiberInDEV(fiber) {\n  if (__DEV__) {\n    const tag = fiber.tag;\n    if (\n      tag !== HostRoot &&\n      tag !== ClassComponent &&\n      tag !== FunctionComponent &&\n      tag !== ForwardRef &&\n      tag !== MemoComponent &&\n      tag !== SimpleMemoComponent\n    ) {\n      // Only warn for user-defined components, not internal ones like Suspense.\n      return;\n    }\n    // We show the whole stack but dedupe on the top component's name because\n    // the problematic code almost always lies inside that component.\n    const componentName = getComponentName(fiber.type) || 'ReactComponent';\n    if (didWarnStateUpdateForUnmountedComponent !== null) {\n      if (didWarnStateUpdateForUnmountedComponent.has(componentName)) {\n        return;\n      }\n      didWarnStateUpdateForUnmountedComponent.add(componentName);\n    } else {\n      didWarnStateUpdateForUnmountedComponent = new Set([componentName]);\n    }\n    warningWithoutStack(\n      false,\n      \"Can't perform a React state update on an unmounted component. This \" +\n        'is a no-op, but it indicates a memory leak in your application. To ' +\n        'fix, cancel all subscriptions and asynchronous tasks in %s.%s',\n      tag === ClassComponent\n        ? 'the componentWillUnmount method'\n        : 'a useEffect cleanup function',\n      getStackByFiberInDevAndProd(fiber),\n    );\n  }\n}\n\nlet beginWork;\nif (__DEV__ && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n  let dummyFiber = null;\n  beginWork = (current, unitOfWork, expirationTime) => {\n    // If a component throws an error, we replay it again in a synchronously\n    // dispatched event, so that the debugger will treat it as an uncaught\n    // error See ReactErrorUtils for more information.\n\n    // Before entering the begin phase, copy the work-in-progress onto a dummy\n    // fiber. If beginWork throws, we'll use this to reset the state.\n    const originalWorkInProgressCopy = assignFiberPropertiesInDEV(\n      dummyFiber,\n      unitOfWork,\n    );\n    try {\n      return originalBeginWork(current, unitOfWork, expirationTime);\n    } catch (originalError) {\n      if (\n        originalError !== null &&\n        typeof originalError === 'object' &&\n        typeof originalError.then === 'function'\n      ) {\n        // Don't replay promises. Treat everything else like an error.\n        throw originalError;\n      }\n\n      // Keep this code in sync with renderRoot; any changes here must have\n      // corresponding changes there.\n      resetContextDependencies();\n      resetHooks();\n\n      // Unwind the failed stack frame\n      unwindInterruptedWork(unitOfWork);\n\n      // Restore the original properties of the fiber.\n      assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);\n\n      if (enableProfilerTimer && unitOfWork.mode & ProfileMode) {\n        // Reset the profiler timer.\n        startProfilerTimer(unitOfWork);\n      }\n\n      // Run beginWork again.\n      invokeGuardedCallback(\n        null,\n        originalBeginWork,\n        null,\n        current,\n        unitOfWork,\n        expirationTime,\n      );\n\n      if (hasCaughtError()) {\n        const replayError = clearCaughtError();\n        // `invokeGuardedCallback` sometimes sets an expando `_suppressLogging`.\n        // Rethrow this error instead of the original one.\n        throw replayError;\n      } else {\n        // This branch is reachable if the render phase is impure.\n        throw originalError;\n      }\n    }\n  };\n} else {\n  beginWork = originalBeginWork;\n}\n\nlet didWarnAboutUpdateInRender = false;\nlet didWarnAboutUpdateInGetChildContext = false;\nfunction warnAboutInvalidUpdatesOnClassComponentsInDEV(fiber) {\n  if (__DEV__) {\n    if (fiber.tag === ClassComponent) {\n      switch (ReactCurrentDebugFiberPhaseInDEV) {\n        case 'getChildContext':\n          if (didWarnAboutUpdateInGetChildContext) {\n            return;\n          }\n          warningWithoutStack(\n            false,\n            'setState(...): Cannot call setState() inside getChildContext()',\n          );\n          didWarnAboutUpdateInGetChildContext = true;\n          break;\n        case 'render':\n          if (didWarnAboutUpdateInRender) {\n            return;\n          }\n          warningWithoutStack(\n            false,\n            'Cannot update during an existing state transition (such as ' +\n              'within `render`). Render methods should be a pure function of ' +\n              'props and state.',\n          );\n          didWarnAboutUpdateInRender = true;\n          break;\n      }\n    }\n  }\n}\n\n// a 'shared' variable that changes when act() opens/closes in tests.\nexport const IsThisRendererActing = {current: (false: boolean)};\n\nexport function warnIfNotScopedWithMatchingAct(fiber: Fiber): void {\n  if (__DEV__) {\n    if (\n      warnsIfNotActing === true &&\n      IsSomeRendererActing.current === true &&\n      IsThisRendererActing.current !== true\n    ) {\n      warningWithoutStack(\n        false,\n        \"It looks like you're using the wrong act() around your test interactions.\\n\" +\n          'Be sure to use the matching version of act() corresponding to your renderer:\\n\\n' +\n          '// for react-dom:\\n' +\n          \"import {act} from 'react-dom/test-utils';\\n\" +\n          '// ...\\n' +\n          'act(() => ...);\\n\\n' +\n          '// for react-test-renderer:\\n' +\n          \"import TestRenderer from 'react-test-renderer';\\n\" +\n          'const {act} = TestRenderer;\\n' +\n          '// ...\\n' +\n          'act(() => ...);' +\n          '%s',\n        getStackByFiberInDevAndProd(fiber),\n      );\n    }\n  }\n}\n\nexport function warnIfNotCurrentlyActingEffectsInDEV(fiber: Fiber): void {\n  if (__DEV__) {\n    if (\n      warnsIfNotActing === true &&\n      (fiber.mode & StrictMode) !== NoMode &&\n      IsSomeRendererActing.current === false &&\n      IsThisRendererActing.current === false\n    ) {\n      warningWithoutStack(\n        false,\n        'An update to %s ran an effect, but was not wrapped in act(...).\\n\\n' +\n          'When testing, code that causes React state updates should be ' +\n          'wrapped into act(...):\\n\\n' +\n          'act(() => {\\n' +\n          '  /* fire events that update state */\\n' +\n          '});\\n' +\n          '/* assert on the output */\\n\\n' +\n          \"This ensures that you're testing the behavior the user would see \" +\n          'in the browser.' +\n          ' Learn more at https://fb.me/react-wrap-tests-with-act' +\n          '%s',\n        getComponentName(fiber.type),\n        getStackByFiberInDevAndProd(fiber),\n      );\n    }\n  }\n}\n\nfunction warnIfNotCurrentlyActingUpdatesInDEV(fiber: Fiber): void {\n  if (__DEV__) {\n    if (\n      warnsIfNotActing === true &&\n      executionContext === NoContext &&\n      IsSomeRendererActing.current === false &&\n      IsThisRendererActing.current === false\n    ) {\n      warningWithoutStack(\n        false,\n        'An update to %s inside a test was not wrapped in act(...).\\n\\n' +\n          'When testing, code that causes React state updates should be ' +\n          'wrapped into act(...):\\n\\n' +\n          'act(() => {\\n' +\n          '  /* fire events that update state */\\n' +\n          '});\\n' +\n          '/* assert on the output */\\n\\n' +\n          \"This ensures that you're testing the behavior the user would see \" +\n          'in the browser.' +\n          ' Learn more at https://fb.me/react-wrap-tests-with-act' +\n          '%s',\n        getComponentName(fiber.type),\n        getStackByFiberInDevAndProd(fiber),\n      );\n    }\n  }\n}\n\nexport const warnIfNotCurrentlyActingUpdatesInDev = warnIfNotCurrentlyActingUpdatesInDEV;\n\n// In tests, we want to enforce a mocked scheduler.\nlet didWarnAboutUnmockedScheduler = false;\n// TODO Before we release concurrent mode, revisit this and decide whether a mocked\n// scheduler is the actual recommendation. The alternative could be a testing build,\n// a new lib, or whatever; we dunno just yet. This message is for early adopters\n// to get their tests right.\n\nexport function warnIfUnmockedScheduler(fiber: Fiber) {\n  if (__DEV__) {\n    if (\n      didWarnAboutUnmockedScheduler === false &&\n      Scheduler.unstable_flushAllWithoutAsserting === undefined\n    ) {\n      if (fiber.mode & BatchedMode || fiber.mode & ConcurrentMode) {\n        didWarnAboutUnmockedScheduler = true;\n        warningWithoutStack(\n          false,\n          'In Concurrent or Sync modes, the \"scheduler\" module needs to be mocked ' +\n            'to guarantee consistent behaviour across tests and browsers. ' +\n            'For example, with jest: \\n' +\n            \"jest.mock('scheduler', () => require('scheduler/unstable_mock'));\\n\\n\" +\n            'For more info, visit https://fb.me/react-mock-scheduler',\n        );\n      } else if (warnAboutUnmockedScheduler === true) {\n        didWarnAboutUnmockedScheduler = true;\n        warningWithoutStack(\n          false,\n          'Starting from React v17, the \"scheduler\" module will need to be mocked ' +\n            'to guarantee consistent behaviour across tests and browsers. ' +\n            'For example, with jest: \\n' +\n            \"jest.mock('scheduler', () => require('scheduler/unstable_mock'));\\n\\n\" +\n            'For more info, visit https://fb.me/react-mock-scheduler',\n        );\n      }\n    }\n  }\n}\n\nlet componentsThatTriggeredHighPriSuspend = null;\nexport function checkForWrongSuspensePriorityInDEV(sourceFiber: Fiber) {\n  if (__DEV__) {\n    const currentPriorityLevel = getCurrentPriorityLevel();\n    if (\n      (sourceFiber.mode & ConcurrentMode) !== NoEffect &&\n      (currentPriorityLevel === UserBlockingPriority ||\n        currentPriorityLevel === ImmediatePriority)\n    ) {\n      let workInProgressNode = sourceFiber;\n      while (workInProgressNode !== null) {\n        // Add the component that triggered the suspense\n        const current = workInProgressNode.alternate;\n        if (current !== null) {\n          // TODO: warn component that triggers the high priority\n          // suspend is the HostRoot\n          switch (workInProgressNode.tag) {\n            case ClassComponent:\n              // Loop through the component's update queue and see whether the component\n              // has triggered any high priority updates\n              const updateQueue = current.updateQueue;\n              if (updateQueue !== null) {\n                let update = updateQueue.firstUpdate;\n                while (update !== null) {\n                  const priorityLevel = update.priority;\n                  if (\n                    priorityLevel === UserBlockingPriority ||\n                    priorityLevel === ImmediatePriority\n                  ) {\n                    if (componentsThatTriggeredHighPriSuspend === null) {\n                      componentsThatTriggeredHighPriSuspend = new Set([\n                        getComponentName(workInProgressNode.type),\n                      ]);\n                    } else {\n                      componentsThatTriggeredHighPriSuspend.add(\n                        getComponentName(workInProgressNode.type),\n                      );\n                    }\n                    break;\n                  }\n                  update = update.next;\n                }\n              }\n              break;\n            case FunctionComponent:\n            case ForwardRef:\n            case SimpleMemoComponent:\n              if (\n                workInProgressNode.memoizedState !== null &&\n                workInProgressNode.memoizedState.baseUpdate !== null\n              ) {\n                let update = workInProgressNode.memoizedState.baseUpdate;\n                // Loop through the functional component's memoized state to see whether\n                // the component has triggered any high pri updates\n                while (update !== null) {\n                  const priority = update.priority;\n                  if (\n                    priority === UserBlockingPriority ||\n                    priority === ImmediatePriority\n                  ) {\n                    if (componentsThatTriggeredHighPriSuspend === null) {\n                      componentsThatTriggeredHighPriSuspend = new Set([\n                        getComponentName(workInProgressNode.type),\n                      ]);\n                    } else {\n                      componentsThatTriggeredHighPriSuspend.add(\n                        getComponentName(workInProgressNode.type),\n                      );\n                    }\n                    break;\n                  }\n                  if (\n                    update.next === workInProgressNode.memoizedState.baseUpdate\n                  ) {\n                    break;\n                  }\n                  update = update.next;\n                }\n              }\n              break;\n            default:\n              break;\n          }\n        }\n        workInProgressNode = workInProgressNode.return;\n      }\n    }\n  }\n}\n\nfunction flushSuspensePriorityWarningInDEV() {\n  if (__DEV__) {\n    if (componentsThatTriggeredHighPriSuspend !== null) {\n      const componentNames = [];\n      componentsThatTriggeredHighPriSuspend.forEach(name =>\n        componentNames.push(name),\n      );\n      componentsThatTriggeredHighPriSuspend = null;\n\n      if (componentNames.length > 0) {\n        warningWithoutStack(\n          false,\n          '%s triggered a user-blocking update that suspended.' +\n            '\\n\\n' +\n            'The fix is to split the update into multiple parts: a user-blocking ' +\n            'update to provide immediate feedback, and another update that ' +\n            'triggers the bulk of the changes.' +\n            '\\n\\n' +\n            'Refer to the documentation for useSuspenseTransition to learn how ' +\n            'to implement this pattern.',\n          // TODO: Add link to React docs with more information, once it exists\n          componentNames.sort().join(', '),\n        );\n      }\n    }\n  }\n}\n\nfunction computeThreadID(root, expirationTime) {\n  // Interaction threads are unique per root and expiration time.\n  return expirationTime * 1000 + root.interactionThreadID;\n}\n\nexport function markSpawnedWork(expirationTime: ExpirationTime) {\n  if (!enableSchedulerTracing) {\n    return;\n  }\n  if (spawnedWorkDuringRender === null) {\n    spawnedWorkDuringRender = [expirationTime];\n  } else {\n    spawnedWorkDuringRender.push(expirationTime);\n  }\n}\n\nfunction scheduleInteractions(root, expirationTime, interactions) {\n  if (!enableSchedulerTracing) {\n    return;\n  }\n\n  if (interactions.size > 0) {\n    const pendingInteractionMap = root.pendingInteractionMap;\n    const pendingInteractions = pendingInteractionMap.get(expirationTime);\n    if (pendingInteractions != null) {\n      interactions.forEach(interaction => {\n        if (!pendingInteractions.has(interaction)) {\n          // Update the pending async work count for previously unscheduled interaction.\n          interaction.__count++;\n        }\n\n        pendingInteractions.add(interaction);\n      });\n    } else {\n      pendingInteractionMap.set(expirationTime, new Set(interactions));\n\n      // Update the pending async work count for the current interactions.\n      interactions.forEach(interaction => {\n        interaction.__count++;\n      });\n    }\n\n    const subscriber = __subscriberRef.current;\n    if (subscriber !== null) {\n      const threadID = computeThreadID(root, expirationTime);\n      subscriber.onWorkScheduled(interactions, threadID);\n    }\n  }\n}\n\nfunction schedulePendingInteractions(root, expirationTime) {\n  // This is called when work is scheduled on a root.\n  // It associates the current interactions with the newly-scheduled expiration.\n  // They will be restored when that expiration is later committed.\n  if (!enableSchedulerTracing) {\n    return;\n  }\n\n  scheduleInteractions(root, expirationTime, __interactionsRef.current);\n}\n\nfunction startWorkOnPendingInteractions(root, expirationTime) {\n  // This is called when new work is started on a root.\n  if (!enableSchedulerTracing) {\n    return;\n  }\n\n  // Determine which interactions this batch of work currently includes, So that\n  // we can accurately attribute time spent working on it, And so that cascading\n  // work triggered during the render phase will be associated with it.\n  const interactions: Set<Interaction> = new Set();\n  root.pendingInteractionMap.forEach(\n    (scheduledInteractions, scheduledExpirationTime) => {\n      if (scheduledExpirationTime >= expirationTime) {\n        scheduledInteractions.forEach(interaction =>\n          interactions.add(interaction),\n        );\n      }\n    },\n  );\n\n  // Store the current set of interactions on the FiberRoot for a few reasons:\n  // We can re-use it in hot functions like renderRoot() without having to\n  // recalculate it. We will also use it in commitWork() to pass to any Profiler\n  // onRender() hooks. This also provides DevTools with a way to access it when\n  // the onCommitRoot() hook is called.\n  root.memoizedInteractions = interactions;\n\n  if (interactions.size > 0) {\n    const subscriber = __subscriberRef.current;\n    if (subscriber !== null) {\n      const threadID = computeThreadID(root, expirationTime);\n      try {\n        subscriber.onWorkStarted(interactions, threadID);\n      } catch (error) {\n        // If the subscriber throws, rethrow it in a separate task\n        scheduleCallback(ImmediatePriority, () => {\n          throw error;\n        });\n      }\n    }\n  }\n}\n\nfunction finishPendingInteractions(root, committedExpirationTime) {\n  if (!enableSchedulerTracing) {\n    return;\n  }\n\n  const earliestRemainingTimeAfterCommit = root.firstPendingTime;\n\n  let subscriber;\n\n  try {\n    subscriber = __subscriberRef.current;\n    if (subscriber !== null && root.memoizedInteractions.size > 0) {\n      const threadID = computeThreadID(root, committedExpirationTime);\n      subscriber.onWorkStopped(root.memoizedInteractions, threadID);\n    }\n  } catch (error) {\n    // If the subscriber throws, rethrow it in a separate task\n    scheduleCallback(ImmediatePriority, () => {\n      throw error;\n    });\n  } finally {\n    // Clear completed interactions from the pending Map.\n    // Unless the render was suspended or cascading work was scheduled,\n    // In which case– leave pending interactions until the subsequent render.\n    const pendingInteractionMap = root.pendingInteractionMap;\n    pendingInteractionMap.forEach(\n      (scheduledInteractions, scheduledExpirationTime) => {\n        // Only decrement the pending interaction count if we're done.\n        // If there's still work at the current priority,\n        // That indicates that we are waiting for suspense data.\n        if (scheduledExpirationTime > earliestRemainingTimeAfterCommit) {\n          pendingInteractionMap.delete(scheduledExpirationTime);\n\n          scheduledInteractions.forEach(interaction => {\n            interaction.__count--;\n\n            if (subscriber !== null && interaction.__count === 0) {\n              try {\n                subscriber.onInteractionScheduledWorkCompleted(interaction);\n              } catch (error) {\n                // If the subscriber throws, rethrow it in a separate task\n                scheduleCallback(ImmediatePriority, () => {\n                  throw error;\n                });\n              }\n            }\n          });\n        }\n      },\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}