{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { getPublicInstance } from './ReactFiberHostConfig';\nimport { HostComponent, SuspenseComponent, ScopeComponent } from 'shared/ReactWorkTags';\nimport { enableScopeAPI } from 'shared/ReactFeatureFlags';\n\nfunction isFiberSuspenseAndTimedOut(fiber) {\n  return fiber.tag === SuspenseComponent && fiber.memoizedState !== null;\n}\n\nfunction getSuspenseFallbackChild(fiber) {\n  return fiber.child.sibling.child;\n}\n\nfunction collectScopedNodes(node, fn, scopedNodes) {\n  if (enableScopeAPI) {\n    if (node.tag === HostComponent) {\n      const {\n        type,\n        memoizedProps\n      } = node;\n\n      if (fn(type, memoizedProps) === true) {\n        scopedNodes.push(getPublicInstance(node.stateNode));\n      }\n    }\n\n    let child = node.child;\n\n    if (isFiberSuspenseAndTimedOut(node)) {\n      child = getSuspenseFallbackChild(node);\n    }\n\n    if (child !== null) {\n      collectScopedNodesFromChildren(child, fn, scopedNodes);\n    }\n  }\n}\n\nfunction collectScopedNodesFromChildren(startingChild, fn, scopedNodes) {\n  let child = startingChild;\n\n  while (child !== null) {\n    collectScopedNodes(child, fn, scopedNodes);\n    child = child.sibling;\n  }\n}\n\nfunction collectNearestScopeMethods(node, scope, childrenScopes) {\n  if (isValidScopeNode(node, scope)) {\n    childrenScopes.push(node.stateNode.methods);\n  } else {\n    let child = node.child;\n\n    if (isFiberSuspenseAndTimedOut(node)) {\n      child = getSuspenseFallbackChild(node);\n    }\n\n    if (child !== null) {\n      collectNearestChildScopeMethods(child, scope, childrenScopes);\n    }\n  }\n}\n\nfunction collectNearestChildScopeMethods(startingChild, scope, childrenScopes) {\n  let child = startingChild;\n\n  while (child !== null) {\n    collectNearestScopeMethods(child, scope, childrenScopes);\n    child = child.sibling;\n  }\n}\n\nfunction isValidScopeNode(node, scope) {\n  return node.tag === ScopeComponent && node.type === scope;\n}\n\nexport function createScopeMethods(scope, instance) {\n  const fn = scope.fn;\n  return {\n    getChildren() {\n      const currentFiber = instance.fiber;\n      const child = currentFiber.child;\n      const childrenScopes = [];\n\n      if (child !== null) {\n        collectNearestChildScopeMethods(child, scope, childrenScopes);\n      }\n\n      return childrenScopes.length === 0 ? null : childrenScopes;\n    },\n\n    getChildrenFromRoot() {\n      const currentFiber = instance.fiber;\n      let node = currentFiber;\n\n      while (node !== null) {\n        const parent = node.return;\n\n        if (parent === null) {\n          break;\n        }\n\n        node = parent;\n\n        if (node.tag === ScopeComponent && node.type === scope) {\n          break;\n        }\n      }\n\n      const childrenScopes = [];\n      collectNearestChildScopeMethods(node.child, scope, childrenScopes);\n      return childrenScopes.length === 0 ? null : childrenScopes;\n    },\n\n    getParent() {\n      let node = instance.fiber.return;\n\n      while (node !== null) {\n        if (node.tag === ScopeComponent && node.type === scope) {\n          return node.stateNode.methods;\n        }\n\n        node = node.return;\n      }\n\n      return null;\n    },\n\n    getScopedNodes() {\n      const currentFiber = instance.fiber;\n      const child = currentFiber.child;\n      const scopedNodes = [];\n\n      if (child !== null) {\n        collectScopedNodesFromChildren(child, fn, scopedNodes);\n      }\n\n      return scopedNodes.length === 0 ? null : scopedNodes;\n    }\n\n  };\n}","map":{"version":3,"sources":["/Users/gaoshaoyun/Documents/library/debug-react/src/react/packages/react-reconciler/src/ReactFiberScope.js"],"names":["getPublicInstance","HostComponent","SuspenseComponent","ScopeComponent","enableScopeAPI","isFiberSuspenseAndTimedOut","fiber","tag","memoizedState","getSuspenseFallbackChild","child","sibling","collectScopedNodes","node","fn","scopedNodes","type","memoizedProps","push","stateNode","collectScopedNodesFromChildren","startingChild","collectNearestScopeMethods","scope","childrenScopes","isValidScopeNode","methods","collectNearestChildScopeMethods","createScopeMethods","instance","getChildren","currentFiber","length","getChildrenFromRoot","parent","return","getParent","getScopedNodes"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber} from './ReactFiber';\nimport type {\n  ReactScope,\n  ReactScopeInstance,\n  ReactScopeMethods,\n} from 'shared/ReactTypes';\n\nimport {getPublicInstance} from './ReactFiberHostConfig';\n\nimport {\n  HostComponent,\n  SuspenseComponent,\n  ScopeComponent,\n} from 'shared/ReactWorkTags';\nimport {enableScopeAPI} from 'shared/ReactFeatureFlags';\n\nfunction isFiberSuspenseAndTimedOut(fiber: Fiber): boolean {\n  return fiber.tag === SuspenseComponent && fiber.memoizedState !== null;\n}\n\nfunction getSuspenseFallbackChild(fiber: Fiber): Fiber | null {\n  return ((((fiber.child: any): Fiber).sibling: any): Fiber).child;\n}\n\nfunction collectScopedNodes(\n  node: Fiber,\n  fn: (type: string | Object, props: Object) => boolean,\n  scopedNodes: Array<any>,\n): void {\n  if (enableScopeAPI) {\n    if (node.tag === HostComponent) {\n      const {type, memoizedProps} = node;\n      if (fn(type, memoizedProps) === true) {\n        scopedNodes.push(getPublicInstance(node.stateNode));\n      }\n    }\n    let child = node.child;\n\n    if (isFiberSuspenseAndTimedOut(node)) {\n      child = getSuspenseFallbackChild(node);\n    }\n    if (child !== null) {\n      collectScopedNodesFromChildren(child, fn, scopedNodes);\n    }\n  }\n}\n\nfunction collectScopedNodesFromChildren(\n  startingChild: Fiber,\n  fn: (type: string | Object, props: Object) => boolean,\n  scopedNodes: Array<any>,\n): void {\n  let child = startingChild;\n  while (child !== null) {\n    collectScopedNodes(child, fn, scopedNodes);\n    child = child.sibling;\n  }\n}\n\nfunction collectNearestScopeMethods(\n  node: Fiber,\n  scope: ReactScope,\n  childrenScopes: Array<ReactScopeMethods>,\n): void {\n  if (isValidScopeNode(node, scope)) {\n    childrenScopes.push(node.stateNode.methods);\n  } else {\n    let child = node.child;\n\n    if (isFiberSuspenseAndTimedOut(node)) {\n      child = getSuspenseFallbackChild(node);\n    }\n    if (child !== null) {\n      collectNearestChildScopeMethods(child, scope, childrenScopes);\n    }\n  }\n}\n\nfunction collectNearestChildScopeMethods(\n  startingChild: Fiber | null,\n  scope: ReactScope,\n  childrenScopes: Array<ReactScopeMethods>,\n): void {\n  let child = startingChild;\n  while (child !== null) {\n    collectNearestScopeMethods(child, scope, childrenScopes);\n    child = child.sibling;\n  }\n}\n\nfunction isValidScopeNode(node, scope) {\n  return node.tag === ScopeComponent && node.type === scope;\n}\n\nexport function createScopeMethods(\n  scope: ReactScope,\n  instance: ReactScopeInstance,\n): ReactScopeMethods {\n  const fn = scope.fn;\n  return {\n    getChildren(): null | Array<ReactScopeMethods> {\n      const currentFiber = ((instance.fiber: any): Fiber);\n      const child = currentFiber.child;\n      const childrenScopes = [];\n      if (child !== null) {\n        collectNearestChildScopeMethods(child, scope, childrenScopes);\n      }\n      return childrenScopes.length === 0 ? null : childrenScopes;\n    },\n    getChildrenFromRoot(): null | Array<ReactScopeMethods> {\n      const currentFiber = ((instance.fiber: any): Fiber);\n      let node = currentFiber;\n      while (node !== null) {\n        const parent = node.return;\n        if (parent === null) {\n          break;\n        }\n        node = parent;\n        if (node.tag === ScopeComponent && node.type === scope) {\n          break;\n        }\n      }\n      const childrenScopes = [];\n      collectNearestChildScopeMethods(node.child, scope, childrenScopes);\n      return childrenScopes.length === 0 ? null : childrenScopes;\n    },\n    getParent(): null | ReactScopeMethods {\n      let node = ((instance.fiber: any): Fiber).return;\n      while (node !== null) {\n        if (node.tag === ScopeComponent && node.type === scope) {\n          return node.stateNode.methods;\n        }\n        node = node.return;\n      }\n      return null;\n    },\n    getScopedNodes(): null | Array<Object> {\n      const currentFiber = ((instance.fiber: any): Fiber);\n      const child = currentFiber.child;\n      const scopedNodes = [];\n      if (child !== null) {\n        collectScopedNodesFromChildren(child, fn, scopedNodes);\n      }\n      return scopedNodes.length === 0 ? null : scopedNodes;\n    },\n  };\n}\n"]},"metadata":{},"sourceType":"module"}