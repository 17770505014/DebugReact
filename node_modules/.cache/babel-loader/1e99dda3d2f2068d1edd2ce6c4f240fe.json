{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport invariant from 'shared/invariant';\nimport warning from 'shared/warning';\nimport { getIteratorFn, REACT_ELEMENT_TYPE, REACT_PORTAL_TYPE } from 'shared/ReactSymbols';\nimport { isValidElement, cloneAndReplaceKey } from './ReactElement';\nimport ReactDebugCurrentFrame from './ReactDebugCurrentFrame';\nconst SEPARATOR = '.';\nconst SUBSEPARATOR = ':';\n/**\n * Escape and wrap key so it is safe to use as a reactid\n *\n * @param {string} key to be escaped.\n * @return {string} the escaped key.\n */\n\nfunction escape(key) {\n  const escapeRegex = /[=:]/g;\n  const escaperLookup = {\n    '=': '=0',\n    ':': '=2'\n  };\n  const escapedString = ('' + key).replace(escapeRegex, function (match) {\n    return escaperLookup[match];\n  });\n  return '$' + escapedString;\n}\n/**\n * TODO: Test that a single child and an array with one item have the same key\n * pattern.\n */\n\n\nlet didWarnAboutMaps = false;\nconst userProvidedKeyEscapeRegex = /\\/+/g;\n\nfunction escapeUserProvidedKey(text) {\n  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');\n}\n\nconst POOL_SIZE = 10;\nconst traverseContextPool = [];\n\nfunction getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {\n  if (traverseContextPool.length) {\n    const traverseContext = traverseContextPool.pop();\n    traverseContext.result = mapResult;\n    traverseContext.keyPrefix = keyPrefix;\n    traverseContext.func = mapFunction;\n    traverseContext.context = mapContext;\n    traverseContext.count = 0;\n    return traverseContext;\n  } else {\n    return {\n      result: mapResult,\n      keyPrefix: keyPrefix,\n      func: mapFunction,\n      context: mapContext,\n      count: 0\n    };\n  }\n}\n\nfunction releaseTraverseContext(traverseContext) {\n  traverseContext.result = null;\n  traverseContext.keyPrefix = null;\n  traverseContext.func = null;\n  traverseContext.context = null;\n  traverseContext.count = 0;\n\n  if (traverseContextPool.length < POOL_SIZE) {\n    traverseContextPool.push(traverseContext);\n  }\n}\n/**\n * @param {?*} children Children tree container.\n * @param {!string} nameSoFar Name of the key path so far.\n * @param {!function} callback Callback to invoke with each child found.\n * @param {?*} traverseContext Used to pass information throughout the traversal\n * process.\n * @return {!number} The number of children in this subtree.\n */\n\n\nfunction traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {\n  const type = typeof children;\n\n  if (type === 'undefined' || type === 'boolean') {\n    // All of the above are perceived as null.\n    children = null;\n  }\n\n  let invokeCallback = false;\n\n  if (children === null) {\n    invokeCallback = true;\n  } else {\n    switch (type) {\n      case 'string':\n      case 'number':\n        invokeCallback = true;\n        break;\n\n      case 'object':\n        switch (children.$$typeof) {\n          case REACT_ELEMENT_TYPE:\n          case REACT_PORTAL_TYPE:\n            invokeCallback = true;\n        }\n\n    }\n  }\n\n  if (invokeCallback) {\n    callback(traverseContext, children, // If it's the only child, treat the name as if it was wrapped in an array\n    // so that it's consistent if the number of children grows.\n    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);\n    return 1;\n  }\n\n  let child;\n  let nextName;\n  let subtreeCount = 0; // Count of children found in the current subtree.\n\n  const nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n\n  if (Array.isArray(children)) {\n    for (let i = 0; i < children.length; i++) {\n      child = children[i];\n      nextName = nextNamePrefix + getComponentKey(child, i);\n      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);\n    }\n  } else {\n    const iteratorFn = getIteratorFn(children);\n\n    if (typeof iteratorFn === 'function') {\n      if (__DEV__) {\n        // Warn about using Maps as children\n        if (iteratorFn === children.entries) {\n          warning(didWarnAboutMaps, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.');\n          didWarnAboutMaps = true;\n        }\n      }\n\n      const iterator = iteratorFn.call(children);\n      let step;\n      let ii = 0;\n\n      while (!(step = iterator.next()).done) {\n        child = step.value;\n        nextName = nextNamePrefix + getComponentKey(child, ii++);\n        subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);\n      }\n    } else if (type === 'object') {\n      let addendum = '';\n\n      if (__DEV__) {\n        addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + ReactDebugCurrentFrame.getStackAddendum();\n      }\n\n      const childrenString = '' + children;\n      invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum);\n    }\n  }\n\n  return subtreeCount;\n}\n/**\n * Traverses children that are typically specified as `props.children`, but\n * might also be specified through attributes:\n *\n * - `traverseAllChildren(this.props.children, ...)`\n * - `traverseAllChildren(this.props.leftPanelChildren, ...)`\n *\n * The `traverseContext` is an optional argument that is passed through the\n * entire traversal. It can be used to store accumulations or anything else that\n * the callback might find relevant.\n *\n * @param {?*} children Children tree object.\n * @param {!function} callback To invoke upon traversing each child.\n * @param {?*} traverseContext Context for traversal.\n * @return {!number} The number of children in this subtree.\n */\n\n\nfunction traverseAllChildren(children, callback, traverseContext) {\n  if (children == null) {\n    return 0;\n  }\n\n  return traverseAllChildrenImpl(children, '', callback, traverseContext);\n}\n/**\n * Generate a key string that identifies a component within a set.\n *\n * @param {*} component A component that could contain a manual key.\n * @param {number} index Index that is used if a manual key is not provided.\n * @return {string}\n */\n\n\nfunction getComponentKey(component, index) {\n  // Do some typechecking here since we call this blindly. We want to ensure\n  // that we don't block potential future ES APIs.\n  if (typeof component === 'object' && component !== null && component.key != null) {\n    // Explicit key\n    return escape(component.key);\n  } // Implicit key determined by the index in the set\n\n\n  return index.toString(36);\n}\n\nfunction forEachSingleChild(bookKeeping, child, name) {\n  const {\n    func,\n    context\n  } = bookKeeping;\n  func.call(context, child, bookKeeping.count++);\n}\n/**\n * Iterates through children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenforeach\n *\n * The provided forEachFunc(child, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} forEachFunc\n * @param {*} forEachContext Context for forEachContext.\n */\n\n\nfunction forEachChildren(children, forEachFunc, forEachContext) {\n  if (children == null) {\n    return children;\n  }\n\n  const traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);\n  traverseAllChildren(children, forEachSingleChild, traverseContext);\n  releaseTraverseContext(traverseContext);\n}\n\nfunction mapSingleChildIntoContext(bookKeeping, child, childKey) {\n  const {\n    result,\n    keyPrefix,\n    func,\n    context\n  } = bookKeeping;\n  let mappedChild = func.call(context, child, bookKeeping.count++);\n\n  if (Array.isArray(mappedChild)) {\n    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, c => c);\n  } else if (mappedChild != null) {\n    if (isValidElement(mappedChild)) {\n      mappedChild = cloneAndReplaceKey(mappedChild, // Keep both the (mapped) and old keys if they differ, just as\n      // traverseAllChildren used to do for objects as children\n      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);\n    }\n\n    result.push(mappedChild);\n  }\n}\n\nfunction mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {\n  let escapedPrefix = '';\n\n  if (prefix != null) {\n    escapedPrefix = escapeUserProvidedKey(prefix) + '/';\n  }\n\n  const traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);\n  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);\n  releaseTraverseContext(traverseContext);\n}\n/**\n * Maps children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenmap\n *\n * The provided mapFunction(child, key, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} func The map function.\n * @param {*} context Context for mapFunction.\n * @return {object} Object containing the ordered map of results.\n */\n\n\nfunction mapChildren(children, func, context) {\n  if (children == null) {\n    return children;\n  }\n\n  const result = [];\n  mapIntoWithKeyPrefixInternal(children, result, null, func, context);\n  return result;\n}\n/**\n * Count the number of children that are typically specified as\n * `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrencount\n *\n * @param {?*} children Children tree container.\n * @return {number} The number of children.\n */\n\n\nfunction countChildren(children) {\n  return traverseAllChildren(children, () => null, null);\n}\n/**\n * Flatten a children object (typically specified as `props.children`) and\n * return an array with appropriately re-keyed children.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrentoarray\n */\n\n\nfunction toArray(children) {\n  const result = [];\n  mapIntoWithKeyPrefixInternal(children, result, null, child => child);\n  return result;\n}\n/**\n * Returns the first child in a collection of children and verifies that there\n * is only one child in the collection.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenonly\n *\n * The current implementation of this function assumes that a single child gets\n * passed without a wrapper, but the purpose of this helper function is to\n * abstract away the particular structure of children.\n *\n * @param {?object} children Child collection structure.\n * @return {ReactElement} The first and only `ReactElement` contained in the\n * structure.\n */\n\n\nfunction onlyChild(children) {\n  invariant(isValidElement(children), 'React.Children.only expected to receive a single React element child.');\n  return children;\n}\n\nexport { forEachChildren as forEach, mapChildren as map, countChildren as count, onlyChild as only, toArray };","map":{"version":3,"sources":["/Users/gaoshaoyun/Documents/library/debug-react/src/react/packages/react/src/ReactChildren.js"],"names":["invariant","warning","getIteratorFn","REACT_ELEMENT_TYPE","REACT_PORTAL_TYPE","isValidElement","cloneAndReplaceKey","ReactDebugCurrentFrame","SEPARATOR","SUBSEPARATOR","escape","key","escapeRegex","escaperLookup","escapedString","replace","match","didWarnAboutMaps","userProvidedKeyEscapeRegex","escapeUserProvidedKey","text","POOL_SIZE","traverseContextPool","getPooledTraverseContext","mapResult","keyPrefix","mapFunction","mapContext","length","traverseContext","pop","result","func","context","count","releaseTraverseContext","push","traverseAllChildrenImpl","children","nameSoFar","callback","type","invokeCallback","$$typeof","getComponentKey","child","nextName","subtreeCount","nextNamePrefix","Array","isArray","i","iteratorFn","__DEV__","entries","iterator","call","step","ii","next","done","value","addendum","getStackAddendum","childrenString","Object","keys","join","traverseAllChildren","component","index","toString","forEachSingleChild","bookKeeping","name","forEachChildren","forEachFunc","forEachContext","mapSingleChildIntoContext","childKey","mappedChild","mapIntoWithKeyPrefixInternal","c","array","prefix","escapedPrefix","mapChildren","countChildren","toArray","onlyChild","forEach","map","only"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport invariant from 'shared/invariant';\nimport warning from 'shared/warning';\nimport {\n  getIteratorFn,\n  REACT_ELEMENT_TYPE,\n  REACT_PORTAL_TYPE,\n} from 'shared/ReactSymbols';\n\nimport {isValidElement, cloneAndReplaceKey} from './ReactElement';\nimport ReactDebugCurrentFrame from './ReactDebugCurrentFrame';\n\nconst SEPARATOR = '.';\nconst SUBSEPARATOR = ':';\n\n/**\n * Escape and wrap key so it is safe to use as a reactid\n *\n * @param {string} key to be escaped.\n * @return {string} the escaped key.\n */\nfunction escape(key) {\n  const escapeRegex = /[=:]/g;\n  const escaperLookup = {\n    '=': '=0',\n    ':': '=2',\n  };\n  const escapedString = ('' + key).replace(escapeRegex, function(match) {\n    return escaperLookup[match];\n  });\n\n  return '$' + escapedString;\n}\n\n/**\n * TODO: Test that a single child and an array with one item have the same key\n * pattern.\n */\n\nlet didWarnAboutMaps = false;\n\nconst userProvidedKeyEscapeRegex = /\\/+/g;\nfunction escapeUserProvidedKey(text) {\n  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');\n}\n\nconst POOL_SIZE = 10;\nconst traverseContextPool = [];\nfunction getPooledTraverseContext(\n  mapResult,\n  keyPrefix,\n  mapFunction,\n  mapContext,\n) {\n  if (traverseContextPool.length) {\n    const traverseContext = traverseContextPool.pop();\n    traverseContext.result = mapResult;\n    traverseContext.keyPrefix = keyPrefix;\n    traverseContext.func = mapFunction;\n    traverseContext.context = mapContext;\n    traverseContext.count = 0;\n    return traverseContext;\n  } else {\n    return {\n      result: mapResult,\n      keyPrefix: keyPrefix,\n      func: mapFunction,\n      context: mapContext,\n      count: 0,\n    };\n  }\n}\n\nfunction releaseTraverseContext(traverseContext) {\n  traverseContext.result = null;\n  traverseContext.keyPrefix = null;\n  traverseContext.func = null;\n  traverseContext.context = null;\n  traverseContext.count = 0;\n  if (traverseContextPool.length < POOL_SIZE) {\n    traverseContextPool.push(traverseContext);\n  }\n}\n\n/**\n * @param {?*} children Children tree container.\n * @param {!string} nameSoFar Name of the key path so far.\n * @param {!function} callback Callback to invoke with each child found.\n * @param {?*} traverseContext Used to pass information throughout the traversal\n * process.\n * @return {!number} The number of children in this subtree.\n */\nfunction traverseAllChildrenImpl(\n  children,\n  nameSoFar,\n  callback,\n  traverseContext,\n) {\n  const type = typeof children;\n\n  if (type === 'undefined' || type === 'boolean') {\n    // All of the above are perceived as null.\n    children = null;\n  }\n\n  let invokeCallback = false;\n\n  if (children === null) {\n    invokeCallback = true;\n  } else {\n    switch (type) {\n      case 'string':\n      case 'number':\n        invokeCallback = true;\n        break;\n      case 'object':\n        switch (children.$$typeof) {\n          case REACT_ELEMENT_TYPE:\n          case REACT_PORTAL_TYPE:\n            invokeCallback = true;\n        }\n    }\n  }\n\n  if (invokeCallback) {\n    callback(\n      traverseContext,\n      children,\n      // If it's the only child, treat the name as if it was wrapped in an array\n      // so that it's consistent if the number of children grows.\n      nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar,\n    );\n    return 1;\n  }\n\n  let child;\n  let nextName;\n  let subtreeCount = 0; // Count of children found in the current subtree.\n  const nextNamePrefix =\n    nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n\n  if (Array.isArray(children)) {\n    for (let i = 0; i < children.length; i++) {\n      child = children[i];\n      nextName = nextNamePrefix + getComponentKey(child, i);\n      subtreeCount += traverseAllChildrenImpl(\n        child,\n        nextName,\n        callback,\n        traverseContext,\n      );\n    }\n  } else {\n    const iteratorFn = getIteratorFn(children);\n    if (typeof iteratorFn === 'function') {\n      if (__DEV__) {\n        // Warn about using Maps as children\n        if (iteratorFn === children.entries) {\n          warning(\n            didWarnAboutMaps,\n            'Using Maps as children is unsupported and will likely yield ' +\n              'unexpected results. Convert it to a sequence/iterable of keyed ' +\n              'ReactElements instead.',\n          );\n          didWarnAboutMaps = true;\n        }\n      }\n\n      const iterator = iteratorFn.call(children);\n      let step;\n      let ii = 0;\n      while (!(step = iterator.next()).done) {\n        child = step.value;\n        nextName = nextNamePrefix + getComponentKey(child, ii++);\n        subtreeCount += traverseAllChildrenImpl(\n          child,\n          nextName,\n          callback,\n          traverseContext,\n        );\n      }\n    } else if (type === 'object') {\n      let addendum = '';\n      if (__DEV__) {\n        addendum =\n          ' If you meant to render a collection of children, use an array ' +\n          'instead.' +\n          ReactDebugCurrentFrame.getStackAddendum();\n      }\n      const childrenString = '' + children;\n      invariant(\n        false,\n        'Objects are not valid as a React child (found: %s).%s',\n        childrenString === '[object Object]'\n          ? 'object with keys {' + Object.keys(children).join(', ') + '}'\n          : childrenString,\n        addendum,\n      );\n    }\n  }\n\n  return subtreeCount;\n}\n\n/**\n * Traverses children that are typically specified as `props.children`, but\n * might also be specified through attributes:\n *\n * - `traverseAllChildren(this.props.children, ...)`\n * - `traverseAllChildren(this.props.leftPanelChildren, ...)`\n *\n * The `traverseContext` is an optional argument that is passed through the\n * entire traversal. It can be used to store accumulations or anything else that\n * the callback might find relevant.\n *\n * @param {?*} children Children tree object.\n * @param {!function} callback To invoke upon traversing each child.\n * @param {?*} traverseContext Context for traversal.\n * @return {!number} The number of children in this subtree.\n */\nfunction traverseAllChildren(children, callback, traverseContext) {\n  if (children == null) {\n    return 0;\n  }\n\n  return traverseAllChildrenImpl(children, '', callback, traverseContext);\n}\n\n/**\n * Generate a key string that identifies a component within a set.\n *\n * @param {*} component A component that could contain a manual key.\n * @param {number} index Index that is used if a manual key is not provided.\n * @return {string}\n */\nfunction getComponentKey(component, index) {\n  // Do some typechecking here since we call this blindly. We want to ensure\n  // that we don't block potential future ES APIs.\n  if (\n    typeof component === 'object' &&\n    component !== null &&\n    component.key != null\n  ) {\n    // Explicit key\n    return escape(component.key);\n  }\n  // Implicit key determined by the index in the set\n  return index.toString(36);\n}\n\nfunction forEachSingleChild(bookKeeping, child, name) {\n  const {func, context} = bookKeeping;\n  func.call(context, child, bookKeeping.count++);\n}\n\n/**\n * Iterates through children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenforeach\n *\n * The provided forEachFunc(child, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} forEachFunc\n * @param {*} forEachContext Context for forEachContext.\n */\nfunction forEachChildren(children, forEachFunc, forEachContext) {\n  if (children == null) {\n    return children;\n  }\n  const traverseContext = getPooledTraverseContext(\n    null,\n    null,\n    forEachFunc,\n    forEachContext,\n  );\n  traverseAllChildren(children, forEachSingleChild, traverseContext);\n  releaseTraverseContext(traverseContext);\n}\n\nfunction mapSingleChildIntoContext(bookKeeping, child, childKey) {\n  const {result, keyPrefix, func, context} = bookKeeping;\n\n  let mappedChild = func.call(context, child, bookKeeping.count++);\n  if (Array.isArray(mappedChild)) {\n    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, c => c);\n  } else if (mappedChild != null) {\n    if (isValidElement(mappedChild)) {\n      mappedChild = cloneAndReplaceKey(\n        mappedChild,\n        // Keep both the (mapped) and old keys if they differ, just as\n        // traverseAllChildren used to do for objects as children\n        keyPrefix +\n          (mappedChild.key && (!child || child.key !== mappedChild.key)\n            ? escapeUserProvidedKey(mappedChild.key) + '/'\n            : '') +\n          childKey,\n      );\n    }\n    result.push(mappedChild);\n  }\n}\n\nfunction mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {\n  let escapedPrefix = '';\n  if (prefix != null) {\n    escapedPrefix = escapeUserProvidedKey(prefix) + '/';\n  }\n  const traverseContext = getPooledTraverseContext(\n    array,\n    escapedPrefix,\n    func,\n    context,\n  );\n  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);\n  releaseTraverseContext(traverseContext);\n}\n\n/**\n * Maps children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenmap\n *\n * The provided mapFunction(child, key, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} func The map function.\n * @param {*} context Context for mapFunction.\n * @return {object} Object containing the ordered map of results.\n */\nfunction mapChildren(children, func, context) {\n  if (children == null) {\n    return children;\n  }\n  const result = [];\n  mapIntoWithKeyPrefixInternal(children, result, null, func, context);\n  return result;\n}\n\n/**\n * Count the number of children that are typically specified as\n * `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrencount\n *\n * @param {?*} children Children tree container.\n * @return {number} The number of children.\n */\nfunction countChildren(children) {\n  return traverseAllChildren(children, () => null, null);\n}\n\n/**\n * Flatten a children object (typically specified as `props.children`) and\n * return an array with appropriately re-keyed children.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrentoarray\n */\nfunction toArray(children) {\n  const result = [];\n  mapIntoWithKeyPrefixInternal(children, result, null, child => child);\n  return result;\n}\n\n/**\n * Returns the first child in a collection of children and verifies that there\n * is only one child in the collection.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenonly\n *\n * The current implementation of this function assumes that a single child gets\n * passed without a wrapper, but the purpose of this helper function is to\n * abstract away the particular structure of children.\n *\n * @param {?object} children Child collection structure.\n * @return {ReactElement} The first and only `ReactElement` contained in the\n * structure.\n */\nfunction onlyChild(children) {\n  invariant(\n    isValidElement(children),\n    'React.Children.only expected to receive a single React element child.',\n  );\n  return children;\n}\n\nexport {\n  forEachChildren as forEach,\n  mapChildren as map,\n  countChildren as count,\n  onlyChild as only,\n  toArray,\n};\n"]},"metadata":{},"sourceType":"module"}