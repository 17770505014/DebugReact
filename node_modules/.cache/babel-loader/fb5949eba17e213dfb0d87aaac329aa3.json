{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n * \n */\nimport { IS_PASSIVE, PASSIVE_NOT_SUPPORTED } from 'legacy-events/EventSystemFlags';\nimport { HostComponent, ScopeComponent } from 'shared/ReactWorkTags';\nimport { batchedEventUpdates, discreteUpdates, flushDiscreteUpdatesIfNeeded, executeUserEventHandler } from 'legacy-events/ReactGenericBatching';\nimport { enqueueStateRestore } from 'legacy-events/ReactControlledComponent';\nimport warning from 'shared/warning';\nimport { enableFlareAPI } from 'shared/ReactFeatureFlags';\nimport invariant from 'shared/invariant';\nimport { getClosestInstanceFromNode } from '../client/ReactDOMComponentTree';\nimport { ContinuousEvent, UserBlockingEvent, DiscreteEvent } from 'shared/ReactTypes';\nimport { enableUserBlockingEvents } from 'shared/ReactFeatureFlags'; // Intentionally not named imports because Rollup would use dynamic dispatch for\n// CommonJS interop named imports.\n\nimport * as Scheduler from 'scheduler';\nconst {\n  unstable_UserBlockingPriority: UserBlockingPriority,\n  unstable_runWithPriority: runWithPriority\n} = Scheduler;\nexport let listenToResponderEventTypesImpl;\nexport function setListenToResponderEventTypes(_listenToResponderEventTypesImpl) {\n  listenToResponderEventTypesImpl = _listenToResponderEventTypesImpl;\n}\nconst activeTimeouts = new Map();\nconst rootEventTypesToEventResponderInstances = new Map();\nconst DoNotPropagateToNextResponder = 0;\nconst PropagateToNextResponder = 1;\nlet currentTimeStamp = 0;\nlet currentTimers = new Map();\nlet currentInstance = null;\nlet currentTimerIDCounter = 0;\nlet currentDocument = null;\nlet currentPropagationBehavior = DoNotPropagateToNextResponder;\nconst eventResponderContext = {\n  dispatchEvent(eventValue, eventListener, eventPriority) {\n    validateResponderContext();\n    validateEventValue(eventValue);\n\n    switch (eventPriority) {\n      case DiscreteEvent:\n        {\n          flushDiscreteUpdatesIfNeeded(currentTimeStamp);\n          discreteUpdates(() => executeUserEventHandler(eventListener, eventValue));\n          break;\n        }\n\n      case UserBlockingEvent:\n        {\n          if (enableUserBlockingEvents) {\n            runWithPriority(UserBlockingPriority, () => executeUserEventHandler(eventListener, eventValue));\n          } else {\n            executeUserEventHandler(eventListener, eventValue);\n          }\n\n          break;\n        }\n\n      case ContinuousEvent:\n        {\n          executeUserEventHandler(eventListener, eventValue);\n          break;\n        }\n    }\n  },\n\n  isTargetWithinResponder(target) {\n    validateResponderContext();\n\n    if (target != null) {\n      let fiber = getClosestInstanceFromNode(target);\n      const responderFiber = currentInstance.fiber;\n\n      while (fiber !== null) {\n        if (fiber === responderFiber || fiber.alternate === responderFiber) {\n          return true;\n        }\n\n        fiber = fiber.return;\n      }\n    }\n\n    return false;\n  },\n\n  isTargetWithinResponderScope(target) {\n    validateResponderContext();\n    const componentInstance = currentInstance;\n    const responder = componentInstance.responder;\n\n    if (target != null) {\n      let fiber = getClosestInstanceFromNode(target);\n      const responderFiber = currentInstance.fiber;\n\n      while (fiber !== null) {\n        if (fiber === responderFiber || fiber.alternate === responderFiber) {\n          return true;\n        }\n\n        if (doesFiberHaveResponder(fiber, responder)) {\n          return false;\n        }\n\n        fiber = fiber.return;\n      }\n    }\n\n    return false;\n  },\n\n  isTargetWithinNode(childTarget, parentTarget) {\n    validateResponderContext();\n    const childFiber = getClosestInstanceFromNode(childTarget);\n    const parentFiber = getClosestInstanceFromNode(parentTarget);\n\n    if (childFiber != null && parentFiber != null) {\n      const parentAlternateFiber = parentFiber.alternate;\n      let node = childFiber;\n\n      while (node !== null) {\n        if (node === parentFiber || node === parentAlternateFiber) {\n          return true;\n        }\n\n        node = node.return;\n      }\n\n      return false;\n    } // Fallback to DOM APIs\n\n\n    return parentTarget.contains(childTarget);\n  },\n\n  addRootEventTypes(rootEventTypes) {\n    validateResponderContext();\n    listenToResponderEventTypesImpl(rootEventTypes, currentDocument);\n\n    for (let i = 0; i < rootEventTypes.length; i++) {\n      const rootEventType = rootEventTypes[i];\n      const eventResponderInstance = currentInstance;\n      registerRootEventType(rootEventType, eventResponderInstance);\n    }\n  },\n\n  removeRootEventTypes(rootEventTypes) {\n    validateResponderContext();\n\n    for (let i = 0; i < rootEventTypes.length; i++) {\n      const rootEventType = rootEventTypes[i];\n      let rootEventResponders = rootEventTypesToEventResponderInstances.get(rootEventType);\n      let rootEventTypesSet = currentInstance.rootEventTypes;\n\n      if (rootEventTypesSet !== null) {\n        rootEventTypesSet.delete(rootEventType);\n      }\n\n      if (rootEventResponders !== undefined) {\n        rootEventResponders.delete(currentInstance);\n      }\n    }\n  },\n\n  setTimeout(func, delay) {\n    validateResponderContext();\n\n    if (currentTimers === null) {\n      currentTimers = new Map();\n    }\n\n    let timeout = currentTimers.get(delay);\n    const timerId = currentTimerIDCounter++;\n\n    if (timeout === undefined) {\n      const timers = new Map();\n      const id = setTimeout(() => {\n        processTimers(timers, delay);\n      }, delay);\n      timeout = {\n        id,\n        timers\n      };\n      currentTimers.set(delay, timeout);\n    }\n\n    timeout.timers.set(timerId, {\n      instance: currentInstance,\n      func,\n      id: timerId,\n      timeStamp: currentTimeStamp\n    });\n    activeTimeouts.set(timerId, timeout);\n    return timerId;\n  },\n\n  clearTimeout(timerId) {\n    validateResponderContext();\n    const timeout = activeTimeouts.get(timerId);\n\n    if (timeout !== undefined) {\n      const timers = timeout.timers;\n      timers.delete(timerId);\n\n      if (timers.size === 0) {\n        clearTimeout(timeout.id);\n      }\n    }\n  },\n\n  getActiveDocument,\n  objectAssign: Object.assign,\n\n  getTimeStamp() {\n    validateResponderContext();\n    return currentTimeStamp;\n  },\n\n  isTargetWithinHostComponent(target, elementType) {\n    validateResponderContext();\n    let fiber = getClosestInstanceFromNode(target);\n\n    while (fiber !== null) {\n      if (fiber.tag === HostComponent && fiber.type === elementType) {\n        return true;\n      }\n\n      fiber = fiber.return;\n    }\n\n    return false;\n  },\n\n  continuePropagation() {\n    currentPropagationBehavior = PropagateToNextResponder;\n  },\n\n  enqueueStateRestore,\n\n  getResponderNode() {\n    validateResponderContext();\n    const responderFiber = currentInstance.fiber;\n\n    if (responderFiber.tag === ScopeComponent) {\n      return null;\n    }\n\n    return responderFiber.stateNode;\n  }\n\n};\n\nfunction validateEventValue(eventValue) {\n  if (typeof eventValue === 'object' && eventValue !== null) {\n    const {\n      target,\n      type,\n      timeStamp\n    } = eventValue;\n\n    if (target == null || type == null || timeStamp == null) {\n      throw new Error('context.dispatchEvent: \"target\", \"timeStamp\", and \"type\" fields on event object are required.');\n    }\n\n    const showWarning = name => {\n      if (__DEV__) {\n        warning(false, '%s is not available on event objects created from event responder modules (React Flare). ' + 'Try wrapping in a conditional, i.e. `if (event.type !== \"press\") { event.%s }`', name, name);\n      }\n    };\n\n    eventValue.preventDefault = () => {\n      if (__DEV__) {\n        showWarning('preventDefault()');\n      }\n    };\n\n    eventValue.stopPropagation = () => {\n      if (__DEV__) {\n        showWarning('stopPropagation()');\n      }\n    };\n\n    eventValue.isDefaultPrevented = () => {\n      if (__DEV__) {\n        showWarning('isDefaultPrevented()');\n      }\n    };\n\n    eventValue.isPropagationStopped = () => {\n      if (__DEV__) {\n        showWarning('isPropagationStopped()');\n      }\n    }; // $FlowFixMe: we don't need value, Flow thinks we do\n\n\n    Object.defineProperty(eventValue, 'nativeEvent', {\n      get() {\n        if (__DEV__) {\n          showWarning('nativeEvent');\n        }\n      }\n\n    });\n  }\n}\n\nfunction doesFiberHaveResponder(fiber, responder) {\n  const tag = fiber.tag;\n\n  if (tag === HostComponent || tag === ScopeComponent) {\n    const dependencies = fiber.dependencies;\n\n    if (dependencies !== null) {\n      const respondersMap = dependencies.responders;\n\n      if (respondersMap !== null && respondersMap.has(responder)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction getActiveDocument() {\n  return currentDocument;\n}\n\nfunction processTimers(timers, delay) {\n  const timersArr = Array.from(timers.values());\n  const previousInstance = currentInstance;\n  const previousTimers = currentTimers;\n\n  try {\n    batchedEventUpdates(() => {\n      for (let i = 0; i < timersArr.length; i++) {\n        const {\n          instance,\n          func,\n          id,\n          timeStamp\n        } = timersArr[i];\n        currentInstance = instance;\n        currentTimeStamp = timeStamp + delay;\n\n        try {\n          func();\n        } finally {\n          activeTimeouts.delete(id);\n        }\n      }\n    });\n  } finally {\n    currentTimers = previousTimers;\n    currentInstance = previousInstance;\n    currentTimeStamp = 0;\n  }\n}\n\nfunction createDOMResponderEvent(topLevelType, nativeEvent, nativeEventTarget, passive, passiveSupported) {\n  const {\n    buttons,\n    pointerType\n  } = nativeEvent;\n  let eventPointerType = '';\n\n  if (pointerType !== undefined) {\n    eventPointerType = pointerType;\n  } else if (nativeEvent.key !== undefined) {\n    eventPointerType = 'keyboard';\n  } else if (buttons !== undefined) {\n    eventPointerType = 'mouse';\n  } else if (nativeEvent.changedTouches !== undefined) {\n    eventPointerType = 'touch';\n  }\n\n  return {\n    nativeEvent: nativeEvent,\n    passive,\n    passiveSupported,\n    pointerType: eventPointerType,\n    target: nativeEventTarget,\n    type: topLevelType\n  };\n}\n\nfunction responderEventTypesContainType(eventTypes, type) {\n  for (let i = 0, len = eventTypes.length; i < len; i++) {\n    if (eventTypes[i] === type) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction validateResponderTargetEventTypes(eventType, responder) {\n  const {\n    targetEventTypes\n  } = responder; // Validate the target event type exists on the responder\n\n  if (targetEventTypes !== null) {\n    return responderEventTypesContainType(targetEventTypes, eventType);\n  }\n\n  return false;\n}\n\nfunction traverseAndHandleEventResponderInstances(topLevelType, targetFiber, nativeEvent, nativeEventTarget, eventSystemFlags) {\n  const isPassiveEvent = (eventSystemFlags & IS_PASSIVE) !== 0;\n  const isPassiveSupported = (eventSystemFlags & PASSIVE_NOT_SUPPORTED) === 0;\n  const isPassive = isPassiveEvent || !isPassiveSupported;\n  const eventType = isPassive ? topLevelType : topLevelType + '_active'; // Trigger event responders in this order:\n  // - Bubble target responder phase\n  // - Root responder phase\n\n  const visitedResponders = new Set();\n  const responderEvent = createDOMResponderEvent(topLevelType, nativeEvent, nativeEventTarget, isPassiveEvent, isPassiveSupported);\n  let node = targetFiber;\n\n  while (node !== null) {\n    const {\n      dependencies,\n      tag\n    } = node;\n\n    if ((tag === HostComponent || tag === ScopeComponent) && dependencies !== null) {\n      const respondersMap = dependencies.responders;\n\n      if (respondersMap !== null) {\n        const responderInstances = Array.from(respondersMap.values());\n\n        for (let i = 0, length = responderInstances.length; i < length; i++) {\n          const responderInstance = responderInstances[i];\n          const {\n            props,\n            responder,\n            state\n          } = responderInstance;\n\n          if (!visitedResponders.has(responder) && validateResponderTargetEventTypes(eventType, responder)) {\n            visitedResponders.add(responder);\n            const onEvent = responder.onEvent;\n\n            if (onEvent !== null) {\n              currentInstance = responderInstance;\n              onEvent(responderEvent, eventResponderContext, props, state);\n\n              if (currentPropagationBehavior === PropagateToNextResponder) {\n                visitedResponders.delete(responder);\n                currentPropagationBehavior = DoNotPropagateToNextResponder;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    node = node.return;\n  } // Root phase\n\n\n  const rootEventResponderInstances = rootEventTypesToEventResponderInstances.get(eventType);\n\n  if (rootEventResponderInstances !== undefined) {\n    const responderInstances = Array.from(rootEventResponderInstances);\n\n    for (let i = 0; i < responderInstances.length; i++) {\n      const responderInstance = responderInstances[i];\n      const {\n        props,\n        responder,\n        state\n      } = responderInstance;\n      const onRootEvent = responder.onRootEvent;\n\n      if (onRootEvent !== null) {\n        currentInstance = responderInstance;\n        onRootEvent(responderEvent, eventResponderContext, props, state);\n      }\n    }\n  }\n}\n\nexport function mountEventResponder(responder, responderInstance, props, state) {\n  const onMount = responder.onMount;\n\n  if (onMount !== null) {\n    const previousInstance = currentInstance;\n    const previousTimers = currentTimers;\n    currentInstance = responderInstance;\n\n    try {\n      batchedEventUpdates(() => {\n        onMount(eventResponderContext, props, state);\n      });\n    } finally {\n      currentInstance = previousInstance;\n      currentTimers = previousTimers;\n    }\n  }\n}\nexport function unmountEventResponder(responderInstance) {\n  const responder = responderInstance.responder;\n  const onUnmount = responder.onUnmount;\n\n  if (onUnmount !== null) {\n    let {\n      props,\n      state\n    } = responderInstance;\n    const previousInstance = currentInstance;\n    const previousTimers = currentTimers;\n    currentInstance = responderInstance;\n\n    try {\n      batchedEventUpdates(() => {\n        onUnmount(eventResponderContext, props, state);\n      });\n    } finally {\n      currentInstance = previousInstance;\n      currentTimers = previousTimers;\n    }\n  }\n\n  const rootEventTypesSet = responderInstance.rootEventTypes;\n\n  if (rootEventTypesSet !== null) {\n    const rootEventTypes = Array.from(rootEventTypesSet);\n\n    for (let i = 0; i < rootEventTypes.length; i++) {\n      const topLevelEventType = rootEventTypes[i];\n      let rootEventResponderInstances = rootEventTypesToEventResponderInstances.get(topLevelEventType);\n\n      if (rootEventResponderInstances !== undefined) {\n        rootEventResponderInstances.delete(responderInstance);\n      }\n    }\n  }\n}\n\nfunction validateResponderContext() {\n  invariant(currentInstance !== null, 'An event responder context was used outside of an event cycle. ' + 'Use context.setTimeout() to use asynchronous responder context outside of event cycle .');\n}\n\nexport function dispatchEventForResponderEventSystem(topLevelType, targetFiber, nativeEvent, nativeEventTarget, eventSystemFlags) {\n  if (enableFlareAPI) {\n    const previousInstance = currentInstance;\n    const previousTimers = currentTimers;\n    const previousTimeStamp = currentTimeStamp;\n    const previousDocument = currentDocument;\n    const previousPropagationBehavior = currentPropagationBehavior;\n    currentPropagationBehavior = DoNotPropagateToNextResponder;\n    currentTimers = null; // nodeType 9 is DOCUMENT_NODE\n\n    currentDocument = nativeEventTarget.nodeType === 9 ? nativeEventTarget : nativeEventTarget.ownerDocument; // We might want to control timeStamp another way here\n\n    currentTimeStamp = nativeEvent.timeStamp;\n\n    try {\n      batchedEventUpdates(() => {\n        traverseAndHandleEventResponderInstances(topLevelType, targetFiber, nativeEvent, nativeEventTarget, eventSystemFlags);\n      });\n    } finally {\n      currentTimers = previousTimers;\n      currentInstance = previousInstance;\n      currentTimeStamp = previousTimeStamp;\n      currentDocument = previousDocument;\n      currentPropagationBehavior = previousPropagationBehavior;\n    }\n  }\n}\nexport function addRootEventTypesForResponderInstance(responderInstance, rootEventTypes) {\n  for (let i = 0; i < rootEventTypes.length; i++) {\n    const rootEventType = rootEventTypes[i];\n    registerRootEventType(rootEventType, responderInstance);\n  }\n}\n\nfunction registerRootEventType(rootEventType, eventResponderInstance) {\n  let rootEventResponderInstances = rootEventTypesToEventResponderInstances.get(rootEventType);\n\n  if (rootEventResponderInstances === undefined) {\n    rootEventResponderInstances = new Set();\n    rootEventTypesToEventResponderInstances.set(rootEventType, rootEventResponderInstances);\n  }\n\n  let rootEventTypesSet = eventResponderInstance.rootEventTypes;\n\n  if (rootEventTypesSet === null) {\n    rootEventTypesSet = eventResponderInstance.rootEventTypes = new Set();\n  }\n\n  invariant(!rootEventTypesSet.has(rootEventType), 'addRootEventTypes() found a duplicate root event ' + 'type of \"%s\". This might be because the event type exists in the event responder \"rootEventTypes\" ' + 'array or because of a previous addRootEventTypes() using this root event type.', rootEventType);\n  rootEventTypesSet.add(rootEventType);\n  rootEventResponderInstances.add(eventResponderInstance);\n}","map":{"version":3,"sources":["/Users/gaoshaoyun/Documents/library/debug-react/src/react/packages/react-dom/src/events/DOMEventResponderSystem.js"],"names":["IS_PASSIVE","PASSIVE_NOT_SUPPORTED","HostComponent","ScopeComponent","batchedEventUpdates","discreteUpdates","flushDiscreteUpdatesIfNeeded","executeUserEventHandler","enqueueStateRestore","warning","enableFlareAPI","invariant","getClosestInstanceFromNode","ContinuousEvent","UserBlockingEvent","DiscreteEvent","enableUserBlockingEvents","Scheduler","unstable_UserBlockingPriority","UserBlockingPriority","unstable_runWithPriority","runWithPriority","listenToResponderEventTypesImpl","setListenToResponderEventTypes","_listenToResponderEventTypesImpl","activeTimeouts","Map","rootEventTypesToEventResponderInstances","DoNotPropagateToNextResponder","PropagateToNextResponder","currentTimeStamp","currentTimers","currentInstance","currentTimerIDCounter","currentDocument","currentPropagationBehavior","eventResponderContext","dispatchEvent","eventValue","eventListener","eventPriority","validateResponderContext","validateEventValue","isTargetWithinResponder","target","fiber","responderFiber","alternate","return","isTargetWithinResponderScope","componentInstance","responder","doesFiberHaveResponder","isTargetWithinNode","childTarget","parentTarget","childFiber","parentFiber","parentAlternateFiber","node","contains","addRootEventTypes","rootEventTypes","i","length","rootEventType","eventResponderInstance","registerRootEventType","removeRootEventTypes","rootEventResponders","get","rootEventTypesSet","delete","undefined","setTimeout","func","delay","timeout","timerId","timers","id","processTimers","set","instance","timeStamp","clearTimeout","size","getActiveDocument","objectAssign","Object","assign","getTimeStamp","isTargetWithinHostComponent","elementType","tag","type","continuePropagation","getResponderNode","stateNode","Error","showWarning","name","__DEV__","preventDefault","stopPropagation","isDefaultPrevented","isPropagationStopped","defineProperty","dependencies","respondersMap","responders","has","timersArr","Array","from","values","previousInstance","previousTimers","createDOMResponderEvent","topLevelType","nativeEvent","nativeEventTarget","passive","passiveSupported","buttons","pointerType","eventPointerType","key","changedTouches","responderEventTypesContainType","eventTypes","len","validateResponderTargetEventTypes","eventType","targetEventTypes","traverseAndHandleEventResponderInstances","targetFiber","eventSystemFlags","isPassiveEvent","isPassiveSupported","isPassive","visitedResponders","Set","responderEvent","responderInstances","responderInstance","props","state","add","onEvent","rootEventResponderInstances","onRootEvent","mountEventResponder","onMount","unmountEventResponder","onUnmount","topLevelEventType","dispatchEventForResponderEventSystem","previousTimeStamp","previousDocument","previousPropagationBehavior","nodeType","ownerDocument","addRootEventTypesForResponderInstance"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n * @flow\n */\n\nimport {\n  type EventSystemFlags,\n  IS_PASSIVE,\n  PASSIVE_NOT_SUPPORTED,\n} from 'legacy-events/EventSystemFlags';\nimport type {AnyNativeEvent} from 'legacy-events/PluginModuleType';\nimport {HostComponent, ScopeComponent} from 'shared/ReactWorkTags';\nimport type {EventPriority} from 'shared/ReactTypes';\nimport type {\n  ReactDOMEventResponder,\n  ReactDOMEventResponderInstance,\n  ReactDOMResponderContext,\n  ReactDOMResponderEvent,\n} from 'shared/ReactDOMTypes';\nimport type {DOMTopLevelEventType} from 'legacy-events/TopLevelEventTypes';\nimport {\n  batchedEventUpdates,\n  discreteUpdates,\n  flushDiscreteUpdatesIfNeeded,\n  executeUserEventHandler,\n} from 'legacy-events/ReactGenericBatching';\nimport {enqueueStateRestore} from 'legacy-events/ReactControlledComponent';\nimport type {Fiber} from 'react-reconciler/src/ReactFiber';\nimport warning from 'shared/warning';\nimport {enableFlareAPI} from 'shared/ReactFeatureFlags';\nimport invariant from 'shared/invariant';\n\nimport {getClosestInstanceFromNode} from '../client/ReactDOMComponentTree';\nimport {\n  ContinuousEvent,\n  UserBlockingEvent,\n  DiscreteEvent,\n} from 'shared/ReactTypes';\nimport {enableUserBlockingEvents} from 'shared/ReactFeatureFlags';\n\n// Intentionally not named imports because Rollup would use dynamic dispatch for\n// CommonJS interop named imports.\nimport * as Scheduler from 'scheduler';\nconst {\n  unstable_UserBlockingPriority: UserBlockingPriority,\n  unstable_runWithPriority: runWithPriority,\n} = Scheduler;\n\nexport let listenToResponderEventTypesImpl;\n\nexport function setListenToResponderEventTypes(\n  _listenToResponderEventTypesImpl: Function,\n) {\n  listenToResponderEventTypesImpl = _listenToResponderEventTypesImpl;\n}\n\ntype ResponderTimeout = {|\n  id: TimeoutID,\n  timers: Map<number, ResponderTimer>,\n|};\n\ntype ResponderTimer = {|\n  instance: ReactDOMEventResponderInstance,\n  func: () => void,\n  id: number,\n  timeStamp: number,\n|};\n\nconst activeTimeouts: Map<number, ResponderTimeout> = new Map();\nconst rootEventTypesToEventResponderInstances: Map<\n  DOMTopLevelEventType | string,\n  Set<ReactDOMEventResponderInstance>,\n> = new Map();\n\ntype PropagationBehavior = 0 | 1;\n\nconst DoNotPropagateToNextResponder = 0;\nconst PropagateToNextResponder = 1;\n\nlet currentTimeStamp = 0;\nlet currentTimers = new Map();\nlet currentInstance: null | ReactDOMEventResponderInstance = null;\nlet currentTimerIDCounter = 0;\nlet currentDocument: null | Document = null;\nlet currentPropagationBehavior: PropagationBehavior = DoNotPropagateToNextResponder;\n\nconst eventResponderContext: ReactDOMResponderContext = {\n  dispatchEvent(\n    eventValue: any,\n    eventListener: any => void,\n    eventPriority: EventPriority,\n  ): void {\n    validateResponderContext();\n    validateEventValue(eventValue);\n    switch (eventPriority) {\n      case DiscreteEvent: {\n        flushDiscreteUpdatesIfNeeded(currentTimeStamp);\n        discreteUpdates(() =>\n          executeUserEventHandler(eventListener, eventValue),\n        );\n        break;\n      }\n      case UserBlockingEvent: {\n        if (enableUserBlockingEvents) {\n          runWithPriority(UserBlockingPriority, () =>\n            executeUserEventHandler(eventListener, eventValue),\n          );\n        } else {\n          executeUserEventHandler(eventListener, eventValue);\n        }\n        break;\n      }\n      case ContinuousEvent: {\n        executeUserEventHandler(eventListener, eventValue);\n        break;\n      }\n    }\n  },\n  isTargetWithinResponder(target: null | Element | Document): boolean {\n    validateResponderContext();\n    if (target != null) {\n      let fiber = getClosestInstanceFromNode(target);\n      const responderFiber = ((currentInstance: any): ReactDOMEventResponderInstance)\n        .fiber;\n\n      while (fiber !== null) {\n        if (fiber === responderFiber || fiber.alternate === responderFiber) {\n          return true;\n        }\n        fiber = fiber.return;\n      }\n    }\n    return false;\n  },\n  isTargetWithinResponderScope(target: null | Element | Document): boolean {\n    validateResponderContext();\n    const componentInstance = ((currentInstance: any): ReactDOMEventResponderInstance);\n    const responder = componentInstance.responder;\n\n    if (target != null) {\n      let fiber = getClosestInstanceFromNode(target);\n      const responderFiber = ((currentInstance: any): ReactDOMEventResponderInstance)\n        .fiber;\n\n      while (fiber !== null) {\n        if (fiber === responderFiber || fiber.alternate === responderFiber) {\n          return true;\n        }\n        if (doesFiberHaveResponder(fiber, responder)) {\n          return false;\n        }\n        fiber = fiber.return;\n      }\n    }\n    return false;\n  },\n  isTargetWithinNode(\n    childTarget: Element | Document,\n    parentTarget: Element | Document,\n  ): boolean {\n    validateResponderContext();\n    const childFiber = getClosestInstanceFromNode(childTarget);\n    const parentFiber = getClosestInstanceFromNode(parentTarget);\n\n    if (childFiber != null && parentFiber != null) {\n      const parentAlternateFiber = parentFiber.alternate;\n      let node = childFiber;\n      while (node !== null) {\n        if (node === parentFiber || node === parentAlternateFiber) {\n          return true;\n        }\n        node = node.return;\n      }\n      return false;\n    }\n    // Fallback to DOM APIs\n    return parentTarget.contains(childTarget);\n  },\n  addRootEventTypes(rootEventTypes: Array<string>): void {\n    validateResponderContext();\n    listenToResponderEventTypesImpl(rootEventTypes, currentDocument);\n    for (let i = 0; i < rootEventTypes.length; i++) {\n      const rootEventType = rootEventTypes[i];\n      const eventResponderInstance = ((currentInstance: any): ReactDOMEventResponderInstance);\n      registerRootEventType(rootEventType, eventResponderInstance);\n    }\n  },\n  removeRootEventTypes(rootEventTypes: Array<string>): void {\n    validateResponderContext();\n    for (let i = 0; i < rootEventTypes.length; i++) {\n      const rootEventType = rootEventTypes[i];\n      let rootEventResponders = rootEventTypesToEventResponderInstances.get(\n        rootEventType,\n      );\n      let rootEventTypesSet = ((currentInstance: any): ReactDOMEventResponderInstance)\n        .rootEventTypes;\n      if (rootEventTypesSet !== null) {\n        rootEventTypesSet.delete(rootEventType);\n      }\n      if (rootEventResponders !== undefined) {\n        rootEventResponders.delete(\n          ((currentInstance: any): ReactDOMEventResponderInstance),\n        );\n      }\n    }\n  },\n  setTimeout(func: () => void, delay): number {\n    validateResponderContext();\n    if (currentTimers === null) {\n      currentTimers = new Map();\n    }\n    let timeout = currentTimers.get(delay);\n\n    const timerId = currentTimerIDCounter++;\n    if (timeout === undefined) {\n      const timers = new Map();\n      const id = setTimeout(() => {\n        processTimers(timers, delay);\n      }, delay);\n      timeout = {\n        id,\n        timers,\n      };\n      currentTimers.set(delay, timeout);\n    }\n    timeout.timers.set(timerId, {\n      instance: ((currentInstance: any): ReactDOMEventResponderInstance),\n      func,\n      id: timerId,\n      timeStamp: currentTimeStamp,\n    });\n    activeTimeouts.set(timerId, timeout);\n    return timerId;\n  },\n  clearTimeout(timerId: number): void {\n    validateResponderContext();\n    const timeout = activeTimeouts.get(timerId);\n\n    if (timeout !== undefined) {\n      const timers = timeout.timers;\n      timers.delete(timerId);\n      if (timers.size === 0) {\n        clearTimeout(timeout.id);\n      }\n    }\n  },\n  getActiveDocument,\n  objectAssign: Object.assign,\n  getTimeStamp(): number {\n    validateResponderContext();\n    return currentTimeStamp;\n  },\n  isTargetWithinHostComponent(\n    target: Element | Document,\n    elementType: string,\n  ): boolean {\n    validateResponderContext();\n    let fiber = getClosestInstanceFromNode(target);\n\n    while (fiber !== null) {\n      if (fiber.tag === HostComponent && fiber.type === elementType) {\n        return true;\n      }\n      fiber = fiber.return;\n    }\n    return false;\n  },\n  continuePropagation() {\n    currentPropagationBehavior = PropagateToNextResponder;\n  },\n  enqueueStateRestore,\n  getResponderNode(): Element | null {\n    validateResponderContext();\n    const responderFiber = ((currentInstance: any): ReactDOMEventResponderInstance)\n      .fiber;\n    if (responderFiber.tag === ScopeComponent) {\n      return null;\n    }\n    return responderFiber.stateNode;\n  },\n};\n\nfunction validateEventValue(eventValue: any): void {\n  if (typeof eventValue === 'object' && eventValue !== null) {\n    const {target, type, timeStamp} = eventValue;\n\n    if (target == null || type == null || timeStamp == null) {\n      throw new Error(\n        'context.dispatchEvent: \"target\", \"timeStamp\", and \"type\" fields on event object are required.',\n      );\n    }\n    const showWarning = name => {\n      if (__DEV__) {\n        warning(\n          false,\n          '%s is not available on event objects created from event responder modules (React Flare). ' +\n            'Try wrapping in a conditional, i.e. `if (event.type !== \"press\") { event.%s }`',\n          name,\n          name,\n        );\n      }\n    };\n    eventValue.preventDefault = () => {\n      if (__DEV__) {\n        showWarning('preventDefault()');\n      }\n    };\n    eventValue.stopPropagation = () => {\n      if (__DEV__) {\n        showWarning('stopPropagation()');\n      }\n    };\n    eventValue.isDefaultPrevented = () => {\n      if (__DEV__) {\n        showWarning('isDefaultPrevented()');\n      }\n    };\n    eventValue.isPropagationStopped = () => {\n      if (__DEV__) {\n        showWarning('isPropagationStopped()');\n      }\n    };\n    // $FlowFixMe: we don't need value, Flow thinks we do\n    Object.defineProperty(eventValue, 'nativeEvent', {\n      get() {\n        if (__DEV__) {\n          showWarning('nativeEvent');\n        }\n      },\n    });\n  }\n}\n\nfunction doesFiberHaveResponder(\n  fiber: Fiber,\n  responder: ReactDOMEventResponder,\n): boolean {\n  const tag = fiber.tag;\n  if (tag === HostComponent || tag === ScopeComponent) {\n    const dependencies = fiber.dependencies;\n    if (dependencies !== null) {\n      const respondersMap = dependencies.responders;\n      if (respondersMap !== null && respondersMap.has(responder)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfunction getActiveDocument(): Document {\n  return ((currentDocument: any): Document);\n}\n\nfunction processTimers(\n  timers: Map<number, ResponderTimer>,\n  delay: number,\n): void {\n  const timersArr = Array.from(timers.values());\n  const previousInstance = currentInstance;\n  const previousTimers = currentTimers;\n  try {\n    batchedEventUpdates(() => {\n      for (let i = 0; i < timersArr.length; i++) {\n        const {instance, func, id, timeStamp} = timersArr[i];\n        currentInstance = instance;\n        currentTimeStamp = timeStamp + delay;\n        try {\n          func();\n        } finally {\n          activeTimeouts.delete(id);\n        }\n      }\n    });\n  } finally {\n    currentTimers = previousTimers;\n    currentInstance = previousInstance;\n    currentTimeStamp = 0;\n  }\n}\n\nfunction createDOMResponderEvent(\n  topLevelType: string,\n  nativeEvent: AnyNativeEvent,\n  nativeEventTarget: Element | Document,\n  passive: boolean,\n  passiveSupported: boolean,\n): ReactDOMResponderEvent {\n  const {buttons, pointerType} = (nativeEvent: any);\n  let eventPointerType = '';\n\n  if (pointerType !== undefined) {\n    eventPointerType = pointerType;\n  } else if (nativeEvent.key !== undefined) {\n    eventPointerType = 'keyboard';\n  } else if (buttons !== undefined) {\n    eventPointerType = 'mouse';\n  } else if ((nativeEvent: any).changedTouches !== undefined) {\n    eventPointerType = 'touch';\n  }\n\n  return {\n    nativeEvent: nativeEvent,\n    passive,\n    passiveSupported,\n    pointerType: eventPointerType,\n    target: nativeEventTarget,\n    type: topLevelType,\n  };\n}\n\nfunction responderEventTypesContainType(\n  eventTypes: Array<string>,\n  type: string,\n): boolean {\n  for (let i = 0, len = eventTypes.length; i < len; i++) {\n    if (eventTypes[i] === type) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction validateResponderTargetEventTypes(\n  eventType: string,\n  responder: ReactDOMEventResponder,\n): boolean {\n  const {targetEventTypes} = responder;\n  // Validate the target event type exists on the responder\n  if (targetEventTypes !== null) {\n    return responderEventTypesContainType(targetEventTypes, eventType);\n  }\n  return false;\n}\n\nfunction traverseAndHandleEventResponderInstances(\n  topLevelType: string,\n  targetFiber: null | Fiber,\n  nativeEvent: AnyNativeEvent,\n  nativeEventTarget: Document | Element,\n  eventSystemFlags: EventSystemFlags,\n): void {\n  const isPassiveEvent = (eventSystemFlags & IS_PASSIVE) !== 0;\n  const isPassiveSupported = (eventSystemFlags & PASSIVE_NOT_SUPPORTED) === 0;\n  const isPassive = isPassiveEvent || !isPassiveSupported;\n  const eventType = isPassive ? topLevelType : topLevelType + '_active';\n\n  // Trigger event responders in this order:\n  // - Bubble target responder phase\n  // - Root responder phase\n\n  const visitedResponders = new Set();\n  const responderEvent = createDOMResponderEvent(\n    topLevelType,\n    nativeEvent,\n    nativeEventTarget,\n    isPassiveEvent,\n    isPassiveSupported,\n  );\n  let node = targetFiber;\n  while (node !== null) {\n    const {dependencies, tag} = node;\n    if (\n      (tag === HostComponent || tag === ScopeComponent) &&\n      dependencies !== null\n    ) {\n      const respondersMap = dependencies.responders;\n      if (respondersMap !== null) {\n        const responderInstances = Array.from(respondersMap.values());\n        for (let i = 0, length = responderInstances.length; i < length; i++) {\n          const responderInstance = responderInstances[i];\n          const {props, responder, state} = responderInstance;\n          if (\n            !visitedResponders.has(responder) &&\n            validateResponderTargetEventTypes(eventType, responder)\n          ) {\n            visitedResponders.add(responder);\n            const onEvent = responder.onEvent;\n            if (onEvent !== null) {\n              currentInstance = responderInstance;\n              onEvent(responderEvent, eventResponderContext, props, state);\n              if (currentPropagationBehavior === PropagateToNextResponder) {\n                visitedResponders.delete(responder);\n                currentPropagationBehavior = DoNotPropagateToNextResponder;\n              }\n            }\n          }\n        }\n      }\n    }\n    node = node.return;\n  }\n  // Root phase\n  const rootEventResponderInstances = rootEventTypesToEventResponderInstances.get(\n    eventType,\n  );\n  if (rootEventResponderInstances !== undefined) {\n    const responderInstances = Array.from(rootEventResponderInstances);\n\n    for (let i = 0; i < responderInstances.length; i++) {\n      const responderInstance = responderInstances[i];\n      const {props, responder, state} = responderInstance;\n      const onRootEvent = responder.onRootEvent;\n      if (onRootEvent !== null) {\n        currentInstance = responderInstance;\n        onRootEvent(responderEvent, eventResponderContext, props, state);\n      }\n    }\n  }\n}\n\nexport function mountEventResponder(\n  responder: ReactDOMEventResponder,\n  responderInstance: ReactDOMEventResponderInstance,\n  props: Object,\n  state: Object,\n) {\n  const onMount = responder.onMount;\n  if (onMount !== null) {\n    const previousInstance = currentInstance;\n    const previousTimers = currentTimers;\n    currentInstance = responderInstance;\n    try {\n      batchedEventUpdates(() => {\n        onMount(eventResponderContext, props, state);\n      });\n    } finally {\n      currentInstance = previousInstance;\n      currentTimers = previousTimers;\n    }\n  }\n}\n\nexport function unmountEventResponder(\n  responderInstance: ReactDOMEventResponderInstance,\n): void {\n  const responder = ((responderInstance.responder: any): ReactDOMEventResponder);\n  const onUnmount = responder.onUnmount;\n  if (onUnmount !== null) {\n    let {props, state} = responderInstance;\n    const previousInstance = currentInstance;\n    const previousTimers = currentTimers;\n    currentInstance = responderInstance;\n    try {\n      batchedEventUpdates(() => {\n        onUnmount(eventResponderContext, props, state);\n      });\n    } finally {\n      currentInstance = previousInstance;\n      currentTimers = previousTimers;\n    }\n  }\n  const rootEventTypesSet = responderInstance.rootEventTypes;\n  if (rootEventTypesSet !== null) {\n    const rootEventTypes = Array.from(rootEventTypesSet);\n\n    for (let i = 0; i < rootEventTypes.length; i++) {\n      const topLevelEventType = rootEventTypes[i];\n      let rootEventResponderInstances = rootEventTypesToEventResponderInstances.get(\n        topLevelEventType,\n      );\n      if (rootEventResponderInstances !== undefined) {\n        rootEventResponderInstances.delete(responderInstance);\n      }\n    }\n  }\n}\n\nfunction validateResponderContext(): void {\n  invariant(\n    currentInstance !== null,\n    'An event responder context was used outside of an event cycle. ' +\n      'Use context.setTimeout() to use asynchronous responder context outside of event cycle .',\n  );\n}\n\nexport function dispatchEventForResponderEventSystem(\n  topLevelType: string,\n  targetFiber: null | Fiber,\n  nativeEvent: AnyNativeEvent,\n  nativeEventTarget: Document | Element,\n  eventSystemFlags: EventSystemFlags,\n): void {\n  if (enableFlareAPI) {\n    const previousInstance = currentInstance;\n    const previousTimers = currentTimers;\n    const previousTimeStamp = currentTimeStamp;\n    const previousDocument = currentDocument;\n    const previousPropagationBehavior = currentPropagationBehavior;\n    currentPropagationBehavior = DoNotPropagateToNextResponder;\n    currentTimers = null;\n    // nodeType 9 is DOCUMENT_NODE\n    currentDocument =\n      (nativeEventTarget: any).nodeType === 9\n        ? ((nativeEventTarget: any): Document)\n        : (nativeEventTarget: any).ownerDocument;\n    // We might want to control timeStamp another way here\n    currentTimeStamp = (nativeEvent: any).timeStamp;\n    try {\n      batchedEventUpdates(() => {\n        traverseAndHandleEventResponderInstances(\n          topLevelType,\n          targetFiber,\n          nativeEvent,\n          nativeEventTarget,\n          eventSystemFlags,\n        );\n      });\n    } finally {\n      currentTimers = previousTimers;\n      currentInstance = previousInstance;\n      currentTimeStamp = previousTimeStamp;\n      currentDocument = previousDocument;\n      currentPropagationBehavior = previousPropagationBehavior;\n    }\n  }\n}\n\nexport function addRootEventTypesForResponderInstance(\n  responderInstance: ReactDOMEventResponderInstance,\n  rootEventTypes: Array<string>,\n): void {\n  for (let i = 0; i < rootEventTypes.length; i++) {\n    const rootEventType = rootEventTypes[i];\n    registerRootEventType(rootEventType, responderInstance);\n  }\n}\n\nfunction registerRootEventType(\n  rootEventType: string,\n  eventResponderInstance: ReactDOMEventResponderInstance,\n): void {\n  let rootEventResponderInstances = rootEventTypesToEventResponderInstances.get(\n    rootEventType,\n  );\n  if (rootEventResponderInstances === undefined) {\n    rootEventResponderInstances = new Set();\n    rootEventTypesToEventResponderInstances.set(\n      rootEventType,\n      rootEventResponderInstances,\n    );\n  }\n  let rootEventTypesSet = eventResponderInstance.rootEventTypes;\n  if (rootEventTypesSet === null) {\n    rootEventTypesSet = eventResponderInstance.rootEventTypes = new Set();\n  }\n  invariant(\n    !rootEventTypesSet.has(rootEventType),\n    'addRootEventTypes() found a duplicate root event ' +\n      'type of \"%s\". This might be because the event type exists in the event responder \"rootEventTypes\" ' +\n      'array or because of a previous addRootEventTypes() using this root event type.',\n    rootEventType,\n  );\n  rootEventTypesSet.add(rootEventType);\n  rootEventResponderInstances.add(eventResponderInstance);\n}\n"]},"metadata":{},"sourceType":"module"}