{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { enableFlareAPI, enableSelectiveHydration } from 'shared/ReactFeatureFlags';\nimport { unstable_runWithPriority as runWithPriority, unstable_scheduleCallback as scheduleCallback, unstable_NormalPriority as NormalPriority, unstable_getCurrentPriorityLevel as getCurrentPriorityLevel } from 'scheduler';\nimport { getNearestMountedFiber, getContainerFromFiber, getSuspenseInstanceFromFiber } from 'react-reconciler/reflection';\nimport { attemptToDispatchEvent, trapEventForResponderEventSystem } from './ReactDOMEventListener';\nimport { getListeningSetForElement, listenToTopLevel } from './ReactBrowserEventEmitter';\nimport { getInstanceFromNode, getClosestInstanceFromNode } from '../client/ReactDOMComponentTree';\nimport { unsafeCastDOMTopLevelTypeToString } from 'legacy-events/TopLevelEventTypes';\nimport { HostRoot, SuspenseComponent } from 'shared/ReactWorkTags';\nlet attemptSynchronousHydration;\nexport function setAttemptSynchronousHydration(fn) {\n  attemptSynchronousHydration = fn;\n}\nlet attemptUserBlockingHydration;\nexport function setAttemptUserBlockingHydration(fn) {\n  attemptUserBlockingHydration = fn;\n}\nlet attemptContinuousHydration;\nexport function setAttemptContinuousHydration(fn) {\n  attemptContinuousHydration = fn;\n}\nlet attemptHydrationAtCurrentPriority;\nexport function setAttemptHydrationAtCurrentPriority(fn) {\n  attemptHydrationAtCurrentPriority = fn;\n} // TODO: Upgrade this definition once we're on a newer version of Flow that\n// has this definition built-in.\n\nimport { TOP_MOUSE_DOWN, TOP_MOUSE_UP, TOP_TOUCH_CANCEL, TOP_TOUCH_END, TOP_TOUCH_START, TOP_AUX_CLICK, TOP_DOUBLE_CLICK, TOP_POINTER_CANCEL, TOP_POINTER_DOWN, TOP_POINTER_UP, TOP_DRAG_END, TOP_DRAG_START, TOP_DROP, TOP_COMPOSITION_END, TOP_COMPOSITION_START, TOP_KEY_DOWN, TOP_KEY_PRESS, TOP_KEY_UP, TOP_INPUT, TOP_TEXT_INPUT, TOP_CLOSE, TOP_CANCEL, TOP_COPY, TOP_CUT, TOP_PASTE, TOP_CLICK, TOP_CHANGE, TOP_CONTEXT_MENU, TOP_RESET, TOP_SUBMIT, TOP_DRAG_ENTER, TOP_DRAG_LEAVE, TOP_MOUSE_OVER, TOP_MOUSE_OUT, TOP_POINTER_OVER, TOP_POINTER_OUT, TOP_GOT_POINTER_CAPTURE, TOP_LOST_POINTER_CAPTURE, TOP_FOCUS, TOP_BLUR } from './DOMTopLevelEventTypes';\nimport { IS_REPLAYED } from 'legacy-events/EventSystemFlags';\nlet hasScheduledReplayAttempt = false; // The queue of discrete events to be replayed.\n\nlet queuedDiscreteEvents = []; // Indicates if any continuous event targets are non-null for early bailout.\n\nlet hasAnyQueuedContinuousEvents = false; // The last of each continuous event type. We only need to replay the last one\n// if the last target was dehydrated.\n\nlet queuedFocus = null;\nlet queuedDrag = null;\nlet queuedMouse = null; // For pointer events there can be one latest event per pointerId.\n\nlet queuedPointers = new Map();\nlet queuedPointerCaptures = new Map(); // We could consider replaying selectionchange and touchmoves too.\n\nlet queuedExplicitHydrationTargets = [];\nexport function hasQueuedDiscreteEvents() {\n  return queuedDiscreteEvents.length > 0;\n}\nexport function hasQueuedContinuousEvents() {\n  return hasAnyQueuedContinuousEvents;\n}\nconst discreteReplayableEvents = [TOP_MOUSE_DOWN, TOP_MOUSE_UP, TOP_TOUCH_CANCEL, TOP_TOUCH_END, TOP_TOUCH_START, TOP_AUX_CLICK, TOP_DOUBLE_CLICK, TOP_POINTER_CANCEL, TOP_POINTER_DOWN, TOP_POINTER_UP, TOP_DRAG_END, TOP_DRAG_START, TOP_DROP, TOP_COMPOSITION_END, TOP_COMPOSITION_START, TOP_KEY_DOWN, TOP_KEY_PRESS, TOP_KEY_UP, TOP_INPUT, TOP_TEXT_INPUT, TOP_CLOSE, TOP_CANCEL, TOP_COPY, TOP_CUT, TOP_PASTE, TOP_CLICK, TOP_CHANGE, TOP_CONTEXT_MENU, TOP_RESET, TOP_SUBMIT];\nconst continuousReplayableEvents = [TOP_FOCUS, TOP_BLUR, TOP_DRAG_ENTER, TOP_DRAG_LEAVE, TOP_MOUSE_OVER, TOP_MOUSE_OUT, TOP_POINTER_OVER, TOP_POINTER_OUT, TOP_GOT_POINTER_CAPTURE, TOP_LOST_POINTER_CAPTURE];\nexport function isReplayableDiscreteEvent(eventType) {\n  return discreteReplayableEvents.indexOf(eventType) > -1;\n}\n\nfunction trapReplayableEvent(topLevelType, document, listeningSet) {\n  listenToTopLevel(topLevelType, document, listeningSet);\n\n  if (enableFlareAPI) {\n    // Trap events for the responder system.\n    const passiveEventKey = unsafeCastDOMTopLevelTypeToString(topLevelType) + '_passive';\n\n    if (!listeningSet.has(passiveEventKey)) {\n      trapEventForResponderEventSystem(document, topLevelType, true);\n      listeningSet.add(passiveEventKey);\n    } // TODO: This listens to all events as active which might have\n    // undesirable effects. It's also unnecessary to have both\n    // passive and active listeners. Instead, we could start with\n    // a passive and upgrade it to an active one if needed.\n    // For replaying purposes the active is never needed since we\n    // currently don't preventDefault.\n\n\n    const activeEventKey = unsafeCastDOMTopLevelTypeToString(topLevelType) + '_active';\n\n    if (!listeningSet.has(activeEventKey)) {\n      trapEventForResponderEventSystem(document, topLevelType, false);\n      listeningSet.add(activeEventKey);\n    }\n  }\n}\n\nexport function eagerlyTrapReplayableEvents(document) {\n  const listeningSet = getListeningSetForElement(document); // Discrete\n\n  discreteReplayableEvents.forEach(topLevelType => {\n    trapReplayableEvent(topLevelType, document, listeningSet);\n  }); // Continuous\n\n  continuousReplayableEvents.forEach(topLevelType => {\n    trapReplayableEvent(topLevelType, document, listeningSet);\n  });\n}\n\nfunction createQueuedReplayableEvent(blockedOn, topLevelType, eventSystemFlags, nativeEvent) {\n  return {\n    blockedOn,\n    topLevelType,\n    eventSystemFlags: eventSystemFlags | IS_REPLAYED,\n    nativeEvent\n  };\n}\n\nexport function queueDiscreteEvent(blockedOn, topLevelType, eventSystemFlags, nativeEvent) {\n  const queuedEvent = createQueuedReplayableEvent(blockedOn, topLevelType, eventSystemFlags, nativeEvent);\n  queuedDiscreteEvents.push(queuedEvent);\n\n  if (enableSelectiveHydration) {\n    if (queuedDiscreteEvents.length === 1) {\n      // If this was the first discrete event, we might be able to\n      // synchronously unblock it so that preventDefault still works.\n      while (queuedEvent.blockedOn !== null) {\n        let fiber = getInstanceFromNode(queuedEvent.blockedOn);\n\n        if (fiber === null) {\n          break;\n        }\n\n        attemptSynchronousHydration(fiber);\n\n        if (queuedEvent.blockedOn === null) {\n          // We got unblocked by hydration. Let's try again.\n          replayUnblockedEvents(); // If we're reblocked, on an inner boundary, we might need\n          // to attempt hydrating that one.\n\n          continue;\n        } else {\n          // We're still blocked from hydation, we have to give up\n          // and replay later.\n          break;\n        }\n      }\n    }\n  }\n} // Resets the replaying for this type of continuous event to no event.\n\nexport function clearIfContinuousEvent(topLevelType, nativeEvent) {\n  switch (topLevelType) {\n    case TOP_FOCUS:\n    case TOP_BLUR:\n      queuedFocus = null;\n      break;\n\n    case TOP_DRAG_ENTER:\n    case TOP_DRAG_LEAVE:\n      queuedDrag = null;\n      break;\n\n    case TOP_MOUSE_OVER:\n    case TOP_MOUSE_OUT:\n      queuedMouse = null;\n      break;\n\n    case TOP_POINTER_OVER:\n    case TOP_POINTER_OUT:\n      {\n        let pointerId = nativeEvent.pointerId;\n        queuedPointers.delete(pointerId);\n        break;\n      }\n\n    case TOP_GOT_POINTER_CAPTURE:\n    case TOP_LOST_POINTER_CAPTURE:\n      {\n        let pointerId = nativeEvent.pointerId;\n        queuedPointerCaptures.delete(pointerId);\n        break;\n      }\n  }\n}\n\nfunction accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, topLevelType, eventSystemFlags, nativeEvent) {\n  if (existingQueuedEvent === null || existingQueuedEvent.nativeEvent !== nativeEvent) {\n    let queuedEvent = createQueuedReplayableEvent(blockedOn, topLevelType, eventSystemFlags, nativeEvent);\n\n    if (blockedOn !== null) {\n      let fiber = getInstanceFromNode(blockedOn);\n\n      if (fiber !== null) {\n        // Attempt to increase the priority of this target.\n        attemptContinuousHydration(fiber);\n      }\n    }\n\n    return queuedEvent;\n  } // If we have already queued this exact event, then it's because\n  // the different event systems have different DOM event listeners.\n  // We can accumulate the flags and store a single event to be\n  // replayed.\n\n\n  existingQueuedEvent.eventSystemFlags |= eventSystemFlags;\n  return existingQueuedEvent;\n}\n\nexport function queueIfContinuousEvent(blockedOn, topLevelType, eventSystemFlags, nativeEvent) {\n  // These set relatedTarget to null because the replayed event will be treated as if we\n  // moved from outside the window (no target) onto the target once it hydrates.\n  // Instead of mutating we could clone the event.\n  switch (topLevelType) {\n    case TOP_FOCUS:\n      {\n        const focusEvent = nativeEvent;\n        queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, topLevelType, eventSystemFlags, focusEvent);\n        return true;\n      }\n\n    case TOP_DRAG_ENTER:\n      {\n        const dragEvent = nativeEvent;\n        queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, topLevelType, eventSystemFlags, dragEvent);\n        return true;\n      }\n\n    case TOP_MOUSE_OVER:\n      {\n        const mouseEvent = nativeEvent;\n        queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, topLevelType, eventSystemFlags, mouseEvent);\n        return true;\n      }\n\n    case TOP_POINTER_OVER:\n      {\n        const pointerEvent = nativeEvent;\n        const pointerId = pointerEvent.pointerId;\n        queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, topLevelType, eventSystemFlags, pointerEvent));\n        return true;\n      }\n\n    case TOP_GOT_POINTER_CAPTURE:\n      {\n        const pointerEvent = nativeEvent;\n        const pointerId = pointerEvent.pointerId;\n        queuedPointerCaptures.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(pointerId) || null, blockedOn, topLevelType, eventSystemFlags, pointerEvent));\n        return true;\n      }\n  }\n\n  return false;\n} // Check if this target is unblocked. Returns true if it's unblocked.\n\nfunction attemptExplicitHydrationTarget(queuedTarget) {\n  // TODO: This function shares a lot of logic with attemptToDispatchEvent.\n  // Try to unify them. It's a bit tricky since it would require two return\n  // values.\n  let targetInst = getClosestInstanceFromNode(queuedTarget.target);\n\n  if (targetInst !== null) {\n    let nearestMounted = getNearestMountedFiber(targetInst);\n\n    if (nearestMounted !== null) {\n      const tag = nearestMounted.tag;\n\n      if (tag === SuspenseComponent) {\n        let instance = getSuspenseInstanceFromFiber(nearestMounted);\n\n        if (instance !== null) {\n          // We're blocked on hydrating this boundary.\n          // Increase its priority.\n          queuedTarget.blockedOn = instance;\n          runWithPriority(queuedTarget.priority, () => {\n            attemptHydrationAtCurrentPriority(nearestMounted);\n          });\n          return;\n        }\n      } else if (tag === HostRoot) {\n        const root = nearestMounted.stateNode;\n\n        if (root.hydrate) {\n          queuedTarget.blockedOn = getContainerFromFiber(nearestMounted); // We don't currently have a way to increase the priority of\n          // a root other than sync.\n\n          return;\n        }\n      }\n    }\n  }\n\n  queuedTarget.blockedOn = null;\n}\n\nexport function queueExplicitHydrationTarget(target) {\n  if (enableSelectiveHydration) {\n    let priority = getCurrentPriorityLevel();\n    const queuedTarget = {\n      blockedOn: null,\n      target: target,\n      priority: priority\n    };\n    let i = 0;\n\n    for (; i < queuedExplicitHydrationTargets.length; i++) {\n      if (priority <= queuedExplicitHydrationTargets[i].priority) {\n        break;\n      }\n    }\n\n    queuedExplicitHydrationTargets.splice(i, 0, queuedTarget);\n\n    if (i === 0) {\n      attemptExplicitHydrationTarget(queuedTarget);\n    }\n  }\n}\n\nfunction attemptReplayContinuousQueuedEvent(queuedEvent) {\n  if (queuedEvent.blockedOn !== null) {\n    return false;\n  }\n\n  let nextBlockedOn = attemptToDispatchEvent(queuedEvent.topLevelType, queuedEvent.eventSystemFlags, queuedEvent.nativeEvent);\n\n  if (nextBlockedOn !== null) {\n    // We're still blocked. Try again later.\n    let fiber = getInstanceFromNode(nextBlockedOn);\n\n    if (fiber !== null) {\n      attemptContinuousHydration(fiber);\n    }\n\n    queuedEvent.blockedOn = nextBlockedOn;\n    return false;\n  }\n\n  return true;\n}\n\nfunction attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {\n  if (attemptReplayContinuousQueuedEvent(queuedEvent)) {\n    map.delete(key);\n  }\n}\n\nfunction replayUnblockedEvents() {\n  hasScheduledReplayAttempt = false; // First replay discrete events.\n\n  while (queuedDiscreteEvents.length > 0) {\n    let nextDiscreteEvent = queuedDiscreteEvents[0];\n\n    if (nextDiscreteEvent.blockedOn !== null) {\n      // We're still blocked.\n      // Increase the priority of this boundary to unblock\n      // the next discrete event.\n      let fiber = getInstanceFromNode(nextDiscreteEvent.blockedOn);\n\n      if (fiber !== null) {\n        attemptUserBlockingHydration(fiber);\n      }\n\n      break;\n    }\n\n    let nextBlockedOn = attemptToDispatchEvent(nextDiscreteEvent.topLevelType, nextDiscreteEvent.eventSystemFlags, nextDiscreteEvent.nativeEvent);\n\n    if (nextBlockedOn !== null) {\n      // We're still blocked. Try again later.\n      nextDiscreteEvent.blockedOn = nextBlockedOn;\n    } else {\n      // We've successfully replayed the first event. Let's try the next one.\n      queuedDiscreteEvents.shift();\n    }\n  } // Next replay any continuous events.\n\n\n  if (queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus)) {\n    queuedFocus = null;\n  }\n\n  if (queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag)) {\n    queuedDrag = null;\n  }\n\n  if (queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse)) {\n    queuedMouse = null;\n  }\n\n  queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);\n  queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);\n}\n\nfunction scheduleCallbackIfUnblocked(queuedEvent, unblocked) {\n  if (queuedEvent.blockedOn === unblocked) {\n    queuedEvent.blockedOn = null;\n\n    if (!hasScheduledReplayAttempt) {\n      hasScheduledReplayAttempt = true; // Schedule a callback to attempt replaying as many events as are\n      // now unblocked. This first might not actually be unblocked yet.\n      // We could check it early to avoid scheduling an unnecessary callback.\n\n      scheduleCallback(NormalPriority, replayUnblockedEvents);\n    }\n  }\n}\n\nexport function retryIfBlockedOn(unblocked) {\n  // Mark anything that was blocked on this as no longer blocked\n  // and eligible for a replay.\n  if (queuedDiscreteEvents.length > 0) {\n    scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked); // This is a exponential search for each boundary that commits. I think it's\n    // worth it because we expect very few discrete events to queue up and once\n    // we are actually fully unblocked it will be fast to replay them.\n\n    for (let i = 1; i < queuedDiscreteEvents.length; i++) {\n      let queuedEvent = queuedDiscreteEvents[i];\n\n      if (queuedEvent.blockedOn === unblocked) {\n        queuedEvent.blockedOn = null;\n      }\n    }\n  }\n\n  if (queuedFocus !== null) {\n    scheduleCallbackIfUnblocked(queuedFocus, unblocked);\n  }\n\n  if (queuedDrag !== null) {\n    scheduleCallbackIfUnblocked(queuedDrag, unblocked);\n  }\n\n  if (queuedMouse !== null) {\n    scheduleCallbackIfUnblocked(queuedMouse, unblocked);\n  }\n\n  const unblock = queuedEvent => scheduleCallbackIfUnblocked(queuedEvent, unblocked);\n\n  queuedPointers.forEach(unblock);\n  queuedPointerCaptures.forEach(unblock);\n\n  for (let i = 0; i < queuedExplicitHydrationTargets.length; i++) {\n    let queuedTarget = queuedExplicitHydrationTargets[i];\n\n    if (queuedTarget.blockedOn === unblocked) {\n      queuedTarget.blockedOn = null;\n    }\n  }\n\n  while (queuedExplicitHydrationTargets.length > 0) {\n    let nextExplicitTarget = queuedExplicitHydrationTargets[0];\n\n    if (nextExplicitTarget.blockedOn !== null) {\n      // We're still blocked.\n      break;\n    } else {\n      attemptExplicitHydrationTarget(nextExplicitTarget);\n\n      if (nextExplicitTarget.blockedOn === null) {\n        // We're unblocked.\n        queuedExplicitHydrationTargets.shift();\n      }\n    }\n  }\n}","map":{"version":3,"sources":["/Users/gaoshaoyun/Documents/library/debug-react/src/react/packages/react-dom/src/events/ReactDOMEventReplaying.js"],"names":["enableFlareAPI","enableSelectiveHydration","unstable_runWithPriority","runWithPriority","unstable_scheduleCallback","scheduleCallback","unstable_NormalPriority","NormalPriority","unstable_getCurrentPriorityLevel","getCurrentPriorityLevel","getNearestMountedFiber","getContainerFromFiber","getSuspenseInstanceFromFiber","attemptToDispatchEvent","trapEventForResponderEventSystem","getListeningSetForElement","listenToTopLevel","getInstanceFromNode","getClosestInstanceFromNode","unsafeCastDOMTopLevelTypeToString","HostRoot","SuspenseComponent","attemptSynchronousHydration","setAttemptSynchronousHydration","fn","attemptUserBlockingHydration","setAttemptUserBlockingHydration","attemptContinuousHydration","setAttemptContinuousHydration","attemptHydrationAtCurrentPriority","setAttemptHydrationAtCurrentPriority","TOP_MOUSE_DOWN","TOP_MOUSE_UP","TOP_TOUCH_CANCEL","TOP_TOUCH_END","TOP_TOUCH_START","TOP_AUX_CLICK","TOP_DOUBLE_CLICK","TOP_POINTER_CANCEL","TOP_POINTER_DOWN","TOP_POINTER_UP","TOP_DRAG_END","TOP_DRAG_START","TOP_DROP","TOP_COMPOSITION_END","TOP_COMPOSITION_START","TOP_KEY_DOWN","TOP_KEY_PRESS","TOP_KEY_UP","TOP_INPUT","TOP_TEXT_INPUT","TOP_CLOSE","TOP_CANCEL","TOP_COPY","TOP_CUT","TOP_PASTE","TOP_CLICK","TOP_CHANGE","TOP_CONTEXT_MENU","TOP_RESET","TOP_SUBMIT","TOP_DRAG_ENTER","TOP_DRAG_LEAVE","TOP_MOUSE_OVER","TOP_MOUSE_OUT","TOP_POINTER_OVER","TOP_POINTER_OUT","TOP_GOT_POINTER_CAPTURE","TOP_LOST_POINTER_CAPTURE","TOP_FOCUS","TOP_BLUR","IS_REPLAYED","hasScheduledReplayAttempt","queuedDiscreteEvents","hasAnyQueuedContinuousEvents","queuedFocus","queuedDrag","queuedMouse","queuedPointers","Map","queuedPointerCaptures","queuedExplicitHydrationTargets","hasQueuedDiscreteEvents","length","hasQueuedContinuousEvents","discreteReplayableEvents","continuousReplayableEvents","isReplayableDiscreteEvent","eventType","indexOf","trapReplayableEvent","topLevelType","document","listeningSet","passiveEventKey","has","add","activeEventKey","eagerlyTrapReplayableEvents","forEach","createQueuedReplayableEvent","blockedOn","eventSystemFlags","nativeEvent","queueDiscreteEvent","queuedEvent","push","fiber","replayUnblockedEvents","clearIfContinuousEvent","pointerId","delete","accumulateOrCreateContinuousQueuedReplayableEvent","existingQueuedEvent","queueIfContinuousEvent","focusEvent","dragEvent","mouseEvent","pointerEvent","set","get","attemptExplicitHydrationTarget","queuedTarget","targetInst","target","nearestMounted","tag","instance","priority","root","stateNode","hydrate","queueExplicitHydrationTarget","i","splice","attemptReplayContinuousQueuedEvent","nextBlockedOn","attemptReplayContinuousQueuedEventInMap","key","map","nextDiscreteEvent","shift","scheduleCallbackIfUnblocked","unblocked","retryIfBlockedOn","unblock","nextExplicitTarget"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {AnyNativeEvent} from 'legacy-events/PluginModuleType';\nimport type {Container, SuspenseInstance} from '../client/ReactDOMHostConfig';\nimport type {DOMTopLevelEventType} from 'legacy-events/TopLevelEventTypes';\nimport type {EventSystemFlags} from 'legacy-events/EventSystemFlags';\nimport type {FiberRoot} from 'react-reconciler/src/ReactFiberRoot';\n\nimport {\n  enableFlareAPI,\n  enableSelectiveHydration,\n} from 'shared/ReactFeatureFlags';\nimport {\n  unstable_runWithPriority as runWithPriority,\n  unstable_scheduleCallback as scheduleCallback,\n  unstable_NormalPriority as NormalPriority,\n  unstable_getCurrentPriorityLevel as getCurrentPriorityLevel,\n} from 'scheduler';\nimport {\n  getNearestMountedFiber,\n  getContainerFromFiber,\n  getSuspenseInstanceFromFiber,\n} from 'react-reconciler/reflection';\nimport {\n  attemptToDispatchEvent,\n  trapEventForResponderEventSystem,\n} from './ReactDOMEventListener';\nimport {\n  getListeningSetForElement,\n  listenToTopLevel,\n} from './ReactBrowserEventEmitter';\nimport {\n  getInstanceFromNode,\n  getClosestInstanceFromNode,\n} from '../client/ReactDOMComponentTree';\nimport {unsafeCastDOMTopLevelTypeToString} from 'legacy-events/TopLevelEventTypes';\nimport {HostRoot, SuspenseComponent} from 'shared/ReactWorkTags';\n\nlet attemptSynchronousHydration: (fiber: Object) => void;\n\nexport function setAttemptSynchronousHydration(fn: (fiber: Object) => void) {\n  attemptSynchronousHydration = fn;\n}\n\nlet attemptUserBlockingHydration: (fiber: Object) => void;\n\nexport function setAttemptUserBlockingHydration(fn: (fiber: Object) => void) {\n  attemptUserBlockingHydration = fn;\n}\n\nlet attemptContinuousHydration: (fiber: Object) => void;\n\nexport function setAttemptContinuousHydration(fn: (fiber: Object) => void) {\n  attemptContinuousHydration = fn;\n}\n\nlet attemptHydrationAtCurrentPriority: (fiber: Object) => void;\n\nexport function setAttemptHydrationAtCurrentPriority(\n  fn: (fiber: Object) => void,\n) {\n  attemptHydrationAtCurrentPriority = fn;\n}\n\n// TODO: Upgrade this definition once we're on a newer version of Flow that\n// has this definition built-in.\ntype PointerEvent = Event & {\n  pointerId: number,\n  relatedTarget: EventTarget | null,\n};\n\nimport {\n  TOP_MOUSE_DOWN,\n  TOP_MOUSE_UP,\n  TOP_TOUCH_CANCEL,\n  TOP_TOUCH_END,\n  TOP_TOUCH_START,\n  TOP_AUX_CLICK,\n  TOP_DOUBLE_CLICK,\n  TOP_POINTER_CANCEL,\n  TOP_POINTER_DOWN,\n  TOP_POINTER_UP,\n  TOP_DRAG_END,\n  TOP_DRAG_START,\n  TOP_DROP,\n  TOP_COMPOSITION_END,\n  TOP_COMPOSITION_START,\n  TOP_KEY_DOWN,\n  TOP_KEY_PRESS,\n  TOP_KEY_UP,\n  TOP_INPUT,\n  TOP_TEXT_INPUT,\n  TOP_CLOSE,\n  TOP_CANCEL,\n  TOP_COPY,\n  TOP_CUT,\n  TOP_PASTE,\n  TOP_CLICK,\n  TOP_CHANGE,\n  TOP_CONTEXT_MENU,\n  TOP_RESET,\n  TOP_SUBMIT,\n  TOP_DRAG_ENTER,\n  TOP_DRAG_LEAVE,\n  TOP_MOUSE_OVER,\n  TOP_MOUSE_OUT,\n  TOP_POINTER_OVER,\n  TOP_POINTER_OUT,\n  TOP_GOT_POINTER_CAPTURE,\n  TOP_LOST_POINTER_CAPTURE,\n  TOP_FOCUS,\n  TOP_BLUR,\n} from './DOMTopLevelEventTypes';\nimport {IS_REPLAYED} from 'legacy-events/EventSystemFlags';\n\ntype QueuedReplayableEvent = {|\n  blockedOn: null | Container | SuspenseInstance,\n  topLevelType: DOMTopLevelEventType,\n  eventSystemFlags: EventSystemFlags,\n  nativeEvent: AnyNativeEvent,\n|};\n\nlet hasScheduledReplayAttempt = false;\n\n// The queue of discrete events to be replayed.\nlet queuedDiscreteEvents: Array<QueuedReplayableEvent> = [];\n\n// Indicates if any continuous event targets are non-null for early bailout.\nlet hasAnyQueuedContinuousEvents: boolean = false;\n// The last of each continuous event type. We only need to replay the last one\n// if the last target was dehydrated.\nlet queuedFocus: null | QueuedReplayableEvent = null;\nlet queuedDrag: null | QueuedReplayableEvent = null;\nlet queuedMouse: null | QueuedReplayableEvent = null;\n// For pointer events there can be one latest event per pointerId.\nlet queuedPointers: Map<number, QueuedReplayableEvent> = new Map();\nlet queuedPointerCaptures: Map<number, QueuedReplayableEvent> = new Map();\n// We could consider replaying selectionchange and touchmoves too.\n\ntype QueuedHydrationTarget = {|\n  blockedOn: null | Container | SuspenseInstance,\n  target: Node,\n  priority: number,\n|};\nlet queuedExplicitHydrationTargets: Array<QueuedHydrationTarget> = [];\n\nexport function hasQueuedDiscreteEvents(): boolean {\n  return queuedDiscreteEvents.length > 0;\n}\n\nexport function hasQueuedContinuousEvents(): boolean {\n  return hasAnyQueuedContinuousEvents;\n}\n\nconst discreteReplayableEvents = [\n  TOP_MOUSE_DOWN,\n  TOP_MOUSE_UP,\n  TOP_TOUCH_CANCEL,\n  TOP_TOUCH_END,\n  TOP_TOUCH_START,\n  TOP_AUX_CLICK,\n  TOP_DOUBLE_CLICK,\n  TOP_POINTER_CANCEL,\n  TOP_POINTER_DOWN,\n  TOP_POINTER_UP,\n  TOP_DRAG_END,\n  TOP_DRAG_START,\n  TOP_DROP,\n  TOP_COMPOSITION_END,\n  TOP_COMPOSITION_START,\n  TOP_KEY_DOWN,\n  TOP_KEY_PRESS,\n  TOP_KEY_UP,\n  TOP_INPUT,\n  TOP_TEXT_INPUT,\n  TOP_CLOSE,\n  TOP_CANCEL,\n  TOP_COPY,\n  TOP_CUT,\n  TOP_PASTE,\n  TOP_CLICK,\n  TOP_CHANGE,\n  TOP_CONTEXT_MENU,\n  TOP_RESET,\n  TOP_SUBMIT,\n];\n\nconst continuousReplayableEvents = [\n  TOP_FOCUS,\n  TOP_BLUR,\n  TOP_DRAG_ENTER,\n  TOP_DRAG_LEAVE,\n  TOP_MOUSE_OVER,\n  TOP_MOUSE_OUT,\n  TOP_POINTER_OVER,\n  TOP_POINTER_OUT,\n  TOP_GOT_POINTER_CAPTURE,\n  TOP_LOST_POINTER_CAPTURE,\n];\n\nexport function isReplayableDiscreteEvent(\n  eventType: DOMTopLevelEventType,\n): boolean {\n  return discreteReplayableEvents.indexOf(eventType) > -1;\n}\n\nfunction trapReplayableEvent(\n  topLevelType: DOMTopLevelEventType,\n  document: Document,\n  listeningSet: Set<DOMTopLevelEventType | string>,\n) {\n  listenToTopLevel(topLevelType, document, listeningSet);\n  if (enableFlareAPI) {\n    // Trap events for the responder system.\n    const passiveEventKey =\n      unsafeCastDOMTopLevelTypeToString(topLevelType) + '_passive';\n    if (!listeningSet.has(passiveEventKey)) {\n      trapEventForResponderEventSystem(document, topLevelType, true);\n      listeningSet.add(passiveEventKey);\n    }\n    // TODO: This listens to all events as active which might have\n    // undesirable effects. It's also unnecessary to have both\n    // passive and active listeners. Instead, we could start with\n    // a passive and upgrade it to an active one if needed.\n    // For replaying purposes the active is never needed since we\n    // currently don't preventDefault.\n    const activeEventKey =\n      unsafeCastDOMTopLevelTypeToString(topLevelType) + '_active';\n    if (!listeningSet.has(activeEventKey)) {\n      trapEventForResponderEventSystem(document, topLevelType, false);\n      listeningSet.add(activeEventKey);\n    }\n  }\n}\n\nexport function eagerlyTrapReplayableEvents(document: Document) {\n  const listeningSet = getListeningSetForElement(document);\n  // Discrete\n  discreteReplayableEvents.forEach(topLevelType => {\n    trapReplayableEvent(topLevelType, document, listeningSet);\n  });\n  // Continuous\n  continuousReplayableEvents.forEach(topLevelType => {\n    trapReplayableEvent(topLevelType, document, listeningSet);\n  });\n}\n\nfunction createQueuedReplayableEvent(\n  blockedOn: null | Container | SuspenseInstance,\n  topLevelType: DOMTopLevelEventType,\n  eventSystemFlags: EventSystemFlags,\n  nativeEvent: AnyNativeEvent,\n): QueuedReplayableEvent {\n  return {\n    blockedOn,\n    topLevelType,\n    eventSystemFlags: eventSystemFlags | IS_REPLAYED,\n    nativeEvent,\n  };\n}\n\nexport function queueDiscreteEvent(\n  blockedOn: null | Container | SuspenseInstance,\n  topLevelType: DOMTopLevelEventType,\n  eventSystemFlags: EventSystemFlags,\n  nativeEvent: AnyNativeEvent,\n): void {\n  const queuedEvent = createQueuedReplayableEvent(\n    blockedOn,\n    topLevelType,\n    eventSystemFlags,\n    nativeEvent,\n  );\n  queuedDiscreteEvents.push(queuedEvent);\n  if (enableSelectiveHydration) {\n    if (queuedDiscreteEvents.length === 1) {\n      // If this was the first discrete event, we might be able to\n      // synchronously unblock it so that preventDefault still works.\n      while (queuedEvent.blockedOn !== null) {\n        let fiber = getInstanceFromNode(queuedEvent.blockedOn);\n        if (fiber === null) {\n          break;\n        }\n        attemptSynchronousHydration(fiber);\n        if (queuedEvent.blockedOn === null) {\n          // We got unblocked by hydration. Let's try again.\n          replayUnblockedEvents();\n          // If we're reblocked, on an inner boundary, we might need\n          // to attempt hydrating that one.\n          continue;\n        } else {\n          // We're still blocked from hydation, we have to give up\n          // and replay later.\n          break;\n        }\n      }\n    }\n  }\n}\n\n// Resets the replaying for this type of continuous event to no event.\nexport function clearIfContinuousEvent(\n  topLevelType: DOMTopLevelEventType,\n  nativeEvent: AnyNativeEvent,\n): void {\n  switch (topLevelType) {\n    case TOP_FOCUS:\n    case TOP_BLUR:\n      queuedFocus = null;\n      break;\n    case TOP_DRAG_ENTER:\n    case TOP_DRAG_LEAVE:\n      queuedDrag = null;\n      break;\n    case TOP_MOUSE_OVER:\n    case TOP_MOUSE_OUT:\n      queuedMouse = null;\n      break;\n    case TOP_POINTER_OVER:\n    case TOP_POINTER_OUT: {\n      let pointerId = ((nativeEvent: any): PointerEvent).pointerId;\n      queuedPointers.delete(pointerId);\n      break;\n    }\n    case TOP_GOT_POINTER_CAPTURE:\n    case TOP_LOST_POINTER_CAPTURE: {\n      let pointerId = ((nativeEvent: any): PointerEvent).pointerId;\n      queuedPointerCaptures.delete(pointerId);\n      break;\n    }\n  }\n}\n\nfunction accumulateOrCreateContinuousQueuedReplayableEvent(\n  existingQueuedEvent: null | QueuedReplayableEvent,\n  blockedOn: null | Container | SuspenseInstance,\n  topLevelType: DOMTopLevelEventType,\n  eventSystemFlags: EventSystemFlags,\n  nativeEvent: AnyNativeEvent,\n): QueuedReplayableEvent {\n  if (\n    existingQueuedEvent === null ||\n    existingQueuedEvent.nativeEvent !== nativeEvent\n  ) {\n    let queuedEvent = createQueuedReplayableEvent(\n      blockedOn,\n      topLevelType,\n      eventSystemFlags,\n      nativeEvent,\n    );\n    if (blockedOn !== null) {\n      let fiber = getInstanceFromNode(blockedOn);\n      if (fiber !== null) {\n        // Attempt to increase the priority of this target.\n        attemptContinuousHydration(fiber);\n      }\n    }\n    return queuedEvent;\n  }\n  // If we have already queued this exact event, then it's because\n  // the different event systems have different DOM event listeners.\n  // We can accumulate the flags and store a single event to be\n  // replayed.\n  existingQueuedEvent.eventSystemFlags |= eventSystemFlags;\n  return existingQueuedEvent;\n}\n\nexport function queueIfContinuousEvent(\n  blockedOn: null | Container | SuspenseInstance,\n  topLevelType: DOMTopLevelEventType,\n  eventSystemFlags: EventSystemFlags,\n  nativeEvent: AnyNativeEvent,\n): boolean {\n  // These set relatedTarget to null because the replayed event will be treated as if we\n  // moved from outside the window (no target) onto the target once it hydrates.\n  // Instead of mutating we could clone the event.\n  switch (topLevelType) {\n    case TOP_FOCUS: {\n      const focusEvent = ((nativeEvent: any): FocusEvent);\n      queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(\n        queuedFocus,\n        blockedOn,\n        topLevelType,\n        eventSystemFlags,\n        focusEvent,\n      );\n      return true;\n    }\n    case TOP_DRAG_ENTER: {\n      const dragEvent = ((nativeEvent: any): DragEvent);\n      queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(\n        queuedDrag,\n        blockedOn,\n        topLevelType,\n        eventSystemFlags,\n        dragEvent,\n      );\n      return true;\n    }\n    case TOP_MOUSE_OVER: {\n      const mouseEvent = ((nativeEvent: any): MouseEvent);\n      queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(\n        queuedMouse,\n        blockedOn,\n        topLevelType,\n        eventSystemFlags,\n        mouseEvent,\n      );\n      return true;\n    }\n    case TOP_POINTER_OVER: {\n      const pointerEvent = ((nativeEvent: any): PointerEvent);\n      const pointerId = pointerEvent.pointerId;\n      queuedPointers.set(\n        pointerId,\n        accumulateOrCreateContinuousQueuedReplayableEvent(\n          queuedPointers.get(pointerId) || null,\n          blockedOn,\n          topLevelType,\n          eventSystemFlags,\n          pointerEvent,\n        ),\n      );\n      return true;\n    }\n    case TOP_GOT_POINTER_CAPTURE: {\n      const pointerEvent = ((nativeEvent: any): PointerEvent);\n      const pointerId = pointerEvent.pointerId;\n      queuedPointerCaptures.set(\n        pointerId,\n        accumulateOrCreateContinuousQueuedReplayableEvent(\n          queuedPointerCaptures.get(pointerId) || null,\n          blockedOn,\n          topLevelType,\n          eventSystemFlags,\n          pointerEvent,\n        ),\n      );\n      return true;\n    }\n  }\n  return false;\n}\n\n// Check if this target is unblocked. Returns true if it's unblocked.\nfunction attemptExplicitHydrationTarget(\n  queuedTarget: QueuedHydrationTarget,\n): void {\n  // TODO: This function shares a lot of logic with attemptToDispatchEvent.\n  // Try to unify them. It's a bit tricky since it would require two return\n  // values.\n  let targetInst = getClosestInstanceFromNode(queuedTarget.target);\n  if (targetInst !== null) {\n    let nearestMounted = getNearestMountedFiber(targetInst);\n    if (nearestMounted !== null) {\n      const tag = nearestMounted.tag;\n      if (tag === SuspenseComponent) {\n        let instance = getSuspenseInstanceFromFiber(nearestMounted);\n        if (instance !== null) {\n          // We're blocked on hydrating this boundary.\n          // Increase its priority.\n          queuedTarget.blockedOn = instance;\n          runWithPriority(queuedTarget.priority, () => {\n            attemptHydrationAtCurrentPriority(nearestMounted);\n          });\n          return;\n        }\n      } else if (tag === HostRoot) {\n        const root: FiberRoot = nearestMounted.stateNode;\n        if (root.hydrate) {\n          queuedTarget.blockedOn = getContainerFromFiber(nearestMounted);\n          // We don't currently have a way to increase the priority of\n          // a root other than sync.\n          return;\n        }\n      }\n    }\n  }\n  queuedTarget.blockedOn = null;\n}\n\nexport function queueExplicitHydrationTarget(target: Node): void {\n  if (enableSelectiveHydration) {\n    let priority = getCurrentPriorityLevel();\n    const queuedTarget: QueuedHydrationTarget = {\n      blockedOn: null,\n      target: target,\n      priority: priority,\n    };\n    let i = 0;\n    for (; i < queuedExplicitHydrationTargets.length; i++) {\n      if (priority <= queuedExplicitHydrationTargets[i].priority) {\n        break;\n      }\n    }\n    queuedExplicitHydrationTargets.splice(i, 0, queuedTarget);\n    if (i === 0) {\n      attemptExplicitHydrationTarget(queuedTarget);\n    }\n  }\n}\n\nfunction attemptReplayContinuousQueuedEvent(\n  queuedEvent: QueuedReplayableEvent,\n): boolean {\n  if (queuedEvent.blockedOn !== null) {\n    return false;\n  }\n  let nextBlockedOn = attemptToDispatchEvent(\n    queuedEvent.topLevelType,\n    queuedEvent.eventSystemFlags,\n    queuedEvent.nativeEvent,\n  );\n  if (nextBlockedOn !== null) {\n    // We're still blocked. Try again later.\n    let fiber = getInstanceFromNode(nextBlockedOn);\n    if (fiber !== null) {\n      attemptContinuousHydration(fiber);\n    }\n    queuedEvent.blockedOn = nextBlockedOn;\n    return false;\n  }\n  return true;\n}\n\nfunction attemptReplayContinuousQueuedEventInMap(\n  queuedEvent: QueuedReplayableEvent,\n  key: number,\n  map: Map<number, QueuedReplayableEvent>,\n): void {\n  if (attemptReplayContinuousQueuedEvent(queuedEvent)) {\n    map.delete(key);\n  }\n}\n\nfunction replayUnblockedEvents() {\n  hasScheduledReplayAttempt = false;\n  // First replay discrete events.\n  while (queuedDiscreteEvents.length > 0) {\n    let nextDiscreteEvent = queuedDiscreteEvents[0];\n    if (nextDiscreteEvent.blockedOn !== null) {\n      // We're still blocked.\n      // Increase the priority of this boundary to unblock\n      // the next discrete event.\n      let fiber = getInstanceFromNode(nextDiscreteEvent.blockedOn);\n      if (fiber !== null) {\n        attemptUserBlockingHydration(fiber);\n      }\n      break;\n    }\n    let nextBlockedOn = attemptToDispatchEvent(\n      nextDiscreteEvent.topLevelType,\n      nextDiscreteEvent.eventSystemFlags,\n      nextDiscreteEvent.nativeEvent,\n    );\n    if (nextBlockedOn !== null) {\n      // We're still blocked. Try again later.\n      nextDiscreteEvent.blockedOn = nextBlockedOn;\n    } else {\n      // We've successfully replayed the first event. Let's try the next one.\n      queuedDiscreteEvents.shift();\n    }\n  }\n  // Next replay any continuous events.\n  if (queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus)) {\n    queuedFocus = null;\n  }\n  if (queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag)) {\n    queuedDrag = null;\n  }\n  if (queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse)) {\n    queuedMouse = null;\n  }\n  queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);\n  queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);\n}\n\nfunction scheduleCallbackIfUnblocked(\n  queuedEvent: QueuedReplayableEvent,\n  unblocked: Container | SuspenseInstance,\n) {\n  if (queuedEvent.blockedOn === unblocked) {\n    queuedEvent.blockedOn = null;\n    if (!hasScheduledReplayAttempt) {\n      hasScheduledReplayAttempt = true;\n      // Schedule a callback to attempt replaying as many events as are\n      // now unblocked. This first might not actually be unblocked yet.\n      // We could check it early to avoid scheduling an unnecessary callback.\n      scheduleCallback(NormalPriority, replayUnblockedEvents);\n    }\n  }\n}\n\nexport function retryIfBlockedOn(\n  unblocked: Container | SuspenseInstance,\n): void {\n  // Mark anything that was blocked on this as no longer blocked\n  // and eligible for a replay.\n  if (queuedDiscreteEvents.length > 0) {\n    scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked);\n    // This is a exponential search for each boundary that commits. I think it's\n    // worth it because we expect very few discrete events to queue up and once\n    // we are actually fully unblocked it will be fast to replay them.\n    for (let i = 1; i < queuedDiscreteEvents.length; i++) {\n      let queuedEvent = queuedDiscreteEvents[i];\n      if (queuedEvent.blockedOn === unblocked) {\n        queuedEvent.blockedOn = null;\n      }\n    }\n  }\n\n  if (queuedFocus !== null) {\n    scheduleCallbackIfUnblocked(queuedFocus, unblocked);\n  }\n  if (queuedDrag !== null) {\n    scheduleCallbackIfUnblocked(queuedDrag, unblocked);\n  }\n  if (queuedMouse !== null) {\n    scheduleCallbackIfUnblocked(queuedMouse, unblocked);\n  }\n  const unblock = queuedEvent =>\n    scheduleCallbackIfUnblocked(queuedEvent, unblocked);\n  queuedPointers.forEach(unblock);\n  queuedPointerCaptures.forEach(unblock);\n\n  for (let i = 0; i < queuedExplicitHydrationTargets.length; i++) {\n    let queuedTarget = queuedExplicitHydrationTargets[i];\n    if (queuedTarget.blockedOn === unblocked) {\n      queuedTarget.blockedOn = null;\n    }\n  }\n\n  while (queuedExplicitHydrationTargets.length > 0) {\n    let nextExplicitTarget = queuedExplicitHydrationTargets[0];\n    if (nextExplicitTarget.blockedOn !== null) {\n      // We're still blocked.\n      break;\n    } else {\n      attemptExplicitHydrationTarget(nextExplicitTarget);\n      if (nextExplicitTarget.blockedOn === null) {\n        // We're unblocked.\n        queuedExplicitHydrationTargets.shift();\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}