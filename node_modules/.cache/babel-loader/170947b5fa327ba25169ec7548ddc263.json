{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { precacheFiberNode, updateFiberProps } from './ReactDOMComponentTree';\nimport { createElement, createTextNode, setInitialProperties, diffProperties, updateProperties, diffHydratedProperties, diffHydratedText, trapClickOnNonInteractiveElement, warnForUnmatchedText, warnForDeletedHydratableElement, warnForDeletedHydratableText, warnForInsertedHydratedElement, warnForInsertedHydratedText, listenToEventResponderEventTypes } from './ReactDOMComponent';\nimport { getSelectionInformation, restoreSelection } from './ReactInputSelection';\nimport setTextContent from './setTextContent';\nimport { validateDOMNesting, updatedAncestorInfo } from './validateDOMNesting';\nimport { isEnabled as ReactBrowserEventEmitterIsEnabled, setEnabled as ReactBrowserEventEmitterSetEnabled } from '../events/ReactBrowserEventEmitter';\nimport { getChildNamespace } from '../shared/DOMNamespaces';\nimport { ELEMENT_NODE, TEXT_NODE, COMMENT_NODE, DOCUMENT_NODE, DOCUMENT_FRAGMENT_NODE } from '../shared/HTMLNodeType';\nimport dangerousStyleValue from '../shared/dangerousStyleValue';\nimport { addRootEventTypesForResponderInstance, mountEventResponder, unmountEventResponder } from '../events/DOMEventResponderSystem';\nimport { enableSuspenseServerRenderer, enableFlareAPI, enableFundamentalAPI } from 'shared/ReactFeatureFlags';\nlet SUPPRESS_HYDRATION_WARNING;\n\nif (__DEV__) {\n  SUPPRESS_HYDRATION_WARNING = 'suppressHydrationWarning';\n}\n\nconst SUSPENSE_START_DATA = '$';\nconst SUSPENSE_END_DATA = '/$';\nconst SUSPENSE_PENDING_START_DATA = '$?';\nconst SUSPENSE_FALLBACK_START_DATA = '$!';\nconst STYLE = 'style';\nlet eventsEnabled = null;\nlet selectionInformation = null;\n\nfunction shouldAutoFocusHostComponent(type, props) {\n  switch (type) {\n    case 'button':\n    case 'input':\n    case 'select':\n    case 'textarea':\n      return !!props.autoFocus;\n  }\n\n  return false;\n}\n\nexport * from 'shared/HostConfigWithNoPersistence';\nexport function getRootHostContext(rootContainerInstance) {\n  let type;\n  let namespace;\n  const nodeType = rootContainerInstance.nodeType;\n\n  switch (nodeType) {\n    case DOCUMENT_NODE:\n    case DOCUMENT_FRAGMENT_NODE:\n      {\n        type = nodeType === DOCUMENT_NODE ? '#document' : '#fragment';\n        let root = rootContainerInstance.documentElement;\n        namespace = root ? root.namespaceURI : getChildNamespace(null, '');\n        break;\n      }\n\n    default:\n      {\n        const container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;\n        const ownNamespace = container.namespaceURI || null;\n        type = container.tagName;\n        namespace = getChildNamespace(ownNamespace, type);\n        break;\n      }\n  }\n\n  if (__DEV__) {\n    const validatedTag = type.toLowerCase();\n    const ancestorInfo = updatedAncestorInfo(null, validatedTag);\n    return {\n      namespace,\n      ancestorInfo\n    };\n  }\n\n  return namespace;\n}\nexport function getChildHostContext(parentHostContext, type, rootContainerInstance) {\n  if (__DEV__) {\n    const parentHostContextDev = parentHostContext;\n    const namespace = getChildNamespace(parentHostContextDev.namespace, type);\n    const ancestorInfo = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type);\n    return {\n      namespace,\n      ancestorInfo\n    };\n  }\n\n  const parentNamespace = parentHostContext;\n  return getChildNamespace(parentNamespace, type);\n}\nexport function getPublicInstance(instance) {\n  return instance;\n}\nexport function prepareForCommit(containerInfo) {\n  eventsEnabled = ReactBrowserEventEmitterIsEnabled();\n  selectionInformation = getSelectionInformation();\n  ReactBrowserEventEmitterSetEnabled(false);\n}\nexport function resetAfterCommit(containerInfo) {\n  restoreSelection(selectionInformation);\n  selectionInformation = null;\n  ReactBrowserEventEmitterSetEnabled(eventsEnabled);\n  eventsEnabled = null;\n}\nexport function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {\n  let parentNamespace;\n\n  if (__DEV__) {\n    // TODO: take namespace into account when validating.\n    const hostContextDev = hostContext;\n    validateDOMNesting(type, null, hostContextDev.ancestorInfo);\n\n    if (typeof props.children === 'string' || typeof props.children === 'number') {\n      const string = '' + props.children;\n      const ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);\n      validateDOMNesting(null, string, ownAncestorInfo);\n    }\n\n    parentNamespace = hostContextDev.namespace;\n  } else {\n    parentNamespace = hostContext;\n  }\n\n  const domElement = createElement(type, props, rootContainerInstance, parentNamespace);\n  precacheFiberNode(internalInstanceHandle, domElement);\n  updateFiberProps(domElement, props);\n  return domElement;\n}\nexport function appendInitialChild(parentInstance, child) {\n  parentInstance.appendChild(child);\n}\nexport function finalizeInitialChildren(domElement, type, props, rootContainerInstance, hostContext) {\n  setInitialProperties(domElement, type, props, rootContainerInstance);\n  return shouldAutoFocusHostComponent(type, props);\n}\nexport function prepareUpdate(domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {\n  if (__DEV__) {\n    const hostContextDev = hostContext;\n\n    if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === 'string' || typeof newProps.children === 'number')) {\n      const string = '' + newProps.children;\n      const ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);\n      validateDOMNesting(null, string, ownAncestorInfo);\n    }\n  }\n\n  return diffProperties(domElement, type, oldProps, newProps, rootContainerInstance);\n}\nexport function shouldSetTextContent(type, props) {\n  return type === 'textarea' || type === 'option' || type === 'noscript' || typeof props.children === 'string' || typeof props.children === 'number' || typeof props.dangerouslySetInnerHTML === 'object' && props.dangerouslySetInnerHTML !== null && props.dangerouslySetInnerHTML.__html != null;\n}\nexport function shouldDeprioritizeSubtree(type, props) {\n  return !!props.hidden;\n}\nexport function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {\n  if (__DEV__) {\n    const hostContextDev = hostContext;\n    validateDOMNesting(null, text, hostContextDev.ancestorInfo);\n  }\n\n  const textNode = createTextNode(text, rootContainerInstance);\n  precacheFiberNode(internalInstanceHandle, textNode);\n  return textNode;\n}\nexport const isPrimaryRenderer = true;\nexport const warnsIfNotActing = true; // This initialization code may run even on server environments\n// if a component just imports ReactDOM (e.g. for findDOMNode).\n// Some environments might not have setTimeout or clearTimeout.\n\nexport const scheduleTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;\nexport const cancelTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined;\nexport const noTimeout = -1; // -------------------\n//     Mutation\n// -------------------\n\nexport const supportsMutation = true;\nexport function commitMount(domElement, type, newProps, internalInstanceHandle) {\n  // Despite the naming that might imply otherwise, this method only\n  // fires if there is an `Update` effect scheduled during mounting.\n  // This happens if `finalizeInitialChildren` returns `true` (which it\n  // does to implement the `autoFocus` attribute on the client). But\n  // there are also other cases when this might happen (such as patching\n  // up text content during hydration mismatch). So we'll check this again.\n  if (shouldAutoFocusHostComponent(type, newProps)) {\n    domElement.focus();\n  }\n}\nexport function commitUpdate(domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {\n  // Update the props handle so that we know which props are the ones with\n  // with current event handlers.\n  updateFiberProps(domElement, newProps); // Apply the diff to the DOM node.\n\n  updateProperties(domElement, updatePayload, type, oldProps, newProps);\n}\nexport function resetTextContent(domElement) {\n  setTextContent(domElement, '');\n}\nexport function commitTextUpdate(textInstance, oldText, newText) {\n  textInstance.nodeValue = newText;\n}\nexport function appendChild(parentInstance, child) {\n  parentInstance.appendChild(child);\n}\nexport function appendChildToContainer(container, child) {\n  let parentNode;\n\n  if (container.nodeType === COMMENT_NODE) {\n    parentNode = container.parentNode;\n    parentNode.insertBefore(child, container);\n  } else {\n    parentNode = container;\n    parentNode.appendChild(child);\n  } // This container might be used for a portal.\n  // If something inside a portal is clicked, that click should bubble\n  // through the React tree. However, on Mobile Safari the click would\n  // never bubble through the *DOM* tree unless an ancestor with onclick\n  // event exists. So we wouldn't see it and dispatch it.\n  // This is why we ensure that non React root containers have inline onclick\n  // defined.\n  // https://github.com/facebook/react/issues/11918\n\n\n  const reactRootContainer = container._reactRootContainer;\n\n  if ((reactRootContainer === null || reactRootContainer === undefined) && parentNode.onclick === null) {\n    // TODO: This cast may not be sound for SVG, MathML or custom elements.\n    trapClickOnNonInteractiveElement(parentNode);\n  }\n}\nexport function insertBefore(parentInstance, child, beforeChild) {\n  parentInstance.insertBefore(child, beforeChild);\n}\nexport function insertInContainerBefore(container, child, beforeChild) {\n  if (container.nodeType === COMMENT_NODE) {\n    container.parentNode.insertBefore(child, beforeChild);\n  } else {\n    container.insertBefore(child, beforeChild);\n  }\n}\nexport function removeChild(parentInstance, child) {\n  parentInstance.removeChild(child);\n}\nexport function removeChildFromContainer(container, child) {\n  if (container.nodeType === COMMENT_NODE) {\n    container.parentNode.removeChild(child);\n  } else {\n    container.removeChild(child);\n  }\n}\nexport function clearSuspenseBoundary(parentInstance, suspenseInstance) {\n  let node = suspenseInstance; // Delete all nodes within this suspense boundary.\n  // There might be nested nodes so we need to keep track of how\n  // deep we are and only break out when we're back on top.\n\n  let depth = 0;\n\n  do {\n    let nextNode = node.nextSibling;\n    parentInstance.removeChild(node);\n\n    if (nextNode && nextNode.nodeType === COMMENT_NODE) {\n      let data = nextNode.data;\n\n      if (data === SUSPENSE_END_DATA) {\n        if (depth === 0) {\n          parentInstance.removeChild(nextNode);\n          return;\n        } else {\n          depth--;\n        }\n      } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_PENDING_START_DATA || data === SUSPENSE_FALLBACK_START_DATA) {\n        depth++;\n      }\n    }\n\n    node = nextNode;\n  } while (node); // TODO: Warn, we didn't find the end comment boundary.\n\n}\nexport function clearSuspenseBoundaryFromContainer(container, suspenseInstance) {\n  if (container.nodeType === COMMENT_NODE) {\n    clearSuspenseBoundary(container.parentNode, suspenseInstance);\n  } else if (container.nodeType === ELEMENT_NODE) {\n    clearSuspenseBoundary(container, suspenseInstance);\n  } else {// Document nodes should never contain suspense boundaries.\n  }\n}\nexport function hideInstance(instance) {\n  // TODO: Does this work for all element types? What about MathML? Should we\n  // pass host context to this method?\n  instance = instance;\n  const style = instance.style;\n\n  if (typeof style.setProperty === 'function') {\n    style.setProperty('display', 'none', 'important');\n  } else {\n    style.display = 'none';\n  }\n}\nexport function hideTextInstance(textInstance) {\n  textInstance.nodeValue = '';\n}\nexport function unhideInstance(instance, props) {\n  instance = instance;\n  const styleProp = props[STYLE];\n  const display = styleProp !== undefined && styleProp !== null && styleProp.hasOwnProperty('display') ? styleProp.display : null;\n  instance.style.display = dangerousStyleValue('display', display);\n}\nexport function unhideTextInstance(textInstance, text) {\n  textInstance.nodeValue = text;\n} // -------------------\n//     Hydration\n// -------------------\n\nexport const supportsHydration = true;\nexport function canHydrateInstance(instance, type, props) {\n  if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {\n    return null;\n  } // This has now been refined to an element node.\n\n\n  return instance;\n}\nexport function canHydrateTextInstance(instance, text) {\n  if (text === '' || instance.nodeType !== TEXT_NODE) {\n    // Empty strings are not parsed by HTML so there won't be a correct match here.\n    return null;\n  } // This has now been refined to a text node.\n\n\n  return instance;\n}\nexport function canHydrateSuspenseInstance(instance) {\n  if (instance.nodeType !== COMMENT_NODE) {\n    // Empty strings are not parsed by HTML so there won't be a correct match here.\n    return null;\n  } // This has now been refined to a suspense node.\n\n\n  return instance;\n}\nexport function isSuspenseInstancePending(instance) {\n  return instance.data === SUSPENSE_PENDING_START_DATA;\n}\nexport function isSuspenseInstanceFallback(instance) {\n  return instance.data === SUSPENSE_FALLBACK_START_DATA;\n}\nexport function registerSuspenseInstanceRetry(instance, callback) {\n  instance._reactRetry = callback;\n}\n\nfunction getNextHydratable(node) {\n  // Skip non-hydratable nodes.\n  for (; node != null; node = node.nextSibling) {\n    const nodeType = node.nodeType;\n\n    if (nodeType === ELEMENT_NODE || nodeType === TEXT_NODE) {\n      break;\n    }\n\n    if (enableSuspenseServerRenderer) {\n      if (nodeType === COMMENT_NODE) {\n        const nodeData = node.data;\n\n        if (nodeData === SUSPENSE_START_DATA || nodeData === SUSPENSE_FALLBACK_START_DATA || nodeData === SUSPENSE_PENDING_START_DATA) {\n          break;\n        }\n      }\n    }\n  }\n\n  return node;\n}\n\nexport function getNextHydratableSibling(instance) {\n  return getNextHydratable(instance.nextSibling);\n}\nexport function getFirstHydratableChild(parentInstance) {\n  return getNextHydratable(parentInstance.firstChild);\n}\nexport function hydrateInstance(instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle) {\n  precacheFiberNode(internalInstanceHandle, instance); // TODO: Possibly defer this until the commit phase where all the events\n  // get attached.\n\n  updateFiberProps(instance, props);\n  let parentNamespace;\n\n  if (__DEV__) {\n    const hostContextDev = hostContext;\n    parentNamespace = hostContextDev.namespace;\n  } else {\n    parentNamespace = hostContext;\n  }\n\n  return diffHydratedProperties(instance, type, props, parentNamespace, rootContainerInstance);\n}\nexport function hydrateTextInstance(textInstance, text, internalInstanceHandle) {\n  precacheFiberNode(internalInstanceHandle, textInstance);\n  return diffHydratedText(textInstance, text);\n}\nexport function hydrateSuspenseInstance(suspenseInstance, internalInstanceHandle) {\n  precacheFiberNode(internalInstanceHandle, suspenseInstance);\n}\nexport function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {\n  let node = suspenseInstance.nextSibling; // Skip past all nodes within this suspense boundary.\n  // There might be nested nodes so we need to keep track of how\n  // deep we are and only break out when we're back on top.\n\n  let depth = 0;\n\n  while (node) {\n    if (node.nodeType === COMMENT_NODE) {\n      let data = node.data;\n\n      if (data === SUSPENSE_END_DATA) {\n        if (depth === 0) {\n          return getNextHydratableSibling(node);\n        } else {\n          depth--;\n        }\n      } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {\n        depth++;\n      }\n    }\n\n    node = node.nextSibling;\n  } // TODO: Warn, we didn't find the end comment boundary.\n\n\n  return null;\n} // Returns the SuspenseInstance if this node is a direct child of a\n// SuspenseInstance. I.e. if its previous sibling is a Comment with\n// SUSPENSE_x_START_DATA. Otherwise, null.\n\nexport function getParentSuspenseInstance(targetInstance) {\n  let node = targetInstance.previousSibling; // Skip past all nodes within this suspense boundary.\n  // There might be nested nodes so we need to keep track of how\n  // deep we are and only break out when we're back on top.\n\n  let depth = 0;\n\n  while (node) {\n    if (node.nodeType === COMMENT_NODE) {\n      let data = node.data;\n\n      if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {\n        if (depth === 0) {\n          return node;\n        } else {\n          depth--;\n        }\n      } else if (data === SUSPENSE_END_DATA) {\n        depth++;\n      }\n    }\n\n    node = node.previousSibling;\n  }\n\n  return null;\n}\nexport function didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text) {\n  if (__DEV__) {\n    warnForUnmatchedText(textInstance, text);\n  }\n}\nexport function didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text) {\n  if (__DEV__ && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n    warnForUnmatchedText(textInstance, text);\n  }\n}\nexport function didNotHydrateContainerInstance(parentContainer, instance) {\n  if (__DEV__) {\n    if (instance.nodeType === ELEMENT_NODE) {\n      warnForDeletedHydratableElement(parentContainer, instance);\n    } else if (instance.nodeType === COMMENT_NODE) {// TODO: warnForDeletedHydratableSuspenseBoundary\n    } else {\n      warnForDeletedHydratableText(parentContainer, instance);\n    }\n  }\n}\nexport function didNotHydrateInstance(parentType, parentProps, parentInstance, instance) {\n  if (__DEV__ && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n    if (instance.nodeType === ELEMENT_NODE) {\n      warnForDeletedHydratableElement(parentInstance, instance);\n    } else if (instance.nodeType === COMMENT_NODE) {// TODO: warnForDeletedHydratableSuspenseBoundary\n    } else {\n      warnForDeletedHydratableText(parentInstance, instance);\n    }\n  }\n}\nexport function didNotFindHydratableContainerInstance(parentContainer, type, props) {\n  if (__DEV__) {\n    warnForInsertedHydratedElement(parentContainer, type, props);\n  }\n}\nexport function didNotFindHydratableContainerTextInstance(parentContainer, text) {\n  if (__DEV__) {\n    warnForInsertedHydratedText(parentContainer, text);\n  }\n}\nexport function didNotFindHydratableContainerSuspenseInstance(parentContainer) {\n  if (__DEV__) {// TODO: warnForInsertedHydratedSupsense(parentContainer);\n  }\n}\nexport function didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props) {\n  if (__DEV__ && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n    warnForInsertedHydratedElement(parentInstance, type, props);\n  }\n}\nexport function didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text) {\n  if (__DEV__ && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n    warnForInsertedHydratedText(parentInstance, text);\n  }\n}\nexport function didNotFindHydratableSuspenseInstance(parentType, parentProps, parentInstance) {\n  if (__DEV__ && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {// TODO: warnForInsertedHydratedSuspense(parentInstance);\n  }\n}\nexport function mountResponderInstance(responder, responderInstance, responderProps, responderState, instance) {\n  // Listen to events\n  const doc = instance.ownerDocument;\n  const {\n    rootEventTypes,\n    targetEventTypes\n  } = responder;\n\n  if (targetEventTypes !== null) {\n    listenToEventResponderEventTypes(targetEventTypes, doc);\n  }\n\n  if (rootEventTypes !== null) {\n    addRootEventTypesForResponderInstance(responderInstance, rootEventTypes);\n    listenToEventResponderEventTypes(rootEventTypes, doc);\n  }\n\n  mountEventResponder(responder, responderInstance, responderProps, responderState);\n  return responderInstance;\n}\nexport function unmountResponderInstance(responderInstance) {\n  if (enableFlareAPI) {\n    // TODO stop listening to targetEventTypes\n    unmountEventResponder(responderInstance);\n  }\n}\nexport function getFundamentalComponentInstance(fundamentalInstance) {\n  if (enableFundamentalAPI) {\n    const {\n      currentFiber,\n      impl,\n      props,\n      state\n    } = fundamentalInstance;\n    const instance = impl.getInstance(null, props, state);\n    precacheFiberNode(currentFiber, instance);\n    return instance;\n  } // Because of the flag above, this gets around the Flow error;\n\n\n  return null;\n}\nexport function mountFundamentalComponent(fundamentalInstance) {\n  if (enableFundamentalAPI) {\n    const {\n      impl,\n      instance,\n      props,\n      state\n    } = fundamentalInstance;\n    const onMount = impl.onMount;\n\n    if (onMount !== undefined) {\n      onMount(null, instance, props, state);\n    }\n  }\n}\nexport function shouldUpdateFundamentalComponent(fundamentalInstance) {\n  if (enableFundamentalAPI) {\n    const {\n      impl,\n      prevProps,\n      props,\n      state\n    } = fundamentalInstance;\n    const shouldUpdate = impl.shouldUpdate;\n\n    if (shouldUpdate !== undefined) {\n      return shouldUpdate(null, prevProps, props, state);\n    }\n  }\n\n  return true;\n}\nexport function updateFundamentalComponent(fundamentalInstance) {\n  if (enableFundamentalAPI) {\n    const {\n      impl,\n      instance,\n      prevProps,\n      props,\n      state\n    } = fundamentalInstance;\n    const onUpdate = impl.onUpdate;\n\n    if (onUpdate !== undefined) {\n      onUpdate(null, instance, prevProps, props, state);\n    }\n  }\n}\nexport function unmountFundamentalComponent(fundamentalInstance) {\n  if (enableFundamentalAPI) {\n    const {\n      impl,\n      instance,\n      props,\n      state\n    } = fundamentalInstance;\n    const onUnmount = impl.onUnmount;\n\n    if (onUnmount !== undefined) {\n      onUnmount(null, instance, props, state);\n    }\n  }\n}","map":{"version":3,"sources":["/Users/gaoshaoyun/Documents/library/debug-react/src/react/packages/react-dom/src/client/ReactDOMHostConfig.js"],"names":["precacheFiberNode","updateFiberProps","createElement","createTextNode","setInitialProperties","diffProperties","updateProperties","diffHydratedProperties","diffHydratedText","trapClickOnNonInteractiveElement","warnForUnmatchedText","warnForDeletedHydratableElement","warnForDeletedHydratableText","warnForInsertedHydratedElement","warnForInsertedHydratedText","listenToEventResponderEventTypes","getSelectionInformation","restoreSelection","setTextContent","validateDOMNesting","updatedAncestorInfo","isEnabled","ReactBrowserEventEmitterIsEnabled","setEnabled","ReactBrowserEventEmitterSetEnabled","getChildNamespace","ELEMENT_NODE","TEXT_NODE","COMMENT_NODE","DOCUMENT_NODE","DOCUMENT_FRAGMENT_NODE","dangerousStyleValue","addRootEventTypesForResponderInstance","mountEventResponder","unmountEventResponder","enableSuspenseServerRenderer","enableFlareAPI","enableFundamentalAPI","SUPPRESS_HYDRATION_WARNING","__DEV__","SUSPENSE_START_DATA","SUSPENSE_END_DATA","SUSPENSE_PENDING_START_DATA","SUSPENSE_FALLBACK_START_DATA","STYLE","eventsEnabled","selectionInformation","shouldAutoFocusHostComponent","type","props","autoFocus","getRootHostContext","rootContainerInstance","namespace","nodeType","root","documentElement","namespaceURI","container","parentNode","ownNamespace","tagName","validatedTag","toLowerCase","ancestorInfo","getChildHostContext","parentHostContext","parentHostContextDev","parentNamespace","getPublicInstance","instance","prepareForCommit","containerInfo","resetAfterCommit","createInstance","hostContext","internalInstanceHandle","hostContextDev","children","string","ownAncestorInfo","domElement","appendInitialChild","parentInstance","child","appendChild","finalizeInitialChildren","prepareUpdate","oldProps","newProps","shouldSetTextContent","dangerouslySetInnerHTML","__html","shouldDeprioritizeSubtree","hidden","createTextInstance","text","textNode","isPrimaryRenderer","warnsIfNotActing","scheduleTimeout","setTimeout","undefined","cancelTimeout","clearTimeout","noTimeout","supportsMutation","commitMount","focus","commitUpdate","updatePayload","resetTextContent","commitTextUpdate","textInstance","oldText","newText","nodeValue","appendChildToContainer","insertBefore","reactRootContainer","_reactRootContainer","onclick","beforeChild","insertInContainerBefore","removeChild","removeChildFromContainer","clearSuspenseBoundary","suspenseInstance","node","depth","nextNode","nextSibling","data","clearSuspenseBoundaryFromContainer","hideInstance","style","setProperty","display","hideTextInstance","unhideInstance","styleProp","hasOwnProperty","unhideTextInstance","supportsHydration","canHydrateInstance","nodeName","canHydrateTextInstance","canHydrateSuspenseInstance","isSuspenseInstancePending","isSuspenseInstanceFallback","registerSuspenseInstanceRetry","callback","_reactRetry","getNextHydratable","nodeData","getNextHydratableSibling","getFirstHydratableChild","firstChild","hydrateInstance","hydrateTextInstance","hydrateSuspenseInstance","getNextHydratableInstanceAfterSuspenseInstance","getParentSuspenseInstance","targetInstance","previousSibling","didNotMatchHydratedContainerTextInstance","parentContainer","didNotMatchHydratedTextInstance","parentType","parentProps","didNotHydrateContainerInstance","didNotHydrateInstance","didNotFindHydratableContainerInstance","didNotFindHydratableContainerTextInstance","didNotFindHydratableContainerSuspenseInstance","didNotFindHydratableInstance","didNotFindHydratableTextInstance","didNotFindHydratableSuspenseInstance","mountResponderInstance","responder","responderInstance","responderProps","responderState","doc","ownerDocument","rootEventTypes","targetEventTypes","unmountResponderInstance","getFundamentalComponentInstance","fundamentalInstance","currentFiber","impl","state","getInstance","mountFundamentalComponent","onMount","shouldUpdateFundamentalComponent","prevProps","shouldUpdate","updateFundamentalComponent","onUpdate","unmountFundamentalComponent","onUnmount"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport {precacheFiberNode, updateFiberProps} from './ReactDOMComponentTree';\nimport {\n  createElement,\n  createTextNode,\n  setInitialProperties,\n  diffProperties,\n  updateProperties,\n  diffHydratedProperties,\n  diffHydratedText,\n  trapClickOnNonInteractiveElement,\n  warnForUnmatchedText,\n  warnForDeletedHydratableElement,\n  warnForDeletedHydratableText,\n  warnForInsertedHydratedElement,\n  warnForInsertedHydratedText,\n  listenToEventResponderEventTypes,\n} from './ReactDOMComponent';\nimport {getSelectionInformation, restoreSelection} from './ReactInputSelection';\nimport setTextContent from './setTextContent';\nimport {validateDOMNesting, updatedAncestorInfo} from './validateDOMNesting';\nimport {\n  isEnabled as ReactBrowserEventEmitterIsEnabled,\n  setEnabled as ReactBrowserEventEmitterSetEnabled,\n} from '../events/ReactBrowserEventEmitter';\nimport {getChildNamespace} from '../shared/DOMNamespaces';\nimport {\n  ELEMENT_NODE,\n  TEXT_NODE,\n  COMMENT_NODE,\n  DOCUMENT_NODE,\n  DOCUMENT_FRAGMENT_NODE,\n} from '../shared/HTMLNodeType';\nimport dangerousStyleValue from '../shared/dangerousStyleValue';\n\nimport type {DOMContainer} from './ReactDOM';\nimport type {\n  ReactDOMEventResponder,\n  ReactDOMEventResponderInstance,\n  ReactDOMFundamentalComponentInstance,\n} from 'shared/ReactDOMTypes';\nimport {\n  addRootEventTypesForResponderInstance,\n  mountEventResponder,\n  unmountEventResponder,\n} from '../events/DOMEventResponderSystem';\n\nexport type Type = string;\nexport type Props = {\n  autoFocus?: boolean,\n  children?: mixed,\n  hidden?: boolean,\n  suppressHydrationWarning?: boolean,\n  dangerouslySetInnerHTML?: mixed,\n  style?: {\n    display?: string,\n  },\n  bottom?: null | number,\n  left?: null | number,\n  right?: null | number,\n  top?: null | number,\n};\nexport type EventTargetChildElement = {\n  type: string,\n  props: null | {\n    style?: {\n      position?: string,\n      zIndex?: number,\n      bottom?: string,\n      left?: string,\n      right?: string,\n      top?: string,\n    },\n  },\n};\nexport type Container = Element | Document;\nexport type Instance = Element;\nexport type TextInstance = Text;\nexport type SuspenseInstance = Comment & {_reactRetry?: () => void};\nexport type HydratableInstance = Instance | TextInstance | SuspenseInstance;\nexport type PublicInstance = Element | Text;\ntype HostContextDev = {\n  namespace: string,\n  ancestorInfo: mixed,\n};\ntype HostContextProd = string;\nexport type HostContext = HostContextDev | HostContextProd;\nexport type UpdatePayload = Array<mixed>;\nexport type ChildSet = void; // Unused\nexport type TimeoutHandle = TimeoutID;\nexport type NoTimeout = -1;\n\nimport {\n  enableSuspenseServerRenderer,\n  enableFlareAPI,\n  enableFundamentalAPI,\n} from 'shared/ReactFeatureFlags';\n\nlet SUPPRESS_HYDRATION_WARNING;\nif (__DEV__) {\n  SUPPRESS_HYDRATION_WARNING = 'suppressHydrationWarning';\n}\n\nconst SUSPENSE_START_DATA = '$';\nconst SUSPENSE_END_DATA = '/$';\nconst SUSPENSE_PENDING_START_DATA = '$?';\nconst SUSPENSE_FALLBACK_START_DATA = '$!';\n\nconst STYLE = 'style';\n\nlet eventsEnabled: ?boolean = null;\nlet selectionInformation: ?mixed = null;\n\nfunction shouldAutoFocusHostComponent(type: string, props: Props): boolean {\n  switch (type) {\n    case 'button':\n    case 'input':\n    case 'select':\n    case 'textarea':\n      return !!props.autoFocus;\n  }\n  return false;\n}\n\nexport * from 'shared/HostConfigWithNoPersistence';\n\nexport function getRootHostContext(\n  rootContainerInstance: Container,\n): HostContext {\n  let type;\n  let namespace;\n  const nodeType = rootContainerInstance.nodeType;\n  switch (nodeType) {\n    case DOCUMENT_NODE:\n    case DOCUMENT_FRAGMENT_NODE: {\n      type = nodeType === DOCUMENT_NODE ? '#document' : '#fragment';\n      let root = (rootContainerInstance: any).documentElement;\n      namespace = root ? root.namespaceURI : getChildNamespace(null, '');\n      break;\n    }\n    default: {\n      const container: any =\n        nodeType === COMMENT_NODE\n          ? rootContainerInstance.parentNode\n          : rootContainerInstance;\n      const ownNamespace = container.namespaceURI || null;\n      type = container.tagName;\n      namespace = getChildNamespace(ownNamespace, type);\n      break;\n    }\n  }\n  if (__DEV__) {\n    const validatedTag = type.toLowerCase();\n    const ancestorInfo = updatedAncestorInfo(null, validatedTag);\n    return {namespace, ancestorInfo};\n  }\n  return namespace;\n}\n\nexport function getChildHostContext(\n  parentHostContext: HostContext,\n  type: string,\n  rootContainerInstance: Container,\n): HostContext {\n  if (__DEV__) {\n    const parentHostContextDev = ((parentHostContext: any): HostContextDev);\n    const namespace = getChildNamespace(parentHostContextDev.namespace, type);\n    const ancestorInfo = updatedAncestorInfo(\n      parentHostContextDev.ancestorInfo,\n      type,\n    );\n    return {namespace, ancestorInfo};\n  }\n  const parentNamespace = ((parentHostContext: any): HostContextProd);\n  return getChildNamespace(parentNamespace, type);\n}\n\nexport function getPublicInstance(instance: Instance): * {\n  return instance;\n}\n\nexport function prepareForCommit(containerInfo: Container): void {\n  eventsEnabled = ReactBrowserEventEmitterIsEnabled();\n  selectionInformation = getSelectionInformation();\n  ReactBrowserEventEmitterSetEnabled(false);\n}\n\nexport function resetAfterCommit(containerInfo: Container): void {\n  restoreSelection(selectionInformation);\n  selectionInformation = null;\n  ReactBrowserEventEmitterSetEnabled(eventsEnabled);\n  eventsEnabled = null;\n}\n\nexport function createInstance(\n  type: string,\n  props: Props,\n  rootContainerInstance: Container,\n  hostContext: HostContext,\n  internalInstanceHandle: Object,\n): Instance {\n  let parentNamespace: string;\n  if (__DEV__) {\n    // TODO: take namespace into account when validating.\n    const hostContextDev = ((hostContext: any): HostContextDev);\n    validateDOMNesting(type, null, hostContextDev.ancestorInfo);\n    if (\n      typeof props.children === 'string' ||\n      typeof props.children === 'number'\n    ) {\n      const string = '' + props.children;\n      const ownAncestorInfo = updatedAncestorInfo(\n        hostContextDev.ancestorInfo,\n        type,\n      );\n      validateDOMNesting(null, string, ownAncestorInfo);\n    }\n    parentNamespace = hostContextDev.namespace;\n  } else {\n    parentNamespace = ((hostContext: any): HostContextProd);\n  }\n  const domElement: Instance = createElement(\n    type,\n    props,\n    rootContainerInstance,\n    parentNamespace,\n  );\n  precacheFiberNode(internalInstanceHandle, domElement);\n  updateFiberProps(domElement, props);\n  return domElement;\n}\n\nexport function appendInitialChild(\n  parentInstance: Instance,\n  child: Instance | TextInstance,\n): void {\n  parentInstance.appendChild(child);\n}\n\nexport function finalizeInitialChildren(\n  domElement: Instance,\n  type: string,\n  props: Props,\n  rootContainerInstance: Container,\n  hostContext: HostContext,\n): boolean {\n  setInitialProperties(domElement, type, props, rootContainerInstance);\n  return shouldAutoFocusHostComponent(type, props);\n}\n\nexport function prepareUpdate(\n  domElement: Instance,\n  type: string,\n  oldProps: Props,\n  newProps: Props,\n  rootContainerInstance: Container,\n  hostContext: HostContext,\n): null | Array<mixed> {\n  if (__DEV__) {\n    const hostContextDev = ((hostContext: any): HostContextDev);\n    if (\n      typeof newProps.children !== typeof oldProps.children &&\n      (typeof newProps.children === 'string' ||\n        typeof newProps.children === 'number')\n    ) {\n      const string = '' + newProps.children;\n      const ownAncestorInfo = updatedAncestorInfo(\n        hostContextDev.ancestorInfo,\n        type,\n      );\n      validateDOMNesting(null, string, ownAncestorInfo);\n    }\n  }\n  return diffProperties(\n    domElement,\n    type,\n    oldProps,\n    newProps,\n    rootContainerInstance,\n  );\n}\n\nexport function shouldSetTextContent(type: string, props: Props): boolean {\n  return (\n    type === 'textarea' ||\n    type === 'option' ||\n    type === 'noscript' ||\n    typeof props.children === 'string' ||\n    typeof props.children === 'number' ||\n    (typeof props.dangerouslySetInnerHTML === 'object' &&\n      props.dangerouslySetInnerHTML !== null &&\n      props.dangerouslySetInnerHTML.__html != null)\n  );\n}\n\nexport function shouldDeprioritizeSubtree(type: string, props: Props): boolean {\n  return !!props.hidden;\n}\n\nexport function createTextInstance(\n  text: string,\n  rootContainerInstance: Container,\n  hostContext: HostContext,\n  internalInstanceHandle: Object,\n): TextInstance {\n  if (__DEV__) {\n    const hostContextDev = ((hostContext: any): HostContextDev);\n    validateDOMNesting(null, text, hostContextDev.ancestorInfo);\n  }\n  const textNode: TextInstance = createTextNode(text, rootContainerInstance);\n  precacheFiberNode(internalInstanceHandle, textNode);\n  return textNode;\n}\n\nexport const isPrimaryRenderer = true;\nexport const warnsIfNotActing = true;\n// This initialization code may run even on server environments\n// if a component just imports ReactDOM (e.g. for findDOMNode).\n// Some environments might not have setTimeout or clearTimeout.\nexport const scheduleTimeout =\n  typeof setTimeout === 'function' ? setTimeout : (undefined: any);\nexport const cancelTimeout =\n  typeof clearTimeout === 'function' ? clearTimeout : (undefined: any);\nexport const noTimeout = -1;\n\n// -------------------\n//     Mutation\n// -------------------\n\nexport const supportsMutation = true;\n\nexport function commitMount(\n  domElement: Instance,\n  type: string,\n  newProps: Props,\n  internalInstanceHandle: Object,\n): void {\n  // Despite the naming that might imply otherwise, this method only\n  // fires if there is an `Update` effect scheduled during mounting.\n  // This happens if `finalizeInitialChildren` returns `true` (which it\n  // does to implement the `autoFocus` attribute on the client). But\n  // there are also other cases when this might happen (such as patching\n  // up text content during hydration mismatch). So we'll check this again.\n  if (shouldAutoFocusHostComponent(type, newProps)) {\n    ((domElement: any):\n      | HTMLButtonElement\n      | HTMLInputElement\n      | HTMLSelectElement\n      | HTMLTextAreaElement).focus();\n  }\n}\n\nexport function commitUpdate(\n  domElement: Instance,\n  updatePayload: Array<mixed>,\n  type: string,\n  oldProps: Props,\n  newProps: Props,\n  internalInstanceHandle: Object,\n): void {\n  // Update the props handle so that we know which props are the ones with\n  // with current event handlers.\n  updateFiberProps(domElement, newProps);\n  // Apply the diff to the DOM node.\n  updateProperties(domElement, updatePayload, type, oldProps, newProps);\n}\n\nexport function resetTextContent(domElement: Instance): void {\n  setTextContent(domElement, '');\n}\n\nexport function commitTextUpdate(\n  textInstance: TextInstance,\n  oldText: string,\n  newText: string,\n): void {\n  textInstance.nodeValue = newText;\n}\n\nexport function appendChild(\n  parentInstance: Instance,\n  child: Instance | TextInstance,\n): void {\n  parentInstance.appendChild(child);\n}\n\nexport function appendChildToContainer(\n  container: DOMContainer,\n  child: Instance | TextInstance,\n): void {\n  let parentNode;\n  if (container.nodeType === COMMENT_NODE) {\n    parentNode = (container.parentNode: any);\n    parentNode.insertBefore(child, container);\n  } else {\n    parentNode = container;\n    parentNode.appendChild(child);\n  }\n  // This container might be used for a portal.\n  // If something inside a portal is clicked, that click should bubble\n  // through the React tree. However, on Mobile Safari the click would\n  // never bubble through the *DOM* tree unless an ancestor with onclick\n  // event exists. So we wouldn't see it and dispatch it.\n  // This is why we ensure that non React root containers have inline onclick\n  // defined.\n  // https://github.com/facebook/react/issues/11918\n  const reactRootContainer = container._reactRootContainer;\n  if (\n    (reactRootContainer === null || reactRootContainer === undefined) &&\n    parentNode.onclick === null\n  ) {\n    // TODO: This cast may not be sound for SVG, MathML or custom elements.\n    trapClickOnNonInteractiveElement(((parentNode: any): HTMLElement));\n  }\n}\n\nexport function insertBefore(\n  parentInstance: Instance,\n  child: Instance | TextInstance,\n  beforeChild: Instance | TextInstance | SuspenseInstance,\n): void {\n  parentInstance.insertBefore(child, beforeChild);\n}\n\nexport function insertInContainerBefore(\n  container: Container,\n  child: Instance | TextInstance,\n  beforeChild: Instance | TextInstance | SuspenseInstance,\n): void {\n  if (container.nodeType === COMMENT_NODE) {\n    (container.parentNode: any).insertBefore(child, beforeChild);\n  } else {\n    container.insertBefore(child, beforeChild);\n  }\n}\n\nexport function removeChild(\n  parentInstance: Instance,\n  child: Instance | TextInstance | SuspenseInstance,\n): void {\n  parentInstance.removeChild(child);\n}\n\nexport function removeChildFromContainer(\n  container: Container,\n  child: Instance | TextInstance | SuspenseInstance,\n): void {\n  if (container.nodeType === COMMENT_NODE) {\n    (container.parentNode: any).removeChild(child);\n  } else {\n    container.removeChild(child);\n  }\n}\n\nexport function clearSuspenseBoundary(\n  parentInstance: Instance,\n  suspenseInstance: SuspenseInstance,\n): void {\n  let node = suspenseInstance;\n  // Delete all nodes within this suspense boundary.\n  // There might be nested nodes so we need to keep track of how\n  // deep we are and only break out when we're back on top.\n  let depth = 0;\n  do {\n    let nextNode = node.nextSibling;\n    parentInstance.removeChild(node);\n    if (nextNode && nextNode.nodeType === COMMENT_NODE) {\n      let data = ((nextNode: any).data: string);\n      if (data === SUSPENSE_END_DATA) {\n        if (depth === 0) {\n          parentInstance.removeChild(nextNode);\n          return;\n        } else {\n          depth--;\n        }\n      } else if (\n        data === SUSPENSE_START_DATA ||\n        data === SUSPENSE_PENDING_START_DATA ||\n        data === SUSPENSE_FALLBACK_START_DATA\n      ) {\n        depth++;\n      }\n    }\n    node = nextNode;\n  } while (node);\n  // TODO: Warn, we didn't find the end comment boundary.\n}\n\nexport function clearSuspenseBoundaryFromContainer(\n  container: Container,\n  suspenseInstance: SuspenseInstance,\n): void {\n  if (container.nodeType === COMMENT_NODE) {\n    clearSuspenseBoundary((container.parentNode: any), suspenseInstance);\n  } else if (container.nodeType === ELEMENT_NODE) {\n    clearSuspenseBoundary((container: any), suspenseInstance);\n  } else {\n    // Document nodes should never contain suspense boundaries.\n  }\n}\n\nexport function hideInstance(instance: Instance): void {\n  // TODO: Does this work for all element types? What about MathML? Should we\n  // pass host context to this method?\n  instance = ((instance: any): HTMLElement);\n  const style = instance.style;\n  if (typeof style.setProperty === 'function') {\n    style.setProperty('display', 'none', 'important');\n  } else {\n    style.display = 'none';\n  }\n}\n\nexport function hideTextInstance(textInstance: TextInstance): void {\n  textInstance.nodeValue = '';\n}\n\nexport function unhideInstance(instance: Instance, props: Props): void {\n  instance = ((instance: any): HTMLElement);\n  const styleProp = props[STYLE];\n  const display =\n    styleProp !== undefined &&\n    styleProp !== null &&\n    styleProp.hasOwnProperty('display')\n      ? styleProp.display\n      : null;\n  instance.style.display = dangerousStyleValue('display', display);\n}\n\nexport function unhideTextInstance(\n  textInstance: TextInstance,\n  text: string,\n): void {\n  textInstance.nodeValue = text;\n}\n\n// -------------------\n//     Hydration\n// -------------------\n\nexport const supportsHydration = true;\n\nexport function canHydrateInstance(\n  instance: HydratableInstance,\n  type: string,\n  props: Props,\n): null | Instance {\n  if (\n    instance.nodeType !== ELEMENT_NODE ||\n    type.toLowerCase() !== instance.nodeName.toLowerCase()\n  ) {\n    return null;\n  }\n  // This has now been refined to an element node.\n  return ((instance: any): Instance);\n}\n\nexport function canHydrateTextInstance(\n  instance: HydratableInstance,\n  text: string,\n): null | TextInstance {\n  if (text === '' || instance.nodeType !== TEXT_NODE) {\n    // Empty strings are not parsed by HTML so there won't be a correct match here.\n    return null;\n  }\n  // This has now been refined to a text node.\n  return ((instance: any): TextInstance);\n}\n\nexport function canHydrateSuspenseInstance(\n  instance: HydratableInstance,\n): null | SuspenseInstance {\n  if (instance.nodeType !== COMMENT_NODE) {\n    // Empty strings are not parsed by HTML so there won't be a correct match here.\n    return null;\n  }\n  // This has now been refined to a suspense node.\n  return ((instance: any): SuspenseInstance);\n}\n\nexport function isSuspenseInstancePending(instance: SuspenseInstance) {\n  return instance.data === SUSPENSE_PENDING_START_DATA;\n}\n\nexport function isSuspenseInstanceFallback(instance: SuspenseInstance) {\n  return instance.data === SUSPENSE_FALLBACK_START_DATA;\n}\n\nexport function registerSuspenseInstanceRetry(\n  instance: SuspenseInstance,\n  callback: () => void,\n) {\n  instance._reactRetry = callback;\n}\n\nfunction getNextHydratable(node) {\n  // Skip non-hydratable nodes.\n  for (; node != null; node = node.nextSibling) {\n    const nodeType = node.nodeType;\n    if (nodeType === ELEMENT_NODE || nodeType === TEXT_NODE) {\n      break;\n    }\n    if (enableSuspenseServerRenderer) {\n      if (nodeType === COMMENT_NODE) {\n        const nodeData = (node: any).data;\n        if (\n          nodeData === SUSPENSE_START_DATA ||\n          nodeData === SUSPENSE_FALLBACK_START_DATA ||\n          nodeData === SUSPENSE_PENDING_START_DATA\n        ) {\n          break;\n        }\n      }\n    }\n  }\n  return (node: any);\n}\n\nexport function getNextHydratableSibling(\n  instance: HydratableInstance,\n): null | HydratableInstance {\n  return getNextHydratable(instance.nextSibling);\n}\n\nexport function getFirstHydratableChild(\n  parentInstance: Container | Instance,\n): null | HydratableInstance {\n  return getNextHydratable(parentInstance.firstChild);\n}\n\nexport function hydrateInstance(\n  instance: Instance,\n  type: string,\n  props: Props,\n  rootContainerInstance: Container,\n  hostContext: HostContext,\n  internalInstanceHandle: Object,\n): null | Array<mixed> {\n  precacheFiberNode(internalInstanceHandle, instance);\n  // TODO: Possibly defer this until the commit phase where all the events\n  // get attached.\n  updateFiberProps(instance, props);\n  let parentNamespace: string;\n  if (__DEV__) {\n    const hostContextDev = ((hostContext: any): HostContextDev);\n    parentNamespace = hostContextDev.namespace;\n  } else {\n    parentNamespace = ((hostContext: any): HostContextProd);\n  }\n  return diffHydratedProperties(\n    instance,\n    type,\n    props,\n    parentNamespace,\n    rootContainerInstance,\n  );\n}\n\nexport function hydrateTextInstance(\n  textInstance: TextInstance,\n  text: string,\n  internalInstanceHandle: Object,\n): boolean {\n  precacheFiberNode(internalInstanceHandle, textInstance);\n  return diffHydratedText(textInstance, text);\n}\n\nexport function hydrateSuspenseInstance(\n  suspenseInstance: SuspenseInstance,\n  internalInstanceHandle: Object,\n) {\n  precacheFiberNode(internalInstanceHandle, suspenseInstance);\n}\n\nexport function getNextHydratableInstanceAfterSuspenseInstance(\n  suspenseInstance: SuspenseInstance,\n): null | HydratableInstance {\n  let node = suspenseInstance.nextSibling;\n  // Skip past all nodes within this suspense boundary.\n  // There might be nested nodes so we need to keep track of how\n  // deep we are and only break out when we're back on top.\n  let depth = 0;\n  while (node) {\n    if (node.nodeType === COMMENT_NODE) {\n      let data = ((node: any).data: string);\n      if (data === SUSPENSE_END_DATA) {\n        if (depth === 0) {\n          return getNextHydratableSibling((node: any));\n        } else {\n          depth--;\n        }\n      } else if (\n        data === SUSPENSE_START_DATA ||\n        data === SUSPENSE_FALLBACK_START_DATA ||\n        data === SUSPENSE_PENDING_START_DATA\n      ) {\n        depth++;\n      }\n    }\n    node = node.nextSibling;\n  }\n  // TODO: Warn, we didn't find the end comment boundary.\n  return null;\n}\n\n// Returns the SuspenseInstance if this node is a direct child of a\n// SuspenseInstance. I.e. if its previous sibling is a Comment with\n// SUSPENSE_x_START_DATA. Otherwise, null.\nexport function getParentSuspenseInstance(\n  targetInstance: Instance,\n): null | SuspenseInstance {\n  let node = targetInstance.previousSibling;\n  // Skip past all nodes within this suspense boundary.\n  // There might be nested nodes so we need to keep track of how\n  // deep we are and only break out when we're back on top.\n  let depth = 0;\n  while (node) {\n    if (node.nodeType === COMMENT_NODE) {\n      let data = ((node: any).data: string);\n      if (\n        data === SUSPENSE_START_DATA ||\n        data === SUSPENSE_FALLBACK_START_DATA ||\n        data === SUSPENSE_PENDING_START_DATA\n      ) {\n        if (depth === 0) {\n          return ((node: any): SuspenseInstance);\n        } else {\n          depth--;\n        }\n      } else if (data === SUSPENSE_END_DATA) {\n        depth++;\n      }\n    }\n    node = node.previousSibling;\n  }\n  return null;\n}\n\nexport function didNotMatchHydratedContainerTextInstance(\n  parentContainer: Container,\n  textInstance: TextInstance,\n  text: string,\n) {\n  if (__DEV__) {\n    warnForUnmatchedText(textInstance, text);\n  }\n}\n\nexport function didNotMatchHydratedTextInstance(\n  parentType: string,\n  parentProps: Props,\n  parentInstance: Instance,\n  textInstance: TextInstance,\n  text: string,\n) {\n  if (__DEV__ && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n    warnForUnmatchedText(textInstance, text);\n  }\n}\n\nexport function didNotHydrateContainerInstance(\n  parentContainer: Container,\n  instance: HydratableInstance,\n) {\n  if (__DEV__) {\n    if (instance.nodeType === ELEMENT_NODE) {\n      warnForDeletedHydratableElement(parentContainer, (instance: any));\n    } else if (instance.nodeType === COMMENT_NODE) {\n      // TODO: warnForDeletedHydratableSuspenseBoundary\n    } else {\n      warnForDeletedHydratableText(parentContainer, (instance: any));\n    }\n  }\n}\n\nexport function didNotHydrateInstance(\n  parentType: string,\n  parentProps: Props,\n  parentInstance: Instance,\n  instance: HydratableInstance,\n) {\n  if (__DEV__ && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n    if (instance.nodeType === ELEMENT_NODE) {\n      warnForDeletedHydratableElement(parentInstance, (instance: any));\n    } else if (instance.nodeType === COMMENT_NODE) {\n      // TODO: warnForDeletedHydratableSuspenseBoundary\n    } else {\n      warnForDeletedHydratableText(parentInstance, (instance: any));\n    }\n  }\n}\n\nexport function didNotFindHydratableContainerInstance(\n  parentContainer: Container,\n  type: string,\n  props: Props,\n) {\n  if (__DEV__) {\n    warnForInsertedHydratedElement(parentContainer, type, props);\n  }\n}\n\nexport function didNotFindHydratableContainerTextInstance(\n  parentContainer: Container,\n  text: string,\n) {\n  if (__DEV__) {\n    warnForInsertedHydratedText(parentContainer, text);\n  }\n}\n\nexport function didNotFindHydratableContainerSuspenseInstance(\n  parentContainer: Container,\n) {\n  if (__DEV__) {\n    // TODO: warnForInsertedHydratedSupsense(parentContainer);\n  }\n}\n\nexport function didNotFindHydratableInstance(\n  parentType: string,\n  parentProps: Props,\n  parentInstance: Instance,\n  type: string,\n  props: Props,\n) {\n  if (__DEV__ && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n    warnForInsertedHydratedElement(parentInstance, type, props);\n  }\n}\n\nexport function didNotFindHydratableTextInstance(\n  parentType: string,\n  parentProps: Props,\n  parentInstance: Instance,\n  text: string,\n) {\n  if (__DEV__ && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n    warnForInsertedHydratedText(parentInstance, text);\n  }\n}\n\nexport function didNotFindHydratableSuspenseInstance(\n  parentType: string,\n  parentProps: Props,\n  parentInstance: Instance,\n) {\n  if (__DEV__ && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n    // TODO: warnForInsertedHydratedSuspense(parentInstance);\n  }\n}\n\nexport function mountResponderInstance(\n  responder: ReactDOMEventResponder,\n  responderInstance: ReactDOMEventResponderInstance,\n  responderProps: Object,\n  responderState: Object,\n  instance: Instance,\n): ReactDOMEventResponderInstance {\n  // Listen to events\n  const doc = instance.ownerDocument;\n  const {\n    rootEventTypes,\n    targetEventTypes,\n  } = ((responder: any): ReactDOMEventResponder);\n  if (targetEventTypes !== null) {\n    listenToEventResponderEventTypes(targetEventTypes, doc);\n  }\n  if (rootEventTypes !== null) {\n    addRootEventTypesForResponderInstance(responderInstance, rootEventTypes);\n    listenToEventResponderEventTypes(rootEventTypes, doc);\n  }\n  mountEventResponder(\n    responder,\n    responderInstance,\n    responderProps,\n    responderState,\n  );\n  return responderInstance;\n}\n\nexport function unmountResponderInstance(\n  responderInstance: ReactDOMEventResponderInstance,\n): void {\n  if (enableFlareAPI) {\n    // TODO stop listening to targetEventTypes\n    unmountEventResponder(responderInstance);\n  }\n}\n\nexport function getFundamentalComponentInstance(\n  fundamentalInstance: ReactDOMFundamentalComponentInstance,\n): Instance {\n  if (enableFundamentalAPI) {\n    const {currentFiber, impl, props, state} = fundamentalInstance;\n    const instance = impl.getInstance(null, props, state);\n    precacheFiberNode(currentFiber, instance);\n    return instance;\n  }\n  // Because of the flag above, this gets around the Flow error;\n  return (null: any);\n}\n\nexport function mountFundamentalComponent(\n  fundamentalInstance: ReactDOMFundamentalComponentInstance,\n): void {\n  if (enableFundamentalAPI) {\n    const {impl, instance, props, state} = fundamentalInstance;\n    const onMount = impl.onMount;\n    if (onMount !== undefined) {\n      onMount(null, instance, props, state);\n    }\n  }\n}\n\nexport function shouldUpdateFundamentalComponent(\n  fundamentalInstance: ReactDOMFundamentalComponentInstance,\n): boolean {\n  if (enableFundamentalAPI) {\n    const {impl, prevProps, props, state} = fundamentalInstance;\n    const shouldUpdate = impl.shouldUpdate;\n    if (shouldUpdate !== undefined) {\n      return shouldUpdate(null, prevProps, props, state);\n    }\n  }\n  return true;\n}\n\nexport function updateFundamentalComponent(\n  fundamentalInstance: ReactDOMFundamentalComponentInstance,\n): void {\n  if (enableFundamentalAPI) {\n    const {impl, instance, prevProps, props, state} = fundamentalInstance;\n    const onUpdate = impl.onUpdate;\n    if (onUpdate !== undefined) {\n      onUpdate(null, instance, prevProps, props, state);\n    }\n  }\n}\n\nexport function unmountFundamentalComponent(\n  fundamentalInstance: ReactDOMFundamentalComponentInstance,\n): void {\n  if (enableFundamentalAPI) {\n    const {impl, instance, props, state} = fundamentalInstance;\n    const onUnmount = impl.onUnmount;\n    if (onUnmount !== undefined) {\n      onUnmount(null, instance, props, state);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}