{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport checkPropTypes from 'prop-types/checkPropTypes';\nimport { IndeterminateComponent, FunctionComponent, ClassComponent, HostRoot, HostComponent, HostText, HostPortal, ForwardRef, Fragment, Mode, ContextProvider, ContextConsumer, Profiler, SuspenseComponent, SuspenseListComponent, MemoComponent, SimpleMemoComponent, LazyComponent, IncompleteClassComponent, FundamentalComponent, ScopeComponent } from 'shared/ReactWorkTags';\nimport { NoEffect, PerformedWork, Placement, Hydrating, ContentReset, DidCapture, Update, Ref, Deletion } from 'shared/ReactSideEffectTags';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport { debugRenderPhaseSideEffectsForStrictMode, disableLegacyContext, enableProfilerTimer, enableSchedulerTracing, enableSuspenseServerRenderer, enableFundamentalAPI, warnAboutDefaultPropsOnFunctionComponents, enableScopeAPI } from 'shared/ReactFeatureFlags';\nimport invariant from 'shared/invariant';\nimport shallowEqual from 'shared/shallowEqual';\nimport getComponentName from 'shared/getComponentName';\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings';\nimport { refineResolvedLazyComponent } from 'shared/ReactLazyComponent';\nimport { REACT_LAZY_TYPE, getIteratorFn } from 'shared/ReactSymbols';\nimport warning from 'shared/warning';\nimport warningWithoutStack from 'shared/warningWithoutStack';\nimport { setCurrentPhase, getCurrentFiberOwnerNameInDevOrNull, getCurrentFiberStackInDev } from './ReactCurrentFiber';\nimport { startWorkTimer, cancelWorkTimer } from './ReactDebugFiberPerf';\nimport { resolveFunctionForHotReloading, resolveForwardRefForHotReloading, resolveClassForHotReloading } from './ReactFiberHotReloading';\nimport { mountChildFibers, reconcileChildFibers, cloneChildFibers } from './ReactChildFiber';\nimport { processUpdateQueue } from './ReactUpdateQueue';\nimport { NoWork, Never, Sync, computeAsyncExpiration } from './ReactFiberExpirationTime';\nimport { ConcurrentMode, NoMode, ProfileMode, StrictMode, BlockingMode } from './ReactTypeOfMode';\nimport { shouldSetTextContent, shouldDeprioritizeSubtree, isSuspenseInstancePending, isSuspenseInstanceFallback, registerSuspenseInstanceRetry } from './ReactFiberHostConfig';\nimport { shouldSuspend } from './ReactFiberReconciler';\nimport { pushHostContext, pushHostContainer } from './ReactFiberHostContext';\nimport { suspenseStackCursor, pushSuspenseContext, InvisibleParentSuspenseContext, ForceSuspenseFallback, hasSuspenseContext, setDefaultShallowSuspenseContext, addSubtreeSuspenseContext, setShallowSuspenseContext } from './ReactFiberSuspenseContext';\nimport { findFirstSuspended } from './ReactFiberSuspenseComponent';\nimport { pushProvider, propagateContextChange, readContext, prepareToReadContext, calculateChangedBits, scheduleWorkOnParentPath } from './ReactFiberNewContext';\nimport { resetHooks, renderWithHooks, bailoutHooks } from './ReactFiberHooks';\nimport { stopProfilerTimerIfRunning } from './ReactProfilerTimer';\nimport { getMaskedContext, getUnmaskedContext, hasContextChanged as hasLegacyContextChanged, pushContextProvider as pushLegacyContextProvider, isContextProvider as isLegacyContextProvider, pushTopLevelContextObject, invalidateContextProvider } from './ReactFiberContext';\nimport { enterHydrationState, reenterHydrationStateFromDehydratedSuspenseInstance, resetHydrationState, tryToClaimNextHydratableInstance, warnIfHydrating } from './ReactFiberHydrationContext';\nimport { adoptClassInstance, applyDerivedStateFromProps, constructClassInstance, mountClassInstance, resumeMountClassInstance, updateClassInstance } from './ReactFiberClassComponent';\nimport { readLazyComponentType, resolveDefaultProps } from './ReactFiberLazyComponent';\nimport { resolveLazyComponentTag, createFiberFromTypeAndProps, createFiberFromFragment, createWorkInProgress, isSimpleFunctionComponent } from './ReactFiber';\nimport { markSpawnedWork, requestCurrentTimeForUpdate, retryDehydratedSuspenseBoundary, scheduleWork, renderDidSuspendDelayIfPossible, markUnprocessedUpdateTime } from './ReactFiberWorkLoop';\nconst ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nlet didReceiveUpdate = false;\nlet didWarnAboutBadClass;\nlet didWarnAboutModulePatternComponent;\nlet didWarnAboutContextTypeOnFunctionComponent;\nlet didWarnAboutGetDerivedStateOnFunctionComponent;\nlet didWarnAboutFunctionRefs;\nexport let didWarnAboutReassigningProps;\nlet didWarnAboutMaxDuration;\nlet didWarnAboutRevealOrder;\nlet didWarnAboutTailOptions;\nlet didWarnAboutDefaultPropsOnFunctionComponent;\n\nif (__DEV__) {\n  didWarnAboutBadClass = {};\n  didWarnAboutModulePatternComponent = {};\n  didWarnAboutContextTypeOnFunctionComponent = {};\n  didWarnAboutGetDerivedStateOnFunctionComponent = {};\n  didWarnAboutFunctionRefs = {};\n  didWarnAboutReassigningProps = false;\n  didWarnAboutMaxDuration = false;\n  didWarnAboutRevealOrder = {};\n  didWarnAboutTailOptions = {};\n  didWarnAboutDefaultPropsOnFunctionComponent = {};\n}\n\nexport function reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime) {\n  if (current === null) {\n    // If this is a fresh new component that hasn't been rendered yet, we\n    // won't update its child set by applying minimal side-effects. Instead,\n    // we will add them all to the child before it gets rendered. That means\n    // we can optimize this reconciliation pass by not tracking side-effects.\n    workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime);\n  } else {\n    // If the current child is the same as the work in progress, it means that\n    // we haven't yet started any work on these children. Therefore, we use\n    // the clone algorithm to create a copy of all the current children.\n    // If we had any progressed work already, that is invalid at this point so\n    // let's throw it out.\n    workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderExpirationTime);\n  }\n}\n\nfunction forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderExpirationTime) {\n  // This function is fork of reconcileChildren. It's used in cases where we\n  // want to reconcile without matching against the existing set. This has the\n  // effect of all current children being unmounted; even if the type and key\n  // are the same, the old child is unmounted and a new child is created.\n  //\n  // To do this, we're going to go through the reconcile algorithm twice. In\n  // the first pass, we schedule a deletion for all the current children by\n  // passing null.\n  workInProgress.child = reconcileChildFibers(workInProgress, current.child, null, renderExpirationTime); // In the second pass, we mount the new children. The trick here is that we\n  // pass null in place of where we usually pass the current child set. This has\n  // the effect of remounting all children regardless of whether their their\n  // identity matches.\n\n  workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderExpirationTime);\n}\n\nfunction updateForwardRef(current, workInProgress, Component, nextProps, renderExpirationTime) {\n  // TODO: current can be non-null here even if the component\n  // hasn't yet mounted. This happens after the first render suspends.\n  // We'll need to figure out if this is fine or can cause issues.\n  if (__DEV__) {\n    if (workInProgress.type !== workInProgress.elementType) {\n      // Lazy component props can't be validated in createElement\n      // because they're only guaranteed to be resolved here.\n      const innerPropTypes = Component.propTypes;\n\n      if (innerPropTypes) {\n        checkPropTypes(innerPropTypes, nextProps, // Resolved props\n        'prop', getComponentName(Component), getCurrentFiberStackInDev);\n      }\n    }\n  }\n\n  const render = Component.render;\n  const ref = workInProgress.ref; // The rest is a fork of updateFunctionComponent\n\n  let nextChildren;\n  prepareToReadContext(workInProgress, renderExpirationTime);\n\n  if (__DEV__) {\n    ReactCurrentOwner.current = workInProgress;\n    setCurrentPhase('render');\n    nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderExpirationTime);\n\n    if (debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {\n      // Only double-render components with Hooks\n      if (workInProgress.memoizedState !== null) {\n        nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderExpirationTime);\n      }\n    }\n\n    setCurrentPhase(null);\n  } else {\n    nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderExpirationTime);\n  }\n\n  if (current !== null && !didReceiveUpdate) {\n    bailoutHooks(current, workInProgress, renderExpirationTime);\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);\n  } // React DevTools reads this flag.\n\n\n  workInProgress.effectTag |= PerformedWork;\n  reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);\n  return workInProgress.child;\n}\n\nfunction updateMemoComponent(current, workInProgress, Component, nextProps, updateExpirationTime, renderExpirationTime) {\n  if (current === null) {\n    let type = Component.type;\n\n    if (isSimpleFunctionComponent(type) && Component.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.\n    Component.defaultProps === undefined) {\n      let resolvedType = type;\n\n      if (__DEV__) {\n        resolvedType = resolveFunctionForHotReloading(type);\n      } // If this is a plain function component without default props,\n      // and with only the default shallow comparison, we upgrade it\n      // to a SimpleMemoComponent to allow fast path updates.\n\n\n      workInProgress.tag = SimpleMemoComponent;\n      workInProgress.type = resolvedType;\n\n      if (__DEV__) {\n        validateFunctionComponentInDev(workInProgress, type);\n      }\n\n      return updateSimpleMemoComponent(current, workInProgress, resolvedType, nextProps, updateExpirationTime, renderExpirationTime);\n    }\n\n    if (__DEV__) {\n      const innerPropTypes = type.propTypes;\n\n      if (innerPropTypes) {\n        // Inner memo component props aren't currently validated in createElement.\n        // We could move it there, but we'd still need this for lazy code path.\n        checkPropTypes(innerPropTypes, nextProps, // Resolved props\n        'prop', getComponentName(type), getCurrentFiberStackInDev);\n      }\n    }\n\n    let child = createFiberFromTypeAndProps(Component.type, null, nextProps, null, workInProgress.mode, renderExpirationTime);\n    child.ref = workInProgress.ref;\n    child.return = workInProgress;\n    workInProgress.child = child;\n    return child;\n  }\n\n  if (__DEV__) {\n    const type = Component.type;\n    const innerPropTypes = type.propTypes;\n\n    if (innerPropTypes) {\n      // Inner memo component props aren't currently validated in createElement.\n      // We could move it there, but we'd still need this for lazy code path.\n      checkPropTypes(innerPropTypes, nextProps, // Resolved props\n      'prop', getComponentName(type), getCurrentFiberStackInDev);\n    }\n  }\n\n  let currentChild = current.child; // This is always exactly one child\n\n  if (updateExpirationTime < renderExpirationTime) {\n    // This will be the props with resolved defaultProps,\n    // unlike current.memoizedProps which will be the unresolved ones.\n    const prevProps = currentChild.memoizedProps; // Default to shallow comparison\n\n    let compare = Component.compare;\n    compare = compare !== null ? compare : shallowEqual;\n\n    if (compare(prevProps, nextProps) && current.ref === workInProgress.ref) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);\n    }\n  } // React DevTools reads this flag.\n\n\n  workInProgress.effectTag |= PerformedWork;\n  let newChild = createWorkInProgress(currentChild, nextProps, renderExpirationTime);\n  newChild.ref = workInProgress.ref;\n  newChild.return = workInProgress;\n  workInProgress.child = newChild;\n  return newChild;\n}\n\nfunction updateSimpleMemoComponent(current, workInProgress, Component, nextProps, updateExpirationTime, renderExpirationTime) {\n  // TODO: current can be non-null here even if the component\n  // hasn't yet mounted. This happens when the inner render suspends.\n  // We'll need to figure out if this is fine or can cause issues.\n  if (__DEV__) {\n    if (workInProgress.type !== workInProgress.elementType) {\n      // Lazy component props can't be validated in createElement\n      // because they're only guaranteed to be resolved here.\n      let outerMemoType = workInProgress.elementType;\n\n      if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {\n        // We warn when you define propTypes on lazy()\n        // so let's just skip over it to find memo() outer wrapper.\n        // Inner props for memo are validated later.\n        outerMemoType = refineResolvedLazyComponent(outerMemoType);\n      }\n\n      const outerPropTypes = outerMemoType && outerMemoType.propTypes;\n\n      if (outerPropTypes) {\n        checkPropTypes(outerPropTypes, nextProps, // Resolved (SimpleMemoComponent has no defaultProps)\n        'prop', getComponentName(outerMemoType), getCurrentFiberStackInDev);\n      } // Inner propTypes will be validated in the function component path.\n\n    }\n  }\n\n  if (current !== null) {\n    const prevProps = current.memoizedProps;\n\n    if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress.ref && ( // Prevent bailout if the implementation changed due to hot reload:\n    __DEV__ ? workInProgress.type === current.type : true)) {\n      didReceiveUpdate = false;\n\n      if (updateExpirationTime < renderExpirationTime) {\n        return bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);\n      }\n    }\n  }\n\n  return updateFunctionComponent(current, workInProgress, Component, nextProps, renderExpirationTime);\n}\n\nfunction updateFragment(current, workInProgress, renderExpirationTime) {\n  const nextChildren = workInProgress.pendingProps;\n  reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);\n  return workInProgress.child;\n}\n\nfunction updateMode(current, workInProgress, renderExpirationTime) {\n  const nextChildren = workInProgress.pendingProps.children;\n  reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);\n  return workInProgress.child;\n}\n\nfunction updateProfiler(current, workInProgress, renderExpirationTime) {\n  if (enableProfilerTimer) {\n    workInProgress.effectTag |= Update;\n  }\n\n  const nextProps = workInProgress.pendingProps;\n  const nextChildren = nextProps.children;\n  reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);\n  return workInProgress.child;\n}\n\nfunction markRef(current, workInProgress) {\n  const ref = workInProgress.ref;\n\n  if (current === null && ref !== null || current !== null && current.ref !== ref) {\n    // Schedule a Ref effect\n    workInProgress.effectTag |= Ref;\n  }\n}\n\nfunction updateFunctionComponent(current, workInProgress, Component, nextProps, renderExpirationTime) {\n  if (__DEV__) {\n    if (workInProgress.type !== workInProgress.elementType) {\n      // Lazy component props can't be validated in createElement\n      // because they're only guaranteed to be resolved here.\n      const innerPropTypes = Component.propTypes;\n\n      if (innerPropTypes) {\n        checkPropTypes(innerPropTypes, nextProps, // Resolved props\n        'prop', getComponentName(Component), getCurrentFiberStackInDev);\n      }\n    }\n  }\n\n  let context;\n\n  if (!disableLegacyContext) {\n    const unmaskedContext = getUnmaskedContext(workInProgress, Component, true);\n    context = getMaskedContext(workInProgress, unmaskedContext);\n  }\n\n  let nextChildren;\n  prepareToReadContext(workInProgress, renderExpirationTime);\n\n  if (__DEV__) {\n    ReactCurrentOwner.current = workInProgress;\n    setCurrentPhase('render');\n    nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderExpirationTime);\n\n    if (debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {\n      // Only double-render components with Hooks\n      if (workInProgress.memoizedState !== null) {\n        nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderExpirationTime);\n      }\n    }\n\n    setCurrentPhase(null);\n  } else {\n    nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderExpirationTime);\n  }\n\n  if (current !== null && !didReceiveUpdate) {\n    bailoutHooks(current, workInProgress, renderExpirationTime);\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);\n  } // React DevTools reads this flag.\n\n\n  workInProgress.effectTag |= PerformedWork;\n  reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);\n  return workInProgress.child;\n}\n\nfunction updateClassComponent(current, workInProgress, Component, nextProps, renderExpirationTime) {\n  if (__DEV__) {\n    if (workInProgress.type !== workInProgress.elementType) {\n      // Lazy component props can't be validated in createElement\n      // because they're only guaranteed to be resolved here.\n      const innerPropTypes = Component.propTypes;\n\n      if (innerPropTypes) {\n        checkPropTypes(innerPropTypes, nextProps, // Resolved props\n        'prop', getComponentName(Component), getCurrentFiberStackInDev);\n      }\n    }\n  } // Push context providers early to prevent context stack mismatches.\n  // During mounting we don't know the child context yet as the instance doesn't exist.\n  // We will invalidate the child context in finishClassComponent() right after rendering.\n\n\n  let hasContext;\n\n  if (isLegacyContextProvider(Component)) {\n    hasContext = true;\n    pushLegacyContextProvider(workInProgress);\n  } else {\n    hasContext = false;\n  }\n\n  prepareToReadContext(workInProgress, renderExpirationTime);\n  const instance = workInProgress.stateNode;\n  let shouldUpdate;\n\n  if (instance === null) {\n    if (current !== null) {\n      // An class component without an instance only mounts if it suspended\n      // inside a non- concurrent tree, in an inconsistent state. We want to\n      // tree it like a new mount, even though an empty version of it already\n      // committed. Disconnect the alternate pointers.\n      current.alternate = null;\n      workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect\n\n      workInProgress.effectTag |= Placement;\n    } // In the initial pass we might need to construct the instance.\n\n\n    constructClassInstance(workInProgress, Component, nextProps, renderExpirationTime);\n    mountClassInstance(workInProgress, Component, nextProps, renderExpirationTime);\n    shouldUpdate = true;\n  } else if (current === null) {\n    // In a resume, we'll already have an instance we can reuse.\n    shouldUpdate = resumeMountClassInstance(workInProgress, Component, nextProps, renderExpirationTime);\n  } else {\n    shouldUpdate = updateClassInstance(current, workInProgress, Component, nextProps, renderExpirationTime);\n  }\n\n  const nextUnitOfWork = finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderExpirationTime);\n\n  if (__DEV__) {\n    let inst = workInProgress.stateNode;\n\n    if (inst.props !== nextProps) {\n      warning(didWarnAboutReassigningProps, 'It looks like %s is reassigning its own `this.props` while rendering. ' + 'This is not supported and can lead to confusing bugs.', getComponentName(workInProgress.type) || 'a component');\n      didWarnAboutReassigningProps = true;\n    }\n  }\n\n  return nextUnitOfWork;\n}\n\nfunction finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderExpirationTime) {\n  // Refs should update even if shouldComponentUpdate returns false\n  markRef(current, workInProgress);\n  const didCaptureError = (workInProgress.effectTag & DidCapture) !== NoEffect;\n\n  if (!shouldUpdate && !didCaptureError) {\n    // Context providers should defer to sCU for rendering\n    if (hasContext) {\n      invalidateContextProvider(workInProgress, Component, false);\n    }\n\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);\n  }\n\n  const instance = workInProgress.stateNode; // Rerender\n\n  ReactCurrentOwner.current = workInProgress;\n  let nextChildren;\n\n  if (didCaptureError && typeof Component.getDerivedStateFromError !== 'function') {\n    // If we captured an error, but getDerivedStateFrom catch is not defined,\n    // unmount all the children. componentDidCatch will schedule an update to\n    // re-render a fallback. This is temporary until we migrate everyone to\n    // the new API.\n    // TODO: Warn in a future release.\n    nextChildren = null;\n\n    if (enableProfilerTimer) {\n      stopProfilerTimerIfRunning(workInProgress);\n    }\n  } else {\n    if (__DEV__) {\n      setCurrentPhase('render');\n      nextChildren = instance.render();\n\n      if (debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {\n        instance.render();\n      }\n\n      setCurrentPhase(null);\n    } else {\n      nextChildren = instance.render();\n    }\n  } // React DevTools reads this flag.\n\n\n  workInProgress.effectTag |= PerformedWork;\n\n  if (current !== null && didCaptureError) {\n    // If we're recovering from an error, reconcile without reusing any of\n    // the existing children. Conceptually, the normal children and the children\n    // that are shown on error are two different sets, so we shouldn't reuse\n    // normal children even if their identities match.\n    forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderExpirationTime);\n  } else {\n    reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);\n  } // Memoize state using the values we just used to render.\n  // TODO: Restructure so we never read values from the instance.\n\n\n  workInProgress.memoizedState = instance.state; // The context might have changed so we need to recalculate it.\n\n  if (hasContext) {\n    invalidateContextProvider(workInProgress, Component, true);\n  }\n\n  return workInProgress.child;\n}\n\nfunction pushHostRootContext(workInProgress) {\n  const root = workInProgress.stateNode;\n\n  if (root.pendingContext) {\n    pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);\n  } else if (root.context) {\n    // Should always be set\n    pushTopLevelContextObject(workInProgress, root.context, false);\n  }\n\n  pushHostContainer(workInProgress, root.containerInfo);\n}\n\nfunction updateHostRoot(current, workInProgress, renderExpirationTime) {\n  pushHostRootContext(workInProgress);\n  const updateQueue = workInProgress.updateQueue;\n  invariant(updateQueue !== null, 'If the root does not have an updateQueue, we should have already ' + 'bailed out. This error is likely caused by a bug in React. Please ' + 'file an issue.');\n  const nextProps = workInProgress.pendingProps;\n  const prevState = workInProgress.memoizedState;\n  const prevChildren = prevState !== null ? prevState.element : null;\n  processUpdateQueue(workInProgress, updateQueue, nextProps, null, renderExpirationTime);\n  const nextState = workInProgress.memoizedState; // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n\n  const nextChildren = nextState.element;\n\n  if (nextChildren === prevChildren) {\n    // If the state is the same as before, that's a bailout because we had\n    // no work that expires at this time.\n    resetHydrationState();\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);\n  }\n\n  const root = workInProgress.stateNode;\n\n  if (root.hydrate && enterHydrationState(workInProgress)) {\n    // If we don't have any current children this might be the first pass.\n    // We always try to hydrate. If this isn't a hydration pass there won't\n    // be any children to hydrate which is effectively the same thing as\n    // not hydrating.\n    let child = mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime);\n    workInProgress.child = child;\n    let node = child;\n\n    while (node) {\n      // Mark each child as hydrating. This is a fast path to know whether this\n      // tree is part of a hydrating tree. This is used to determine if a child\n      // node has fully mounted yet, and for scheduling event replaying.\n      // Conceptually this is similar to Placement in that a new subtree is\n      // inserted into the React tree here. It just happens to not need DOM\n      // mutations because it already exists.\n      node.effectTag = node.effectTag & ~Placement | Hydrating;\n      node = node.sibling;\n    }\n  } else {\n    // Otherwise reset hydration state in case we aborted and resumed another\n    // root.\n    reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);\n    resetHydrationState();\n  }\n\n  return workInProgress.child;\n}\n\nfunction updateHostComponent(current, workInProgress, renderExpirationTime) {\n  pushHostContext(workInProgress);\n\n  if (current === null) {\n    tryToClaimNextHydratableInstance(workInProgress);\n  }\n\n  const type = workInProgress.type;\n  const nextProps = workInProgress.pendingProps;\n  const prevProps = current !== null ? current.memoizedProps : null;\n  let nextChildren = nextProps.children;\n  const isDirectTextChild = shouldSetTextContent(type, nextProps);\n\n  if (isDirectTextChild) {\n    // We special case a direct text child of a host node. This is a common\n    // case. We won't handle it as a reified child. We will instead handle\n    // this in the host environment that also have access to this prop. That\n    // avoids allocating another HostText fiber and traversing it.\n    nextChildren = null;\n  } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {\n    // If we're switching from a direct text child to a normal child, or to\n    // empty, we need to schedule the text content to be reset.\n    workInProgress.effectTag |= ContentReset;\n  }\n\n  markRef(current, workInProgress); // Check the host config to see if the children are offscreen/hidden.\n\n  if (workInProgress.mode & ConcurrentMode && renderExpirationTime !== Never && shouldDeprioritizeSubtree(type, nextProps)) {\n    if (enableSchedulerTracing) {\n      markSpawnedWork(Never);\n    } // Schedule this fiber to re-render at offscreen priority. Then bailout.\n\n\n    workInProgress.expirationTime = workInProgress.childExpirationTime = Never;\n    return null;\n  }\n\n  reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);\n  return workInProgress.child;\n}\n\nfunction updateHostText(current, workInProgress) {\n  if (current === null) {\n    tryToClaimNextHydratableInstance(workInProgress);\n  } // Nothing to do here. This is terminal. We'll do the completion step\n  // immediately after.\n\n\n  return null;\n}\n\nfunction mountLazyComponent(_current, workInProgress, elementType, updateExpirationTime, renderExpirationTime) {\n  if (_current !== null) {\n    // An lazy component only mounts if it suspended inside a non-\n    // concurrent tree, in an inconsistent state. We want to treat it like\n    // a new mount, even though an empty version of it already committed.\n    // Disconnect the alternate pointers.\n    _current.alternate = null;\n    workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect\n\n    workInProgress.effectTag |= Placement;\n  }\n\n  const props = workInProgress.pendingProps; // We can't start a User Timing measurement with correct label yet.\n  // Cancel and resume right after we know the tag.\n\n  cancelWorkTimer(workInProgress);\n  let Component = readLazyComponentType(elementType); // Store the unwrapped component in the type.\n\n  workInProgress.type = Component;\n  const resolvedTag = workInProgress.tag = resolveLazyComponentTag(Component);\n  startWorkTimer(workInProgress);\n  const resolvedProps = resolveDefaultProps(Component, props);\n  let child;\n\n  switch (resolvedTag) {\n    case FunctionComponent:\n      {\n        if (__DEV__) {\n          validateFunctionComponentInDev(workInProgress, Component);\n          workInProgress.type = Component = resolveFunctionForHotReloading(Component);\n        }\n\n        child = updateFunctionComponent(null, workInProgress, Component, resolvedProps, renderExpirationTime);\n        break;\n      }\n\n    case ClassComponent:\n      {\n        if (__DEV__) {\n          workInProgress.type = Component = resolveClassForHotReloading(Component);\n        }\n\n        child = updateClassComponent(null, workInProgress, Component, resolvedProps, renderExpirationTime);\n        break;\n      }\n\n    case ForwardRef:\n      {\n        if (__DEV__) {\n          workInProgress.type = Component = resolveForwardRefForHotReloading(Component);\n        }\n\n        child = updateForwardRef(null, workInProgress, Component, resolvedProps, renderExpirationTime);\n        break;\n      }\n\n    case MemoComponent:\n      {\n        if (__DEV__) {\n          if (workInProgress.type !== workInProgress.elementType) {\n            const outerPropTypes = Component.propTypes;\n\n            if (outerPropTypes) {\n              checkPropTypes(outerPropTypes, resolvedProps, // Resolved for outer only\n              'prop', getComponentName(Component), getCurrentFiberStackInDev);\n            }\n          }\n        }\n\n        child = updateMemoComponent(null, workInProgress, Component, resolveDefaultProps(Component.type, resolvedProps), // The inner type can have defaults too\n        updateExpirationTime, renderExpirationTime);\n        break;\n      }\n\n    default:\n      {\n        let hint = '';\n\n        if (__DEV__) {\n          if (Component !== null && typeof Component === 'object' && Component.$$typeof === REACT_LAZY_TYPE) {\n            hint = ' Did you wrap a component in React.lazy() more than once?';\n          }\n        } // This message intentionally doesn't mention ForwardRef or MemoComponent\n        // because the fact that it's a separate type of work is an\n        // implementation detail.\n\n\n        invariant(false, 'Element type is invalid. Received a promise that resolves to: %s. ' + 'Lazy element type must resolve to a class or function.%s', Component, hint);\n      }\n  }\n\n  return child;\n}\n\nfunction mountIncompleteClassComponent(_current, workInProgress, Component, nextProps, renderExpirationTime) {\n  if (_current !== null) {\n    // An incomplete component only mounts if it suspended inside a non-\n    // concurrent tree, in an inconsistent state. We want to treat it like\n    // a new mount, even though an empty version of it already committed.\n    // Disconnect the alternate pointers.\n    _current.alternate = null;\n    workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect\n\n    workInProgress.effectTag |= Placement;\n  } // Promote the fiber to a class and try rendering again.\n\n\n  workInProgress.tag = ClassComponent; // The rest of this function is a fork of `updateClassComponent`\n  // Push context providers early to prevent context stack mismatches.\n  // During mounting we don't know the child context yet as the instance doesn't exist.\n  // We will invalidate the child context in finishClassComponent() right after rendering.\n\n  let hasContext;\n\n  if (isLegacyContextProvider(Component)) {\n    hasContext = true;\n    pushLegacyContextProvider(workInProgress);\n  } else {\n    hasContext = false;\n  }\n\n  prepareToReadContext(workInProgress, renderExpirationTime);\n  constructClassInstance(workInProgress, Component, nextProps, renderExpirationTime);\n  mountClassInstance(workInProgress, Component, nextProps, renderExpirationTime);\n  return finishClassComponent(null, workInProgress, Component, true, hasContext, renderExpirationTime);\n}\n\nfunction mountIndeterminateComponent(_current, workInProgress, Component, renderExpirationTime) {\n  if (_current !== null) {\n    // An indeterminate component only mounts if it suspended inside a non-\n    // concurrent tree, in an inconsistent state. We want to treat it like\n    // a new mount, even though an empty version of it already committed.\n    // Disconnect the alternate pointers.\n    _current.alternate = null;\n    workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect\n\n    workInProgress.effectTag |= Placement;\n  }\n\n  const props = workInProgress.pendingProps;\n  let context;\n\n  if (!disableLegacyContext) {\n    const unmaskedContext = getUnmaskedContext(workInProgress, Component, false);\n    context = getMaskedContext(workInProgress, unmaskedContext);\n  }\n\n  prepareToReadContext(workInProgress, renderExpirationTime);\n  let value;\n\n  if (__DEV__) {\n    if (Component.prototype && typeof Component.prototype.render === 'function') {\n      const componentName = getComponentName(Component) || 'Unknown';\n\n      if (!didWarnAboutBadClass[componentName]) {\n        warningWithoutStack(false, \"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" + 'This is likely to cause errors. Change %s to extend React.Component instead.', componentName, componentName);\n        didWarnAboutBadClass[componentName] = true;\n      }\n    }\n\n    if (workInProgress.mode & StrictMode) {\n      ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);\n    }\n\n    ReactCurrentOwner.current = workInProgress;\n    value = renderWithHooks(null, workInProgress, Component, props, context, renderExpirationTime);\n  } else {\n    value = renderWithHooks(null, workInProgress, Component, props, context, renderExpirationTime);\n  } // React DevTools reads this flag.\n\n\n  workInProgress.effectTag |= PerformedWork;\n\n  if (typeof value === 'object' && value !== null && typeof value.render === 'function' && value.$$typeof === undefined) {\n    if (__DEV__) {\n      const componentName = getComponentName(Component) || 'Unknown';\n\n      if (!didWarnAboutModulePatternComponent[componentName]) {\n        warningWithoutStack(false, 'The <%s /> component appears to be a function component that returns a class instance. ' + 'Change %s to a class that extends React.Component instead. ' + \"If you can't use a class try assigning the prototype on the function as a workaround. \" + \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" + 'cannot be called with `new` by React.', componentName, componentName, componentName);\n        didWarnAboutModulePatternComponent[componentName] = true;\n      }\n    } // Proceed under the assumption that this is a class instance\n\n\n    workInProgress.tag = ClassComponent; // Throw out any hooks that were used.\n\n    resetHooks(); // Push context providers early to prevent context stack mismatches.\n    // During mounting we don't know the child context yet as the instance doesn't exist.\n    // We will invalidate the child context in finishClassComponent() right after rendering.\n\n    let hasContext = false;\n\n    if (isLegacyContextProvider(Component)) {\n      hasContext = true;\n      pushLegacyContextProvider(workInProgress);\n    } else {\n      hasContext = false;\n    }\n\n    workInProgress.memoizedState = value.state !== null && value.state !== undefined ? value.state : null;\n    const getDerivedStateFromProps = Component.getDerivedStateFromProps;\n\n    if (typeof getDerivedStateFromProps === 'function') {\n      applyDerivedStateFromProps(workInProgress, Component, getDerivedStateFromProps, props);\n    }\n\n    adoptClassInstance(workInProgress, value);\n    mountClassInstance(workInProgress, Component, props, renderExpirationTime);\n    return finishClassComponent(null, workInProgress, Component, true, hasContext, renderExpirationTime);\n  } else {\n    // Proceed under the assumption that this is a function component\n    workInProgress.tag = FunctionComponent;\n\n    if (__DEV__) {\n      if (disableLegacyContext && Component.contextTypes) {\n        warningWithoutStack(false, '%s uses the legacy contextTypes API which is no longer supported. ' + 'Use React.createContext() with React.useContext() instead.', getComponentName(Component) || 'Unknown');\n      }\n\n      if (debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {\n        // Only double-render components with Hooks\n        if (workInProgress.memoizedState !== null) {\n          value = renderWithHooks(null, workInProgress, Component, props, context, renderExpirationTime);\n        }\n      }\n    }\n\n    reconcileChildren(null, workInProgress, value, renderExpirationTime);\n\n    if (__DEV__) {\n      validateFunctionComponentInDev(workInProgress, Component);\n    }\n\n    return workInProgress.child;\n  }\n}\n\nfunction validateFunctionComponentInDev(workInProgress, Component) {\n  if (Component) {\n    warningWithoutStack(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a function component.', Component.displayName || Component.name || 'Component');\n  }\n\n  if (workInProgress.ref !== null) {\n    let info = '';\n    const ownerName = getCurrentFiberOwnerNameInDevOrNull();\n\n    if (ownerName) {\n      info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n    }\n\n    let warningKey = ownerName || workInProgress._debugID || '';\n    const debugSource = workInProgress._debugSource;\n\n    if (debugSource) {\n      warningKey = debugSource.fileName + ':' + debugSource.lineNumber;\n    }\n\n    if (!didWarnAboutFunctionRefs[warningKey]) {\n      didWarnAboutFunctionRefs[warningKey] = true;\n      warning(false, 'Function components cannot be given refs. ' + 'Attempts to access this ref will fail. ' + 'Did you mean to use React.forwardRef()?%s', info);\n    }\n  }\n\n  if (warnAboutDefaultPropsOnFunctionComponents && Component.defaultProps !== undefined) {\n    const componentName = getComponentName(Component) || 'Unknown';\n\n    if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {\n      warningWithoutStack(false, '%s: Support for defaultProps will be removed from function components ' + 'in a future major release. Use JavaScript default parameters instead.', componentName);\n      didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;\n    }\n  }\n\n  if (typeof Component.getDerivedStateFromProps === 'function') {\n    const componentName = getComponentName(Component) || 'Unknown';\n\n    if (!didWarnAboutGetDerivedStateOnFunctionComponent[componentName]) {\n      warningWithoutStack(false, '%s: Function components do not support getDerivedStateFromProps.', componentName);\n      didWarnAboutGetDerivedStateOnFunctionComponent[componentName] = true;\n    }\n  }\n\n  if (typeof Component.contextType === 'object' && Component.contextType !== null) {\n    const componentName = getComponentName(Component) || 'Unknown';\n\n    if (!didWarnAboutContextTypeOnFunctionComponent[componentName]) {\n      warningWithoutStack(false, '%s: Function components do not support contextType.', componentName);\n      didWarnAboutContextTypeOnFunctionComponent[componentName] = true;\n    }\n  }\n}\n\nconst SUSPENDED_MARKER = {\n  dehydrated: null,\n  retryTime: NoWork\n};\n\nfunction shouldRemainOnFallback(suspenseContext, current, workInProgress) {\n  // If the context is telling us that we should show a fallback, and we're not\n  // already showing content, then we should show the fallback instead.\n  return hasSuspenseContext(suspenseContext, ForceSuspenseFallback) && (current === null || current.memoizedState !== null);\n}\n\nfunction updateSuspenseComponent(current, workInProgress, renderExpirationTime) {\n  const mode = workInProgress.mode;\n  const nextProps = workInProgress.pendingProps; // This is used by DevTools to force a boundary to suspend.\n\n  if (__DEV__) {\n    if (shouldSuspend(workInProgress)) {\n      workInProgress.effectTag |= DidCapture;\n    }\n  }\n\n  let suspenseContext = suspenseStackCursor.current;\n  let nextDidTimeout = false;\n  const didSuspend = (workInProgress.effectTag & DidCapture) !== NoEffect;\n\n  if (didSuspend || shouldRemainOnFallback(suspenseContext, current, workInProgress)) {\n    // Something in this boundary's subtree already suspended. Switch to\n    // rendering the fallback children.\n    nextDidTimeout = true;\n    workInProgress.effectTag &= ~DidCapture;\n  } else {\n    // Attempting the main content\n    if (current === null || current.memoizedState !== null) {\n      // This is a new mount or this boundary is already showing a fallback state.\n      // Mark this subtree context as having at least one invisible parent that could\n      // handle the fallback state.\n      // Boundaries without fallbacks or should be avoided are not considered since\n      // they cannot handle preferred fallback states.\n      if (nextProps.fallback !== undefined && nextProps.unstable_avoidThisFallback !== true) {\n        suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);\n      }\n    }\n  }\n\n  suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n  pushSuspenseContext(workInProgress, suspenseContext);\n\n  if (__DEV__) {\n    if ('maxDuration' in nextProps) {\n      if (!didWarnAboutMaxDuration) {\n        didWarnAboutMaxDuration = true;\n        warning(false, 'maxDuration has been removed from React. ' + 'Remove the maxDuration prop.');\n      }\n    }\n  } // This next part is a bit confusing. If the children timeout, we switch to\n  // showing the fallback children in place of the \"primary\" children.\n  // However, we don't want to delete the primary children because then their\n  // state will be lost (both the React state and the host state, e.g.\n  // uncontrolled form inputs). Instead we keep them mounted and hide them.\n  // Both the fallback children AND the primary children are rendered at the\n  // same time. Once the primary children are un-suspended, we can delete\n  // the fallback children — don't need to preserve their state.\n  //\n  // The two sets of children are siblings in the host environment, but\n  // semantically, for purposes of reconciliation, they are two separate sets.\n  // So we store them using two fragment fibers.\n  //\n  // However, we want to avoid allocating extra fibers for every placeholder.\n  // They're only necessary when the children time out, because that's the\n  // only time when both sets are mounted.\n  //\n  // So, the extra fragment fibers are only used if the children time out.\n  // Otherwise, we render the primary children directly. This requires some\n  // custom reconciliation logic to preserve the state of the primary\n  // children. It's essentially a very basic form of re-parenting.\n\n\n  if (current === null) {\n    // If we're currently hydrating, try to hydrate this boundary.\n    // But only if this has a fallback.\n    if (nextProps.fallback !== undefined) {\n      tryToClaimNextHydratableInstance(workInProgress); // This could've been a dehydrated suspense component.\n\n      if (enableSuspenseServerRenderer) {\n        const suspenseState = workInProgress.memoizedState;\n\n        if (suspenseState !== null) {\n          const dehydrated = suspenseState.dehydrated;\n\n          if (dehydrated !== null) {\n            return mountDehydratedSuspenseComponent(workInProgress, dehydrated, renderExpirationTime);\n          }\n        }\n      }\n    } // This is the initial mount. This branch is pretty simple because there's\n    // no previous state that needs to be preserved.\n\n\n    if (nextDidTimeout) {\n      // Mount separate fragments for primary and fallback children.\n      const nextFallbackChildren = nextProps.fallback;\n      const primaryChildFragment = createFiberFromFragment(null, mode, NoWork, null);\n      primaryChildFragment.return = workInProgress;\n\n      if ((workInProgress.mode & BlockingMode) === NoMode) {\n        // Outside of blocking mode, we commit the effects from the\n        // partially completed, timed-out tree, too.\n        const progressedState = workInProgress.memoizedState;\n        const progressedPrimaryChild = progressedState !== null ? workInProgress.child.child : workInProgress.child;\n        primaryChildFragment.child = progressedPrimaryChild;\n        let progressedChild = progressedPrimaryChild;\n\n        while (progressedChild !== null) {\n          progressedChild.return = primaryChildFragment;\n          progressedChild = progressedChild.sibling;\n        }\n      }\n\n      const fallbackChildFragment = createFiberFromFragment(nextFallbackChildren, mode, renderExpirationTime, null);\n      fallbackChildFragment.return = workInProgress;\n      primaryChildFragment.sibling = fallbackChildFragment; // Skip the primary children, and continue working on the\n      // fallback children.\n\n      workInProgress.memoizedState = SUSPENDED_MARKER;\n      workInProgress.child = primaryChildFragment;\n      return fallbackChildFragment;\n    } else {\n      // Mount the primary children without an intermediate fragment fiber.\n      const nextPrimaryChildren = nextProps.children;\n      workInProgress.memoizedState = null;\n      return workInProgress.child = mountChildFibers(workInProgress, null, nextPrimaryChildren, renderExpirationTime);\n    }\n  } else {\n    // This is an update. This branch is more complicated because we need to\n    // ensure the state of the primary children is preserved.\n    const prevState = current.memoizedState;\n\n    if (prevState !== null) {\n      if (enableSuspenseServerRenderer) {\n        const dehydrated = prevState.dehydrated;\n\n        if (dehydrated !== null) {\n          if (!didSuspend) {\n            return updateDehydratedSuspenseComponent(current, workInProgress, dehydrated, prevState, renderExpirationTime);\n          } else if (workInProgress.memoizedState !== null) {\n            // Something suspended and we should still be in dehydrated mode.\n            // Leave the existing child in place.\n            workInProgress.child = current.child; // The dehydrated completion pass expects this flag to be there\n            // but the normal suspense pass doesn't.\n\n            workInProgress.effectTag |= DidCapture;\n            return null;\n          } else {\n            // Suspended but we should no longer be in dehydrated mode.\n            // Therefore we now have to render the fallback. Wrap the children\n            // in a fragment fiber to keep them separate from the fallback\n            // children.\n            const nextFallbackChildren = nextProps.fallback;\n            const primaryChildFragment = createFiberFromFragment( // It shouldn't matter what the pending props are because we aren't\n            // going to render this fragment.\n            null, mode, NoWork, null);\n            primaryChildFragment.return = workInProgress; // This is always null since we never want the previous child\n            // that we're not going to hydrate.\n\n            primaryChildFragment.child = null;\n\n            if ((workInProgress.mode & BlockingMode) === NoMode) {\n              // Outside of blocking mode, we commit the effects from the\n              // partially completed, timed-out tree, too.\n              let progressedChild = primaryChildFragment.child = workInProgress.child;\n\n              while (progressedChild !== null) {\n                progressedChild.return = primaryChildFragment;\n                progressedChild = progressedChild.sibling;\n              }\n            } else {\n              // We will have dropped the effect list which contains the deletion.\n              // We need to reconcile to delete the current child.\n              reconcileChildFibers(workInProgress, current.child, null, renderExpirationTime);\n            } // Because primaryChildFragment is a new fiber that we're inserting as the\n            // parent of a new tree, we need to set its treeBaseDuration.\n\n\n            if (enableProfilerTimer && workInProgress.mode & ProfileMode) {\n              // treeBaseDuration is the sum of all the child tree base durations.\n              let treeBaseDuration = 0;\n              let hiddenChild = primaryChildFragment.child;\n\n              while (hiddenChild !== null) {\n                treeBaseDuration += hiddenChild.treeBaseDuration;\n                hiddenChild = hiddenChild.sibling;\n              }\n\n              primaryChildFragment.treeBaseDuration = treeBaseDuration;\n            } // Create a fragment from the fallback children, too.\n\n\n            const fallbackChildFragment = createFiberFromFragment(nextFallbackChildren, mode, renderExpirationTime, null);\n            fallbackChildFragment.return = workInProgress;\n            primaryChildFragment.sibling = fallbackChildFragment;\n            fallbackChildFragment.effectTag |= Placement;\n            primaryChildFragment.childExpirationTime = NoWork;\n            workInProgress.memoizedState = SUSPENDED_MARKER;\n            workInProgress.child = primaryChildFragment; // Skip the primary children, and continue working on the\n            // fallback children.\n\n            return fallbackChildFragment;\n          }\n        }\n      } // The current tree already timed out. That means each child set is\n      // wrapped in a fragment fiber.\n\n\n      const currentPrimaryChildFragment = current.child;\n      const currentFallbackChildFragment = currentPrimaryChildFragment.sibling;\n\n      if (nextDidTimeout) {\n        // Still timed out. Reuse the current primary children by cloning\n        // its fragment. We're going to skip over these entirely.\n        const nextFallbackChildren = nextProps.fallback;\n        const primaryChildFragment = createWorkInProgress(currentPrimaryChildFragment, currentPrimaryChildFragment.pendingProps, NoWork);\n        primaryChildFragment.return = workInProgress;\n\n        if ((workInProgress.mode & BlockingMode) === NoMode) {\n          // Outside of blocking mode, we commit the effects from the\n          // partially completed, timed-out tree, too.\n          const progressedState = workInProgress.memoizedState;\n          const progressedPrimaryChild = progressedState !== null ? workInProgress.child.child : workInProgress.child;\n\n          if (progressedPrimaryChild !== currentPrimaryChildFragment.child) {\n            primaryChildFragment.child = progressedPrimaryChild;\n            let progressedChild = progressedPrimaryChild;\n\n            while (progressedChild !== null) {\n              progressedChild.return = primaryChildFragment;\n              progressedChild = progressedChild.sibling;\n            }\n          }\n        } // Because primaryChildFragment is a new fiber that we're inserting as the\n        // parent of a new tree, we need to set its treeBaseDuration.\n\n\n        if (enableProfilerTimer && workInProgress.mode & ProfileMode) {\n          // treeBaseDuration is the sum of all the child tree base durations.\n          let treeBaseDuration = 0;\n          let hiddenChild = primaryChildFragment.child;\n\n          while (hiddenChild !== null) {\n            treeBaseDuration += hiddenChild.treeBaseDuration;\n            hiddenChild = hiddenChild.sibling;\n          }\n\n          primaryChildFragment.treeBaseDuration = treeBaseDuration;\n        } // Clone the fallback child fragment, too. These we'll continue\n        // working on.\n\n\n        const fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, nextFallbackChildren, currentFallbackChildFragment.expirationTime);\n        fallbackChildFragment.return = workInProgress;\n        primaryChildFragment.sibling = fallbackChildFragment;\n        primaryChildFragment.childExpirationTime = NoWork; // Skip the primary children, and continue working on the\n        // fallback children.\n\n        workInProgress.memoizedState = SUSPENDED_MARKER;\n        workInProgress.child = primaryChildFragment;\n        return fallbackChildFragment;\n      } else {\n        // No longer suspended. Switch back to showing the primary children,\n        // and remove the intermediate fragment fiber.\n        const nextPrimaryChildren = nextProps.children;\n        const currentPrimaryChild = currentPrimaryChildFragment.child;\n        const primaryChild = reconcileChildFibers(workInProgress, currentPrimaryChild, nextPrimaryChildren, renderExpirationTime); // If this render doesn't suspend, we need to delete the fallback\n        // children. Wait until the complete phase, after we've confirmed the\n        // fallback is no longer needed.\n        // TODO: Would it be better to store the fallback fragment on\n        // the stateNode?\n        // Continue rendering the children, like we normally do.\n\n        workInProgress.memoizedState = null;\n        return workInProgress.child = primaryChild;\n      }\n    } else {\n      // The current tree has not already timed out. That means the primary\n      // children are not wrapped in a fragment fiber.\n      const currentPrimaryChild = current.child;\n\n      if (nextDidTimeout) {\n        // Timed out. Wrap the children in a fragment fiber to keep them\n        // separate from the fallback children.\n        const nextFallbackChildren = nextProps.fallback;\n        const primaryChildFragment = createFiberFromFragment( // It shouldn't matter what the pending props are because we aren't\n        // going to render this fragment.\n        null, mode, NoWork, null);\n        primaryChildFragment.return = workInProgress;\n        primaryChildFragment.child = currentPrimaryChild;\n\n        if (currentPrimaryChild !== null) {\n          currentPrimaryChild.return = primaryChildFragment;\n        } // Even though we're creating a new fiber, there are no new children,\n        // because we're reusing an already mounted tree. So we don't need to\n        // schedule a placement.\n        // primaryChildFragment.effectTag |= Placement;\n\n\n        if ((workInProgress.mode & BlockingMode) === NoMode) {\n          // Outside of blocking mode, we commit the effects from the\n          // partially completed, timed-out tree, too.\n          const progressedState = workInProgress.memoizedState;\n          const progressedPrimaryChild = progressedState !== null ? workInProgress.child.child : workInProgress.child;\n          primaryChildFragment.child = progressedPrimaryChild;\n          let progressedChild = progressedPrimaryChild;\n\n          while (progressedChild !== null) {\n            progressedChild.return = primaryChildFragment;\n            progressedChild = progressedChild.sibling;\n          }\n        } // Because primaryChildFragment is a new fiber that we're inserting as the\n        // parent of a new tree, we need to set its treeBaseDuration.\n\n\n        if (enableProfilerTimer && workInProgress.mode & ProfileMode) {\n          // treeBaseDuration is the sum of all the child tree base durations.\n          let treeBaseDuration = 0;\n          let hiddenChild = primaryChildFragment.child;\n\n          while (hiddenChild !== null) {\n            treeBaseDuration += hiddenChild.treeBaseDuration;\n            hiddenChild = hiddenChild.sibling;\n          }\n\n          primaryChildFragment.treeBaseDuration = treeBaseDuration;\n        } // Create a fragment from the fallback children, too.\n\n\n        const fallbackChildFragment = createFiberFromFragment(nextFallbackChildren, mode, renderExpirationTime, null);\n        fallbackChildFragment.return = workInProgress;\n        primaryChildFragment.sibling = fallbackChildFragment;\n        fallbackChildFragment.effectTag |= Placement;\n        primaryChildFragment.childExpirationTime = NoWork; // Skip the primary children, and continue working on the\n        // fallback children.\n\n        workInProgress.memoizedState = SUSPENDED_MARKER;\n        workInProgress.child = primaryChildFragment;\n        return fallbackChildFragment;\n      } else {\n        // Still haven't timed out.  Continue rendering the children, like we\n        // normally do.\n        workInProgress.memoizedState = null;\n        const nextPrimaryChildren = nextProps.children;\n        return workInProgress.child = reconcileChildFibers(workInProgress, currentPrimaryChild, nextPrimaryChildren, renderExpirationTime);\n      }\n    }\n  }\n}\n\nfunction retrySuspenseComponentWithoutHydrating(current, workInProgress, renderExpirationTime) {\n  // We're now not suspended nor dehydrated.\n  workInProgress.memoizedState = null; // Retry with the full children.\n\n  const nextProps = workInProgress.pendingProps;\n  const nextChildren = nextProps.children; // This will ensure that the children get Placement effects and\n  // that the old child gets a Deletion effect.\n  // We could also call forceUnmountCurrentAndReconcile.\n\n  reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);\n  return workInProgress.child;\n}\n\nfunction mountDehydratedSuspenseComponent(workInProgress, suspenseInstance, renderExpirationTime) {\n  // During the first pass, we'll bail out and not drill into the children.\n  // Instead, we'll leave the content in place and try to hydrate it later.\n  if ((workInProgress.mode & BlockingMode) === NoMode) {\n    if (__DEV__) {\n      warning(false, 'Cannot hydrate Suspense in legacy mode. Switch from ' + 'ReactDOM.hydrate(element, container) to ' + 'ReactDOM.createBlockingRoot(container, { hydrate: true })' + '.render(element) or remove the Suspense components from ' + 'the server rendered components.');\n    }\n\n    workInProgress.expirationTime = Sync;\n  } else if (isSuspenseInstanceFallback(suspenseInstance)) {\n    // This is a client-only boundary. Since we won't get any content from the server\n    // for this, we need to schedule that at a higher priority based on when it would\n    // have timed out. In theory we could render it in this pass but it would have the\n    // wrong priority associated with it and will prevent hydration of parent path.\n    // Instead, we'll leave work left on it to render it in a separate commit.\n    // TODO This time should be the time at which the server rendered response that is\n    // a parent to this boundary was displayed. However, since we currently don't have\n    // a protocol to transfer that time, we'll just estimate it by using the current\n    // time. This will mean that Suspense timeouts are slightly shifted to later than\n    // they should be.\n    let serverDisplayTime = requestCurrentTimeForUpdate(); // Schedule a normal pri update to render this content.\n\n    let newExpirationTime = computeAsyncExpiration(serverDisplayTime);\n\n    if (enableSchedulerTracing) {\n      markSpawnedWork(newExpirationTime);\n    }\n\n    workInProgress.expirationTime = newExpirationTime;\n  } else {\n    // We'll continue hydrating the rest at offscreen priority since we'll already\n    // be showing the right content coming from the server, it is no rush.\n    workInProgress.expirationTime = Never;\n\n    if (enableSchedulerTracing) {\n      markSpawnedWork(Never);\n    }\n  }\n\n  return null;\n}\n\nfunction updateDehydratedSuspenseComponent(current, workInProgress, suspenseInstance, suspenseState, renderExpirationTime) {\n  // We should never be hydrating at this point because it is the first pass,\n  // but after we've already committed once.\n  warnIfHydrating();\n\n  if ((workInProgress.mode & BlockingMode) === NoMode) {\n    return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderExpirationTime);\n  }\n\n  if (isSuspenseInstanceFallback(suspenseInstance)) {\n    // This boundary is in a permanent fallback state. In this case, we'll never\n    // get an update and we'll never be able to hydrate the final content. Let's just try the\n    // client side render instead.\n    return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderExpirationTime);\n  } // We use childExpirationTime to indicate that a child might depend on context, so if\n  // any context has changed, we need to treat is as if the input might have changed.\n\n\n  const hasContextChanged = current.childExpirationTime >= renderExpirationTime;\n\n  if (didReceiveUpdate || hasContextChanged) {\n    // This boundary has changed since the first render. This means that we are now unable to\n    // hydrate it. We might still be able to hydrate it using an earlier expiration time, if\n    // we are rendering at lower expiration than sync.\n    if (renderExpirationTime < Sync) {\n      if (suspenseState.retryTime <= renderExpirationTime) {\n        // This render is even higher pri than we've seen before, let's try again\n        // at even higher pri.\n        let attemptHydrationAtExpirationTime = renderExpirationTime + 1;\n        suspenseState.retryTime = attemptHydrationAtExpirationTime;\n        scheduleWork(current, attemptHydrationAtExpirationTime); // TODO: Early abort this render.\n      } else {// We have already tried to ping at a higher priority than we're rendering with\n          // so if we got here, we must have failed to hydrate at those levels. We must\n          // now give up. Instead, we're going to delete the whole subtree and instead inject\n          // a new real Suspense boundary to take its place, which may render content\n          // or fallback. This might suspend for a while and if it does we might still have\n          // an opportunity to hydrate before this pass commits.\n        }\n    } // If we have scheduled higher pri work above, this will probably just abort the render\n    // since we now have higher priority work, but in case it doesn't, we need to prepare to\n    // render something, if we time out. Even if that requires us to delete everything and\n    // skip hydration.\n    // Delay having to do this as long as the suspense timeout allows us.\n\n\n    renderDidSuspendDelayIfPossible();\n    return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderExpirationTime);\n  } else if (isSuspenseInstancePending(suspenseInstance)) {\n    // This component is still pending more data from the server, so we can't hydrate its\n    // content. We treat it as if this component suspended itself. It might seem as if\n    // we could just try to render it client-side instead. However, this will perform a\n    // lot of unnecessary work and is unlikely to complete since it often will suspend\n    // on missing data anyway. Additionally, the server might be able to render more\n    // than we can on the client yet. In that case we'd end up with more fallback states\n    // on the client than if we just leave it alone. If the server times out or errors\n    // these should update this boundary to the permanent Fallback state instead.\n    // Mark it as having captured (i.e. suspended).\n    workInProgress.effectTag |= DidCapture; // Leave the child in place. I.e. the dehydrated fragment.\n\n    workInProgress.child = current.child; // Register a callback to retry this boundary once the server has sent the result.\n\n    registerSuspenseInstanceRetry(suspenseInstance, retryDehydratedSuspenseBoundary.bind(null, current));\n    return null;\n  } else {\n    // This is the first attempt.\n    reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress, suspenseInstance);\n    const nextProps = workInProgress.pendingProps;\n    const nextChildren = nextProps.children;\n    const child = mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime);\n    let node = child;\n\n    while (node) {\n      // Mark each child as hydrating. This is a fast path to know whether this\n      // tree is part of a hydrating tree. This is used to determine if a child\n      // node has fully mounted yet, and for scheduling event replaying.\n      // Conceptually this is similar to Placement in that a new subtree is\n      // inserted into the React tree here. It just happens to not need DOM\n      // mutations because it already exists.\n      node.effectTag |= Hydrating;\n      node = node.sibling;\n    }\n\n    workInProgress.child = child;\n    return workInProgress.child;\n  }\n}\n\nfunction scheduleWorkOnFiber(fiber, renderExpirationTime) {\n  if (fiber.expirationTime < renderExpirationTime) {\n    fiber.expirationTime = renderExpirationTime;\n  }\n\n  let alternate = fiber.alternate;\n\n  if (alternate !== null && alternate.expirationTime < renderExpirationTime) {\n    alternate.expirationTime = renderExpirationTime;\n  }\n\n  scheduleWorkOnParentPath(fiber.return, renderExpirationTime);\n}\n\nfunction propagateSuspenseContextChange(workInProgress, firstChild, renderExpirationTime) {\n  // Mark any Suspense boundaries with fallbacks as having work to do.\n  // If they were previously forced into fallbacks, they may now be able\n  // to unblock.\n  let node = firstChild;\n\n  while (node !== null) {\n    if (node.tag === SuspenseComponent) {\n      const state = node.memoizedState;\n\n      if (state !== null) {\n        scheduleWorkOnFiber(node, renderExpirationTime);\n      }\n    } else if (node.tag === SuspenseListComponent) {\n      // If the tail is hidden there might not be an Suspense boundaries\n      // to schedule work on. In this case we have to schedule it on the\n      // list itself.\n      // We don't have to traverse to the children of the list since\n      // the list will propagate the change when it rerenders.\n      scheduleWorkOnFiber(node, renderExpirationTime);\n    } else if (node.child !== null) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n\n    if (node === workInProgress) {\n      return;\n    }\n\n    while (node.sibling === null) {\n      if (node.return === null || node.return === workInProgress) {\n        return;\n      }\n\n      node = node.return;\n    }\n\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction findLastContentRow(firstChild) {\n  // This is going to find the last row among these children that is already\n  // showing content on the screen, as opposed to being in fallback state or\n  // new. If a row has multiple Suspense boundaries, any of them being in the\n  // fallback state, counts as the whole row being in a fallback state.\n  // Note that the \"rows\" will be workInProgress, but any nested children\n  // will still be current since we haven't rendered them yet. The mounted\n  // order may not be the same as the new order. We use the new order.\n  let row = firstChild;\n  let lastContentRow = null;\n\n  while (row !== null) {\n    let currentRow = row.alternate; // New rows can't be content rows.\n\n    if (currentRow !== null && findFirstSuspended(currentRow) === null) {\n      lastContentRow = row;\n    }\n\n    row = row.sibling;\n  }\n\n  return lastContentRow;\n}\n\nfunction validateRevealOrder(revealOrder) {\n  if (__DEV__) {\n    if (revealOrder !== undefined && revealOrder !== 'forwards' && revealOrder !== 'backwards' && revealOrder !== 'together' && !didWarnAboutRevealOrder[revealOrder]) {\n      didWarnAboutRevealOrder[revealOrder] = true;\n\n      if (typeof revealOrder === 'string') {\n        switch (revealOrder.toLowerCase()) {\n          case 'together':\n          case 'forwards':\n          case 'backwards':\n            {\n              warning(false, '\"%s\" is not a valid value for revealOrder on <SuspenseList />. ' + 'Use lowercase \"%s\" instead.', revealOrder, revealOrder.toLowerCase());\n              break;\n            }\n\n          case 'forward':\n          case 'backward':\n            {\n              warning(false, '\"%s\" is not a valid value for revealOrder on <SuspenseList />. ' + 'React uses the -s suffix in the spelling. Use \"%ss\" instead.', revealOrder, revealOrder.toLowerCase());\n              break;\n            }\n\n          default:\n            warning(false, '\"%s\" is not a supported revealOrder on <SuspenseList />. ' + 'Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n            break;\n        }\n      } else {\n        warning(false, '%s is not a supported value for revealOrder on <SuspenseList />. ' + 'Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n      }\n    }\n  }\n}\n\nfunction validateTailOptions(tailMode, revealOrder) {\n  if (__DEV__) {\n    if (tailMode !== undefined && !didWarnAboutTailOptions[tailMode]) {\n      if (tailMode !== 'collapsed' && tailMode !== 'hidden') {\n        didWarnAboutTailOptions[tailMode] = true;\n        warning(false, '\"%s\" is not a supported value for tail on <SuspenseList />. ' + 'Did you mean \"collapsed\" or \"hidden\"?', tailMode);\n      } else if (revealOrder !== 'forwards' && revealOrder !== 'backwards') {\n        didWarnAboutTailOptions[tailMode] = true;\n        warning(false, '<SuspenseList tail=\"%s\" /> is only valid if revealOrder is ' + '\"forwards\" or \"backwards\". ' + 'Did you mean to specify revealOrder=\"forwards\"?', tailMode);\n      }\n    }\n  }\n}\n\nfunction validateSuspenseListNestedChild(childSlot, index) {\n  if (__DEV__) {\n    let isArray = Array.isArray(childSlot);\n    let isIterable = !isArray && typeof getIteratorFn(childSlot) === 'function';\n\n    if (isArray || isIterable) {\n      let type = isArray ? 'array' : 'iterable';\n      warning(false, 'A nested %s was passed to row #%s in <SuspenseList />. Wrap it in ' + 'an additional SuspenseList to configure its revealOrder: ' + '<SuspenseList revealOrder=...> ... ' + '<SuspenseList revealOrder=...>{%s}</SuspenseList> ... ' + '</SuspenseList>', type, index, type);\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction validateSuspenseListChildren(children, revealOrder) {\n  if (__DEV__) {\n    if ((revealOrder === 'forwards' || revealOrder === 'backwards') && children !== undefined && children !== null && children !== false) {\n      if (Array.isArray(children)) {\n        for (let i = 0; i < children.length; i++) {\n          if (!validateSuspenseListNestedChild(children[i], i)) {\n            return;\n          }\n        }\n      } else {\n        let iteratorFn = getIteratorFn(children);\n\n        if (typeof iteratorFn === 'function') {\n          const childrenIterator = iteratorFn.call(children);\n\n          if (childrenIterator) {\n            let step = childrenIterator.next();\n            let i = 0;\n\n            for (; !step.done; step = childrenIterator.next()) {\n              if (!validateSuspenseListNestedChild(step.value, i)) {\n                return;\n              }\n\n              i++;\n            }\n          }\n        } else {\n          warning(false, 'A single row was passed to a <SuspenseList revealOrder=\"%s\" />. ' + 'This is not useful since it needs multiple rows. ' + 'Did you mean to pass multiple children or an array?', revealOrder);\n        }\n      }\n    }\n  }\n}\n\nfunction initSuspenseListRenderState(workInProgress, isBackwards, tail, lastContentRow, tailMode, lastEffectBeforeRendering) {\n  let renderState = workInProgress.memoizedState;\n\n  if (renderState === null) {\n    workInProgress.memoizedState = {\n      isBackwards: isBackwards,\n      rendering: null,\n      last: lastContentRow,\n      tail: tail,\n      tailExpiration: 0,\n      tailMode: tailMode,\n      lastEffect: lastEffectBeforeRendering\n    };\n  } else {\n    // We can reuse the existing object from previous renders.\n    renderState.isBackwards = isBackwards;\n    renderState.rendering = null;\n    renderState.last = lastContentRow;\n    renderState.tail = tail;\n    renderState.tailExpiration = 0;\n    renderState.tailMode = tailMode;\n    renderState.lastEffect = lastEffectBeforeRendering;\n  }\n} // This can end up rendering this component multiple passes.\n// The first pass splits the children fibers into two sets. A head and tail.\n// We first render the head. If anything is in fallback state, we do another\n// pass through beginWork to rerender all children (including the tail) with\n// the force suspend context. If the first render didn't have anything in\n// in fallback state. Then we render each row in the tail one-by-one.\n// That happens in the completeWork phase without going back to beginWork.\n\n\nfunction updateSuspenseListComponent(current, workInProgress, renderExpirationTime) {\n  const nextProps = workInProgress.pendingProps;\n  const revealOrder = nextProps.revealOrder;\n  const tailMode = nextProps.tail;\n  const newChildren = nextProps.children;\n  validateRevealOrder(revealOrder);\n  validateTailOptions(tailMode, revealOrder);\n  validateSuspenseListChildren(newChildren, revealOrder);\n  reconcileChildren(current, workInProgress, newChildren, renderExpirationTime);\n  let suspenseContext = suspenseStackCursor.current;\n  let shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);\n\n  if (shouldForceFallback) {\n    suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);\n    workInProgress.effectTag |= DidCapture;\n  } else {\n    const didSuspendBefore = current !== null && (current.effectTag & DidCapture) !== NoEffect;\n\n    if (didSuspendBefore) {\n      // If we previously forced a fallback, we need to schedule work\n      // on any nested boundaries to let them know to try to render\n      // again. This is the same as context updating.\n      propagateSuspenseContextChange(workInProgress, workInProgress.child, renderExpirationTime);\n    }\n\n    suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n  }\n\n  pushSuspenseContext(workInProgress, suspenseContext);\n\n  if ((workInProgress.mode & BlockingMode) === NoMode) {\n    // Outside of blocking mode, SuspenseList doesn't work so we just\n    // use make it a noop by treating it as the default revealOrder.\n    workInProgress.memoizedState = null;\n  } else {\n    switch (revealOrder) {\n      case 'forwards':\n        {\n          let lastContentRow = findLastContentRow(workInProgress.child);\n          let tail;\n\n          if (lastContentRow === null) {\n            // The whole list is part of the tail.\n            // TODO: We could fast path by just rendering the tail now.\n            tail = workInProgress.child;\n            workInProgress.child = null;\n          } else {\n            // Disconnect the tail rows after the content row.\n            // We're going to render them separately later.\n            tail = lastContentRow.sibling;\n            lastContentRow.sibling = null;\n          }\n\n          initSuspenseListRenderState(workInProgress, false, // isBackwards\n          tail, lastContentRow, tailMode, workInProgress.lastEffect);\n          break;\n        }\n\n      case 'backwards':\n        {\n          // We're going to find the first row that has existing content.\n          // At the same time we're going to reverse the list of everything\n          // we pass in the meantime. That's going to be our tail in reverse\n          // order.\n          let tail = null;\n          let row = workInProgress.child;\n          workInProgress.child = null;\n\n          while (row !== null) {\n            let currentRow = row.alternate; // New rows can't be content rows.\n\n            if (currentRow !== null && findFirstSuspended(currentRow) === null) {\n              // This is the beginning of the main content.\n              workInProgress.child = row;\n              break;\n            }\n\n            let nextRow = row.sibling;\n            row.sibling = tail;\n            tail = row;\n            row = nextRow;\n          } // TODO: If workInProgress.child is null, we can continue on the tail immediately.\n\n\n          initSuspenseListRenderState(workInProgress, true, // isBackwards\n          tail, null, // last\n          tailMode, workInProgress.lastEffect);\n          break;\n        }\n\n      case 'together':\n        {\n          initSuspenseListRenderState(workInProgress, false, // isBackwards\n          null, // tail\n          null, // last\n          undefined, workInProgress.lastEffect);\n          break;\n        }\n\n      default:\n        {\n          // The default reveal order is the same as not having\n          // a boundary.\n          workInProgress.memoizedState = null;\n        }\n    }\n  }\n\n  return workInProgress.child;\n}\n\nfunction updatePortalComponent(current, workInProgress, renderExpirationTime) {\n  pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n  const nextChildren = workInProgress.pendingProps;\n\n  if (current === null) {\n    // Portals are special because we don't append the children during mount\n    // but at commit. Therefore we need to track insertions which the normal\n    // flow doesn't do during mount. This doesn't happen at the root because\n    // the root always starts with a \"current\" with a null child.\n    // TODO: Consider unifying this with how the root works.\n    workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderExpirationTime);\n  } else {\n    reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);\n  }\n\n  return workInProgress.child;\n}\n\nfunction updateContextProvider(current, workInProgress, renderExpirationTime) {\n  const providerType = workInProgress.type;\n  const context = providerType._context;\n  const newProps = workInProgress.pendingProps;\n  const oldProps = workInProgress.memoizedProps;\n  const newValue = newProps.value;\n\n  if (__DEV__) {\n    const providerPropTypes = workInProgress.type.propTypes;\n\n    if (providerPropTypes) {\n      checkPropTypes(providerPropTypes, newProps, 'prop', 'Context.Provider', getCurrentFiberStackInDev);\n    }\n  }\n\n  pushProvider(workInProgress, newValue);\n\n  if (oldProps !== null) {\n    const oldValue = oldProps.value;\n    const changedBits = calculateChangedBits(context, newValue, oldValue);\n\n    if (changedBits === 0) {\n      // No change. Bailout early if children are the same.\n      if (oldProps.children === newProps.children && !hasLegacyContextChanged()) {\n        return bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);\n      }\n    } else {\n      // The context value changed. Search for matching consumers and schedule\n      // them to update.\n      propagateContextChange(workInProgress, context, changedBits, renderExpirationTime);\n    }\n  }\n\n  const newChildren = newProps.children;\n  reconcileChildren(current, workInProgress, newChildren, renderExpirationTime);\n  return workInProgress.child;\n}\n\nlet hasWarnedAboutUsingContextAsConsumer = false;\n\nfunction updateContextConsumer(current, workInProgress, renderExpirationTime) {\n  let context = workInProgress.type; // The logic below for Context differs depending on PROD or DEV mode. In\n  // DEV mode, we create a separate object for Context.Consumer that acts\n  // like a proxy to Context. This proxy object adds unnecessary code in PROD\n  // so we use the old behaviour (Context.Consumer references Context) to\n  // reduce size and overhead. The separate object references context via\n  // a property called \"_context\", which also gives us the ability to check\n  // in DEV mode if this property exists or not and warn if it does not.\n\n  if (__DEV__) {\n    if (context._context === undefined) {\n      // This may be because it's a Context (rather than a Consumer).\n      // Or it may be because it's older React where they're the same thing.\n      // We only want to warn if we're sure it's a new React.\n      if (context !== context.Consumer) {\n        if (!hasWarnedAboutUsingContextAsConsumer) {\n          hasWarnedAboutUsingContextAsConsumer = true;\n          warning(false, 'Rendering <Context> directly is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');\n        }\n      }\n    } else {\n      context = context._context;\n    }\n  }\n\n  const newProps = workInProgress.pendingProps;\n  const render = newProps.children;\n\n  if (__DEV__) {\n    warningWithoutStack(typeof render === 'function', 'A context consumer was rendered with multiple children, or a child ' + \"that isn't a function. A context consumer expects a single child \" + 'that is a function. If you did pass a function, make sure there ' + 'is no trailing or leading whitespace around it.');\n  }\n\n  prepareToReadContext(workInProgress, renderExpirationTime);\n  const newValue = readContext(context, newProps.unstable_observedBits);\n  let newChildren;\n\n  if (__DEV__) {\n    ReactCurrentOwner.current = workInProgress;\n    setCurrentPhase('render');\n    newChildren = render(newValue);\n    setCurrentPhase(null);\n  } else {\n    newChildren = render(newValue);\n  } // React DevTools reads this flag.\n\n\n  workInProgress.effectTag |= PerformedWork;\n  reconcileChildren(current, workInProgress, newChildren, renderExpirationTime);\n  return workInProgress.child;\n}\n\nfunction updateFundamentalComponent(current, workInProgress, renderExpirationTime) {\n  const fundamentalImpl = workInProgress.type.impl;\n\n  if (fundamentalImpl.reconcileChildren === false) {\n    return null;\n  }\n\n  const nextProps = workInProgress.pendingProps;\n  const nextChildren = nextProps.children;\n  reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);\n  return workInProgress.child;\n}\n\nfunction updateScopeComponent(current, workInProgress, renderExpirationTime) {\n  const nextProps = workInProgress.pendingProps;\n  const nextChildren = nextProps.children;\n  reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);\n  return workInProgress.child;\n}\n\nexport function markWorkInProgressReceivedUpdate() {\n  didReceiveUpdate = true;\n}\n\nfunction bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime) {\n  cancelWorkTimer(workInProgress);\n\n  if (current !== null) {\n    // Reuse previous dependencies\n    workInProgress.dependencies = current.dependencies;\n  }\n\n  if (enableProfilerTimer) {\n    // Don't update \"base\" render times for bailouts.\n    stopProfilerTimerIfRunning(workInProgress);\n  }\n\n  const updateExpirationTime = workInProgress.expirationTime;\n\n  if (updateExpirationTime !== NoWork) {\n    markUnprocessedUpdateTime(updateExpirationTime);\n  } // Check if the children have any pending work.\n\n\n  const childExpirationTime = workInProgress.childExpirationTime;\n\n  if (childExpirationTime < renderExpirationTime) {\n    // The children don't have any work either. We can skip them.\n    // TODO: Once we add back resuming, we should check if the children are\n    // a work-in-progress set. If so, we need to transfer their effects.\n    return null;\n  } else {\n    // This fiber doesn't have work, but its subtree does. Clone the child\n    // fibers and continue.\n    cloneChildFibers(current, workInProgress);\n    return workInProgress.child;\n  }\n}\n\nfunction remountFiber(current, oldWorkInProgress, newWorkInProgress) {\n  if (__DEV__) {\n    const returnFiber = oldWorkInProgress.return;\n\n    if (returnFiber === null) {\n      throw new Error('Cannot swap the root fiber.');\n    } // Disconnect from the old current.\n    // It will get deleted.\n\n\n    current.alternate = null;\n    oldWorkInProgress.alternate = null; // Connect to the new tree.\n\n    newWorkInProgress.index = oldWorkInProgress.index;\n    newWorkInProgress.sibling = oldWorkInProgress.sibling;\n    newWorkInProgress.return = oldWorkInProgress.return;\n    newWorkInProgress.ref = oldWorkInProgress.ref; // Replace the child/sibling pointers above it.\n\n    if (oldWorkInProgress === returnFiber.child) {\n      returnFiber.child = newWorkInProgress;\n    } else {\n      let prevSibling = returnFiber.child;\n\n      if (prevSibling === null) {\n        throw new Error('Expected parent to have a child.');\n      }\n\n      while (prevSibling.sibling !== oldWorkInProgress) {\n        prevSibling = prevSibling.sibling;\n\n        if (prevSibling === null) {\n          throw new Error('Expected to find the previous sibling.');\n        }\n      }\n\n      prevSibling.sibling = newWorkInProgress;\n    } // Delete the old fiber and place the new one.\n    // Since the old fiber is disconnected, we have to schedule it manually.\n\n\n    const last = returnFiber.lastEffect;\n\n    if (last !== null) {\n      last.nextEffect = current;\n      returnFiber.lastEffect = current;\n    } else {\n      returnFiber.firstEffect = returnFiber.lastEffect = current;\n    }\n\n    current.nextEffect = null;\n    current.effectTag = Deletion;\n    newWorkInProgress.effectTag |= Placement; // Restart work from the new fiber.\n\n    return newWorkInProgress;\n  } else {\n    throw new Error('Did not expect this call in production. ' + 'This is a bug in React. Please file an issue.');\n  }\n}\n\nfunction beginWork(current, workInProgress, renderExpirationTime) {\n  const updateExpirationTime = workInProgress.expirationTime;\n\n  if (__DEV__) {\n    if (workInProgress._debugNeedsRemount && current !== null) {\n      // This will restart the begin phase with a new fiber.\n      return remountFiber(current, workInProgress, createFiberFromTypeAndProps(workInProgress.type, workInProgress.key, workInProgress.pendingProps, workInProgress._debugOwner || null, workInProgress.mode, workInProgress.expirationTime));\n    }\n  }\n\n  if (current !== null) {\n    const oldProps = current.memoizedProps;\n    const newProps = workInProgress.pendingProps;\n\n    if (oldProps !== newProps || hasLegacyContextChanged() || ( // Force a re-render if the implementation changed due to hot reload:\n    __DEV__ ? workInProgress.type !== current.type : false)) {\n      // If props or context changed, mark the fiber as having performed work.\n      // This may be unset if the props are determined to be equal later (memo).\n      didReceiveUpdate = true;\n    } else if (updateExpirationTime < renderExpirationTime) {\n      didReceiveUpdate = false; // This fiber does not have any pending work. Bailout without entering\n      // the begin phase. There's still some bookkeeping we that needs to be done\n      // in this optimized path, mostly pushing stuff onto the stack.\n\n      switch (workInProgress.tag) {\n        case HostRoot:\n          pushHostRootContext(workInProgress);\n          resetHydrationState();\n          break;\n\n        case HostComponent:\n          pushHostContext(workInProgress);\n\n          if (workInProgress.mode & ConcurrentMode && renderExpirationTime !== Never && shouldDeprioritizeSubtree(workInProgress.type, newProps)) {\n            if (enableSchedulerTracing) {\n              markSpawnedWork(Never);\n            } // Schedule this fiber to re-render at offscreen priority. Then bailout.\n\n\n            workInProgress.expirationTime = workInProgress.childExpirationTime = Never;\n            return null;\n          }\n\n          break;\n\n        case ClassComponent:\n          {\n            const Component = workInProgress.type;\n\n            if (isLegacyContextProvider(Component)) {\n              pushLegacyContextProvider(workInProgress);\n            }\n\n            break;\n          }\n\n        case HostPortal:\n          pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n          break;\n\n        case ContextProvider:\n          {\n            const newValue = workInProgress.memoizedProps.value;\n            pushProvider(workInProgress, newValue);\n            break;\n          }\n\n        case Profiler:\n          if (enableProfilerTimer) {\n            // Profiler should only call onRender when one of its descendants actually rendered.\n            const hasChildWork = workInProgress.childExpirationTime >= renderExpirationTime;\n\n            if (hasChildWork) {\n              workInProgress.effectTag |= Update;\n            }\n          }\n\n          break;\n\n        case SuspenseComponent:\n          {\n            const state = workInProgress.memoizedState;\n\n            if (state !== null) {\n              if (enableSuspenseServerRenderer) {\n                if (state.dehydrated !== null) {\n                  pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current)); // We know that this component will suspend again because if it has\n                  // been unsuspended it has committed as a resolved Suspense component.\n                  // If it needs to be retried, it should have work scheduled on it.\n\n                  workInProgress.effectTag |= DidCapture;\n                  break;\n                }\n              } // If this boundary is currently timed out, we need to decide\n              // whether to retry the primary children, or to skip over it and\n              // go straight to the fallback. Check the priority of the primary\n              // child fragment.\n\n\n              const primaryChildFragment = workInProgress.child;\n              const primaryChildExpirationTime = primaryChildFragment.childExpirationTime;\n\n              if (primaryChildExpirationTime !== NoWork && primaryChildExpirationTime >= renderExpirationTime) {\n                // The primary children have pending work. Use the normal path\n                // to attempt to render the primary children again.\n                return updateSuspenseComponent(current, workInProgress, renderExpirationTime);\n              } else {\n                pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current)); // The primary children do not have pending work with sufficient\n                // priority. Bailout.\n\n                const child = bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);\n\n                if (child !== null) {\n                  // The fallback children have pending work. Skip over the\n                  // primary children and work on the fallback.\n                  return child.sibling;\n                } else {\n                  return null;\n                }\n              }\n            } else {\n              pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current));\n            }\n\n            break;\n          }\n\n        case SuspenseListComponent:\n          {\n            const didSuspendBefore = (current.effectTag & DidCapture) !== NoEffect;\n            const hasChildWork = workInProgress.childExpirationTime >= renderExpirationTime;\n\n            if (didSuspendBefore) {\n              if (hasChildWork) {\n                // If something was in fallback state last time, and we have all the\n                // same children then we're still in progressive loading state.\n                // Something might get unblocked by state updates or retries in the\n                // tree which will affect the tail. So we need to use the normal\n                // path to compute the correct tail.\n                return updateSuspenseListComponent(current, workInProgress, renderExpirationTime);\n              } // If none of the children had any work, that means that none of\n              // them got retried so they'll still be blocked in the same way\n              // as before. We can fast bail out.\n\n\n              workInProgress.effectTag |= DidCapture;\n            } // If nothing suspended before and we're rendering the same children,\n            // then the tail doesn't matter. Anything new that suspends will work\n            // in the \"together\" mode, so we can continue from the state we had.\n\n\n            let renderState = workInProgress.memoizedState;\n\n            if (renderState !== null) {\n              // Reset to the \"together\" mode in case we've started a different\n              // update in the past but didn't complete it.\n              renderState.rendering = null;\n              renderState.tail = null;\n            }\n\n            pushSuspenseContext(workInProgress, suspenseStackCursor.current);\n\n            if (hasChildWork) {\n              break;\n            } else {\n              // If none of the children had any work, that means that none of\n              // them got retried so they'll still be blocked in the same way\n              // as before. We can fast bail out.\n              return null;\n            }\n          }\n      }\n\n      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);\n    } else {\n      // An update was scheduled on this fiber, but there are no new props\n      // nor legacy context. Set this to false. If an update queue or context\n      // consumer produces a changed value, it will set this to true. Otherwise,\n      // the component will assume the children have not changed and bail out.\n      didReceiveUpdate = false;\n    }\n  } else {\n    didReceiveUpdate = false;\n  } // Before entering the begin phase, clear the expiration time.\n\n\n  workInProgress.expirationTime = NoWork;\n\n  switch (workInProgress.tag) {\n    case IndeterminateComponent:\n      {\n        return mountIndeterminateComponent(current, workInProgress, workInProgress.type, renderExpirationTime);\n      }\n\n    case LazyComponent:\n      {\n        const elementType = workInProgress.elementType;\n        return mountLazyComponent(current, workInProgress, elementType, updateExpirationTime, renderExpirationTime);\n      }\n\n    case FunctionComponent:\n      {\n        const Component = workInProgress.type;\n        const unresolvedProps = workInProgress.pendingProps;\n        const resolvedProps = workInProgress.elementType === Component ? unresolvedProps : resolveDefaultProps(Component, unresolvedProps);\n        return updateFunctionComponent(current, workInProgress, Component, resolvedProps, renderExpirationTime);\n      }\n\n    case ClassComponent:\n      {\n        const Component = workInProgress.type;\n        const unresolvedProps = workInProgress.pendingProps;\n        const resolvedProps = workInProgress.elementType === Component ? unresolvedProps : resolveDefaultProps(Component, unresolvedProps);\n        return updateClassComponent(current, workInProgress, Component, resolvedProps, renderExpirationTime);\n      }\n\n    case HostRoot:\n      return updateHostRoot(current, workInProgress, renderExpirationTime);\n\n    case HostComponent:\n      return updateHostComponent(current, workInProgress, renderExpirationTime);\n\n    case HostText:\n      return updateHostText(current, workInProgress);\n\n    case SuspenseComponent:\n      return updateSuspenseComponent(current, workInProgress, renderExpirationTime);\n\n    case HostPortal:\n      return updatePortalComponent(current, workInProgress, renderExpirationTime);\n\n    case ForwardRef:\n      {\n        const type = workInProgress.type;\n        const unresolvedProps = workInProgress.pendingProps;\n        const resolvedProps = workInProgress.elementType === type ? unresolvedProps : resolveDefaultProps(type, unresolvedProps);\n        return updateForwardRef(current, workInProgress, type, resolvedProps, renderExpirationTime);\n      }\n\n    case Fragment:\n      return updateFragment(current, workInProgress, renderExpirationTime);\n\n    case Mode:\n      return updateMode(current, workInProgress, renderExpirationTime);\n\n    case Profiler:\n      return updateProfiler(current, workInProgress, renderExpirationTime);\n\n    case ContextProvider:\n      return updateContextProvider(current, workInProgress, renderExpirationTime);\n\n    case ContextConsumer:\n      return updateContextConsumer(current, workInProgress, renderExpirationTime);\n\n    case MemoComponent:\n      {\n        const type = workInProgress.type;\n        const unresolvedProps = workInProgress.pendingProps; // Resolve outer props first, then resolve inner props.\n\n        let resolvedProps = resolveDefaultProps(type, unresolvedProps);\n\n        if (__DEV__) {\n          if (workInProgress.type !== workInProgress.elementType) {\n            const outerPropTypes = type.propTypes;\n\n            if (outerPropTypes) {\n              checkPropTypes(outerPropTypes, resolvedProps, // Resolved for outer only\n              'prop', getComponentName(type), getCurrentFiberStackInDev);\n            }\n          }\n        }\n\n        resolvedProps = resolveDefaultProps(type.type, resolvedProps);\n        return updateMemoComponent(current, workInProgress, type, resolvedProps, updateExpirationTime, renderExpirationTime);\n      }\n\n    case SimpleMemoComponent:\n      {\n        return updateSimpleMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, updateExpirationTime, renderExpirationTime);\n      }\n\n    case IncompleteClassComponent:\n      {\n        const Component = workInProgress.type;\n        const unresolvedProps = workInProgress.pendingProps;\n        const resolvedProps = workInProgress.elementType === Component ? unresolvedProps : resolveDefaultProps(Component, unresolvedProps);\n        return mountIncompleteClassComponent(current, workInProgress, Component, resolvedProps, renderExpirationTime);\n      }\n\n    case SuspenseListComponent:\n      {\n        return updateSuspenseListComponent(current, workInProgress, renderExpirationTime);\n      }\n\n    case FundamentalComponent:\n      {\n        if (enableFundamentalAPI) {\n          return updateFundamentalComponent(current, workInProgress, renderExpirationTime);\n        }\n\n        break;\n      }\n\n    case ScopeComponent:\n      {\n        if (enableScopeAPI) {\n          return updateScopeComponent(current, workInProgress, renderExpirationTime);\n        }\n\n        break;\n      }\n  }\n\n  invariant(false, 'Unknown unit of work tag (%s). This error is likely caused by a bug in ' + 'React. Please file an issue.', workInProgress.tag);\n}\n\nexport { beginWork };","map":{"version":3,"sources":["/Users/gaoshaoyun/Documents/library/debug-react/src/react/packages/react-reconciler/src/ReactFiberBeginWork.js"],"names":["checkPropTypes","IndeterminateComponent","FunctionComponent","ClassComponent","HostRoot","HostComponent","HostText","HostPortal","ForwardRef","Fragment","Mode","ContextProvider","ContextConsumer","Profiler","SuspenseComponent","SuspenseListComponent","MemoComponent","SimpleMemoComponent","LazyComponent","IncompleteClassComponent","FundamentalComponent","ScopeComponent","NoEffect","PerformedWork","Placement","Hydrating","ContentReset","DidCapture","Update","Ref","Deletion","ReactSharedInternals","debugRenderPhaseSideEffectsForStrictMode","disableLegacyContext","enableProfilerTimer","enableSchedulerTracing","enableSuspenseServerRenderer","enableFundamentalAPI","warnAboutDefaultPropsOnFunctionComponents","enableScopeAPI","invariant","shallowEqual","getComponentName","ReactStrictModeWarnings","refineResolvedLazyComponent","REACT_LAZY_TYPE","getIteratorFn","warning","warningWithoutStack","setCurrentPhase","getCurrentFiberOwnerNameInDevOrNull","getCurrentFiberStackInDev","startWorkTimer","cancelWorkTimer","resolveFunctionForHotReloading","resolveForwardRefForHotReloading","resolveClassForHotReloading","mountChildFibers","reconcileChildFibers","cloneChildFibers","processUpdateQueue","NoWork","Never","Sync","computeAsyncExpiration","ConcurrentMode","NoMode","ProfileMode","StrictMode","BlockingMode","shouldSetTextContent","shouldDeprioritizeSubtree","isSuspenseInstancePending","isSuspenseInstanceFallback","registerSuspenseInstanceRetry","shouldSuspend","pushHostContext","pushHostContainer","suspenseStackCursor","pushSuspenseContext","InvisibleParentSuspenseContext","ForceSuspenseFallback","hasSuspenseContext","setDefaultShallowSuspenseContext","addSubtreeSuspenseContext","setShallowSuspenseContext","findFirstSuspended","pushProvider","propagateContextChange","readContext","prepareToReadContext","calculateChangedBits","scheduleWorkOnParentPath","resetHooks","renderWithHooks","bailoutHooks","stopProfilerTimerIfRunning","getMaskedContext","getUnmaskedContext","hasContextChanged","hasLegacyContextChanged","pushContextProvider","pushLegacyContextProvider","isContextProvider","isLegacyContextProvider","pushTopLevelContextObject","invalidateContextProvider","enterHydrationState","reenterHydrationStateFromDehydratedSuspenseInstance","resetHydrationState","tryToClaimNextHydratableInstance","warnIfHydrating","adoptClassInstance","applyDerivedStateFromProps","constructClassInstance","mountClassInstance","resumeMountClassInstance","updateClassInstance","readLazyComponentType","resolveDefaultProps","resolveLazyComponentTag","createFiberFromTypeAndProps","createFiberFromFragment","createWorkInProgress","isSimpleFunctionComponent","markSpawnedWork","requestCurrentTimeForUpdate","retryDehydratedSuspenseBoundary","scheduleWork","renderDidSuspendDelayIfPossible","markUnprocessedUpdateTime","ReactCurrentOwner","didReceiveUpdate","didWarnAboutBadClass","didWarnAboutModulePatternComponent","didWarnAboutContextTypeOnFunctionComponent","didWarnAboutGetDerivedStateOnFunctionComponent","didWarnAboutFunctionRefs","didWarnAboutReassigningProps","didWarnAboutMaxDuration","didWarnAboutRevealOrder","didWarnAboutTailOptions","didWarnAboutDefaultPropsOnFunctionComponent","__DEV__","reconcileChildren","current","workInProgress","nextChildren","renderExpirationTime","child","forceUnmountCurrentAndReconcile","updateForwardRef","Component","nextProps","type","elementType","innerPropTypes","propTypes","render","ref","mode","memoizedState","bailoutOnAlreadyFinishedWork","effectTag","updateMemoComponent","updateExpirationTime","compare","defaultProps","undefined","resolvedType","tag","validateFunctionComponentInDev","updateSimpleMemoComponent","return","currentChild","prevProps","memoizedProps","newChild","outerMemoType","$$typeof","outerPropTypes","updateFunctionComponent","updateFragment","pendingProps","updateMode","children","updateProfiler","markRef","context","unmaskedContext","updateClassComponent","hasContext","instance","stateNode","shouldUpdate","alternate","nextUnitOfWork","finishClassComponent","inst","props","didCaptureError","getDerivedStateFromError","state","pushHostRootContext","root","pendingContext","containerInfo","updateHostRoot","updateQueue","prevState","prevChildren","element","nextState","hydrate","node","sibling","updateHostComponent","isDirectTextChild","expirationTime","childExpirationTime","updateHostText","mountLazyComponent","_current","resolvedTag","resolvedProps","hint","mountIncompleteClassComponent","mountIndeterminateComponent","value","prototype","componentName","recordLegacyContextWarning","getDerivedStateFromProps","contextTypes","childContextTypes","displayName","name","info","ownerName","warningKey","_debugID","debugSource","_debugSource","fileName","lineNumber","contextType","SUSPENDED_MARKER","dehydrated","retryTime","shouldRemainOnFallback","suspenseContext","updateSuspenseComponent","nextDidTimeout","didSuspend","fallback","unstable_avoidThisFallback","suspenseState","mountDehydratedSuspenseComponent","nextFallbackChildren","primaryChildFragment","progressedState","progressedPrimaryChild","progressedChild","fallbackChildFragment","nextPrimaryChildren","updateDehydratedSuspenseComponent","treeBaseDuration","hiddenChild","currentPrimaryChildFragment","currentFallbackChildFragment","currentPrimaryChild","primaryChild","retrySuspenseComponentWithoutHydrating","suspenseInstance","serverDisplayTime","newExpirationTime","attemptHydrationAtExpirationTime","bind","scheduleWorkOnFiber","fiber","propagateSuspenseContextChange","firstChild","findLastContentRow","row","lastContentRow","currentRow","validateRevealOrder","revealOrder","toLowerCase","validateTailOptions","tailMode","validateSuspenseListNestedChild","childSlot","index","isArray","Array","isIterable","validateSuspenseListChildren","i","length","iteratorFn","childrenIterator","call","step","next","done","initSuspenseListRenderState","isBackwards","tail","lastEffectBeforeRendering","renderState","rendering","last","tailExpiration","lastEffect","updateSuspenseListComponent","newChildren","shouldForceFallback","didSuspendBefore","nextRow","updatePortalComponent","updateContextProvider","providerType","_context","newProps","oldProps","newValue","providerPropTypes","oldValue","changedBits","hasWarnedAboutUsingContextAsConsumer","updateContextConsumer","Consumer","unstable_observedBits","updateFundamentalComponent","fundamentalImpl","impl","updateScopeComponent","markWorkInProgressReceivedUpdate","dependencies","remountFiber","oldWorkInProgress","newWorkInProgress","returnFiber","Error","prevSibling","nextEffect","firstEffect","beginWork","_debugNeedsRemount","key","_debugOwner","hasChildWork","primaryChildExpirationTime","unresolvedProps"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {ReactProviderType, ReactContext} from 'shared/ReactTypes';\nimport type {Fiber} from './ReactFiber';\nimport type {FiberRoot} from './ReactFiberRoot';\nimport type {ExpirationTime} from './ReactFiberExpirationTime';\nimport type {\n  SuspenseState,\n  SuspenseListRenderState,\n  SuspenseListTailMode,\n} from './ReactFiberSuspenseComponent';\nimport type {SuspenseContext} from './ReactFiberSuspenseContext';\n\nimport checkPropTypes from 'prop-types/checkPropTypes';\n\nimport {\n  IndeterminateComponent,\n  FunctionComponent,\n  ClassComponent,\n  HostRoot,\n  HostComponent,\n  HostText,\n  HostPortal,\n  ForwardRef,\n  Fragment,\n  Mode,\n  ContextProvider,\n  ContextConsumer,\n  Profiler,\n  SuspenseComponent,\n  SuspenseListComponent,\n  MemoComponent,\n  SimpleMemoComponent,\n  LazyComponent,\n  IncompleteClassComponent,\n  FundamentalComponent,\n  ScopeComponent,\n} from 'shared/ReactWorkTags';\nimport {\n  NoEffect,\n  PerformedWork,\n  Placement,\n  Hydrating,\n  ContentReset,\n  DidCapture,\n  Update,\n  Ref,\n  Deletion,\n} from 'shared/ReactSideEffectTags';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport {\n  debugRenderPhaseSideEffectsForStrictMode,\n  disableLegacyContext,\n  enableProfilerTimer,\n  enableSchedulerTracing,\n  enableSuspenseServerRenderer,\n  enableFundamentalAPI,\n  warnAboutDefaultPropsOnFunctionComponents,\n  enableScopeAPI,\n} from 'shared/ReactFeatureFlags';\nimport invariant from 'shared/invariant';\nimport shallowEqual from 'shared/shallowEqual';\nimport getComponentName from 'shared/getComponentName';\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings';\nimport {refineResolvedLazyComponent} from 'shared/ReactLazyComponent';\nimport {REACT_LAZY_TYPE, getIteratorFn} from 'shared/ReactSymbols';\nimport warning from 'shared/warning';\nimport warningWithoutStack from 'shared/warningWithoutStack';\nimport {\n  setCurrentPhase,\n  getCurrentFiberOwnerNameInDevOrNull,\n  getCurrentFiberStackInDev,\n} from './ReactCurrentFiber';\nimport {startWorkTimer, cancelWorkTimer} from './ReactDebugFiberPerf';\nimport {\n  resolveFunctionForHotReloading,\n  resolveForwardRefForHotReloading,\n  resolveClassForHotReloading,\n} from './ReactFiberHotReloading';\n\nimport {\n  mountChildFibers,\n  reconcileChildFibers,\n  cloneChildFibers,\n} from './ReactChildFiber';\nimport {processUpdateQueue} from './ReactUpdateQueue';\nimport {\n  NoWork,\n  Never,\n  Sync,\n  computeAsyncExpiration,\n} from './ReactFiberExpirationTime';\nimport {\n  ConcurrentMode,\n  NoMode,\n  ProfileMode,\n  StrictMode,\n  BlockingMode,\n} from './ReactTypeOfMode';\nimport {\n  shouldSetTextContent,\n  shouldDeprioritizeSubtree,\n  isSuspenseInstancePending,\n  isSuspenseInstanceFallback,\n  registerSuspenseInstanceRetry,\n} from './ReactFiberHostConfig';\nimport type {SuspenseInstance} from './ReactFiberHostConfig';\nimport {shouldSuspend} from './ReactFiberReconciler';\nimport {pushHostContext, pushHostContainer} from './ReactFiberHostContext';\nimport {\n  suspenseStackCursor,\n  pushSuspenseContext,\n  InvisibleParentSuspenseContext,\n  ForceSuspenseFallback,\n  hasSuspenseContext,\n  setDefaultShallowSuspenseContext,\n  addSubtreeSuspenseContext,\n  setShallowSuspenseContext,\n} from './ReactFiberSuspenseContext';\nimport {findFirstSuspended} from './ReactFiberSuspenseComponent';\nimport {\n  pushProvider,\n  propagateContextChange,\n  readContext,\n  prepareToReadContext,\n  calculateChangedBits,\n  scheduleWorkOnParentPath,\n} from './ReactFiberNewContext';\nimport {resetHooks, renderWithHooks, bailoutHooks} from './ReactFiberHooks';\nimport {stopProfilerTimerIfRunning} from './ReactProfilerTimer';\nimport {\n  getMaskedContext,\n  getUnmaskedContext,\n  hasContextChanged as hasLegacyContextChanged,\n  pushContextProvider as pushLegacyContextProvider,\n  isContextProvider as isLegacyContextProvider,\n  pushTopLevelContextObject,\n  invalidateContextProvider,\n} from './ReactFiberContext';\nimport {\n  enterHydrationState,\n  reenterHydrationStateFromDehydratedSuspenseInstance,\n  resetHydrationState,\n  tryToClaimNextHydratableInstance,\n  warnIfHydrating,\n} from './ReactFiberHydrationContext';\nimport {\n  adoptClassInstance,\n  applyDerivedStateFromProps,\n  constructClassInstance,\n  mountClassInstance,\n  resumeMountClassInstance,\n  updateClassInstance,\n} from './ReactFiberClassComponent';\nimport {\n  readLazyComponentType,\n  resolveDefaultProps,\n} from './ReactFiberLazyComponent';\nimport {\n  resolveLazyComponentTag,\n  createFiberFromTypeAndProps,\n  createFiberFromFragment,\n  createWorkInProgress,\n  isSimpleFunctionComponent,\n} from './ReactFiber';\nimport {\n  markSpawnedWork,\n  requestCurrentTimeForUpdate,\n  retryDehydratedSuspenseBoundary,\n  scheduleWork,\n  renderDidSuspendDelayIfPossible,\n  markUnprocessedUpdateTime,\n} from './ReactFiberWorkLoop';\n\nconst ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n\nlet didReceiveUpdate: boolean = false;\n\nlet didWarnAboutBadClass;\nlet didWarnAboutModulePatternComponent;\nlet didWarnAboutContextTypeOnFunctionComponent;\nlet didWarnAboutGetDerivedStateOnFunctionComponent;\nlet didWarnAboutFunctionRefs;\nexport let didWarnAboutReassigningProps;\nlet didWarnAboutMaxDuration;\nlet didWarnAboutRevealOrder;\nlet didWarnAboutTailOptions;\nlet didWarnAboutDefaultPropsOnFunctionComponent;\n\nif (__DEV__) {\n  didWarnAboutBadClass = {};\n  didWarnAboutModulePatternComponent = {};\n  didWarnAboutContextTypeOnFunctionComponent = {};\n  didWarnAboutGetDerivedStateOnFunctionComponent = {};\n  didWarnAboutFunctionRefs = {};\n  didWarnAboutReassigningProps = false;\n  didWarnAboutMaxDuration = false;\n  didWarnAboutRevealOrder = {};\n  didWarnAboutTailOptions = {};\n  didWarnAboutDefaultPropsOnFunctionComponent = {};\n}\n\nexport function reconcileChildren(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  nextChildren: any,\n  renderExpirationTime: ExpirationTime,\n) {\n  if (current === null) {\n    // If this is a fresh new component that hasn't been rendered yet, we\n    // won't update its child set by applying minimal side-effects. Instead,\n    // we will add them all to the child before it gets rendered. That means\n    // we can optimize this reconciliation pass by not tracking side-effects.\n    workInProgress.child = mountChildFibers(\n      workInProgress,\n      null,\n      nextChildren,\n      renderExpirationTime,\n    );\n  } else {\n    // If the current child is the same as the work in progress, it means that\n    // we haven't yet started any work on these children. Therefore, we use\n    // the clone algorithm to create a copy of all the current children.\n\n    // If we had any progressed work already, that is invalid at this point so\n    // let's throw it out.\n    workInProgress.child = reconcileChildFibers(\n      workInProgress,\n      current.child,\n      nextChildren,\n      renderExpirationTime,\n    );\n  }\n}\n\nfunction forceUnmountCurrentAndReconcile(\n  current: Fiber,\n  workInProgress: Fiber,\n  nextChildren: any,\n  renderExpirationTime: ExpirationTime,\n) {\n  // This function is fork of reconcileChildren. It's used in cases where we\n  // want to reconcile without matching against the existing set. This has the\n  // effect of all current children being unmounted; even if the type and key\n  // are the same, the old child is unmounted and a new child is created.\n  //\n  // To do this, we're going to go through the reconcile algorithm twice. In\n  // the first pass, we schedule a deletion for all the current children by\n  // passing null.\n  workInProgress.child = reconcileChildFibers(\n    workInProgress,\n    current.child,\n    null,\n    renderExpirationTime,\n  );\n  // In the second pass, we mount the new children. The trick here is that we\n  // pass null in place of where we usually pass the current child set. This has\n  // the effect of remounting all children regardless of whether their their\n  // identity matches.\n  workInProgress.child = reconcileChildFibers(\n    workInProgress,\n    null,\n    nextChildren,\n    renderExpirationTime,\n  );\n}\n\nfunction updateForwardRef(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  Component: any,\n  nextProps: any,\n  renderExpirationTime: ExpirationTime,\n) {\n  // TODO: current can be non-null here even if the component\n  // hasn't yet mounted. This happens after the first render suspends.\n  // We'll need to figure out if this is fine or can cause issues.\n\n  if (__DEV__) {\n    if (workInProgress.type !== workInProgress.elementType) {\n      // Lazy component props can't be validated in createElement\n      // because they're only guaranteed to be resolved here.\n      const innerPropTypes = Component.propTypes;\n      if (innerPropTypes) {\n        checkPropTypes(\n          innerPropTypes,\n          nextProps, // Resolved props\n          'prop',\n          getComponentName(Component),\n          getCurrentFiberStackInDev,\n        );\n      }\n    }\n  }\n\n  const render = Component.render;\n  const ref = workInProgress.ref;\n\n  // The rest is a fork of updateFunctionComponent\n  let nextChildren;\n  prepareToReadContext(workInProgress, renderExpirationTime);\n  if (__DEV__) {\n    ReactCurrentOwner.current = workInProgress;\n    setCurrentPhase('render');\n    nextChildren = renderWithHooks(\n      current,\n      workInProgress,\n      render,\n      nextProps,\n      ref,\n      renderExpirationTime,\n    );\n    if (\n      debugRenderPhaseSideEffectsForStrictMode &&\n      workInProgress.mode & StrictMode\n    ) {\n      // Only double-render components with Hooks\n      if (workInProgress.memoizedState !== null) {\n        nextChildren = renderWithHooks(\n          current,\n          workInProgress,\n          render,\n          nextProps,\n          ref,\n          renderExpirationTime,\n        );\n      }\n    }\n    setCurrentPhase(null);\n  } else {\n    nextChildren = renderWithHooks(\n      current,\n      workInProgress,\n      render,\n      nextProps,\n      ref,\n      renderExpirationTime,\n    );\n  }\n\n  if (current !== null && !didReceiveUpdate) {\n    bailoutHooks(current, workInProgress, renderExpirationTime);\n    return bailoutOnAlreadyFinishedWork(\n      current,\n      workInProgress,\n      renderExpirationTime,\n    );\n  }\n\n  // React DevTools reads this flag.\n  workInProgress.effectTag |= PerformedWork;\n  reconcileChildren(\n    current,\n    workInProgress,\n    nextChildren,\n    renderExpirationTime,\n  );\n  return workInProgress.child;\n}\n\nfunction updateMemoComponent(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  Component: any,\n  nextProps: any,\n  updateExpirationTime,\n  renderExpirationTime: ExpirationTime,\n): null | Fiber {\n  if (current === null) {\n    let type = Component.type;\n    if (\n      isSimpleFunctionComponent(type) &&\n      Component.compare === null &&\n      // SimpleMemoComponent codepath doesn't resolve outer props either.\n      Component.defaultProps === undefined\n    ) {\n      let resolvedType = type;\n      if (__DEV__) {\n        resolvedType = resolveFunctionForHotReloading(type);\n      }\n      // If this is a plain function component without default props,\n      // and with only the default shallow comparison, we upgrade it\n      // to a SimpleMemoComponent to allow fast path updates.\n      workInProgress.tag = SimpleMemoComponent;\n      workInProgress.type = resolvedType;\n      if (__DEV__) {\n        validateFunctionComponentInDev(workInProgress, type);\n      }\n      return updateSimpleMemoComponent(\n        current,\n        workInProgress,\n        resolvedType,\n        nextProps,\n        updateExpirationTime,\n        renderExpirationTime,\n      );\n    }\n    if (__DEV__) {\n      const innerPropTypes = type.propTypes;\n      if (innerPropTypes) {\n        // Inner memo component props aren't currently validated in createElement.\n        // We could move it there, but we'd still need this for lazy code path.\n        checkPropTypes(\n          innerPropTypes,\n          nextProps, // Resolved props\n          'prop',\n          getComponentName(type),\n          getCurrentFiberStackInDev,\n        );\n      }\n    }\n    let child = createFiberFromTypeAndProps(\n      Component.type,\n      null,\n      nextProps,\n      null,\n      workInProgress.mode,\n      renderExpirationTime,\n    );\n    child.ref = workInProgress.ref;\n    child.return = workInProgress;\n    workInProgress.child = child;\n    return child;\n  }\n  if (__DEV__) {\n    const type = Component.type;\n    const innerPropTypes = type.propTypes;\n    if (innerPropTypes) {\n      // Inner memo component props aren't currently validated in createElement.\n      // We could move it there, but we'd still need this for lazy code path.\n      checkPropTypes(\n        innerPropTypes,\n        nextProps, // Resolved props\n        'prop',\n        getComponentName(type),\n        getCurrentFiberStackInDev,\n      );\n    }\n  }\n  let currentChild = ((current.child: any): Fiber); // This is always exactly one child\n  if (updateExpirationTime < renderExpirationTime) {\n    // This will be the props with resolved defaultProps,\n    // unlike current.memoizedProps which will be the unresolved ones.\n    const prevProps = currentChild.memoizedProps;\n    // Default to shallow comparison\n    let compare = Component.compare;\n    compare = compare !== null ? compare : shallowEqual;\n    if (compare(prevProps, nextProps) && current.ref === workInProgress.ref) {\n      return bailoutOnAlreadyFinishedWork(\n        current,\n        workInProgress,\n        renderExpirationTime,\n      );\n    }\n  }\n  // React DevTools reads this flag.\n  workInProgress.effectTag |= PerformedWork;\n  let newChild = createWorkInProgress(\n    currentChild,\n    nextProps,\n    renderExpirationTime,\n  );\n  newChild.ref = workInProgress.ref;\n  newChild.return = workInProgress;\n  workInProgress.child = newChild;\n  return newChild;\n}\n\nfunction updateSimpleMemoComponent(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  Component: any,\n  nextProps: any,\n  updateExpirationTime,\n  renderExpirationTime: ExpirationTime,\n): null | Fiber {\n  // TODO: current can be non-null here even if the component\n  // hasn't yet mounted. This happens when the inner render suspends.\n  // We'll need to figure out if this is fine or can cause issues.\n\n  if (__DEV__) {\n    if (workInProgress.type !== workInProgress.elementType) {\n      // Lazy component props can't be validated in createElement\n      // because they're only guaranteed to be resolved here.\n      let outerMemoType = workInProgress.elementType;\n      if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {\n        // We warn when you define propTypes on lazy()\n        // so let's just skip over it to find memo() outer wrapper.\n        // Inner props for memo are validated later.\n        outerMemoType = refineResolvedLazyComponent(outerMemoType);\n      }\n      const outerPropTypes = outerMemoType && (outerMemoType: any).propTypes;\n      if (outerPropTypes) {\n        checkPropTypes(\n          outerPropTypes,\n          nextProps, // Resolved (SimpleMemoComponent has no defaultProps)\n          'prop',\n          getComponentName(outerMemoType),\n          getCurrentFiberStackInDev,\n        );\n      }\n      // Inner propTypes will be validated in the function component path.\n    }\n  }\n  if (current !== null) {\n    const prevProps = current.memoizedProps;\n    if (\n      shallowEqual(prevProps, nextProps) &&\n      current.ref === workInProgress.ref &&\n      // Prevent bailout if the implementation changed due to hot reload:\n      (__DEV__ ? workInProgress.type === current.type : true)\n    ) {\n      didReceiveUpdate = false;\n      if (updateExpirationTime < renderExpirationTime) {\n        return bailoutOnAlreadyFinishedWork(\n          current,\n          workInProgress,\n          renderExpirationTime,\n        );\n      }\n    }\n  }\n  return updateFunctionComponent(\n    current,\n    workInProgress,\n    Component,\n    nextProps,\n    renderExpirationTime,\n  );\n}\n\nfunction updateFragment(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderExpirationTime: ExpirationTime,\n) {\n  const nextChildren = workInProgress.pendingProps;\n  reconcileChildren(\n    current,\n    workInProgress,\n    nextChildren,\n    renderExpirationTime,\n  );\n  return workInProgress.child;\n}\n\nfunction updateMode(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderExpirationTime: ExpirationTime,\n) {\n  const nextChildren = workInProgress.pendingProps.children;\n  reconcileChildren(\n    current,\n    workInProgress,\n    nextChildren,\n    renderExpirationTime,\n  );\n  return workInProgress.child;\n}\n\nfunction updateProfiler(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderExpirationTime: ExpirationTime,\n) {\n  if (enableProfilerTimer) {\n    workInProgress.effectTag |= Update;\n  }\n  const nextProps = workInProgress.pendingProps;\n  const nextChildren = nextProps.children;\n  reconcileChildren(\n    current,\n    workInProgress,\n    nextChildren,\n    renderExpirationTime,\n  );\n  return workInProgress.child;\n}\n\nfunction markRef(current: Fiber | null, workInProgress: Fiber) {\n  const ref = workInProgress.ref;\n  if (\n    (current === null && ref !== null) ||\n    (current !== null && current.ref !== ref)\n  ) {\n    // Schedule a Ref effect\n    workInProgress.effectTag |= Ref;\n  }\n}\n\nfunction updateFunctionComponent(\n  current,\n  workInProgress,\n  Component,\n  nextProps: any,\n  renderExpirationTime,\n) {\n  if (__DEV__) {\n    if (workInProgress.type !== workInProgress.elementType) {\n      // Lazy component props can't be validated in createElement\n      // because they're only guaranteed to be resolved here.\n      const innerPropTypes = Component.propTypes;\n      if (innerPropTypes) {\n        checkPropTypes(\n          innerPropTypes,\n          nextProps, // Resolved props\n          'prop',\n          getComponentName(Component),\n          getCurrentFiberStackInDev,\n        );\n      }\n    }\n  }\n\n  let context;\n  if (!disableLegacyContext) {\n    const unmaskedContext = getUnmaskedContext(workInProgress, Component, true);\n    context = getMaskedContext(workInProgress, unmaskedContext);\n  }\n\n  let nextChildren;\n  prepareToReadContext(workInProgress, renderExpirationTime);\n  if (__DEV__) {\n    ReactCurrentOwner.current = workInProgress;\n    setCurrentPhase('render');\n    nextChildren = renderWithHooks(\n      current,\n      workInProgress,\n      Component,\n      nextProps,\n      context,\n      renderExpirationTime,\n    );\n    if (\n      debugRenderPhaseSideEffectsForStrictMode &&\n      workInProgress.mode & StrictMode\n    ) {\n      // Only double-render components with Hooks\n      if (workInProgress.memoizedState !== null) {\n        nextChildren = renderWithHooks(\n          current,\n          workInProgress,\n          Component,\n          nextProps,\n          context,\n          renderExpirationTime,\n        );\n      }\n    }\n    setCurrentPhase(null);\n  } else {\n    nextChildren = renderWithHooks(\n      current,\n      workInProgress,\n      Component,\n      nextProps,\n      context,\n      renderExpirationTime,\n    );\n  }\n\n  if (current !== null && !didReceiveUpdate) {\n    bailoutHooks(current, workInProgress, renderExpirationTime);\n    return bailoutOnAlreadyFinishedWork(\n      current,\n      workInProgress,\n      renderExpirationTime,\n    );\n  }\n\n  // React DevTools reads this flag.\n  workInProgress.effectTag |= PerformedWork;\n  reconcileChildren(\n    current,\n    workInProgress,\n    nextChildren,\n    renderExpirationTime,\n  );\n  return workInProgress.child;\n}\n\nfunction updateClassComponent(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  Component: any,\n  nextProps,\n  renderExpirationTime: ExpirationTime,\n) {\n  if (__DEV__) {\n    if (workInProgress.type !== workInProgress.elementType) {\n      // Lazy component props can't be validated in createElement\n      // because they're only guaranteed to be resolved here.\n      const innerPropTypes = Component.propTypes;\n      if (innerPropTypes) {\n        checkPropTypes(\n          innerPropTypes,\n          nextProps, // Resolved props\n          'prop',\n          getComponentName(Component),\n          getCurrentFiberStackInDev,\n        );\n      }\n    }\n  }\n\n  // Push context providers early to prevent context stack mismatches.\n  // During mounting we don't know the child context yet as the instance doesn't exist.\n  // We will invalidate the child context in finishClassComponent() right after rendering.\n  let hasContext;\n  if (isLegacyContextProvider(Component)) {\n    hasContext = true;\n    pushLegacyContextProvider(workInProgress);\n  } else {\n    hasContext = false;\n  }\n  prepareToReadContext(workInProgress, renderExpirationTime);\n\n  const instance = workInProgress.stateNode;\n  let shouldUpdate;\n  if (instance === null) {\n    if (current !== null) {\n      // An class component without an instance only mounts if it suspended\n      // inside a non- concurrent tree, in an inconsistent state. We want to\n      // tree it like a new mount, even though an empty version of it already\n      // committed. Disconnect the alternate pointers.\n      current.alternate = null;\n      workInProgress.alternate = null;\n      // Since this is conceptually a new fiber, schedule a Placement effect\n      workInProgress.effectTag |= Placement;\n    }\n    // In the initial pass we might need to construct the instance.\n    constructClassInstance(\n      workInProgress,\n      Component,\n      nextProps,\n      renderExpirationTime,\n    );\n    mountClassInstance(\n      workInProgress,\n      Component,\n      nextProps,\n      renderExpirationTime,\n    );\n    shouldUpdate = true;\n  } else if (current === null) {\n    // In a resume, we'll already have an instance we can reuse.\n    shouldUpdate = resumeMountClassInstance(\n      workInProgress,\n      Component,\n      nextProps,\n      renderExpirationTime,\n    );\n  } else {\n    shouldUpdate = updateClassInstance(\n      current,\n      workInProgress,\n      Component,\n      nextProps,\n      renderExpirationTime,\n    );\n  }\n  const nextUnitOfWork = finishClassComponent(\n    current,\n    workInProgress,\n    Component,\n    shouldUpdate,\n    hasContext,\n    renderExpirationTime,\n  );\n  if (__DEV__) {\n    let inst = workInProgress.stateNode;\n    if (inst.props !== nextProps) {\n      warning(\n        didWarnAboutReassigningProps,\n        'It looks like %s is reassigning its own `this.props` while rendering. ' +\n          'This is not supported and can lead to confusing bugs.',\n        getComponentName(workInProgress.type) || 'a component',\n      );\n      didWarnAboutReassigningProps = true;\n    }\n  }\n  return nextUnitOfWork;\n}\n\nfunction finishClassComponent(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  Component: any,\n  shouldUpdate: boolean,\n  hasContext: boolean,\n  renderExpirationTime: ExpirationTime,\n) {\n  // Refs should update even if shouldComponentUpdate returns false\n  markRef(current, workInProgress);\n\n  const didCaptureError = (workInProgress.effectTag & DidCapture) !== NoEffect;\n\n  if (!shouldUpdate && !didCaptureError) {\n    // Context providers should defer to sCU for rendering\n    if (hasContext) {\n      invalidateContextProvider(workInProgress, Component, false);\n    }\n\n    return bailoutOnAlreadyFinishedWork(\n      current,\n      workInProgress,\n      renderExpirationTime,\n    );\n  }\n\n  const instance = workInProgress.stateNode;\n\n  // Rerender\n  ReactCurrentOwner.current = workInProgress;\n  let nextChildren;\n  if (\n    didCaptureError &&\n    typeof Component.getDerivedStateFromError !== 'function'\n  ) {\n    // If we captured an error, but getDerivedStateFrom catch is not defined,\n    // unmount all the children. componentDidCatch will schedule an update to\n    // re-render a fallback. This is temporary until we migrate everyone to\n    // the new API.\n    // TODO: Warn in a future release.\n    nextChildren = null;\n\n    if (enableProfilerTimer) {\n      stopProfilerTimerIfRunning(workInProgress);\n    }\n  } else {\n    if (__DEV__) {\n      setCurrentPhase('render');\n      nextChildren = instance.render();\n      if (\n        debugRenderPhaseSideEffectsForStrictMode &&\n        workInProgress.mode & StrictMode\n      ) {\n        instance.render();\n      }\n      setCurrentPhase(null);\n    } else {\n      nextChildren = instance.render();\n    }\n  }\n\n  // React DevTools reads this flag.\n  workInProgress.effectTag |= PerformedWork;\n  if (current !== null && didCaptureError) {\n    // If we're recovering from an error, reconcile without reusing any of\n    // the existing children. Conceptually, the normal children and the children\n    // that are shown on error are two different sets, so we shouldn't reuse\n    // normal children even if their identities match.\n    forceUnmountCurrentAndReconcile(\n      current,\n      workInProgress,\n      nextChildren,\n      renderExpirationTime,\n    );\n  } else {\n    reconcileChildren(\n      current,\n      workInProgress,\n      nextChildren,\n      renderExpirationTime,\n    );\n  }\n\n  // Memoize state using the values we just used to render.\n  // TODO: Restructure so we never read values from the instance.\n  workInProgress.memoizedState = instance.state;\n\n  // The context might have changed so we need to recalculate it.\n  if (hasContext) {\n    invalidateContextProvider(workInProgress, Component, true);\n  }\n\n  return workInProgress.child;\n}\n\nfunction pushHostRootContext(workInProgress) {\n  const root = (workInProgress.stateNode: FiberRoot);\n  if (root.pendingContext) {\n    pushTopLevelContextObject(\n      workInProgress,\n      root.pendingContext,\n      root.pendingContext !== root.context,\n    );\n  } else if (root.context) {\n    // Should always be set\n    pushTopLevelContextObject(workInProgress, root.context, false);\n  }\n  pushHostContainer(workInProgress, root.containerInfo);\n}\n\nfunction updateHostRoot(current, workInProgress, renderExpirationTime) {\n  pushHostRootContext(workInProgress);\n  const updateQueue = workInProgress.updateQueue;\n  invariant(\n    updateQueue !== null,\n    'If the root does not have an updateQueue, we should have already ' +\n      'bailed out. This error is likely caused by a bug in React. Please ' +\n      'file an issue.',\n  );\n  const nextProps = workInProgress.pendingProps;\n  const prevState = workInProgress.memoizedState;\n  const prevChildren = prevState !== null ? prevState.element : null;\n  processUpdateQueue(\n    workInProgress,\n    updateQueue,\n    nextProps,\n    null,\n    renderExpirationTime,\n  );\n  const nextState = workInProgress.memoizedState;\n  // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n  const nextChildren = nextState.element;\n  if (nextChildren === prevChildren) {\n    // If the state is the same as before, that's a bailout because we had\n    // no work that expires at this time.\n    resetHydrationState();\n    return bailoutOnAlreadyFinishedWork(\n      current,\n      workInProgress,\n      renderExpirationTime,\n    );\n  }\n  const root: FiberRoot = workInProgress.stateNode;\n  if (root.hydrate && enterHydrationState(workInProgress)) {\n    // If we don't have any current children this might be the first pass.\n    // We always try to hydrate. If this isn't a hydration pass there won't\n    // be any children to hydrate which is effectively the same thing as\n    // not hydrating.\n\n    let child = mountChildFibers(\n      workInProgress,\n      null,\n      nextChildren,\n      renderExpirationTime,\n    );\n    workInProgress.child = child;\n\n    let node = child;\n    while (node) {\n      // Mark each child as hydrating. This is a fast path to know whether this\n      // tree is part of a hydrating tree. This is used to determine if a child\n      // node has fully mounted yet, and for scheduling event replaying.\n      // Conceptually this is similar to Placement in that a new subtree is\n      // inserted into the React tree here. It just happens to not need DOM\n      // mutations because it already exists.\n      node.effectTag = (node.effectTag & ~Placement) | Hydrating;\n      node = node.sibling;\n    }\n  } else {\n    // Otherwise reset hydration state in case we aborted and resumed another\n    // root.\n    reconcileChildren(\n      current,\n      workInProgress,\n      nextChildren,\n      renderExpirationTime,\n    );\n    resetHydrationState();\n  }\n  return workInProgress.child;\n}\n\nfunction updateHostComponent(current, workInProgress, renderExpirationTime) {\n  pushHostContext(workInProgress);\n\n  if (current === null) {\n    tryToClaimNextHydratableInstance(workInProgress);\n  }\n\n  const type = workInProgress.type;\n  const nextProps = workInProgress.pendingProps;\n  const prevProps = current !== null ? current.memoizedProps : null;\n\n  let nextChildren = nextProps.children;\n  const isDirectTextChild = shouldSetTextContent(type, nextProps);\n\n  if (isDirectTextChild) {\n    // We special case a direct text child of a host node. This is a common\n    // case. We won't handle it as a reified child. We will instead handle\n    // this in the host environment that also have access to this prop. That\n    // avoids allocating another HostText fiber and traversing it.\n    nextChildren = null;\n  } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {\n    // If we're switching from a direct text child to a normal child, or to\n    // empty, we need to schedule the text content to be reset.\n    workInProgress.effectTag |= ContentReset;\n  }\n\n  markRef(current, workInProgress);\n\n  // Check the host config to see if the children are offscreen/hidden.\n  if (\n    workInProgress.mode & ConcurrentMode &&\n    renderExpirationTime !== Never &&\n    shouldDeprioritizeSubtree(type, nextProps)\n  ) {\n    if (enableSchedulerTracing) {\n      markSpawnedWork(Never);\n    }\n    // Schedule this fiber to re-render at offscreen priority. Then bailout.\n    workInProgress.expirationTime = workInProgress.childExpirationTime = Never;\n    return null;\n  }\n\n  reconcileChildren(\n    current,\n    workInProgress,\n    nextChildren,\n    renderExpirationTime,\n  );\n  return workInProgress.child;\n}\n\nfunction updateHostText(current, workInProgress) {\n  if (current === null) {\n    tryToClaimNextHydratableInstance(workInProgress);\n  }\n  // Nothing to do here. This is terminal. We'll do the completion step\n  // immediately after.\n  return null;\n}\n\nfunction mountLazyComponent(\n  _current,\n  workInProgress,\n  elementType,\n  updateExpirationTime,\n  renderExpirationTime,\n) {\n  if (_current !== null) {\n    // An lazy component only mounts if it suspended inside a non-\n    // concurrent tree, in an inconsistent state. We want to treat it like\n    // a new mount, even though an empty version of it already committed.\n    // Disconnect the alternate pointers.\n    _current.alternate = null;\n    workInProgress.alternate = null;\n    // Since this is conceptually a new fiber, schedule a Placement effect\n    workInProgress.effectTag |= Placement;\n  }\n\n  const props = workInProgress.pendingProps;\n  // We can't start a User Timing measurement with correct label yet.\n  // Cancel and resume right after we know the tag.\n  cancelWorkTimer(workInProgress);\n  let Component = readLazyComponentType(elementType);\n  // Store the unwrapped component in the type.\n  workInProgress.type = Component;\n  const resolvedTag = (workInProgress.tag = resolveLazyComponentTag(Component));\n  startWorkTimer(workInProgress);\n  const resolvedProps = resolveDefaultProps(Component, props);\n  let child;\n  switch (resolvedTag) {\n    case FunctionComponent: {\n      if (__DEV__) {\n        validateFunctionComponentInDev(workInProgress, Component);\n        workInProgress.type = Component = resolveFunctionForHotReloading(\n          Component,\n        );\n      }\n      child = updateFunctionComponent(\n        null,\n        workInProgress,\n        Component,\n        resolvedProps,\n        renderExpirationTime,\n      );\n      break;\n    }\n    case ClassComponent: {\n      if (__DEV__) {\n        workInProgress.type = Component = resolveClassForHotReloading(\n          Component,\n        );\n      }\n      child = updateClassComponent(\n        null,\n        workInProgress,\n        Component,\n        resolvedProps,\n        renderExpirationTime,\n      );\n      break;\n    }\n    case ForwardRef: {\n      if (__DEV__) {\n        workInProgress.type = Component = resolveForwardRefForHotReloading(\n          Component,\n        );\n      }\n      child = updateForwardRef(\n        null,\n        workInProgress,\n        Component,\n        resolvedProps,\n        renderExpirationTime,\n      );\n      break;\n    }\n    case MemoComponent: {\n      if (__DEV__) {\n        if (workInProgress.type !== workInProgress.elementType) {\n          const outerPropTypes = Component.propTypes;\n          if (outerPropTypes) {\n            checkPropTypes(\n              outerPropTypes,\n              resolvedProps, // Resolved for outer only\n              'prop',\n              getComponentName(Component),\n              getCurrentFiberStackInDev,\n            );\n          }\n        }\n      }\n      child = updateMemoComponent(\n        null,\n        workInProgress,\n        Component,\n        resolveDefaultProps(Component.type, resolvedProps), // The inner type can have defaults too\n        updateExpirationTime,\n        renderExpirationTime,\n      );\n      break;\n    }\n    default: {\n      let hint = '';\n      if (__DEV__) {\n        if (\n          Component !== null &&\n          typeof Component === 'object' &&\n          Component.$$typeof === REACT_LAZY_TYPE\n        ) {\n          hint = ' Did you wrap a component in React.lazy() more than once?';\n        }\n      }\n      // This message intentionally doesn't mention ForwardRef or MemoComponent\n      // because the fact that it's a separate type of work is an\n      // implementation detail.\n      invariant(\n        false,\n        'Element type is invalid. Received a promise that resolves to: %s. ' +\n          'Lazy element type must resolve to a class or function.%s',\n        Component,\n        hint,\n      );\n    }\n  }\n  return child;\n}\n\nfunction mountIncompleteClassComponent(\n  _current,\n  workInProgress,\n  Component,\n  nextProps,\n  renderExpirationTime,\n) {\n  if (_current !== null) {\n    // An incomplete component only mounts if it suspended inside a non-\n    // concurrent tree, in an inconsistent state. We want to treat it like\n    // a new mount, even though an empty version of it already committed.\n    // Disconnect the alternate pointers.\n    _current.alternate = null;\n    workInProgress.alternate = null;\n    // Since this is conceptually a new fiber, schedule a Placement effect\n    workInProgress.effectTag |= Placement;\n  }\n\n  // Promote the fiber to a class and try rendering again.\n  workInProgress.tag = ClassComponent;\n\n  // The rest of this function is a fork of `updateClassComponent`\n\n  // Push context providers early to prevent context stack mismatches.\n  // During mounting we don't know the child context yet as the instance doesn't exist.\n  // We will invalidate the child context in finishClassComponent() right after rendering.\n  let hasContext;\n  if (isLegacyContextProvider(Component)) {\n    hasContext = true;\n    pushLegacyContextProvider(workInProgress);\n  } else {\n    hasContext = false;\n  }\n  prepareToReadContext(workInProgress, renderExpirationTime);\n\n  constructClassInstance(\n    workInProgress,\n    Component,\n    nextProps,\n    renderExpirationTime,\n  );\n  mountClassInstance(\n    workInProgress,\n    Component,\n    nextProps,\n    renderExpirationTime,\n  );\n\n  return finishClassComponent(\n    null,\n    workInProgress,\n    Component,\n    true,\n    hasContext,\n    renderExpirationTime,\n  );\n}\n\nfunction mountIndeterminateComponent(\n  _current,\n  workInProgress,\n  Component,\n  renderExpirationTime,\n) {\n  if (_current !== null) {\n    // An indeterminate component only mounts if it suspended inside a non-\n    // concurrent tree, in an inconsistent state. We want to treat it like\n    // a new mount, even though an empty version of it already committed.\n    // Disconnect the alternate pointers.\n    _current.alternate = null;\n    workInProgress.alternate = null;\n    // Since this is conceptually a new fiber, schedule a Placement effect\n    workInProgress.effectTag |= Placement;\n  }\n\n  const props = workInProgress.pendingProps;\n  let context;\n  if (!disableLegacyContext) {\n    const unmaskedContext = getUnmaskedContext(\n      workInProgress,\n      Component,\n      false,\n    );\n    context = getMaskedContext(workInProgress, unmaskedContext);\n  }\n\n  prepareToReadContext(workInProgress, renderExpirationTime);\n  let value;\n\n  if (__DEV__) {\n    if (\n      Component.prototype &&\n      typeof Component.prototype.render === 'function'\n    ) {\n      const componentName = getComponentName(Component) || 'Unknown';\n\n      if (!didWarnAboutBadClass[componentName]) {\n        warningWithoutStack(\n          false,\n          \"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" +\n            'This is likely to cause errors. Change %s to extend React.Component instead.',\n          componentName,\n          componentName,\n        );\n        didWarnAboutBadClass[componentName] = true;\n      }\n    }\n\n    if (workInProgress.mode & StrictMode) {\n      ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);\n    }\n\n    ReactCurrentOwner.current = workInProgress;\n    value = renderWithHooks(\n      null,\n      workInProgress,\n      Component,\n      props,\n      context,\n      renderExpirationTime,\n    );\n  } else {\n    value = renderWithHooks(\n      null,\n      workInProgress,\n      Component,\n      props,\n      context,\n      renderExpirationTime,\n    );\n  }\n  // React DevTools reads this flag.\n  workInProgress.effectTag |= PerformedWork;\n\n  if (\n    typeof value === 'object' &&\n    value !== null &&\n    typeof value.render === 'function' &&\n    value.$$typeof === undefined\n  ) {\n    if (__DEV__) {\n      const componentName = getComponentName(Component) || 'Unknown';\n      if (!didWarnAboutModulePatternComponent[componentName]) {\n        warningWithoutStack(\n          false,\n          'The <%s /> component appears to be a function component that returns a class instance. ' +\n            'Change %s to a class that extends React.Component instead. ' +\n            \"If you can't use a class try assigning the prototype on the function as a workaround. \" +\n            \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" +\n            'cannot be called with `new` by React.',\n          componentName,\n          componentName,\n          componentName,\n        );\n        didWarnAboutModulePatternComponent[componentName] = true;\n      }\n    }\n\n    // Proceed under the assumption that this is a class instance\n    workInProgress.tag = ClassComponent;\n\n    // Throw out any hooks that were used.\n    resetHooks();\n\n    // Push context providers early to prevent context stack mismatches.\n    // During mounting we don't know the child context yet as the instance doesn't exist.\n    // We will invalidate the child context in finishClassComponent() right after rendering.\n    let hasContext = false;\n    if (isLegacyContextProvider(Component)) {\n      hasContext = true;\n      pushLegacyContextProvider(workInProgress);\n    } else {\n      hasContext = false;\n    }\n\n    workInProgress.memoizedState =\n      value.state !== null && value.state !== undefined ? value.state : null;\n\n    const getDerivedStateFromProps = Component.getDerivedStateFromProps;\n    if (typeof getDerivedStateFromProps === 'function') {\n      applyDerivedStateFromProps(\n        workInProgress,\n        Component,\n        getDerivedStateFromProps,\n        props,\n      );\n    }\n\n    adoptClassInstance(workInProgress, value);\n    mountClassInstance(workInProgress, Component, props, renderExpirationTime);\n    return finishClassComponent(\n      null,\n      workInProgress,\n      Component,\n      true,\n      hasContext,\n      renderExpirationTime,\n    );\n  } else {\n    // Proceed under the assumption that this is a function component\n    workInProgress.tag = FunctionComponent;\n    if (__DEV__) {\n      if (disableLegacyContext && Component.contextTypes) {\n        warningWithoutStack(\n          false,\n          '%s uses the legacy contextTypes API which is no longer supported. ' +\n            'Use React.createContext() with React.useContext() instead.',\n          getComponentName(Component) || 'Unknown',\n        );\n      }\n\n      if (\n        debugRenderPhaseSideEffectsForStrictMode &&\n        workInProgress.mode & StrictMode\n      ) {\n        // Only double-render components with Hooks\n        if (workInProgress.memoizedState !== null) {\n          value = renderWithHooks(\n            null,\n            workInProgress,\n            Component,\n            props,\n            context,\n            renderExpirationTime,\n          );\n        }\n      }\n    }\n    reconcileChildren(null, workInProgress, value, renderExpirationTime);\n    if (__DEV__) {\n      validateFunctionComponentInDev(workInProgress, Component);\n    }\n    return workInProgress.child;\n  }\n}\n\nfunction validateFunctionComponentInDev(workInProgress: Fiber, Component: any) {\n  if (Component) {\n    warningWithoutStack(\n      !Component.childContextTypes,\n      '%s(...): childContextTypes cannot be defined on a function component.',\n      Component.displayName || Component.name || 'Component',\n    );\n  }\n  if (workInProgress.ref !== null) {\n    let info = '';\n    const ownerName = getCurrentFiberOwnerNameInDevOrNull();\n    if (ownerName) {\n      info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n    }\n\n    let warningKey = ownerName || workInProgress._debugID || '';\n    const debugSource = workInProgress._debugSource;\n    if (debugSource) {\n      warningKey = debugSource.fileName + ':' + debugSource.lineNumber;\n    }\n    if (!didWarnAboutFunctionRefs[warningKey]) {\n      didWarnAboutFunctionRefs[warningKey] = true;\n      warning(\n        false,\n        'Function components cannot be given refs. ' +\n          'Attempts to access this ref will fail. ' +\n          'Did you mean to use React.forwardRef()?%s',\n        info,\n      );\n    }\n  }\n\n  if (\n    warnAboutDefaultPropsOnFunctionComponents &&\n    Component.defaultProps !== undefined\n  ) {\n    const componentName = getComponentName(Component) || 'Unknown';\n\n    if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {\n      warningWithoutStack(\n        false,\n        '%s: Support for defaultProps will be removed from function components ' +\n          'in a future major release. Use JavaScript default parameters instead.',\n        componentName,\n      );\n      didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;\n    }\n  }\n\n  if (typeof Component.getDerivedStateFromProps === 'function') {\n    const componentName = getComponentName(Component) || 'Unknown';\n\n    if (!didWarnAboutGetDerivedStateOnFunctionComponent[componentName]) {\n      warningWithoutStack(\n        false,\n        '%s: Function components do not support getDerivedStateFromProps.',\n        componentName,\n      );\n      didWarnAboutGetDerivedStateOnFunctionComponent[componentName] = true;\n    }\n  }\n\n  if (\n    typeof Component.contextType === 'object' &&\n    Component.contextType !== null\n  ) {\n    const componentName = getComponentName(Component) || 'Unknown';\n\n    if (!didWarnAboutContextTypeOnFunctionComponent[componentName]) {\n      warningWithoutStack(\n        false,\n        '%s: Function components do not support contextType.',\n        componentName,\n      );\n      didWarnAboutContextTypeOnFunctionComponent[componentName] = true;\n    }\n  }\n}\n\nconst SUSPENDED_MARKER: SuspenseState = {\n  dehydrated: null,\n  retryTime: NoWork,\n};\n\nfunction shouldRemainOnFallback(\n  suspenseContext: SuspenseContext,\n  current: null | Fiber,\n  workInProgress: Fiber,\n) {\n  // If the context is telling us that we should show a fallback, and we're not\n  // already showing content, then we should show the fallback instead.\n  return (\n    hasSuspenseContext(\n      suspenseContext,\n      (ForceSuspenseFallback: SuspenseContext),\n    ) &&\n    (current === null || current.memoizedState !== null)\n  );\n}\n\nfunction updateSuspenseComponent(\n  current,\n  workInProgress,\n  renderExpirationTime,\n) {\n  const mode = workInProgress.mode;\n  const nextProps = workInProgress.pendingProps;\n\n  // This is used by DevTools to force a boundary to suspend.\n  if (__DEV__) {\n    if (shouldSuspend(workInProgress)) {\n      workInProgress.effectTag |= DidCapture;\n    }\n  }\n\n  let suspenseContext: SuspenseContext = suspenseStackCursor.current;\n\n  let nextDidTimeout = false;\n  const didSuspend = (workInProgress.effectTag & DidCapture) !== NoEffect;\n\n  if (\n    didSuspend ||\n    shouldRemainOnFallback(suspenseContext, current, workInProgress)\n  ) {\n    // Something in this boundary's subtree already suspended. Switch to\n    // rendering the fallback children.\n    nextDidTimeout = true;\n    workInProgress.effectTag &= ~DidCapture;\n  } else {\n    // Attempting the main content\n    if (\n      current === null ||\n      (current.memoizedState: null | SuspenseState) !== null\n    ) {\n      // This is a new mount or this boundary is already showing a fallback state.\n      // Mark this subtree context as having at least one invisible parent that could\n      // handle the fallback state.\n      // Boundaries without fallbacks or should be avoided are not considered since\n      // they cannot handle preferred fallback states.\n      if (\n        nextProps.fallback !== undefined &&\n        nextProps.unstable_avoidThisFallback !== true\n      ) {\n        suspenseContext = addSubtreeSuspenseContext(\n          suspenseContext,\n          InvisibleParentSuspenseContext,\n        );\n      }\n    }\n  }\n\n  suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n\n  pushSuspenseContext(workInProgress, suspenseContext);\n\n  if (__DEV__) {\n    if ('maxDuration' in nextProps) {\n      if (!didWarnAboutMaxDuration) {\n        didWarnAboutMaxDuration = true;\n        warning(\n          false,\n          'maxDuration has been removed from React. ' +\n            'Remove the maxDuration prop.',\n        );\n      }\n    }\n  }\n\n  // This next part is a bit confusing. If the children timeout, we switch to\n  // showing the fallback children in place of the \"primary\" children.\n  // However, we don't want to delete the primary children because then their\n  // state will be lost (both the React state and the host state, e.g.\n  // uncontrolled form inputs). Instead we keep them mounted and hide them.\n  // Both the fallback children AND the primary children are rendered at the\n  // same time. Once the primary children are un-suspended, we can delete\n  // the fallback children — don't need to preserve their state.\n  //\n  // The two sets of children are siblings in the host environment, but\n  // semantically, for purposes of reconciliation, they are two separate sets.\n  // So we store them using two fragment fibers.\n  //\n  // However, we want to avoid allocating extra fibers for every placeholder.\n  // They're only necessary when the children time out, because that's the\n  // only time when both sets are mounted.\n  //\n  // So, the extra fragment fibers are only used if the children time out.\n  // Otherwise, we render the primary children directly. This requires some\n  // custom reconciliation logic to preserve the state of the primary\n  // children. It's essentially a very basic form of re-parenting.\n\n  if (current === null) {\n    // If we're currently hydrating, try to hydrate this boundary.\n    // But only if this has a fallback.\n    if (nextProps.fallback !== undefined) {\n      tryToClaimNextHydratableInstance(workInProgress);\n      // This could've been a dehydrated suspense component.\n      if (enableSuspenseServerRenderer) {\n        const suspenseState: null | SuspenseState =\n          workInProgress.memoizedState;\n        if (suspenseState !== null) {\n          const dehydrated = suspenseState.dehydrated;\n          if (dehydrated !== null) {\n            return mountDehydratedSuspenseComponent(\n              workInProgress,\n              dehydrated,\n              renderExpirationTime,\n            );\n          }\n        }\n      }\n    }\n\n    // This is the initial mount. This branch is pretty simple because there's\n    // no previous state that needs to be preserved.\n    if (nextDidTimeout) {\n      // Mount separate fragments for primary and fallback children.\n      const nextFallbackChildren = nextProps.fallback;\n      const primaryChildFragment = createFiberFromFragment(\n        null,\n        mode,\n        NoWork,\n        null,\n      );\n      primaryChildFragment.return = workInProgress;\n\n      if ((workInProgress.mode & BlockingMode) === NoMode) {\n        // Outside of blocking mode, we commit the effects from the\n        // partially completed, timed-out tree, too.\n        const progressedState: SuspenseState = workInProgress.memoizedState;\n        const progressedPrimaryChild: Fiber | null =\n          progressedState !== null\n            ? (workInProgress.child: any).child\n            : (workInProgress.child: any);\n        primaryChildFragment.child = progressedPrimaryChild;\n        let progressedChild = progressedPrimaryChild;\n        while (progressedChild !== null) {\n          progressedChild.return = primaryChildFragment;\n          progressedChild = progressedChild.sibling;\n        }\n      }\n\n      const fallbackChildFragment = createFiberFromFragment(\n        nextFallbackChildren,\n        mode,\n        renderExpirationTime,\n        null,\n      );\n      fallbackChildFragment.return = workInProgress;\n      primaryChildFragment.sibling = fallbackChildFragment;\n      // Skip the primary children, and continue working on the\n      // fallback children.\n      workInProgress.memoizedState = SUSPENDED_MARKER;\n      workInProgress.child = primaryChildFragment;\n      return fallbackChildFragment;\n    } else {\n      // Mount the primary children without an intermediate fragment fiber.\n      const nextPrimaryChildren = nextProps.children;\n      workInProgress.memoizedState = null;\n      return (workInProgress.child = mountChildFibers(\n        workInProgress,\n        null,\n        nextPrimaryChildren,\n        renderExpirationTime,\n      ));\n    }\n  } else {\n    // This is an update. This branch is more complicated because we need to\n    // ensure the state of the primary children is preserved.\n    const prevState: null | SuspenseState = current.memoizedState;\n    if (prevState !== null) {\n      if (enableSuspenseServerRenderer) {\n        const dehydrated = prevState.dehydrated;\n        if (dehydrated !== null) {\n          if (!didSuspend) {\n            return updateDehydratedSuspenseComponent(\n              current,\n              workInProgress,\n              dehydrated,\n              prevState,\n              renderExpirationTime,\n            );\n          } else if (\n            (workInProgress.memoizedState: null | SuspenseState) !== null\n          ) {\n            // Something suspended and we should still be in dehydrated mode.\n            // Leave the existing child in place.\n            workInProgress.child = current.child;\n            // The dehydrated completion pass expects this flag to be there\n            // but the normal suspense pass doesn't.\n            workInProgress.effectTag |= DidCapture;\n            return null;\n          } else {\n            // Suspended but we should no longer be in dehydrated mode.\n            // Therefore we now have to render the fallback. Wrap the children\n            // in a fragment fiber to keep them separate from the fallback\n            // children.\n            const nextFallbackChildren = nextProps.fallback;\n            const primaryChildFragment = createFiberFromFragment(\n              // It shouldn't matter what the pending props are because we aren't\n              // going to render this fragment.\n              null,\n              mode,\n              NoWork,\n              null,\n            );\n            primaryChildFragment.return = workInProgress;\n\n            // This is always null since we never want the previous child\n            // that we're not going to hydrate.\n            primaryChildFragment.child = null;\n\n            if ((workInProgress.mode & BlockingMode) === NoMode) {\n              // Outside of blocking mode, we commit the effects from the\n              // partially completed, timed-out tree, too.\n              let progressedChild = (primaryChildFragment.child =\n                workInProgress.child);\n              while (progressedChild !== null) {\n                progressedChild.return = primaryChildFragment;\n                progressedChild = progressedChild.sibling;\n              }\n            } else {\n              // We will have dropped the effect list which contains the deletion.\n              // We need to reconcile to delete the current child.\n              reconcileChildFibers(\n                workInProgress,\n                current.child,\n                null,\n                renderExpirationTime,\n              );\n            }\n\n            // Because primaryChildFragment is a new fiber that we're inserting as the\n            // parent of a new tree, we need to set its treeBaseDuration.\n            if (enableProfilerTimer && workInProgress.mode & ProfileMode) {\n              // treeBaseDuration is the sum of all the child tree base durations.\n              let treeBaseDuration = 0;\n              let hiddenChild = primaryChildFragment.child;\n              while (hiddenChild !== null) {\n                treeBaseDuration += hiddenChild.treeBaseDuration;\n                hiddenChild = hiddenChild.sibling;\n              }\n              primaryChildFragment.treeBaseDuration = treeBaseDuration;\n            }\n\n            // Create a fragment from the fallback children, too.\n            const fallbackChildFragment = createFiberFromFragment(\n              nextFallbackChildren,\n              mode,\n              renderExpirationTime,\n              null,\n            );\n            fallbackChildFragment.return = workInProgress;\n            primaryChildFragment.sibling = fallbackChildFragment;\n            fallbackChildFragment.effectTag |= Placement;\n            primaryChildFragment.childExpirationTime = NoWork;\n\n            workInProgress.memoizedState = SUSPENDED_MARKER;\n            workInProgress.child = primaryChildFragment;\n\n            // Skip the primary children, and continue working on the\n            // fallback children.\n            return fallbackChildFragment;\n          }\n        }\n      }\n      // The current tree already timed out. That means each child set is\n      // wrapped in a fragment fiber.\n      const currentPrimaryChildFragment: Fiber = (current.child: any);\n      const currentFallbackChildFragment: Fiber = (currentPrimaryChildFragment.sibling: any);\n      if (nextDidTimeout) {\n        // Still timed out. Reuse the current primary children by cloning\n        // its fragment. We're going to skip over these entirely.\n        const nextFallbackChildren = nextProps.fallback;\n        const primaryChildFragment = createWorkInProgress(\n          currentPrimaryChildFragment,\n          currentPrimaryChildFragment.pendingProps,\n          NoWork,\n        );\n        primaryChildFragment.return = workInProgress;\n\n        if ((workInProgress.mode & BlockingMode) === NoMode) {\n          // Outside of blocking mode, we commit the effects from the\n          // partially completed, timed-out tree, too.\n          const progressedState: SuspenseState = workInProgress.memoizedState;\n          const progressedPrimaryChild: Fiber | null =\n            progressedState !== null\n              ? (workInProgress.child: any).child\n              : (workInProgress.child: any);\n          if (progressedPrimaryChild !== currentPrimaryChildFragment.child) {\n            primaryChildFragment.child = progressedPrimaryChild;\n            let progressedChild = progressedPrimaryChild;\n            while (progressedChild !== null) {\n              progressedChild.return = primaryChildFragment;\n              progressedChild = progressedChild.sibling;\n            }\n          }\n        }\n\n        // Because primaryChildFragment is a new fiber that we're inserting as the\n        // parent of a new tree, we need to set its treeBaseDuration.\n        if (enableProfilerTimer && workInProgress.mode & ProfileMode) {\n          // treeBaseDuration is the sum of all the child tree base durations.\n          let treeBaseDuration = 0;\n          let hiddenChild = primaryChildFragment.child;\n          while (hiddenChild !== null) {\n            treeBaseDuration += hiddenChild.treeBaseDuration;\n            hiddenChild = hiddenChild.sibling;\n          }\n          primaryChildFragment.treeBaseDuration = treeBaseDuration;\n        }\n\n        // Clone the fallback child fragment, too. These we'll continue\n        // working on.\n        const fallbackChildFragment = createWorkInProgress(\n          currentFallbackChildFragment,\n          nextFallbackChildren,\n          currentFallbackChildFragment.expirationTime,\n        );\n        fallbackChildFragment.return = workInProgress;\n        primaryChildFragment.sibling = fallbackChildFragment;\n        primaryChildFragment.childExpirationTime = NoWork;\n        // Skip the primary children, and continue working on the\n        // fallback children.\n        workInProgress.memoizedState = SUSPENDED_MARKER;\n        workInProgress.child = primaryChildFragment;\n        return fallbackChildFragment;\n      } else {\n        // No longer suspended. Switch back to showing the primary children,\n        // and remove the intermediate fragment fiber.\n        const nextPrimaryChildren = nextProps.children;\n        const currentPrimaryChild = currentPrimaryChildFragment.child;\n        const primaryChild = reconcileChildFibers(\n          workInProgress,\n          currentPrimaryChild,\n          nextPrimaryChildren,\n          renderExpirationTime,\n        );\n\n        // If this render doesn't suspend, we need to delete the fallback\n        // children. Wait until the complete phase, after we've confirmed the\n        // fallback is no longer needed.\n        // TODO: Would it be better to store the fallback fragment on\n        // the stateNode?\n\n        // Continue rendering the children, like we normally do.\n        workInProgress.memoizedState = null;\n        return (workInProgress.child = primaryChild);\n      }\n    } else {\n      // The current tree has not already timed out. That means the primary\n      // children are not wrapped in a fragment fiber.\n      const currentPrimaryChild = current.child;\n      if (nextDidTimeout) {\n        // Timed out. Wrap the children in a fragment fiber to keep them\n        // separate from the fallback children.\n        const nextFallbackChildren = nextProps.fallback;\n        const primaryChildFragment = createFiberFromFragment(\n          // It shouldn't matter what the pending props are because we aren't\n          // going to render this fragment.\n          null,\n          mode,\n          NoWork,\n          null,\n        );\n        primaryChildFragment.return = workInProgress;\n        primaryChildFragment.child = currentPrimaryChild;\n        if (currentPrimaryChild !== null) {\n          currentPrimaryChild.return = primaryChildFragment;\n        }\n\n        // Even though we're creating a new fiber, there are no new children,\n        // because we're reusing an already mounted tree. So we don't need to\n        // schedule a placement.\n        // primaryChildFragment.effectTag |= Placement;\n\n        if ((workInProgress.mode & BlockingMode) === NoMode) {\n          // Outside of blocking mode, we commit the effects from the\n          // partially completed, timed-out tree, too.\n          const progressedState: SuspenseState = workInProgress.memoizedState;\n          const progressedPrimaryChild: Fiber | null =\n            progressedState !== null\n              ? (workInProgress.child: any).child\n              : (workInProgress.child: any);\n          primaryChildFragment.child = progressedPrimaryChild;\n          let progressedChild = progressedPrimaryChild;\n          while (progressedChild !== null) {\n            progressedChild.return = primaryChildFragment;\n            progressedChild = progressedChild.sibling;\n          }\n        }\n\n        // Because primaryChildFragment is a new fiber that we're inserting as the\n        // parent of a new tree, we need to set its treeBaseDuration.\n        if (enableProfilerTimer && workInProgress.mode & ProfileMode) {\n          // treeBaseDuration is the sum of all the child tree base durations.\n          let treeBaseDuration = 0;\n          let hiddenChild = primaryChildFragment.child;\n          while (hiddenChild !== null) {\n            treeBaseDuration += hiddenChild.treeBaseDuration;\n            hiddenChild = hiddenChild.sibling;\n          }\n          primaryChildFragment.treeBaseDuration = treeBaseDuration;\n        }\n\n        // Create a fragment from the fallback children, too.\n        const fallbackChildFragment = createFiberFromFragment(\n          nextFallbackChildren,\n          mode,\n          renderExpirationTime,\n          null,\n        );\n        fallbackChildFragment.return = workInProgress;\n        primaryChildFragment.sibling = fallbackChildFragment;\n        fallbackChildFragment.effectTag |= Placement;\n        primaryChildFragment.childExpirationTime = NoWork;\n        // Skip the primary children, and continue working on the\n        // fallback children.\n        workInProgress.memoizedState = SUSPENDED_MARKER;\n        workInProgress.child = primaryChildFragment;\n        return fallbackChildFragment;\n      } else {\n        // Still haven't timed out.  Continue rendering the children, like we\n        // normally do.\n        workInProgress.memoizedState = null;\n        const nextPrimaryChildren = nextProps.children;\n        return (workInProgress.child = reconcileChildFibers(\n          workInProgress,\n          currentPrimaryChild,\n          nextPrimaryChildren,\n          renderExpirationTime,\n        ));\n      }\n    }\n  }\n}\n\nfunction retrySuspenseComponentWithoutHydrating(\n  current: Fiber,\n  workInProgress: Fiber,\n  renderExpirationTime: ExpirationTime,\n) {\n  // We're now not suspended nor dehydrated.\n  workInProgress.memoizedState = null;\n  // Retry with the full children.\n  const nextProps = workInProgress.pendingProps;\n  const nextChildren = nextProps.children;\n  // This will ensure that the children get Placement effects and\n  // that the old child gets a Deletion effect.\n  // We could also call forceUnmountCurrentAndReconcile.\n  reconcileChildren(\n    current,\n    workInProgress,\n    nextChildren,\n    renderExpirationTime,\n  );\n  return workInProgress.child;\n}\n\nfunction mountDehydratedSuspenseComponent(\n  workInProgress: Fiber,\n  suspenseInstance: SuspenseInstance,\n  renderExpirationTime: ExpirationTime,\n): null | Fiber {\n  // During the first pass, we'll bail out and not drill into the children.\n  // Instead, we'll leave the content in place and try to hydrate it later.\n  if ((workInProgress.mode & BlockingMode) === NoMode) {\n    if (__DEV__) {\n      warning(\n        false,\n        'Cannot hydrate Suspense in legacy mode. Switch from ' +\n          'ReactDOM.hydrate(element, container) to ' +\n          'ReactDOM.createBlockingRoot(container, { hydrate: true })' +\n          '.render(element) or remove the Suspense components from ' +\n          'the server rendered components.',\n      );\n    }\n    workInProgress.expirationTime = Sync;\n  } else if (isSuspenseInstanceFallback(suspenseInstance)) {\n    // This is a client-only boundary. Since we won't get any content from the server\n    // for this, we need to schedule that at a higher priority based on when it would\n    // have timed out. In theory we could render it in this pass but it would have the\n    // wrong priority associated with it and will prevent hydration of parent path.\n    // Instead, we'll leave work left on it to render it in a separate commit.\n\n    // TODO This time should be the time at which the server rendered response that is\n    // a parent to this boundary was displayed. However, since we currently don't have\n    // a protocol to transfer that time, we'll just estimate it by using the current\n    // time. This will mean that Suspense timeouts are slightly shifted to later than\n    // they should be.\n    let serverDisplayTime = requestCurrentTimeForUpdate();\n    // Schedule a normal pri update to render this content.\n    let newExpirationTime = computeAsyncExpiration(serverDisplayTime);\n    if (enableSchedulerTracing) {\n      markSpawnedWork(newExpirationTime);\n    }\n    workInProgress.expirationTime = newExpirationTime;\n  } else {\n    // We'll continue hydrating the rest at offscreen priority since we'll already\n    // be showing the right content coming from the server, it is no rush.\n    workInProgress.expirationTime = Never;\n    if (enableSchedulerTracing) {\n      markSpawnedWork(Never);\n    }\n  }\n  return null;\n}\n\nfunction updateDehydratedSuspenseComponent(\n  current: Fiber,\n  workInProgress: Fiber,\n  suspenseInstance: SuspenseInstance,\n  suspenseState: SuspenseState,\n  renderExpirationTime: ExpirationTime,\n): null | Fiber {\n  // We should never be hydrating at this point because it is the first pass,\n  // but after we've already committed once.\n  warnIfHydrating();\n\n  if ((workInProgress.mode & BlockingMode) === NoMode) {\n    return retrySuspenseComponentWithoutHydrating(\n      current,\n      workInProgress,\n      renderExpirationTime,\n    );\n  }\n\n  if (isSuspenseInstanceFallback(suspenseInstance)) {\n    // This boundary is in a permanent fallback state. In this case, we'll never\n    // get an update and we'll never be able to hydrate the final content. Let's just try the\n    // client side render instead.\n    return retrySuspenseComponentWithoutHydrating(\n      current,\n      workInProgress,\n      renderExpirationTime,\n    );\n  }\n  // We use childExpirationTime to indicate that a child might depend on context, so if\n  // any context has changed, we need to treat is as if the input might have changed.\n  const hasContextChanged = current.childExpirationTime >= renderExpirationTime;\n  if (didReceiveUpdate || hasContextChanged) {\n    // This boundary has changed since the first render. This means that we are now unable to\n    // hydrate it. We might still be able to hydrate it using an earlier expiration time, if\n    // we are rendering at lower expiration than sync.\n    if (renderExpirationTime < Sync) {\n      if (suspenseState.retryTime <= renderExpirationTime) {\n        // This render is even higher pri than we've seen before, let's try again\n        // at even higher pri.\n        let attemptHydrationAtExpirationTime = renderExpirationTime + 1;\n        suspenseState.retryTime = attemptHydrationAtExpirationTime;\n        scheduleWork(current, attemptHydrationAtExpirationTime);\n        // TODO: Early abort this render.\n      } else {\n        // We have already tried to ping at a higher priority than we're rendering with\n        // so if we got here, we must have failed to hydrate at those levels. We must\n        // now give up. Instead, we're going to delete the whole subtree and instead inject\n        // a new real Suspense boundary to take its place, which may render content\n        // or fallback. This might suspend for a while and if it does we might still have\n        // an opportunity to hydrate before this pass commits.\n      }\n    }\n    // If we have scheduled higher pri work above, this will probably just abort the render\n    // since we now have higher priority work, but in case it doesn't, we need to prepare to\n    // render something, if we time out. Even if that requires us to delete everything and\n    // skip hydration.\n    // Delay having to do this as long as the suspense timeout allows us.\n    renderDidSuspendDelayIfPossible();\n    return retrySuspenseComponentWithoutHydrating(\n      current,\n      workInProgress,\n      renderExpirationTime,\n    );\n  } else if (isSuspenseInstancePending(suspenseInstance)) {\n    // This component is still pending more data from the server, so we can't hydrate its\n    // content. We treat it as if this component suspended itself. It might seem as if\n    // we could just try to render it client-side instead. However, this will perform a\n    // lot of unnecessary work and is unlikely to complete since it often will suspend\n    // on missing data anyway. Additionally, the server might be able to render more\n    // than we can on the client yet. In that case we'd end up with more fallback states\n    // on the client than if we just leave it alone. If the server times out or errors\n    // these should update this boundary to the permanent Fallback state instead.\n    // Mark it as having captured (i.e. suspended).\n    workInProgress.effectTag |= DidCapture;\n    // Leave the child in place. I.e. the dehydrated fragment.\n    workInProgress.child = current.child;\n    // Register a callback to retry this boundary once the server has sent the result.\n    registerSuspenseInstanceRetry(\n      suspenseInstance,\n      retryDehydratedSuspenseBoundary.bind(null, current),\n    );\n    return null;\n  } else {\n    // This is the first attempt.\n    reenterHydrationStateFromDehydratedSuspenseInstance(\n      workInProgress,\n      suspenseInstance,\n    );\n    const nextProps = workInProgress.pendingProps;\n    const nextChildren = nextProps.children;\n    const child = mountChildFibers(\n      workInProgress,\n      null,\n      nextChildren,\n      renderExpirationTime,\n    );\n    let node = child;\n    while (node) {\n      // Mark each child as hydrating. This is a fast path to know whether this\n      // tree is part of a hydrating tree. This is used to determine if a child\n      // node has fully mounted yet, and for scheduling event replaying.\n      // Conceptually this is similar to Placement in that a new subtree is\n      // inserted into the React tree here. It just happens to not need DOM\n      // mutations because it already exists.\n      node.effectTag |= Hydrating;\n      node = node.sibling;\n    }\n    workInProgress.child = child;\n    return workInProgress.child;\n  }\n}\n\nfunction scheduleWorkOnFiber(\n  fiber: Fiber,\n  renderExpirationTime: ExpirationTime,\n) {\n  if (fiber.expirationTime < renderExpirationTime) {\n    fiber.expirationTime = renderExpirationTime;\n  }\n  let alternate = fiber.alternate;\n  if (alternate !== null && alternate.expirationTime < renderExpirationTime) {\n    alternate.expirationTime = renderExpirationTime;\n  }\n  scheduleWorkOnParentPath(fiber.return, renderExpirationTime);\n}\n\nfunction propagateSuspenseContextChange(\n  workInProgress: Fiber,\n  firstChild: null | Fiber,\n  renderExpirationTime: ExpirationTime,\n): void {\n  // Mark any Suspense boundaries with fallbacks as having work to do.\n  // If they were previously forced into fallbacks, they may now be able\n  // to unblock.\n  let node = firstChild;\n  while (node !== null) {\n    if (node.tag === SuspenseComponent) {\n      const state: SuspenseState | null = node.memoizedState;\n      if (state !== null) {\n        scheduleWorkOnFiber(node, renderExpirationTime);\n      }\n    } else if (node.tag === SuspenseListComponent) {\n      // If the tail is hidden there might not be an Suspense boundaries\n      // to schedule work on. In this case we have to schedule it on the\n      // list itself.\n      // We don't have to traverse to the children of the list since\n      // the list will propagate the change when it rerenders.\n      scheduleWorkOnFiber(node, renderExpirationTime);\n    } else if (node.child !== null) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === workInProgress) {\n      return;\n    }\n    while (node.sibling === null) {\n      if (node.return === null || node.return === workInProgress) {\n        return;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction findLastContentRow(firstChild: null | Fiber): null | Fiber {\n  // This is going to find the last row among these children that is already\n  // showing content on the screen, as opposed to being in fallback state or\n  // new. If a row has multiple Suspense boundaries, any of them being in the\n  // fallback state, counts as the whole row being in a fallback state.\n  // Note that the \"rows\" will be workInProgress, but any nested children\n  // will still be current since we haven't rendered them yet. The mounted\n  // order may not be the same as the new order. We use the new order.\n  let row = firstChild;\n  let lastContentRow: null | Fiber = null;\n  while (row !== null) {\n    let currentRow = row.alternate;\n    // New rows can't be content rows.\n    if (currentRow !== null && findFirstSuspended(currentRow) === null) {\n      lastContentRow = row;\n    }\n    row = row.sibling;\n  }\n  return lastContentRow;\n}\n\ntype SuspenseListRevealOrder = 'forwards' | 'backwards' | 'together' | void;\n\nfunction validateRevealOrder(revealOrder: SuspenseListRevealOrder) {\n  if (__DEV__) {\n    if (\n      revealOrder !== undefined &&\n      revealOrder !== 'forwards' &&\n      revealOrder !== 'backwards' &&\n      revealOrder !== 'together' &&\n      !didWarnAboutRevealOrder[revealOrder]\n    ) {\n      didWarnAboutRevealOrder[revealOrder] = true;\n      if (typeof revealOrder === 'string') {\n        switch (revealOrder.toLowerCase()) {\n          case 'together':\n          case 'forwards':\n          case 'backwards': {\n            warning(\n              false,\n              '\"%s\" is not a valid value for revealOrder on <SuspenseList />. ' +\n                'Use lowercase \"%s\" instead.',\n              revealOrder,\n              revealOrder.toLowerCase(),\n            );\n            break;\n          }\n          case 'forward':\n          case 'backward': {\n            warning(\n              false,\n              '\"%s\" is not a valid value for revealOrder on <SuspenseList />. ' +\n                'React uses the -s suffix in the spelling. Use \"%ss\" instead.',\n              revealOrder,\n              revealOrder.toLowerCase(),\n            );\n            break;\n          }\n          default:\n            warning(\n              false,\n              '\"%s\" is not a supported revealOrder on <SuspenseList />. ' +\n                'Did you mean \"together\", \"forwards\" or \"backwards\"?',\n              revealOrder,\n            );\n            break;\n        }\n      } else {\n        warning(\n          false,\n          '%s is not a supported value for revealOrder on <SuspenseList />. ' +\n            'Did you mean \"together\", \"forwards\" or \"backwards\"?',\n          revealOrder,\n        );\n      }\n    }\n  }\n}\n\nfunction validateTailOptions(\n  tailMode: SuspenseListTailMode,\n  revealOrder: SuspenseListRevealOrder,\n) {\n  if (__DEV__) {\n    if (tailMode !== undefined && !didWarnAboutTailOptions[tailMode]) {\n      if (tailMode !== 'collapsed' && tailMode !== 'hidden') {\n        didWarnAboutTailOptions[tailMode] = true;\n        warning(\n          false,\n          '\"%s\" is not a supported value for tail on <SuspenseList />. ' +\n            'Did you mean \"collapsed\" or \"hidden\"?',\n          tailMode,\n        );\n      } else if (revealOrder !== 'forwards' && revealOrder !== 'backwards') {\n        didWarnAboutTailOptions[tailMode] = true;\n        warning(\n          false,\n          '<SuspenseList tail=\"%s\" /> is only valid if revealOrder is ' +\n            '\"forwards\" or \"backwards\". ' +\n            'Did you mean to specify revealOrder=\"forwards\"?',\n          tailMode,\n        );\n      }\n    }\n  }\n}\n\nfunction validateSuspenseListNestedChild(childSlot: mixed, index: number) {\n  if (__DEV__) {\n    let isArray = Array.isArray(childSlot);\n    let isIterable = !isArray && typeof getIteratorFn(childSlot) === 'function';\n    if (isArray || isIterable) {\n      let type = isArray ? 'array' : 'iterable';\n      warning(\n        false,\n        'A nested %s was passed to row #%s in <SuspenseList />. Wrap it in ' +\n          'an additional SuspenseList to configure its revealOrder: ' +\n          '<SuspenseList revealOrder=...> ... ' +\n          '<SuspenseList revealOrder=...>{%s}</SuspenseList> ... ' +\n          '</SuspenseList>',\n        type,\n        index,\n        type,\n      );\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction validateSuspenseListChildren(\n  children: mixed,\n  revealOrder: SuspenseListRevealOrder,\n) {\n  if (__DEV__) {\n    if (\n      (revealOrder === 'forwards' || revealOrder === 'backwards') &&\n      (children !== undefined && children !== null && children !== false)\n    ) {\n      if (Array.isArray(children)) {\n        for (let i = 0; i < children.length; i++) {\n          if (!validateSuspenseListNestedChild(children[i], i)) {\n            return;\n          }\n        }\n      } else {\n        let iteratorFn = getIteratorFn(children);\n        if (typeof iteratorFn === 'function') {\n          const childrenIterator = iteratorFn.call(children);\n          if (childrenIterator) {\n            let step = childrenIterator.next();\n            let i = 0;\n            for (; !step.done; step = childrenIterator.next()) {\n              if (!validateSuspenseListNestedChild(step.value, i)) {\n                return;\n              }\n              i++;\n            }\n          }\n        } else {\n          warning(\n            false,\n            'A single row was passed to a <SuspenseList revealOrder=\"%s\" />. ' +\n              'This is not useful since it needs multiple rows. ' +\n              'Did you mean to pass multiple children or an array?',\n            revealOrder,\n          );\n        }\n      }\n    }\n  }\n}\n\nfunction initSuspenseListRenderState(\n  workInProgress: Fiber,\n  isBackwards: boolean,\n  tail: null | Fiber,\n  lastContentRow: null | Fiber,\n  tailMode: SuspenseListTailMode,\n  lastEffectBeforeRendering: null | Fiber,\n): void {\n  let renderState: null | SuspenseListRenderState =\n    workInProgress.memoizedState;\n  if (renderState === null) {\n    workInProgress.memoizedState = ({\n      isBackwards: isBackwards,\n      rendering: null,\n      last: lastContentRow,\n      tail: tail,\n      tailExpiration: 0,\n      tailMode: tailMode,\n      lastEffect: lastEffectBeforeRendering,\n    }: SuspenseListRenderState);\n  } else {\n    // We can reuse the existing object from previous renders.\n    renderState.isBackwards = isBackwards;\n    renderState.rendering = null;\n    renderState.last = lastContentRow;\n    renderState.tail = tail;\n    renderState.tailExpiration = 0;\n    renderState.tailMode = tailMode;\n    renderState.lastEffect = lastEffectBeforeRendering;\n  }\n}\n\n// This can end up rendering this component multiple passes.\n// The first pass splits the children fibers into two sets. A head and tail.\n// We first render the head. If anything is in fallback state, we do another\n// pass through beginWork to rerender all children (including the tail) with\n// the force suspend context. If the first render didn't have anything in\n// in fallback state. Then we render each row in the tail one-by-one.\n// That happens in the completeWork phase without going back to beginWork.\nfunction updateSuspenseListComponent(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderExpirationTime: ExpirationTime,\n) {\n  const nextProps = workInProgress.pendingProps;\n  const revealOrder: SuspenseListRevealOrder = nextProps.revealOrder;\n  const tailMode: SuspenseListTailMode = nextProps.tail;\n  const newChildren = nextProps.children;\n\n  validateRevealOrder(revealOrder);\n  validateTailOptions(tailMode, revealOrder);\n  validateSuspenseListChildren(newChildren, revealOrder);\n\n  reconcileChildren(current, workInProgress, newChildren, renderExpirationTime);\n\n  let suspenseContext: SuspenseContext = suspenseStackCursor.current;\n\n  let shouldForceFallback = hasSuspenseContext(\n    suspenseContext,\n    (ForceSuspenseFallback: SuspenseContext),\n  );\n  if (shouldForceFallback) {\n    suspenseContext = setShallowSuspenseContext(\n      suspenseContext,\n      ForceSuspenseFallback,\n    );\n    workInProgress.effectTag |= DidCapture;\n  } else {\n    const didSuspendBefore =\n      current !== null && (current.effectTag & DidCapture) !== NoEffect;\n    if (didSuspendBefore) {\n      // If we previously forced a fallback, we need to schedule work\n      // on any nested boundaries to let them know to try to render\n      // again. This is the same as context updating.\n      propagateSuspenseContextChange(\n        workInProgress,\n        workInProgress.child,\n        renderExpirationTime,\n      );\n    }\n    suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n  }\n  pushSuspenseContext(workInProgress, suspenseContext);\n\n  if ((workInProgress.mode & BlockingMode) === NoMode) {\n    // Outside of blocking mode, SuspenseList doesn't work so we just\n    // use make it a noop by treating it as the default revealOrder.\n    workInProgress.memoizedState = null;\n  } else {\n    switch (revealOrder) {\n      case 'forwards': {\n        let lastContentRow = findLastContentRow(workInProgress.child);\n        let tail;\n        if (lastContentRow === null) {\n          // The whole list is part of the tail.\n          // TODO: We could fast path by just rendering the tail now.\n          tail = workInProgress.child;\n          workInProgress.child = null;\n        } else {\n          // Disconnect the tail rows after the content row.\n          // We're going to render them separately later.\n          tail = lastContentRow.sibling;\n          lastContentRow.sibling = null;\n        }\n        initSuspenseListRenderState(\n          workInProgress,\n          false, // isBackwards\n          tail,\n          lastContentRow,\n          tailMode,\n          workInProgress.lastEffect,\n        );\n        break;\n      }\n      case 'backwards': {\n        // We're going to find the first row that has existing content.\n        // At the same time we're going to reverse the list of everything\n        // we pass in the meantime. That's going to be our tail in reverse\n        // order.\n        let tail = null;\n        let row = workInProgress.child;\n        workInProgress.child = null;\n        while (row !== null) {\n          let currentRow = row.alternate;\n          // New rows can't be content rows.\n          if (currentRow !== null && findFirstSuspended(currentRow) === null) {\n            // This is the beginning of the main content.\n            workInProgress.child = row;\n            break;\n          }\n          let nextRow = row.sibling;\n          row.sibling = tail;\n          tail = row;\n          row = nextRow;\n        }\n        // TODO: If workInProgress.child is null, we can continue on the tail immediately.\n        initSuspenseListRenderState(\n          workInProgress,\n          true, // isBackwards\n          tail,\n          null, // last\n          tailMode,\n          workInProgress.lastEffect,\n        );\n        break;\n      }\n      case 'together': {\n        initSuspenseListRenderState(\n          workInProgress,\n          false, // isBackwards\n          null, // tail\n          null, // last\n          undefined,\n          workInProgress.lastEffect,\n        );\n        break;\n      }\n      default: {\n        // The default reveal order is the same as not having\n        // a boundary.\n        workInProgress.memoizedState = null;\n      }\n    }\n  }\n  return workInProgress.child;\n}\n\nfunction updatePortalComponent(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderExpirationTime: ExpirationTime,\n) {\n  pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n  const nextChildren = workInProgress.pendingProps;\n  if (current === null) {\n    // Portals are special because we don't append the children during mount\n    // but at commit. Therefore we need to track insertions which the normal\n    // flow doesn't do during mount. This doesn't happen at the root because\n    // the root always starts with a \"current\" with a null child.\n    // TODO: Consider unifying this with how the root works.\n    workInProgress.child = reconcileChildFibers(\n      workInProgress,\n      null,\n      nextChildren,\n      renderExpirationTime,\n    );\n  } else {\n    reconcileChildren(\n      current,\n      workInProgress,\n      nextChildren,\n      renderExpirationTime,\n    );\n  }\n  return workInProgress.child;\n}\n\nfunction updateContextProvider(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderExpirationTime: ExpirationTime,\n) {\n  const providerType: ReactProviderType<any> = workInProgress.type;\n  const context: ReactContext<any> = providerType._context;\n\n  const newProps = workInProgress.pendingProps;\n  const oldProps = workInProgress.memoizedProps;\n\n  const newValue = newProps.value;\n\n  if (__DEV__) {\n    const providerPropTypes = workInProgress.type.propTypes;\n\n    if (providerPropTypes) {\n      checkPropTypes(\n        providerPropTypes,\n        newProps,\n        'prop',\n        'Context.Provider',\n        getCurrentFiberStackInDev,\n      );\n    }\n  }\n\n  pushProvider(workInProgress, newValue);\n\n  if (oldProps !== null) {\n    const oldValue = oldProps.value;\n    const changedBits = calculateChangedBits(context, newValue, oldValue);\n    if (changedBits === 0) {\n      // No change. Bailout early if children are the same.\n      if (\n        oldProps.children === newProps.children &&\n        !hasLegacyContextChanged()\n      ) {\n        return bailoutOnAlreadyFinishedWork(\n          current,\n          workInProgress,\n          renderExpirationTime,\n        );\n      }\n    } else {\n      // The context value changed. Search for matching consumers and schedule\n      // them to update.\n      propagateContextChange(\n        workInProgress,\n        context,\n        changedBits,\n        renderExpirationTime,\n      );\n    }\n  }\n\n  const newChildren = newProps.children;\n  reconcileChildren(current, workInProgress, newChildren, renderExpirationTime);\n  return workInProgress.child;\n}\n\nlet hasWarnedAboutUsingContextAsConsumer = false;\n\nfunction updateContextConsumer(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderExpirationTime: ExpirationTime,\n) {\n  let context: ReactContext<any> = workInProgress.type;\n  // The logic below for Context differs depending on PROD or DEV mode. In\n  // DEV mode, we create a separate object for Context.Consumer that acts\n  // like a proxy to Context. This proxy object adds unnecessary code in PROD\n  // so we use the old behaviour (Context.Consumer references Context) to\n  // reduce size and overhead. The separate object references context via\n  // a property called \"_context\", which also gives us the ability to check\n  // in DEV mode if this property exists or not and warn if it does not.\n  if (__DEV__) {\n    if ((context: any)._context === undefined) {\n      // This may be because it's a Context (rather than a Consumer).\n      // Or it may be because it's older React where they're the same thing.\n      // We only want to warn if we're sure it's a new React.\n      if (context !== context.Consumer) {\n        if (!hasWarnedAboutUsingContextAsConsumer) {\n          hasWarnedAboutUsingContextAsConsumer = true;\n          warning(\n            false,\n            'Rendering <Context> directly is not supported and will be removed in ' +\n              'a future major release. Did you mean to render <Context.Consumer> instead?',\n          );\n        }\n      }\n    } else {\n      context = (context: any)._context;\n    }\n  }\n  const newProps = workInProgress.pendingProps;\n  const render = newProps.children;\n\n  if (__DEV__) {\n    warningWithoutStack(\n      typeof render === 'function',\n      'A context consumer was rendered with multiple children, or a child ' +\n        \"that isn't a function. A context consumer expects a single child \" +\n        'that is a function. If you did pass a function, make sure there ' +\n        'is no trailing or leading whitespace around it.',\n    );\n  }\n\n  prepareToReadContext(workInProgress, renderExpirationTime);\n  const newValue = readContext(context, newProps.unstable_observedBits);\n  let newChildren;\n  if (__DEV__) {\n    ReactCurrentOwner.current = workInProgress;\n    setCurrentPhase('render');\n    newChildren = render(newValue);\n    setCurrentPhase(null);\n  } else {\n    newChildren = render(newValue);\n  }\n\n  // React DevTools reads this flag.\n  workInProgress.effectTag |= PerformedWork;\n  reconcileChildren(current, workInProgress, newChildren, renderExpirationTime);\n  return workInProgress.child;\n}\n\nfunction updateFundamentalComponent(\n  current,\n  workInProgress,\n  renderExpirationTime,\n) {\n  const fundamentalImpl = workInProgress.type.impl;\n  if (fundamentalImpl.reconcileChildren === false) {\n    return null;\n  }\n  const nextProps = workInProgress.pendingProps;\n  const nextChildren = nextProps.children;\n\n  reconcileChildren(\n    current,\n    workInProgress,\n    nextChildren,\n    renderExpirationTime,\n  );\n  return workInProgress.child;\n}\n\nfunction updateScopeComponent(current, workInProgress, renderExpirationTime) {\n  const nextProps = workInProgress.pendingProps;\n  const nextChildren = nextProps.children;\n\n  reconcileChildren(\n    current,\n    workInProgress,\n    nextChildren,\n    renderExpirationTime,\n  );\n  return workInProgress.child;\n}\n\nexport function markWorkInProgressReceivedUpdate() {\n  didReceiveUpdate = true;\n}\n\nfunction bailoutOnAlreadyFinishedWork(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderExpirationTime: ExpirationTime,\n): Fiber | null {\n  cancelWorkTimer(workInProgress);\n\n  if (current !== null) {\n    // Reuse previous dependencies\n    workInProgress.dependencies = current.dependencies;\n  }\n\n  if (enableProfilerTimer) {\n    // Don't update \"base\" render times for bailouts.\n    stopProfilerTimerIfRunning(workInProgress);\n  }\n\n  const updateExpirationTime = workInProgress.expirationTime;\n  if (updateExpirationTime !== NoWork) {\n    markUnprocessedUpdateTime(updateExpirationTime);\n  }\n\n  // Check if the children have any pending work.\n  const childExpirationTime = workInProgress.childExpirationTime;\n  if (childExpirationTime < renderExpirationTime) {\n    // The children don't have any work either. We can skip them.\n    // TODO: Once we add back resuming, we should check if the children are\n    // a work-in-progress set. If so, we need to transfer their effects.\n    return null;\n  } else {\n    // This fiber doesn't have work, but its subtree does. Clone the child\n    // fibers and continue.\n    cloneChildFibers(current, workInProgress);\n    return workInProgress.child;\n  }\n}\n\nfunction remountFiber(\n  current: Fiber,\n  oldWorkInProgress: Fiber,\n  newWorkInProgress: Fiber,\n): Fiber | null {\n  if (__DEV__) {\n    const returnFiber = oldWorkInProgress.return;\n    if (returnFiber === null) {\n      throw new Error('Cannot swap the root fiber.');\n    }\n\n    // Disconnect from the old current.\n    // It will get deleted.\n    current.alternate = null;\n    oldWorkInProgress.alternate = null;\n\n    // Connect to the new tree.\n    newWorkInProgress.index = oldWorkInProgress.index;\n    newWorkInProgress.sibling = oldWorkInProgress.sibling;\n    newWorkInProgress.return = oldWorkInProgress.return;\n    newWorkInProgress.ref = oldWorkInProgress.ref;\n\n    // Replace the child/sibling pointers above it.\n    if (oldWorkInProgress === returnFiber.child) {\n      returnFiber.child = newWorkInProgress;\n    } else {\n      let prevSibling = returnFiber.child;\n      if (prevSibling === null) {\n        throw new Error('Expected parent to have a child.');\n      }\n      while (prevSibling.sibling !== oldWorkInProgress) {\n        prevSibling = prevSibling.sibling;\n        if (prevSibling === null) {\n          throw new Error('Expected to find the previous sibling.');\n        }\n      }\n      prevSibling.sibling = newWorkInProgress;\n    }\n\n    // Delete the old fiber and place the new one.\n    // Since the old fiber is disconnected, we have to schedule it manually.\n    const last = returnFiber.lastEffect;\n    if (last !== null) {\n      last.nextEffect = current;\n      returnFiber.lastEffect = current;\n    } else {\n      returnFiber.firstEffect = returnFiber.lastEffect = current;\n    }\n    current.nextEffect = null;\n    current.effectTag = Deletion;\n\n    newWorkInProgress.effectTag |= Placement;\n\n    // Restart work from the new fiber.\n    return newWorkInProgress;\n  } else {\n    throw new Error(\n      'Did not expect this call in production. ' +\n        'This is a bug in React. Please file an issue.',\n    );\n  }\n}\n\nfunction beginWork(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderExpirationTime: ExpirationTime,\n): Fiber | null {\n  const updateExpirationTime = workInProgress.expirationTime;\n\n  if (__DEV__) {\n    if (workInProgress._debugNeedsRemount && current !== null) {\n      // This will restart the begin phase with a new fiber.\n      return remountFiber(\n        current,\n        workInProgress,\n        createFiberFromTypeAndProps(\n          workInProgress.type,\n          workInProgress.key,\n          workInProgress.pendingProps,\n          workInProgress._debugOwner || null,\n          workInProgress.mode,\n          workInProgress.expirationTime,\n        ),\n      );\n    }\n  }\n\n  if (current !== null) {\n    const oldProps = current.memoizedProps;\n    const newProps = workInProgress.pendingProps;\n\n    if (\n      oldProps !== newProps ||\n      hasLegacyContextChanged() ||\n      // Force a re-render if the implementation changed due to hot reload:\n      (__DEV__ ? workInProgress.type !== current.type : false)\n    ) {\n      // If props or context changed, mark the fiber as having performed work.\n      // This may be unset if the props are determined to be equal later (memo).\n      didReceiveUpdate = true;\n    } else if (updateExpirationTime < renderExpirationTime) {\n      didReceiveUpdate = false;\n      // This fiber does not have any pending work. Bailout without entering\n      // the begin phase. There's still some bookkeeping we that needs to be done\n      // in this optimized path, mostly pushing stuff onto the stack.\n      switch (workInProgress.tag) {\n        case HostRoot:\n          pushHostRootContext(workInProgress);\n          resetHydrationState();\n          break;\n        case HostComponent:\n          pushHostContext(workInProgress);\n          if (\n            workInProgress.mode & ConcurrentMode &&\n            renderExpirationTime !== Never &&\n            shouldDeprioritizeSubtree(workInProgress.type, newProps)\n          ) {\n            if (enableSchedulerTracing) {\n              markSpawnedWork(Never);\n            }\n            // Schedule this fiber to re-render at offscreen priority. Then bailout.\n            workInProgress.expirationTime = workInProgress.childExpirationTime = Never;\n            return null;\n          }\n          break;\n        case ClassComponent: {\n          const Component = workInProgress.type;\n          if (isLegacyContextProvider(Component)) {\n            pushLegacyContextProvider(workInProgress);\n          }\n          break;\n        }\n        case HostPortal:\n          pushHostContainer(\n            workInProgress,\n            workInProgress.stateNode.containerInfo,\n          );\n          break;\n        case ContextProvider: {\n          const newValue = workInProgress.memoizedProps.value;\n          pushProvider(workInProgress, newValue);\n          break;\n        }\n        case Profiler:\n          if (enableProfilerTimer) {\n            // Profiler should only call onRender when one of its descendants actually rendered.\n            const hasChildWork =\n              workInProgress.childExpirationTime >= renderExpirationTime;\n            if (hasChildWork) {\n              workInProgress.effectTag |= Update;\n            }\n          }\n          break;\n        case SuspenseComponent: {\n          const state: SuspenseState | null = workInProgress.memoizedState;\n          if (state !== null) {\n            if (enableSuspenseServerRenderer) {\n              if (state.dehydrated !== null) {\n                pushSuspenseContext(\n                  workInProgress,\n                  setDefaultShallowSuspenseContext(suspenseStackCursor.current),\n                );\n                // We know that this component will suspend again because if it has\n                // been unsuspended it has committed as a resolved Suspense component.\n                // If it needs to be retried, it should have work scheduled on it.\n                workInProgress.effectTag |= DidCapture;\n                break;\n              }\n            }\n\n            // If this boundary is currently timed out, we need to decide\n            // whether to retry the primary children, or to skip over it and\n            // go straight to the fallback. Check the priority of the primary\n            // child fragment.\n            const primaryChildFragment: Fiber = (workInProgress.child: any);\n            const primaryChildExpirationTime =\n              primaryChildFragment.childExpirationTime;\n            if (\n              primaryChildExpirationTime !== NoWork &&\n              primaryChildExpirationTime >= renderExpirationTime\n            ) {\n              // The primary children have pending work. Use the normal path\n              // to attempt to render the primary children again.\n              return updateSuspenseComponent(\n                current,\n                workInProgress,\n                renderExpirationTime,\n              );\n            } else {\n              pushSuspenseContext(\n                workInProgress,\n                setDefaultShallowSuspenseContext(suspenseStackCursor.current),\n              );\n              // The primary children do not have pending work with sufficient\n              // priority. Bailout.\n              const child = bailoutOnAlreadyFinishedWork(\n                current,\n                workInProgress,\n                renderExpirationTime,\n              );\n              if (child !== null) {\n                // The fallback children have pending work. Skip over the\n                // primary children and work on the fallback.\n                return child.sibling;\n              } else {\n                return null;\n              }\n            }\n          } else {\n            pushSuspenseContext(\n              workInProgress,\n              setDefaultShallowSuspenseContext(suspenseStackCursor.current),\n            );\n          }\n          break;\n        }\n        case SuspenseListComponent: {\n          const didSuspendBefore =\n            (current.effectTag & DidCapture) !== NoEffect;\n\n          const hasChildWork =\n            workInProgress.childExpirationTime >= renderExpirationTime;\n\n          if (didSuspendBefore) {\n            if (hasChildWork) {\n              // If something was in fallback state last time, and we have all the\n              // same children then we're still in progressive loading state.\n              // Something might get unblocked by state updates or retries in the\n              // tree which will affect the tail. So we need to use the normal\n              // path to compute the correct tail.\n              return updateSuspenseListComponent(\n                current,\n                workInProgress,\n                renderExpirationTime,\n              );\n            }\n            // If none of the children had any work, that means that none of\n            // them got retried so they'll still be blocked in the same way\n            // as before. We can fast bail out.\n            workInProgress.effectTag |= DidCapture;\n          }\n\n          // If nothing suspended before and we're rendering the same children,\n          // then the tail doesn't matter. Anything new that suspends will work\n          // in the \"together\" mode, so we can continue from the state we had.\n          let renderState = workInProgress.memoizedState;\n          if (renderState !== null) {\n            // Reset to the \"together\" mode in case we've started a different\n            // update in the past but didn't complete it.\n            renderState.rendering = null;\n            renderState.tail = null;\n          }\n          pushSuspenseContext(workInProgress, suspenseStackCursor.current);\n\n          if (hasChildWork) {\n            break;\n          } else {\n            // If none of the children had any work, that means that none of\n            // them got retried so they'll still be blocked in the same way\n            // as before. We can fast bail out.\n            return null;\n          }\n        }\n      }\n      return bailoutOnAlreadyFinishedWork(\n        current,\n        workInProgress,\n        renderExpirationTime,\n      );\n    } else {\n      // An update was scheduled on this fiber, but there are no new props\n      // nor legacy context. Set this to false. If an update queue or context\n      // consumer produces a changed value, it will set this to true. Otherwise,\n      // the component will assume the children have not changed and bail out.\n      didReceiveUpdate = false;\n    }\n  } else {\n    didReceiveUpdate = false;\n  }\n\n  // Before entering the begin phase, clear the expiration time.\n  workInProgress.expirationTime = NoWork;\n\n  switch (workInProgress.tag) {\n    case IndeterminateComponent: {\n      return mountIndeterminateComponent(\n        current,\n        workInProgress,\n        workInProgress.type,\n        renderExpirationTime,\n      );\n    }\n    case LazyComponent: {\n      const elementType = workInProgress.elementType;\n      return mountLazyComponent(\n        current,\n        workInProgress,\n        elementType,\n        updateExpirationTime,\n        renderExpirationTime,\n      );\n    }\n    case FunctionComponent: {\n      const Component = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      const resolvedProps =\n        workInProgress.elementType === Component\n          ? unresolvedProps\n          : resolveDefaultProps(Component, unresolvedProps);\n      return updateFunctionComponent(\n        current,\n        workInProgress,\n        Component,\n        resolvedProps,\n        renderExpirationTime,\n      );\n    }\n    case ClassComponent: {\n      const Component = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      const resolvedProps =\n        workInProgress.elementType === Component\n          ? unresolvedProps\n          : resolveDefaultProps(Component, unresolvedProps);\n      return updateClassComponent(\n        current,\n        workInProgress,\n        Component,\n        resolvedProps,\n        renderExpirationTime,\n      );\n    }\n    case HostRoot:\n      return updateHostRoot(current, workInProgress, renderExpirationTime);\n    case HostComponent:\n      return updateHostComponent(current, workInProgress, renderExpirationTime);\n    case HostText:\n      return updateHostText(current, workInProgress);\n    case SuspenseComponent:\n      return updateSuspenseComponent(\n        current,\n        workInProgress,\n        renderExpirationTime,\n      );\n    case HostPortal:\n      return updatePortalComponent(\n        current,\n        workInProgress,\n        renderExpirationTime,\n      );\n    case ForwardRef: {\n      const type = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      const resolvedProps =\n        workInProgress.elementType === type\n          ? unresolvedProps\n          : resolveDefaultProps(type, unresolvedProps);\n      return updateForwardRef(\n        current,\n        workInProgress,\n        type,\n        resolvedProps,\n        renderExpirationTime,\n      );\n    }\n    case Fragment:\n      return updateFragment(current, workInProgress, renderExpirationTime);\n    case Mode:\n      return updateMode(current, workInProgress, renderExpirationTime);\n    case Profiler:\n      return updateProfiler(current, workInProgress, renderExpirationTime);\n    case ContextProvider:\n      return updateContextProvider(\n        current,\n        workInProgress,\n        renderExpirationTime,\n      );\n    case ContextConsumer:\n      return updateContextConsumer(\n        current,\n        workInProgress,\n        renderExpirationTime,\n      );\n    case MemoComponent: {\n      const type = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      // Resolve outer props first, then resolve inner props.\n      let resolvedProps = resolveDefaultProps(type, unresolvedProps);\n      if (__DEV__) {\n        if (workInProgress.type !== workInProgress.elementType) {\n          const outerPropTypes = type.propTypes;\n          if (outerPropTypes) {\n            checkPropTypes(\n              outerPropTypes,\n              resolvedProps, // Resolved for outer only\n              'prop',\n              getComponentName(type),\n              getCurrentFiberStackInDev,\n            );\n          }\n        }\n      }\n      resolvedProps = resolveDefaultProps(type.type, resolvedProps);\n      return updateMemoComponent(\n        current,\n        workInProgress,\n        type,\n        resolvedProps,\n        updateExpirationTime,\n        renderExpirationTime,\n      );\n    }\n    case SimpleMemoComponent: {\n      return updateSimpleMemoComponent(\n        current,\n        workInProgress,\n        workInProgress.type,\n        workInProgress.pendingProps,\n        updateExpirationTime,\n        renderExpirationTime,\n      );\n    }\n    case IncompleteClassComponent: {\n      const Component = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      const resolvedProps =\n        workInProgress.elementType === Component\n          ? unresolvedProps\n          : resolveDefaultProps(Component, unresolvedProps);\n      return mountIncompleteClassComponent(\n        current,\n        workInProgress,\n        Component,\n        resolvedProps,\n        renderExpirationTime,\n      );\n    }\n    case SuspenseListComponent: {\n      return updateSuspenseListComponent(\n        current,\n        workInProgress,\n        renderExpirationTime,\n      );\n    }\n    case FundamentalComponent: {\n      if (enableFundamentalAPI) {\n        return updateFundamentalComponent(\n          current,\n          workInProgress,\n          renderExpirationTime,\n        );\n      }\n      break;\n    }\n    case ScopeComponent: {\n      if (enableScopeAPI) {\n        return updateScopeComponent(\n          current,\n          workInProgress,\n          renderExpirationTime,\n        );\n      }\n      break;\n    }\n  }\n  invariant(\n    false,\n    'Unknown unit of work tag (%s). This error is likely caused by a bug in ' +\n      'React. Please file an issue.',\n    workInProgress.tag,\n  );\n}\n\nexport {beginWork};\n"]},"metadata":{},"sourceType":"module"}