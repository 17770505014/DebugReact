{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport { NoWork } from './ReactFiberExpirationTime';\nimport { readContext } from './ReactFiberNewContext';\nimport { createResponderListener } from './ReactFiberEvents';\nimport { Update as UpdateEffect, Passive as PassiveEffect } from 'shared/ReactSideEffectTags';\nimport { NoEffect as NoHookEffect, UnmountMutation, MountLayout, UnmountPassive, MountPassive } from './ReactHookEffectTags';\nimport { scheduleWork, computeExpirationForFiber, requestCurrentTimeForUpdate, warnIfNotCurrentlyActingEffectsInDEV, warnIfNotCurrentlyActingUpdatesInDev, warnIfNotScopedWithMatchingAct, markRenderEventTimeAndConfig, markUnprocessedUpdateTime } from './ReactFiberWorkLoop';\nimport invariant from 'shared/invariant';\nimport warning from 'shared/warning';\nimport getComponentName from 'shared/getComponentName';\nimport is from 'shared/objectIs';\nimport { markWorkInProgressReceivedUpdate } from './ReactFiberBeginWork';\nimport { requestCurrentSuspenseConfig } from './ReactFiberSuspenseConfig';\nimport { UserBlockingPriority, NormalPriority, runWithPriority, getCurrentPriorityLevel } from './SchedulerWithReactIntegration';\nconst {\n  ReactCurrentDispatcher,\n  ReactCurrentBatchConfig\n} = ReactSharedInternals;\nlet didWarnAboutMismatchedHooksForComponent;\n\nif (__DEV__) {\n  didWarnAboutMismatchedHooksForComponent = new Set();\n}\n\n// These are set right before calling the component.\nlet renderExpirationTime = NoWork; // The work-in-progress fiber. I've named it differently to distinguish it from\n// the work-in-progress hook.\n\nlet currentlyRenderingFiber = null; // Hooks are stored as a linked list on the fiber's memoizedState field. The\n// current hook list is the list that belongs to the current fiber. The\n// work-in-progress hook list is a new list that will be added to the\n// work-in-progress fiber.\n\nlet currentHook = null;\nlet nextCurrentHook = null;\nlet firstWorkInProgressHook = null;\nlet workInProgressHook = null;\nlet nextWorkInProgressHook = null;\nlet remainingExpirationTime = NoWork;\nlet componentUpdateQueue = null;\nlet sideEffectTag = 0; // Updates scheduled during render will trigger an immediate re-render at the\n// end of the current pass. We can't store these updates on the normal queue,\n// because if the work is aborted, they should be discarded. Because this is\n// a relatively rare case, we also don't want to add an additional field to\n// either the hook or queue object types. So we store them in a lazily create\n// map of queue -> render-phase updates, which are discarded once the component\n// completes without re-rendering.\n// Whether an update was scheduled during the currently executing render pass.\n\nlet didScheduleRenderPhaseUpdate = false; // Lazily created map of render-phase updates\n\nlet renderPhaseUpdates = null; // Counter to prevent infinite loops.\n\nlet numberOfReRenders = 0;\nconst RE_RENDER_LIMIT = 25; // In DEV, this is the name of the currently executing primitive hook\n\nlet currentHookNameInDev = null; // In DEV, this list ensures that hooks are called in the same order between renders.\n// The list stores the order of hooks used during the initial render (mount).\n// Subsequent renders (updates) reference this list.\n\nlet hookTypesDev = null;\nlet hookTypesUpdateIndexDev = -1; // In DEV, this tracks whether currently rendering component needs to ignore\n// the dependencies for Hooks that need them (e.g. useEffect or useMemo).\n// When true, such Hooks will always be \"remounted\". Only used during hot reload.\n\nlet ignorePreviousDependencies = false;\n\nfunction mountHookTypesDev() {\n  if (__DEV__) {\n    const hookName = currentHookNameInDev;\n\n    if (hookTypesDev === null) {\n      hookTypesDev = [hookName];\n    } else {\n      hookTypesDev.push(hookName);\n    }\n  }\n}\n\nfunction updateHookTypesDev() {\n  if (__DEV__) {\n    const hookName = currentHookNameInDev;\n\n    if (hookTypesDev !== null) {\n      hookTypesUpdateIndexDev++;\n\n      if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {\n        warnOnHookMismatchInDev(hookName);\n      }\n    }\n  }\n}\n\nfunction checkDepsAreArrayDev(deps) {\n  if (__DEV__) {\n    if (deps !== undefined && deps !== null && !Array.isArray(deps)) {\n      // Verify deps, but only on mount to avoid extra checks.\n      // It's unlikely their type would change as usually you define them inline.\n      warning(false, '%s received a final argument that is not an array (instead, received `%s`). When ' + 'specified, the final argument must be an array.', currentHookNameInDev, typeof deps);\n    }\n  }\n}\n\nfunction warnOnHookMismatchInDev(currentHookName) {\n  if (__DEV__) {\n    const componentName = getComponentName(currentlyRenderingFiber.type);\n\n    if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {\n      didWarnAboutMismatchedHooksForComponent.add(componentName);\n\n      if (hookTypesDev !== null) {\n        let table = '';\n        const secondColumnStart = 30;\n\n        for (let i = 0; i <= hookTypesUpdateIndexDev; i++) {\n          const oldHookName = hookTypesDev[i];\n          const newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;\n          let row = `${i + 1}. ${oldHookName}`; // Extra space so second column lines up\n          // lol @ IE not supporting String#repeat\n\n          while (row.length < secondColumnStart) {\n            row += ' ';\n          }\n\n          row += newHookName + '\\n';\n          table += row;\n        }\n\n        warning(false, 'React has detected a change in the order of Hooks called by %s. ' + 'This will lead to bugs and errors if not fixed. ' + 'For more information, read the Rules of Hooks: https://fb.me/rules-of-hooks\\n\\n' + '   Previous render            Next render\\n' + '   ------------------------------------------------------\\n' + '%s' + '   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n', componentName, table);\n      }\n    }\n  }\n}\n\nfunction throwInvalidHookError() {\n  invariant(false, 'Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' + ' one of the following reasons:\\n' + '1. You might have mismatching versions of React and the renderer (such as React DOM)\\n' + '2. You might be breaking the Rules of Hooks\\n' + '3. You might have more than one copy of React in the same app\\n' + 'See https://fb.me/react-invalid-hook-call for tips about how to debug and fix this problem.');\n}\n\nfunction areHookInputsEqual(nextDeps, prevDeps) {\n  if (__DEV__) {\n    if (ignorePreviousDependencies) {\n      // Only true when this component is being hot reloaded.\n      return false;\n    }\n  }\n\n  if (prevDeps === null) {\n    if (__DEV__) {\n      warning(false, '%s received a final argument during this render, but not during ' + 'the previous render. Even though the final argument is optional, ' + 'its type cannot change between renders.', currentHookNameInDev);\n    }\n\n    return false;\n  }\n\n  if (__DEV__) {\n    // Don't bother comparing lengths in prod because these arrays should be\n    // passed inline.\n    if (nextDeps.length !== prevDeps.length) {\n      warning(false, 'The final argument passed to %s changed size between renders. The ' + 'order and size of this array must remain constant.\\n\\n' + 'Previous: %s\\n' + 'Incoming: %s', currentHookNameInDev, `[${prevDeps.join(', ')}]`, `[${nextDeps.join(', ')}]`);\n    }\n  }\n\n  for (let i = 0; i < prevDeps.length && i < nextDeps.length; i++) {\n    if (is(nextDeps[i], prevDeps[i])) {\n      continue;\n    }\n\n    return false;\n  }\n\n  return true;\n}\n\nexport function renderWithHooks(current, workInProgress, Component, props, refOrContext, nextRenderExpirationTime) {\n  renderExpirationTime = nextRenderExpirationTime;\n  currentlyRenderingFiber = workInProgress;\n  nextCurrentHook = current !== null ? current.memoizedState : null;\n\n  if (__DEV__) {\n    hookTypesDev = current !== null ? current._debugHookTypes : null;\n    hookTypesUpdateIndexDev = -1; // Used for hot reloading:\n\n    ignorePreviousDependencies = current !== null && current.type !== workInProgress.type;\n  } // The following should have already been reset\n  // currentHook = null;\n  // workInProgressHook = null;\n  // remainingExpirationTime = NoWork;\n  // componentUpdateQueue = null;\n  // didScheduleRenderPhaseUpdate = false;\n  // renderPhaseUpdates = null;\n  // numberOfReRenders = 0;\n  // sideEffectTag = 0;\n  // TODO Warn if no hooks are used at all during mount, then some are used during update.\n  // Currently we will identify the update render as a mount because nextCurrentHook === null.\n  // This is tricky because it's valid for certain types of components (e.g. React.lazy)\n  // Using nextCurrentHook to differentiate between mount/update only works if at least one stateful hook is used.\n  // Non-stateful hooks (e.g. context) don't get added to memoizedState,\n  // so nextCurrentHook would be null during updates and mounts.\n\n\n  if (__DEV__) {\n    if (nextCurrentHook !== null) {\n      ReactCurrentDispatcher.current = HooksDispatcherOnUpdateInDEV;\n    } else if (hookTypesDev !== null) {\n      // This dispatcher handles an edge case where a component is updating,\n      // but no stateful hooks have been used.\n      // We want to match the production code behavior (which will use HooksDispatcherOnMount),\n      // but with the extra DEV validation to ensure hooks ordering hasn't changed.\n      // This dispatcher does that.\n      ReactCurrentDispatcher.current = HooksDispatcherOnMountWithHookTypesInDEV;\n    } else {\n      ReactCurrentDispatcher.current = HooksDispatcherOnMountInDEV;\n    }\n  } else {\n    ReactCurrentDispatcher.current = nextCurrentHook === null ? HooksDispatcherOnMount : HooksDispatcherOnUpdate;\n  }\n\n  let children = Component(props, refOrContext);\n\n  if (didScheduleRenderPhaseUpdate) {\n    do {\n      didScheduleRenderPhaseUpdate = false;\n      numberOfReRenders += 1;\n\n      if (__DEV__) {\n        // Even when hot reloading, allow dependencies to stabilize\n        // after first render to prevent infinite render phase updates.\n        ignorePreviousDependencies = false;\n      } // Start over from the beginning of the list\n\n\n      nextCurrentHook = current !== null ? current.memoizedState : null;\n      nextWorkInProgressHook = firstWorkInProgressHook;\n      currentHook = null;\n      workInProgressHook = null;\n      componentUpdateQueue = null;\n\n      if (__DEV__) {\n        // Also validate hook order for cascading updates.\n        hookTypesUpdateIndexDev = -1;\n      }\n\n      ReactCurrentDispatcher.current = __DEV__ ? HooksDispatcherOnUpdateInDEV : HooksDispatcherOnUpdate;\n      children = Component(props, refOrContext);\n    } while (didScheduleRenderPhaseUpdate);\n\n    renderPhaseUpdates = null;\n    numberOfReRenders = 0;\n  } // We can assume the previous dispatcher is always this one, since we set it\n  // at the beginning of the render phase and there's no re-entrancy.\n\n\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\n  const renderedWork = currentlyRenderingFiber;\n  renderedWork.memoizedState = firstWorkInProgressHook;\n  renderedWork.expirationTime = remainingExpirationTime;\n  renderedWork.updateQueue = componentUpdateQueue;\n  renderedWork.effectTag |= sideEffectTag;\n\n  if (__DEV__) {\n    renderedWork._debugHookTypes = hookTypesDev;\n  } // This check uses currentHook so that it works the same in DEV and prod bundles.\n  // hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.\n\n\n  const didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;\n  renderExpirationTime = NoWork;\n  currentlyRenderingFiber = null;\n  currentHook = null;\n  nextCurrentHook = null;\n  firstWorkInProgressHook = null;\n  workInProgressHook = null;\n  nextWorkInProgressHook = null;\n\n  if (__DEV__) {\n    currentHookNameInDev = null;\n    hookTypesDev = null;\n    hookTypesUpdateIndexDev = -1;\n  }\n\n  remainingExpirationTime = NoWork;\n  componentUpdateQueue = null;\n  sideEffectTag = 0; // These were reset above\n  // didScheduleRenderPhaseUpdate = false;\n  // renderPhaseUpdates = null;\n  // numberOfReRenders = 0;\n\n  invariant(!didRenderTooFewHooks, 'Rendered fewer hooks than expected. This may be caused by an accidental ' + 'early return statement.');\n  return children;\n}\nexport function bailoutHooks(current, workInProgress, expirationTime) {\n  workInProgress.updateQueue = current.updateQueue;\n  workInProgress.effectTag &= ~(PassiveEffect | UpdateEffect);\n\n  if (current.expirationTime <= expirationTime) {\n    current.expirationTime = NoWork;\n  }\n}\nexport function resetHooks() {\n  // We can assume the previous dispatcher is always this one, since we set it\n  // at the beginning of the render phase and there's no re-entrancy.\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher; // This is used to reset the state of this module when a component throws.\n  // It's also called inside mountIndeterminateComponent if we determine the\n  // component is a module-style component.\n\n  renderExpirationTime = NoWork;\n  currentlyRenderingFiber = null;\n  currentHook = null;\n  nextCurrentHook = null;\n  firstWorkInProgressHook = null;\n  workInProgressHook = null;\n  nextWorkInProgressHook = null;\n\n  if (__DEV__) {\n    hookTypesDev = null;\n    hookTypesUpdateIndexDev = -1;\n    currentHookNameInDev = null;\n  }\n\n  remainingExpirationTime = NoWork;\n  componentUpdateQueue = null;\n  sideEffectTag = 0;\n  didScheduleRenderPhaseUpdate = false;\n  renderPhaseUpdates = null;\n  numberOfReRenders = 0;\n}\n\nfunction mountWorkInProgressHook() {\n  const hook = {\n    memoizedState: null,\n    baseState: null,\n    queue: null,\n    baseUpdate: null,\n    next: null\n  };\n\n  if (workInProgressHook === null) {\n    // This is the first hook in the list\n    firstWorkInProgressHook = workInProgressHook = hook;\n  } else {\n    // Append to the end of the list\n    workInProgressHook = workInProgressHook.next = hook;\n  }\n\n  return workInProgressHook;\n}\n\nfunction updateWorkInProgressHook() {\n  // This function is used both for updates and for re-renders triggered by a\n  // render phase update. It assumes there is either a current hook we can\n  // clone, or a work-in-progress hook from a previous render pass that we can\n  // use as a base. When we reach the end of the base list, we must switch to\n  // the dispatcher used for mounts.\n  if (nextWorkInProgressHook !== null) {\n    // There's already a work-in-progress. Reuse it.\n    workInProgressHook = nextWorkInProgressHook;\n    nextWorkInProgressHook = workInProgressHook.next;\n    currentHook = nextCurrentHook;\n    nextCurrentHook = currentHook !== null ? currentHook.next : null;\n  } else {\n    // Clone from the current hook.\n    invariant(nextCurrentHook !== null, 'Rendered more hooks than during the previous render.');\n    currentHook = nextCurrentHook;\n    const newHook = {\n      memoizedState: currentHook.memoizedState,\n      baseState: currentHook.baseState,\n      queue: currentHook.queue,\n      baseUpdate: currentHook.baseUpdate,\n      next: null\n    };\n\n    if (workInProgressHook === null) {\n      // This is the first hook in the list.\n      workInProgressHook = firstWorkInProgressHook = newHook;\n    } else {\n      // Append to the end of the list.\n      workInProgressHook = workInProgressHook.next = newHook;\n    }\n\n    nextCurrentHook = currentHook.next;\n  }\n\n  return workInProgressHook;\n}\n\nfunction createFunctionComponentUpdateQueue() {\n  return {\n    lastEffect: null\n  };\n}\n\nfunction basicStateReducer(state, action) {\n  return typeof action === 'function' ? action(state) : action;\n}\n\nfunction mountReducer(reducer, initialArg, init) {\n  const hook = mountWorkInProgressHook();\n  let initialState;\n\n  if (init !== undefined) {\n    initialState = init(initialArg);\n  } else {\n    initialState = initialArg;\n  }\n\n  hook.memoizedState = hook.baseState = initialState;\n  const queue = hook.queue = {\n    last: null,\n    dispatch: null,\n    lastRenderedReducer: reducer,\n    lastRenderedState: initialState\n  };\n  const dispatch = queue.dispatch = dispatchAction.bind(null, // Flow doesn't know this is non-null, but we do.\n  currentlyRenderingFiber, queue);\n  return [hook.memoizedState, dispatch];\n}\n\nfunction updateReducer(reducer, initialArg, init) {\n  const hook = updateWorkInProgressHook();\n  const queue = hook.queue;\n  invariant(queue !== null, 'Should have a queue. This is likely a bug in React. Please file an issue.');\n  queue.lastRenderedReducer = reducer;\n\n  if (numberOfReRenders > 0) {\n    // This is a re-render. Apply the new render phase updates to the previous\n    // work-in-progress hook.\n    const dispatch = queue.dispatch;\n\n    if (renderPhaseUpdates !== null) {\n      // Render phase updates are stored in a map of queue -> linked list\n      const firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);\n\n      if (firstRenderPhaseUpdate !== undefined) {\n        renderPhaseUpdates.delete(queue);\n        let newState = hook.memoizedState;\n        let update = firstRenderPhaseUpdate;\n\n        do {\n          // Process this render phase update. We don't have to check the\n          // priority because it will always be the same as the current\n          // render's.\n          const action = update.action;\n          newState = reducer(newState, action);\n          update = update.next;\n        } while (update !== null); // Mark that the fiber performed work, but only if the new state is\n        // different from the current state.\n\n\n        if (!is(newState, hook.memoizedState)) {\n          markWorkInProgressReceivedUpdate();\n        }\n\n        hook.memoizedState = newState; // Don't persist the state accumulated from the render phase updates to\n        // the base state unless the queue is empty.\n        // TODO: Not sure if this is the desired semantics, but it's what we\n        // do for gDSFP. I can't remember why.\n\n        if (hook.baseUpdate === queue.last) {\n          hook.baseState = newState;\n        }\n\n        queue.lastRenderedState = newState;\n        return [newState, dispatch];\n      }\n    }\n\n    return [hook.memoizedState, dispatch];\n  } // The last update in the entire queue\n\n\n  const last = queue.last; // The last update that is part of the base state.\n\n  const baseUpdate = hook.baseUpdate;\n  const baseState = hook.baseState; // Find the first unprocessed update.\n\n  let first;\n\n  if (baseUpdate !== null) {\n    if (last !== null) {\n      // For the first update, the queue is a circular linked list where\n      // `queue.last.next = queue.first`. Once the first update commits, and\n      // the `baseUpdate` is no longer empty, we can unravel the list.\n      last.next = null;\n    }\n\n    first = baseUpdate.next;\n  } else {\n    first = last !== null ? last.next : null;\n  }\n\n  if (first !== null) {\n    let newState = baseState;\n    let newBaseState = null;\n    let newBaseUpdate = null;\n    let prevUpdate = baseUpdate;\n    let update = first;\n    let didSkip = false;\n\n    do {\n      const updateExpirationTime = update.expirationTime;\n\n      if (updateExpirationTime < renderExpirationTime) {\n        // Priority is insufficient. Skip this update. If this is the first\n        // skipped update, the previous update/state is the new base\n        // update/state.\n        if (!didSkip) {\n          didSkip = true;\n          newBaseUpdate = prevUpdate;\n          newBaseState = newState;\n        } // Update the remaining priority in the queue.\n\n\n        if (updateExpirationTime > remainingExpirationTime) {\n          remainingExpirationTime = updateExpirationTime;\n          markUnprocessedUpdateTime(remainingExpirationTime);\n        }\n      } else {\n        // This update does have sufficient priority.\n        // Mark the event time of this update as relevant to this render pass.\n        // TODO: This should ideally use the true event time of this update rather than\n        // its priority which is a derived and not reverseable value.\n        // TODO: We should skip this update if it was already committed but currently\n        // we have no way of detecting the difference between a committed and suspended\n        // update here.\n        markRenderEventTimeAndConfig(updateExpirationTime, update.suspenseConfig); // Process this update.\n\n        if (update.eagerReducer === reducer) {\n          // If this update was processed eagerly, and its reducer matches the\n          // current reducer, we can use the eagerly computed state.\n          newState = update.eagerState;\n        } else {\n          const action = update.action;\n          newState = reducer(newState, action);\n        }\n      }\n\n      prevUpdate = update;\n      update = update.next;\n    } while (update !== null && update !== first);\n\n    if (!didSkip) {\n      newBaseUpdate = prevUpdate;\n      newBaseState = newState;\n    } // Mark that the fiber performed work, but only if the new state is\n    // different from the current state.\n\n\n    if (!is(newState, hook.memoizedState)) {\n      markWorkInProgressReceivedUpdate();\n    }\n\n    hook.memoizedState = newState;\n    hook.baseUpdate = newBaseUpdate;\n    hook.baseState = newBaseState;\n    queue.lastRenderedState = newState;\n  }\n\n  const dispatch = queue.dispatch;\n  return [hook.memoizedState, dispatch];\n}\n\nfunction mountState(initialState) {\n  const hook = mountWorkInProgressHook();\n\n  if (typeof initialState === 'function') {\n    initialState = initialState();\n  }\n\n  hook.memoizedState = hook.baseState = initialState;\n  const queue = hook.queue = {\n    last: null,\n    dispatch: null,\n    lastRenderedReducer: basicStateReducer,\n    lastRenderedState: initialState\n  };\n  const dispatch = queue.dispatch = dispatchAction.bind(null, // Flow doesn't know this is non-null, but we do.\n  currentlyRenderingFiber, queue);\n  return [hook.memoizedState, dispatch];\n}\n\nfunction updateState(initialState) {\n  return updateReducer(basicStateReducer, initialState);\n}\n\nfunction pushEffect(tag, create, destroy, deps) {\n  const effect = {\n    tag,\n    create,\n    destroy,\n    deps,\n    // Circular\n    next: null\n  };\n\n  if (componentUpdateQueue === null) {\n    componentUpdateQueue = createFunctionComponentUpdateQueue();\n    componentUpdateQueue.lastEffect = effect.next = effect;\n  } else {\n    const lastEffect = componentUpdateQueue.lastEffect;\n\n    if (lastEffect === null) {\n      componentUpdateQueue.lastEffect = effect.next = effect;\n    } else {\n      const firstEffect = lastEffect.next;\n      lastEffect.next = effect;\n      effect.next = firstEffect;\n      componentUpdateQueue.lastEffect = effect;\n    }\n  }\n\n  return effect;\n}\n\nfunction mountRef(initialValue) {\n  const hook = mountWorkInProgressHook();\n  const ref = {\n    current: initialValue\n  };\n\n  if (__DEV__) {\n    Object.seal(ref);\n  }\n\n  hook.memoizedState = ref;\n  return ref;\n}\n\nfunction updateRef(initialValue) {\n  const hook = updateWorkInProgressHook();\n  return hook.memoizedState;\n}\n\nfunction mountEffectImpl(fiberEffectTag, hookEffectTag, create, deps) {\n  const hook = mountWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  sideEffectTag |= fiberEffectTag;\n  hook.memoizedState = pushEffect(hookEffectTag, create, undefined, nextDeps);\n}\n\nfunction updateEffectImpl(fiberEffectTag, hookEffectTag, create, deps) {\n  const hook = updateWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  let destroy = undefined;\n\n  if (currentHook !== null) {\n    const prevEffect = currentHook.memoizedState;\n    destroy = prevEffect.destroy;\n\n    if (nextDeps !== null) {\n      const prevDeps = prevEffect.deps;\n\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        pushEffect(NoHookEffect, create, destroy, nextDeps);\n        return;\n      }\n    }\n  }\n\n  sideEffectTag |= fiberEffectTag;\n  hook.memoizedState = pushEffect(hookEffectTag, create, destroy, nextDeps);\n}\n\nfunction mountEffect(create, deps) {\n  if (__DEV__) {\n    // $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests\n    if ('undefined' !== typeof jest) {\n      warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber);\n    }\n  }\n\n  return mountEffectImpl(UpdateEffect | PassiveEffect, UnmountPassive | MountPassive, create, deps);\n}\n\nfunction updateEffect(create, deps) {\n  if (__DEV__) {\n    // $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests\n    if ('undefined' !== typeof jest) {\n      warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber);\n    }\n  }\n\n  return updateEffectImpl(UpdateEffect | PassiveEffect, UnmountPassive | MountPassive, create, deps);\n}\n\nfunction mountLayoutEffect(create, deps) {\n  return mountEffectImpl(UpdateEffect, UnmountMutation | MountLayout, create, deps);\n}\n\nfunction updateLayoutEffect(create, deps) {\n  return updateEffectImpl(UpdateEffect, UnmountMutation | MountLayout, create, deps);\n}\n\nfunction imperativeHandleEffect(create, ref) {\n  if (typeof ref === 'function') {\n    const refCallback = ref;\n    const inst = create();\n    refCallback(inst);\n    return () => {\n      refCallback(null);\n    };\n  } else if (ref !== null && ref !== undefined) {\n    const refObject = ref;\n\n    if (__DEV__) {\n      warning(refObject.hasOwnProperty('current'), 'Expected useImperativeHandle() first argument to either be a ' + 'ref callback or React.createRef() object. Instead received: %s.', 'an object with keys {' + Object.keys(refObject).join(', ') + '}');\n    }\n\n    const inst = create();\n    refObject.current = inst;\n    return () => {\n      refObject.current = null;\n    };\n  }\n}\n\nfunction mountImperativeHandle(ref, create, deps) {\n  if (__DEV__) {\n    warning(typeof create === 'function', 'Expected useImperativeHandle() second argument to be a function ' + 'that creates a handle. Instead received: %s.', create !== null ? typeof create : 'null');\n  } // TODO: If deps are provided, should we skip comparing the ref itself?\n\n\n  const effectDeps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;\n  return mountEffectImpl(UpdateEffect, UnmountMutation | MountLayout, imperativeHandleEffect.bind(null, create, ref), effectDeps);\n}\n\nfunction updateImperativeHandle(ref, create, deps) {\n  if (__DEV__) {\n    warning(typeof create === 'function', 'Expected useImperativeHandle() second argument to be a function ' + 'that creates a handle. Instead received: %s.', create !== null ? typeof create : 'null');\n  } // TODO: If deps are provided, should we skip comparing the ref itself?\n\n\n  const effectDeps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;\n  return updateEffectImpl(UpdateEffect, UnmountMutation | MountLayout, imperativeHandleEffect.bind(null, create, ref), effectDeps);\n}\n\nfunction mountDebugValue(value, formatterFn) {// This hook is normally a no-op.\n  // The react-debug-hooks package injects its own implementation\n  // so that e.g. DevTools can display custom hook values.\n}\n\nconst updateDebugValue = mountDebugValue;\n\nfunction mountCallback(callback, deps) {\n  const hook = mountWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  hook.memoizedState = [callback, nextDeps];\n  return callback;\n}\n\nfunction updateCallback(callback, deps) {\n  const hook = updateWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  const prevState = hook.memoizedState;\n\n  if (prevState !== null) {\n    if (nextDeps !== null) {\n      const prevDeps = prevState[1];\n\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        return prevState[0];\n      }\n    }\n  }\n\n  hook.memoizedState = [callback, nextDeps];\n  return callback;\n}\n\nfunction mountMemo(nextCreate, deps) {\n  const hook = mountWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  const nextValue = nextCreate();\n  hook.memoizedState = [nextValue, nextDeps];\n  return nextValue;\n}\n\nfunction updateMemo(nextCreate, deps) {\n  const hook = updateWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  const prevState = hook.memoizedState;\n\n  if (prevState !== null) {\n    // Assume these are defined. If they're not, areHookInputsEqual will warn.\n    if (nextDeps !== null) {\n      const prevDeps = prevState[1];\n\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        return prevState[0];\n      }\n    }\n  }\n\n  const nextValue = nextCreate();\n  hook.memoizedState = [nextValue, nextDeps];\n  return nextValue;\n}\n\nfunction mountDeferredValue(value, config) {\n  const [prevValue, setValue] = mountState(value);\n  mountEffect(() => {\n    const previousConfig = ReactCurrentBatchConfig.suspense;\n    ReactCurrentBatchConfig.suspense = config === undefined ? null : config;\n\n    try {\n      setValue(value);\n    } finally {\n      ReactCurrentBatchConfig.suspense = previousConfig;\n    }\n  }, [value, config]);\n  return prevValue;\n}\n\nfunction updateDeferredValue(value, config) {\n  const [prevValue, setValue] = updateState(value);\n  updateEffect(() => {\n    const previousConfig = ReactCurrentBatchConfig.suspense;\n    ReactCurrentBatchConfig.suspense = config === undefined ? null : config;\n\n    try {\n      setValue(value);\n    } finally {\n      ReactCurrentBatchConfig.suspense = previousConfig;\n    }\n  }, [value, config]);\n  return prevValue;\n}\n\nfunction startTransition(setPending, config, callback) {\n  const priorityLevel = getCurrentPriorityLevel();\n  runWithPriority(priorityLevel < UserBlockingPriority ? UserBlockingPriority : priorityLevel, () => {\n    setPending(true);\n  });\n  runWithPriority(priorityLevel > NormalPriority ? NormalPriority : priorityLevel, () => {\n    const previousConfig = ReactCurrentBatchConfig.suspense;\n    ReactCurrentBatchConfig.suspense = config === undefined ? null : config;\n\n    try {\n      setPending(false);\n      callback();\n    } finally {\n      ReactCurrentBatchConfig.suspense = previousConfig;\n    }\n  });\n}\n\nfunction mountTransition(config) {\n  const [isPending, setPending] = mountState(false);\n  const start = mountCallback(startTransition.bind(null, setPending, config), [setPending, config]);\n  return [start, isPending];\n}\n\nfunction updateTransition(config) {\n  const [isPending, setPending] = updateState(false);\n  const start = updateCallback(startTransition.bind(null, setPending, config), [setPending, config]);\n  return [start, isPending];\n}\n\nfunction dispatchAction(fiber, queue, action) {\n  invariant(numberOfReRenders < RE_RENDER_LIMIT, 'Too many re-renders. React limits the number of renders to prevent ' + 'an infinite loop.');\n\n  if (__DEV__) {\n    warning(typeof arguments[3] !== 'function', \"State updates from the useState() and useReducer() Hooks don't support the \" + 'second callback argument. To execute a side effect after ' + 'rendering, declare it in the component body with useEffect().');\n  }\n\n  const alternate = fiber.alternate;\n\n  if (fiber === currentlyRenderingFiber || alternate !== null && alternate === currentlyRenderingFiber) {\n    // This is a render phase update. Stash it in a lazily-created map of\n    // queue -> linked list of updates. After this render pass, we'll restart\n    // and apply the stashed updates on top of the work-in-progress hook.\n    didScheduleRenderPhaseUpdate = true;\n    const update = {\n      expirationTime: renderExpirationTime,\n      suspenseConfig: null,\n      action,\n      eagerReducer: null,\n      eagerState: null,\n      next: null\n    };\n\n    if (__DEV__) {\n      update.priority = getCurrentPriorityLevel();\n    }\n\n    if (renderPhaseUpdates === null) {\n      renderPhaseUpdates = new Map();\n    }\n\n    const firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);\n\n    if (firstRenderPhaseUpdate === undefined) {\n      renderPhaseUpdates.set(queue, update);\n    } else {\n      // Append the update to the end of the list.\n      let lastRenderPhaseUpdate = firstRenderPhaseUpdate;\n\n      while (lastRenderPhaseUpdate.next !== null) {\n        lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;\n      }\n\n      lastRenderPhaseUpdate.next = update;\n    }\n  } else {\n    const currentTime = requestCurrentTimeForUpdate();\n    const suspenseConfig = requestCurrentSuspenseConfig();\n    const expirationTime = computeExpirationForFiber(currentTime, fiber, suspenseConfig);\n    const update = {\n      expirationTime,\n      suspenseConfig,\n      action,\n      eagerReducer: null,\n      eagerState: null,\n      next: null\n    };\n\n    if (__DEV__) {\n      update.priority = getCurrentPriorityLevel();\n    } // Append the update to the end of the list.\n\n\n    const last = queue.last;\n\n    if (last === null) {\n      // This is the first update. Create a circular list.\n      update.next = update;\n    } else {\n      const first = last.next;\n\n      if (first !== null) {\n        // Still circular.\n        update.next = first;\n      }\n\n      last.next = update;\n    }\n\n    queue.last = update;\n\n    if (fiber.expirationTime === NoWork && (alternate === null || alternate.expirationTime === NoWork)) {\n      // The queue is currently empty, which means we can eagerly compute the\n      // next state before entering the render phase. If the new state is the\n      // same as the current state, we may be able to bail out entirely.\n      const lastRenderedReducer = queue.lastRenderedReducer;\n\n      if (lastRenderedReducer !== null) {\n        let prevDispatcher;\n\n        if (__DEV__) {\n          prevDispatcher = ReactCurrentDispatcher.current;\n          ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n        }\n\n        try {\n          const currentState = queue.lastRenderedState;\n          const eagerState = lastRenderedReducer(currentState, action); // Stash the eagerly computed state, and the reducer used to compute\n          // it, on the update object. If the reducer hasn't changed by the\n          // time we enter the render phase, then the eager state can be used\n          // without calling the reducer again.\n\n          update.eagerReducer = lastRenderedReducer;\n          update.eagerState = eagerState;\n\n          if (is(eagerState, currentState)) {\n            // Fast path. We can bail out without scheduling React to re-render.\n            // It's still possible that we'll need to rebase this update later,\n            // if the component re-renders for a different reason and by that\n            // time the reducer has changed.\n            return;\n          }\n        } catch (error) {// Suppress the error. It will throw again in the render phase.\n        } finally {\n          if (__DEV__) {\n            ReactCurrentDispatcher.current = prevDispatcher;\n          }\n        }\n      }\n    }\n\n    if (__DEV__) {\n      // $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests\n      if ('undefined' !== typeof jest) {\n        warnIfNotScopedWithMatchingAct(fiber);\n        warnIfNotCurrentlyActingUpdatesInDev(fiber);\n      }\n    }\n\n    scheduleWork(fiber, expirationTime);\n  }\n}\n\nexport const ContextOnlyDispatcher = {\n  readContext,\n  useCallback: throwInvalidHookError,\n  useContext: throwInvalidHookError,\n  useEffect: throwInvalidHookError,\n  useImperativeHandle: throwInvalidHookError,\n  useLayoutEffect: throwInvalidHookError,\n  useMemo: throwInvalidHookError,\n  useReducer: throwInvalidHookError,\n  useRef: throwInvalidHookError,\n  useState: throwInvalidHookError,\n  useDebugValue: throwInvalidHookError,\n  useResponder: throwInvalidHookError,\n  useDeferredValue: throwInvalidHookError,\n  useTransition: throwInvalidHookError\n};\nconst HooksDispatcherOnMount = {\n  readContext,\n  useCallback: mountCallback,\n  useContext: readContext,\n  useEffect: mountEffect,\n  useImperativeHandle: mountImperativeHandle,\n  useLayoutEffect: mountLayoutEffect,\n  useMemo: mountMemo,\n  useReducer: mountReducer,\n  useRef: mountRef,\n  useState: mountState,\n  useDebugValue: mountDebugValue,\n  useResponder: createResponderListener,\n  useDeferredValue: mountDeferredValue,\n  useTransition: mountTransition\n};\nconst HooksDispatcherOnUpdate = {\n  readContext,\n  useCallback: updateCallback,\n  useContext: readContext,\n  useEffect: updateEffect,\n  useImperativeHandle: updateImperativeHandle,\n  useLayoutEffect: updateLayoutEffect,\n  useMemo: updateMemo,\n  useReducer: updateReducer,\n  useRef: updateRef,\n  useState: updateState,\n  useDebugValue: updateDebugValue,\n  useResponder: createResponderListener,\n  useDeferredValue: updateDeferredValue,\n  useTransition: updateTransition\n};\nlet HooksDispatcherOnMountInDEV = null;\nlet HooksDispatcherOnMountWithHookTypesInDEV = null;\nlet HooksDispatcherOnUpdateInDEV = null;\nlet InvalidNestedHooksDispatcherOnMountInDEV = null;\nlet InvalidNestedHooksDispatcherOnUpdateInDEV = null;\n\nif (__DEV__) {\n  const warnInvalidContextAccess = () => {\n    warning(false, 'Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');\n  };\n\n  const warnInvalidHookAccess = () => {\n    warning(false, 'Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. ' + 'You can only call Hooks at the top level of your React function. ' + 'For more information, see ' + 'https://fb.me/rules-of-hooks');\n  };\n\n  HooksDispatcherOnMountInDEV = {\n    readContext(context, observedBits) {\n      return readContext(context, observedBits);\n    },\n\n    useCallback(callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountCallback(callback, deps);\n    },\n\n    useContext(context, observedBits) {\n      currentHookNameInDev = 'useContext';\n      mountHookTypesDev();\n      return readContext(context, observedBits);\n    },\n\n    useEffect(create, deps) {\n      currentHookNameInDev = 'useEffect';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountEffect(create, deps);\n    },\n\n    useImperativeHandle(ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountImperativeHandle(ref, create, deps);\n    },\n\n    useLayoutEffect(create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountLayoutEffect(create, deps);\n    },\n\n    useMemo(create, deps) {\n      currentHookNameInDev = 'useMemo';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useReducer(reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useRef(initialValue) {\n      currentHookNameInDev = 'useRef';\n      mountHookTypesDev();\n      return mountRef(initialValue);\n    },\n\n    useState(initialState) {\n      currentHookNameInDev = 'useState';\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useDebugValue(value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      mountHookTypesDev();\n      return mountDebugValue(value, formatterFn);\n    },\n\n    useResponder(responder, props) {\n      currentHookNameInDev = 'useResponder';\n      mountHookTypesDev();\n      return createResponderListener(responder, props);\n    },\n\n    useDeferredValue(value, config) {\n      currentHookNameInDev = 'useDeferredValue';\n      mountHookTypesDev();\n      return mountDeferredValue(value, config);\n    },\n\n    useTransition(config) {\n      currentHookNameInDev = 'useTransition';\n      mountHookTypesDev();\n      return mountTransition(config);\n    }\n\n  };\n  HooksDispatcherOnMountWithHookTypesInDEV = {\n    readContext(context, observedBits) {\n      return readContext(context, observedBits);\n    },\n\n    useCallback(callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      updateHookTypesDev();\n      return mountCallback(callback, deps);\n    },\n\n    useContext(context, observedBits) {\n      currentHookNameInDev = 'useContext';\n      updateHookTypesDev();\n      return readContext(context, observedBits);\n    },\n\n    useEffect(create, deps) {\n      currentHookNameInDev = 'useEffect';\n      updateHookTypesDev();\n      return mountEffect(create, deps);\n    },\n\n    useImperativeHandle(ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      updateHookTypesDev();\n      return mountImperativeHandle(ref, create, deps);\n    },\n\n    useLayoutEffect(create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      updateHookTypesDev();\n      return mountLayoutEffect(create, deps);\n    },\n\n    useMemo(create, deps) {\n      currentHookNameInDev = 'useMemo';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useReducer(reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useRef(initialValue) {\n      currentHookNameInDev = 'useRef';\n      updateHookTypesDev();\n      return mountRef(initialValue);\n    },\n\n    useState(initialState) {\n      currentHookNameInDev = 'useState';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useDebugValue(value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      updateHookTypesDev();\n      return mountDebugValue(value, formatterFn);\n    },\n\n    useResponder(responder, props) {\n      currentHookNameInDev = 'useResponder';\n      updateHookTypesDev();\n      return createResponderListener(responder, props);\n    },\n\n    useDeferredValue(value, config) {\n      currentHookNameInDev = 'useDeferredValue';\n      updateHookTypesDev();\n      return mountDeferredValue(value, config);\n    },\n\n    useTransition(config) {\n      currentHookNameInDev = 'useTransition';\n      updateHookTypesDev();\n      return mountTransition(config);\n    }\n\n  };\n  HooksDispatcherOnUpdateInDEV = {\n    readContext(context, observedBits) {\n      return readContext(context, observedBits);\n    },\n\n    useCallback(callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      updateHookTypesDev();\n      return updateCallback(callback, deps);\n    },\n\n    useContext(context, observedBits) {\n      currentHookNameInDev = 'useContext';\n      updateHookTypesDev();\n      return readContext(context, observedBits);\n    },\n\n    useEffect(create, deps) {\n      currentHookNameInDev = 'useEffect';\n      updateHookTypesDev();\n      return updateEffect(create, deps);\n    },\n\n    useImperativeHandle(ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      updateHookTypesDev();\n      return updateImperativeHandle(ref, create, deps);\n    },\n\n    useLayoutEffect(create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      updateHookTypesDev();\n      return updateLayoutEffect(create, deps);\n    },\n\n    useMemo(create, deps) {\n      currentHookNameInDev = 'useMemo';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useReducer(reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useRef(initialValue) {\n      currentHookNameInDev = 'useRef';\n      updateHookTypesDev();\n      return updateRef(initialValue);\n    },\n\n    useState(initialState) {\n      currentHookNameInDev = 'useState';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useDebugValue(value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      updateHookTypesDev();\n      return updateDebugValue(value, formatterFn);\n    },\n\n    useResponder(responder, props) {\n      currentHookNameInDev = 'useResponder';\n      updateHookTypesDev();\n      return createResponderListener(responder, props);\n    },\n\n    useDeferredValue(value, config) {\n      currentHookNameInDev = 'useDeferredValue';\n      updateHookTypesDev();\n      return updateDeferredValue(value, config);\n    },\n\n    useTransition(config) {\n      currentHookNameInDev = 'useTransition';\n      updateHookTypesDev();\n      return updateTransition(config);\n    }\n\n  };\n  InvalidNestedHooksDispatcherOnMountInDEV = {\n    readContext(context, observedBits) {\n      warnInvalidContextAccess();\n      return readContext(context, observedBits);\n    },\n\n    useCallback(callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountCallback(callback, deps);\n    },\n\n    useContext(context, observedBits) {\n      currentHookNameInDev = 'useContext';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return readContext(context, observedBits);\n    },\n\n    useEffect(create, deps) {\n      currentHookNameInDev = 'useEffect';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountEffect(create, deps);\n    },\n\n    useImperativeHandle(ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountImperativeHandle(ref, create, deps);\n    },\n\n    useLayoutEffect(create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountLayoutEffect(create, deps);\n    },\n\n    useMemo(create, deps) {\n      currentHookNameInDev = 'useMemo';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useReducer(reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useRef(initialValue) {\n      currentHookNameInDev = 'useRef';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountRef(initialValue);\n    },\n\n    useState(initialState) {\n      currentHookNameInDev = 'useState';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useDebugValue(value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountDebugValue(value, formatterFn);\n    },\n\n    useResponder(responder, props) {\n      currentHookNameInDev = 'useResponder';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return createResponderListener(responder, props);\n    },\n\n    useDeferredValue(value, config) {\n      currentHookNameInDev = 'useDeferredValue';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountDeferredValue(value, config);\n    },\n\n    useTransition(config) {\n      currentHookNameInDev = 'useTransition';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountTransition(config);\n    }\n\n  };\n  InvalidNestedHooksDispatcherOnUpdateInDEV = {\n    readContext(context, observedBits) {\n      warnInvalidContextAccess();\n      return readContext(context, observedBits);\n    },\n\n    useCallback(callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateCallback(callback, deps);\n    },\n\n    useContext(context, observedBits) {\n      currentHookNameInDev = 'useContext';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return readContext(context, observedBits);\n    },\n\n    useEffect(create, deps) {\n      currentHookNameInDev = 'useEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateEffect(create, deps);\n    },\n\n    useImperativeHandle(ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateImperativeHandle(ref, create, deps);\n    },\n\n    useLayoutEffect(create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateLayoutEffect(create, deps);\n    },\n\n    useMemo(create, deps) {\n      currentHookNameInDev = 'useMemo';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useReducer(reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useRef(initialValue) {\n      currentHookNameInDev = 'useRef';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateRef(initialValue);\n    },\n\n    useState(initialState) {\n      currentHookNameInDev = 'useState';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useDebugValue(value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateDebugValue(value, formatterFn);\n    },\n\n    useResponder(responder, props) {\n      currentHookNameInDev = 'useResponder';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return createResponderListener(responder, props);\n    },\n\n    useDeferredValue(value, config) {\n      currentHookNameInDev = 'useDeferredValue';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateDeferredValue(value, config);\n    },\n\n    useTransition(config) {\n      currentHookNameInDev = 'useTransition';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateTransition(config);\n    }\n\n  };\n}","map":{"version":3,"sources":["/Users/gaoshaoyun/Documents/library/debug-react/src/react/packages/react-reconciler/src/ReactFiberHooks.js"],"names":["ReactSharedInternals","NoWork","readContext","createResponderListener","Update","UpdateEffect","Passive","PassiveEffect","NoEffect","NoHookEffect","UnmountMutation","MountLayout","UnmountPassive","MountPassive","scheduleWork","computeExpirationForFiber","requestCurrentTimeForUpdate","warnIfNotCurrentlyActingEffectsInDEV","warnIfNotCurrentlyActingUpdatesInDev","warnIfNotScopedWithMatchingAct","markRenderEventTimeAndConfig","markUnprocessedUpdateTime","invariant","warning","getComponentName","is","markWorkInProgressReceivedUpdate","requestCurrentSuspenseConfig","UserBlockingPriority","NormalPriority","runWithPriority","getCurrentPriorityLevel","ReactCurrentDispatcher","ReactCurrentBatchConfig","didWarnAboutMismatchedHooksForComponent","__DEV__","Set","renderExpirationTime","currentlyRenderingFiber","currentHook","nextCurrentHook","firstWorkInProgressHook","workInProgressHook","nextWorkInProgressHook","remainingExpirationTime","componentUpdateQueue","sideEffectTag","didScheduleRenderPhaseUpdate","renderPhaseUpdates","numberOfReRenders","RE_RENDER_LIMIT","currentHookNameInDev","hookTypesDev","hookTypesUpdateIndexDev","ignorePreviousDependencies","mountHookTypesDev","hookName","push","updateHookTypesDev","warnOnHookMismatchInDev","checkDepsAreArrayDev","deps","undefined","Array","isArray","currentHookName","componentName","type","has","add","table","secondColumnStart","i","oldHookName","newHookName","row","length","throwInvalidHookError","areHookInputsEqual","nextDeps","prevDeps","join","renderWithHooks","current","workInProgress","Component","props","refOrContext","nextRenderExpirationTime","memoizedState","_debugHookTypes","HooksDispatcherOnUpdateInDEV","HooksDispatcherOnMountWithHookTypesInDEV","HooksDispatcherOnMountInDEV","HooksDispatcherOnMount","HooksDispatcherOnUpdate","children","ContextOnlyDispatcher","renderedWork","expirationTime","updateQueue","effectTag","didRenderTooFewHooks","next","bailoutHooks","resetHooks","mountWorkInProgressHook","hook","baseState","queue","baseUpdate","updateWorkInProgressHook","newHook","createFunctionComponentUpdateQueue","lastEffect","basicStateReducer","state","action","mountReducer","reducer","initialArg","init","initialState","last","dispatch","lastRenderedReducer","lastRenderedState","dispatchAction","bind","updateReducer","firstRenderPhaseUpdate","get","delete","newState","update","first","newBaseState","newBaseUpdate","prevUpdate","didSkip","updateExpirationTime","suspenseConfig","eagerReducer","eagerState","mountState","updateState","pushEffect","tag","create","destroy","effect","firstEffect","mountRef","initialValue","ref","Object","seal","updateRef","mountEffectImpl","fiberEffectTag","hookEffectTag","updateEffectImpl","prevEffect","mountEffect","jest","updateEffect","mountLayoutEffect","updateLayoutEffect","imperativeHandleEffect","refCallback","inst","refObject","hasOwnProperty","keys","mountImperativeHandle","effectDeps","concat","updateImperativeHandle","mountDebugValue","value","formatterFn","updateDebugValue","mountCallback","callback","updateCallback","prevState","mountMemo","nextCreate","nextValue","updateMemo","mountDeferredValue","config","prevValue","setValue","previousConfig","suspense","updateDeferredValue","startTransition","setPending","priorityLevel","mountTransition","isPending","start","updateTransition","fiber","arguments","alternate","priority","Map","set","lastRenderPhaseUpdate","currentTime","prevDispatcher","InvalidNestedHooksDispatcherOnUpdateInDEV","currentState","error","useCallback","useContext","useEffect","useImperativeHandle","useLayoutEffect","useMemo","useReducer","useRef","useState","useDebugValue","useResponder","useDeferredValue","useTransition","InvalidNestedHooksDispatcherOnMountInDEV","warnInvalidContextAccess","warnInvalidHookAccess","context","observedBits","responder"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {\n  ReactEventResponder,\n  ReactContext,\n  ReactEventResponderListener,\n} from 'shared/ReactTypes';\nimport type {SideEffectTag} from 'shared/ReactSideEffectTags';\nimport type {Fiber} from './ReactFiber';\nimport type {ExpirationTime} from './ReactFiberExpirationTime';\nimport type {HookEffectTag} from './ReactHookEffectTags';\nimport type {SuspenseConfig} from './ReactFiberSuspenseConfig';\nimport type {ReactPriorityLevel} from './SchedulerWithReactIntegration';\n\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\n\nimport {NoWork} from './ReactFiberExpirationTime';\nimport {readContext} from './ReactFiberNewContext';\nimport {createResponderListener} from './ReactFiberEvents';\nimport {\n  Update as UpdateEffect,\n  Passive as PassiveEffect,\n} from 'shared/ReactSideEffectTags';\nimport {\n  NoEffect as NoHookEffect,\n  UnmountMutation,\n  MountLayout,\n  UnmountPassive,\n  MountPassive,\n} from './ReactHookEffectTags';\nimport {\n  scheduleWork,\n  computeExpirationForFiber,\n  requestCurrentTimeForUpdate,\n  warnIfNotCurrentlyActingEffectsInDEV,\n  warnIfNotCurrentlyActingUpdatesInDev,\n  warnIfNotScopedWithMatchingAct,\n  markRenderEventTimeAndConfig,\n  markUnprocessedUpdateTime,\n} from './ReactFiberWorkLoop';\n\nimport invariant from 'shared/invariant';\nimport warning from 'shared/warning';\nimport getComponentName from 'shared/getComponentName';\nimport is from 'shared/objectIs';\nimport {markWorkInProgressReceivedUpdate} from './ReactFiberBeginWork';\nimport {requestCurrentSuspenseConfig} from './ReactFiberSuspenseConfig';\nimport {\n  UserBlockingPriority,\n  NormalPriority,\n  runWithPriority,\n  getCurrentPriorityLevel,\n} from './SchedulerWithReactIntegration';\n\nconst {ReactCurrentDispatcher, ReactCurrentBatchConfig} = ReactSharedInternals;\n\nexport type Dispatcher = {\n  readContext<T>(\n    context: ReactContext<T>,\n    observedBits: void | number | boolean,\n  ): T,\n  useState<S>(initialState: (() => S) | S): [S, Dispatch<BasicStateAction<S>>],\n  useReducer<S, I, A>(\n    reducer: (S, A) => S,\n    initialArg: I,\n    init?: (I) => S,\n  ): [S, Dispatch<A>],\n  useContext<T>(\n    context: ReactContext<T>,\n    observedBits: void | number | boolean,\n  ): T,\n  useRef<T>(initialValue: T): {current: T},\n  useEffect(\n    create: () => (() => void) | void,\n    deps: Array<mixed> | void | null,\n  ): void,\n  useLayoutEffect(\n    create: () => (() => void) | void,\n    deps: Array<mixed> | void | null,\n  ): void,\n  useCallback<T>(callback: T, deps: Array<mixed> | void | null): T,\n  useMemo<T>(nextCreate: () => T, deps: Array<mixed> | void | null): T,\n  useImperativeHandle<T>(\n    ref: {current: T | null} | ((inst: T | null) => mixed) | null | void,\n    create: () => T,\n    deps: Array<mixed> | void | null,\n  ): void,\n  useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void,\n  useResponder<E, C>(\n    responder: ReactEventResponder<E, C>,\n    props: Object,\n  ): ReactEventResponderListener<E, C>,\n  useDeferredValue<T>(value: T, config: TimeoutConfig | void | null): T,\n  useTransition(\n    config: SuspenseConfig | void | null,\n  ): [(() => void) => void, boolean],\n};\n\ntype Update<S, A> = {\n  expirationTime: ExpirationTime,\n  suspenseConfig: null | SuspenseConfig,\n  action: A,\n  eagerReducer: ((S, A) => S) | null,\n  eagerState: S | null,\n  next: Update<S, A> | null,\n\n  priority?: ReactPriorityLevel,\n};\n\ntype UpdateQueue<S, A> = {\n  last: Update<S, A> | null,\n  dispatch: (A => mixed) | null,\n  lastRenderedReducer: ((S, A) => S) | null,\n  lastRenderedState: S | null,\n};\n\nexport type HookType =\n  | 'useState'\n  | 'useReducer'\n  | 'useContext'\n  | 'useRef'\n  | 'useEffect'\n  | 'useLayoutEffect'\n  | 'useCallback'\n  | 'useMemo'\n  | 'useImperativeHandle'\n  | 'useDebugValue'\n  | 'useResponder'\n  | 'useDeferredValue'\n  | 'useTransition';\n\nlet didWarnAboutMismatchedHooksForComponent;\nif (__DEV__) {\n  didWarnAboutMismatchedHooksForComponent = new Set();\n}\n\nexport type Hook = {\n  memoizedState: any,\n\n  baseState: any,\n  baseUpdate: Update<any, any> | null,\n  queue: UpdateQueue<any, any> | null,\n\n  next: Hook | null,\n};\n\ntype Effect = {\n  tag: HookEffectTag,\n  create: () => (() => void) | void,\n  destroy: (() => void) | void,\n  deps: Array<mixed> | null,\n  next: Effect,\n};\n\nexport type FunctionComponentUpdateQueue = {\n  lastEffect: Effect | null,\n};\n\nexport type TimeoutConfig = {|\n  timeoutMs: number,\n|};\n\ntype BasicStateAction<S> = (S => S) | S;\n\ntype Dispatch<A> = A => void;\n\n// These are set right before calling the component.\nlet renderExpirationTime: ExpirationTime = NoWork;\n// The work-in-progress fiber. I've named it differently to distinguish it from\n// the work-in-progress hook.\nlet currentlyRenderingFiber: Fiber | null = null;\n\n// Hooks are stored as a linked list on the fiber's memoizedState field. The\n// current hook list is the list that belongs to the current fiber. The\n// work-in-progress hook list is a new list that will be added to the\n// work-in-progress fiber.\nlet currentHook: Hook | null = null;\nlet nextCurrentHook: Hook | null = null;\nlet firstWorkInProgressHook: Hook | null = null;\nlet workInProgressHook: Hook | null = null;\nlet nextWorkInProgressHook: Hook | null = null;\n\nlet remainingExpirationTime: ExpirationTime = NoWork;\nlet componentUpdateQueue: FunctionComponentUpdateQueue | null = null;\nlet sideEffectTag: SideEffectTag = 0;\n\n// Updates scheduled during render will trigger an immediate re-render at the\n// end of the current pass. We can't store these updates on the normal queue,\n// because if the work is aborted, they should be discarded. Because this is\n// a relatively rare case, we also don't want to add an additional field to\n// either the hook or queue object types. So we store them in a lazily create\n// map of queue -> render-phase updates, which are discarded once the component\n// completes without re-rendering.\n\n// Whether an update was scheduled during the currently executing render pass.\nlet didScheduleRenderPhaseUpdate: boolean = false;\n// Lazily created map of render-phase updates\nlet renderPhaseUpdates: Map<\n  UpdateQueue<any, any>,\n  Update<any, any>,\n> | null = null;\n// Counter to prevent infinite loops.\nlet numberOfReRenders: number = 0;\nconst RE_RENDER_LIMIT = 25;\n\n// In DEV, this is the name of the currently executing primitive hook\nlet currentHookNameInDev: ?HookType = null;\n\n// In DEV, this list ensures that hooks are called in the same order between renders.\n// The list stores the order of hooks used during the initial render (mount).\n// Subsequent renders (updates) reference this list.\nlet hookTypesDev: Array<HookType> | null = null;\nlet hookTypesUpdateIndexDev: number = -1;\n\n// In DEV, this tracks whether currently rendering component needs to ignore\n// the dependencies for Hooks that need them (e.g. useEffect or useMemo).\n// When true, such Hooks will always be \"remounted\". Only used during hot reload.\nlet ignorePreviousDependencies: boolean = false;\n\nfunction mountHookTypesDev() {\n  if (__DEV__) {\n    const hookName = ((currentHookNameInDev: any): HookType);\n\n    if (hookTypesDev === null) {\n      hookTypesDev = [hookName];\n    } else {\n      hookTypesDev.push(hookName);\n    }\n  }\n}\n\nfunction updateHookTypesDev() {\n  if (__DEV__) {\n    const hookName = ((currentHookNameInDev: any): HookType);\n\n    if (hookTypesDev !== null) {\n      hookTypesUpdateIndexDev++;\n      if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {\n        warnOnHookMismatchInDev(hookName);\n      }\n    }\n  }\n}\n\nfunction checkDepsAreArrayDev(deps: mixed) {\n  if (__DEV__) {\n    if (deps !== undefined && deps !== null && !Array.isArray(deps)) {\n      // Verify deps, but only on mount to avoid extra checks.\n      // It's unlikely their type would change as usually you define them inline.\n      warning(\n        false,\n        '%s received a final argument that is not an array (instead, received `%s`). When ' +\n          'specified, the final argument must be an array.',\n        currentHookNameInDev,\n        typeof deps,\n      );\n    }\n  }\n}\n\nfunction warnOnHookMismatchInDev(currentHookName: HookType) {\n  if (__DEV__) {\n    const componentName = getComponentName(\n      ((currentlyRenderingFiber: any): Fiber).type,\n    );\n    if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {\n      didWarnAboutMismatchedHooksForComponent.add(componentName);\n\n      if (hookTypesDev !== null) {\n        let table = '';\n\n        const secondColumnStart = 30;\n\n        for (let i = 0; i <= ((hookTypesUpdateIndexDev: any): number); i++) {\n          const oldHookName = hookTypesDev[i];\n          const newHookName =\n            i === ((hookTypesUpdateIndexDev: any): number)\n              ? currentHookName\n              : oldHookName;\n\n          let row = `${i + 1}. ${oldHookName}`;\n\n          // Extra space so second column lines up\n          // lol @ IE not supporting String#repeat\n          while (row.length < secondColumnStart) {\n            row += ' ';\n          }\n\n          row += newHookName + '\\n';\n\n          table += row;\n        }\n\n        warning(\n          false,\n          'React has detected a change in the order of Hooks called by %s. ' +\n            'This will lead to bugs and errors if not fixed. ' +\n            'For more information, read the Rules of Hooks: https://fb.me/rules-of-hooks\\n\\n' +\n            '   Previous render            Next render\\n' +\n            '   ------------------------------------------------------\\n' +\n            '%s' +\n            '   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n',\n          componentName,\n          table,\n        );\n      }\n    }\n  }\n}\n\nfunction throwInvalidHookError() {\n  invariant(\n    false,\n    'Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' +\n      ' one of the following reasons:\\n' +\n      '1. You might have mismatching versions of React and the renderer (such as React DOM)\\n' +\n      '2. You might be breaking the Rules of Hooks\\n' +\n      '3. You might have more than one copy of React in the same app\\n' +\n      'See https://fb.me/react-invalid-hook-call for tips about how to debug and fix this problem.',\n  );\n}\n\nfunction areHookInputsEqual(\n  nextDeps: Array<mixed>,\n  prevDeps: Array<mixed> | null,\n) {\n  if (__DEV__) {\n    if (ignorePreviousDependencies) {\n      // Only true when this component is being hot reloaded.\n      return false;\n    }\n  }\n\n  if (prevDeps === null) {\n    if (__DEV__) {\n      warning(\n        false,\n        '%s received a final argument during this render, but not during ' +\n          'the previous render. Even though the final argument is optional, ' +\n          'its type cannot change between renders.',\n        currentHookNameInDev,\n      );\n    }\n    return false;\n  }\n\n  if (__DEV__) {\n    // Don't bother comparing lengths in prod because these arrays should be\n    // passed inline.\n    if (nextDeps.length !== prevDeps.length) {\n      warning(\n        false,\n        'The final argument passed to %s changed size between renders. The ' +\n          'order and size of this array must remain constant.\\n\\n' +\n          'Previous: %s\\n' +\n          'Incoming: %s',\n        currentHookNameInDev,\n        `[${prevDeps.join(', ')}]`,\n        `[${nextDeps.join(', ')}]`,\n      );\n    }\n  }\n  for (let i = 0; i < prevDeps.length && i < nextDeps.length; i++) {\n    if (is(nextDeps[i], prevDeps[i])) {\n      continue;\n    }\n    return false;\n  }\n  return true;\n}\n\nexport function renderWithHooks(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  Component: any,\n  props: any,\n  refOrContext: any,\n  nextRenderExpirationTime: ExpirationTime,\n): any {\n  renderExpirationTime = nextRenderExpirationTime;\n  currentlyRenderingFiber = workInProgress;\n  nextCurrentHook = current !== null ? current.memoizedState : null;\n\n  if (__DEV__) {\n    hookTypesDev =\n      current !== null\n        ? ((current._debugHookTypes: any): Array<HookType>)\n        : null;\n    hookTypesUpdateIndexDev = -1;\n    // Used for hot reloading:\n    ignorePreviousDependencies =\n      current !== null && current.type !== workInProgress.type;\n  }\n\n  // The following should have already been reset\n  // currentHook = null;\n  // workInProgressHook = null;\n\n  // remainingExpirationTime = NoWork;\n  // componentUpdateQueue = null;\n\n  // didScheduleRenderPhaseUpdate = false;\n  // renderPhaseUpdates = null;\n  // numberOfReRenders = 0;\n  // sideEffectTag = 0;\n\n  // TODO Warn if no hooks are used at all during mount, then some are used during update.\n  // Currently we will identify the update render as a mount because nextCurrentHook === null.\n  // This is tricky because it's valid for certain types of components (e.g. React.lazy)\n\n  // Using nextCurrentHook to differentiate between mount/update only works if at least one stateful hook is used.\n  // Non-stateful hooks (e.g. context) don't get added to memoizedState,\n  // so nextCurrentHook would be null during updates and mounts.\n  if (__DEV__) {\n    if (nextCurrentHook !== null) {\n      ReactCurrentDispatcher.current = HooksDispatcherOnUpdateInDEV;\n    } else if (hookTypesDev !== null) {\n      // This dispatcher handles an edge case where a component is updating,\n      // but no stateful hooks have been used.\n      // We want to match the production code behavior (which will use HooksDispatcherOnMount),\n      // but with the extra DEV validation to ensure hooks ordering hasn't changed.\n      // This dispatcher does that.\n      ReactCurrentDispatcher.current = HooksDispatcherOnMountWithHookTypesInDEV;\n    } else {\n      ReactCurrentDispatcher.current = HooksDispatcherOnMountInDEV;\n    }\n  } else {\n    ReactCurrentDispatcher.current =\n      nextCurrentHook === null\n        ? HooksDispatcherOnMount\n        : HooksDispatcherOnUpdate;\n  }\n\n  let children = Component(props, refOrContext);\n\n  if (didScheduleRenderPhaseUpdate) {\n    do {\n      didScheduleRenderPhaseUpdate = false;\n      numberOfReRenders += 1;\n      if (__DEV__) {\n        // Even when hot reloading, allow dependencies to stabilize\n        // after first render to prevent infinite render phase updates.\n        ignorePreviousDependencies = false;\n      }\n\n      // Start over from the beginning of the list\n      nextCurrentHook = current !== null ? current.memoizedState : null;\n      nextWorkInProgressHook = firstWorkInProgressHook;\n\n      currentHook = null;\n      workInProgressHook = null;\n      componentUpdateQueue = null;\n\n      if (__DEV__) {\n        // Also validate hook order for cascading updates.\n        hookTypesUpdateIndexDev = -1;\n      }\n\n      ReactCurrentDispatcher.current = __DEV__\n        ? HooksDispatcherOnUpdateInDEV\n        : HooksDispatcherOnUpdate;\n\n      children = Component(props, refOrContext);\n    } while (didScheduleRenderPhaseUpdate);\n\n    renderPhaseUpdates = null;\n    numberOfReRenders = 0;\n  }\n\n  // We can assume the previous dispatcher is always this one, since we set it\n  // at the beginning of the render phase and there's no re-entrancy.\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\n\n  const renderedWork: Fiber = (currentlyRenderingFiber: any);\n\n  renderedWork.memoizedState = firstWorkInProgressHook;\n  renderedWork.expirationTime = remainingExpirationTime;\n  renderedWork.updateQueue = (componentUpdateQueue: any);\n  renderedWork.effectTag |= sideEffectTag;\n\n  if (__DEV__) {\n    renderedWork._debugHookTypes = hookTypesDev;\n  }\n\n  // This check uses currentHook so that it works the same in DEV and prod bundles.\n  // hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.\n  const didRenderTooFewHooks =\n    currentHook !== null && currentHook.next !== null;\n\n  renderExpirationTime = NoWork;\n  currentlyRenderingFiber = null;\n\n  currentHook = null;\n  nextCurrentHook = null;\n  firstWorkInProgressHook = null;\n  workInProgressHook = null;\n  nextWorkInProgressHook = null;\n\n  if (__DEV__) {\n    currentHookNameInDev = null;\n    hookTypesDev = null;\n    hookTypesUpdateIndexDev = -1;\n  }\n\n  remainingExpirationTime = NoWork;\n  componentUpdateQueue = null;\n  sideEffectTag = 0;\n\n  // These were reset above\n  // didScheduleRenderPhaseUpdate = false;\n  // renderPhaseUpdates = null;\n  // numberOfReRenders = 0;\n\n  invariant(\n    !didRenderTooFewHooks,\n    'Rendered fewer hooks than expected. This may be caused by an accidental ' +\n      'early return statement.',\n  );\n\n  return children;\n}\n\nexport function bailoutHooks(\n  current: Fiber,\n  workInProgress: Fiber,\n  expirationTime: ExpirationTime,\n) {\n  workInProgress.updateQueue = current.updateQueue;\n  workInProgress.effectTag &= ~(PassiveEffect | UpdateEffect);\n  if (current.expirationTime <= expirationTime) {\n    current.expirationTime = NoWork;\n  }\n}\n\nexport function resetHooks(): void {\n  // We can assume the previous dispatcher is always this one, since we set it\n  // at the beginning of the render phase and there's no re-entrancy.\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\n\n  // This is used to reset the state of this module when a component throws.\n  // It's also called inside mountIndeterminateComponent if we determine the\n  // component is a module-style component.\n\n  renderExpirationTime = NoWork;\n  currentlyRenderingFiber = null;\n\n  currentHook = null;\n  nextCurrentHook = null;\n  firstWorkInProgressHook = null;\n  workInProgressHook = null;\n  nextWorkInProgressHook = null;\n\n  if (__DEV__) {\n    hookTypesDev = null;\n    hookTypesUpdateIndexDev = -1;\n\n    currentHookNameInDev = null;\n  }\n\n  remainingExpirationTime = NoWork;\n  componentUpdateQueue = null;\n  sideEffectTag = 0;\n\n  didScheduleRenderPhaseUpdate = false;\n  renderPhaseUpdates = null;\n  numberOfReRenders = 0;\n}\n\nfunction mountWorkInProgressHook(): Hook {\n  const hook: Hook = {\n    memoizedState: null,\n\n    baseState: null,\n    queue: null,\n    baseUpdate: null,\n\n    next: null,\n  };\n\n  if (workInProgressHook === null) {\n    // This is the first hook in the list\n    firstWorkInProgressHook = workInProgressHook = hook;\n  } else {\n    // Append to the end of the list\n    workInProgressHook = workInProgressHook.next = hook;\n  }\n  return workInProgressHook;\n}\n\nfunction updateWorkInProgressHook(): Hook {\n  // This function is used both for updates and for re-renders triggered by a\n  // render phase update. It assumes there is either a current hook we can\n  // clone, or a work-in-progress hook from a previous render pass that we can\n  // use as a base. When we reach the end of the base list, we must switch to\n  // the dispatcher used for mounts.\n  if (nextWorkInProgressHook !== null) {\n    // There's already a work-in-progress. Reuse it.\n    workInProgressHook = nextWorkInProgressHook;\n    nextWorkInProgressHook = workInProgressHook.next;\n\n    currentHook = nextCurrentHook;\n    nextCurrentHook = currentHook !== null ? currentHook.next : null;\n  } else {\n    // Clone from the current hook.\n    invariant(\n      nextCurrentHook !== null,\n      'Rendered more hooks than during the previous render.',\n    );\n    currentHook = nextCurrentHook;\n\n    const newHook: Hook = {\n      memoizedState: currentHook.memoizedState,\n\n      baseState: currentHook.baseState,\n      queue: currentHook.queue,\n      baseUpdate: currentHook.baseUpdate,\n\n      next: null,\n    };\n\n    if (workInProgressHook === null) {\n      // This is the first hook in the list.\n      workInProgressHook = firstWorkInProgressHook = newHook;\n    } else {\n      // Append to the end of the list.\n      workInProgressHook = workInProgressHook.next = newHook;\n    }\n    nextCurrentHook = currentHook.next;\n  }\n  return workInProgressHook;\n}\n\nfunction createFunctionComponentUpdateQueue(): FunctionComponentUpdateQueue {\n  return {\n    lastEffect: null,\n  };\n}\n\nfunction basicStateReducer<S>(state: S, action: BasicStateAction<S>): S {\n  return typeof action === 'function' ? action(state) : action;\n}\n\nfunction mountReducer<S, I, A>(\n  reducer: (S, A) => S,\n  initialArg: I,\n  init?: I => S,\n): [S, Dispatch<A>] {\n  const hook = mountWorkInProgressHook();\n  let initialState;\n  if (init !== undefined) {\n    initialState = init(initialArg);\n  } else {\n    initialState = ((initialArg: any): S);\n  }\n  hook.memoizedState = hook.baseState = initialState;\n  const queue = (hook.queue = {\n    last: null,\n    dispatch: null,\n    lastRenderedReducer: reducer,\n    lastRenderedState: (initialState: any),\n  });\n  const dispatch: Dispatch<A> = (queue.dispatch = (dispatchAction.bind(\n    null,\n    // Flow doesn't know this is non-null, but we do.\n    ((currentlyRenderingFiber: any): Fiber),\n    queue,\n  ): any));\n  return [hook.memoizedState, dispatch];\n}\n\nfunction updateReducer<S, I, A>(\n  reducer: (S, A) => S,\n  initialArg: I,\n  init?: I => S,\n): [S, Dispatch<A>] {\n  const hook = updateWorkInProgressHook();\n  const queue = hook.queue;\n  invariant(\n    queue !== null,\n    'Should have a queue. This is likely a bug in React. Please file an issue.',\n  );\n\n  queue.lastRenderedReducer = reducer;\n\n  if (numberOfReRenders > 0) {\n    // This is a re-render. Apply the new render phase updates to the previous\n    // work-in-progress hook.\n    const dispatch: Dispatch<A> = (queue.dispatch: any);\n    if (renderPhaseUpdates !== null) {\n      // Render phase updates are stored in a map of queue -> linked list\n      const firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);\n      if (firstRenderPhaseUpdate !== undefined) {\n        renderPhaseUpdates.delete(queue);\n        let newState = hook.memoizedState;\n        let update = firstRenderPhaseUpdate;\n        do {\n          // Process this render phase update. We don't have to check the\n          // priority because it will always be the same as the current\n          // render's.\n          const action = update.action;\n          newState = reducer(newState, action);\n          update = update.next;\n        } while (update !== null);\n\n        // Mark that the fiber performed work, but only if the new state is\n        // different from the current state.\n        if (!is(newState, hook.memoizedState)) {\n          markWorkInProgressReceivedUpdate();\n        }\n\n        hook.memoizedState = newState;\n        // Don't persist the state accumulated from the render phase updates to\n        // the base state unless the queue is empty.\n        // TODO: Not sure if this is the desired semantics, but it's what we\n        // do for gDSFP. I can't remember why.\n        if (hook.baseUpdate === queue.last) {\n          hook.baseState = newState;\n        }\n\n        queue.lastRenderedState = newState;\n\n        return [newState, dispatch];\n      }\n    }\n    return [hook.memoizedState, dispatch];\n  }\n\n  // The last update in the entire queue\n  const last = queue.last;\n  // The last update that is part of the base state.\n  const baseUpdate = hook.baseUpdate;\n  const baseState = hook.baseState;\n\n  // Find the first unprocessed update.\n  let first;\n  if (baseUpdate !== null) {\n    if (last !== null) {\n      // For the first update, the queue is a circular linked list where\n      // `queue.last.next = queue.first`. Once the first update commits, and\n      // the `baseUpdate` is no longer empty, we can unravel the list.\n      last.next = null;\n    }\n    first = baseUpdate.next;\n  } else {\n    first = last !== null ? last.next : null;\n  }\n  if (first !== null) {\n    let newState = baseState;\n    let newBaseState = null;\n    let newBaseUpdate = null;\n    let prevUpdate = baseUpdate;\n    let update = first;\n    let didSkip = false;\n    do {\n      const updateExpirationTime = update.expirationTime;\n      if (updateExpirationTime < renderExpirationTime) {\n        // Priority is insufficient. Skip this update. If this is the first\n        // skipped update, the previous update/state is the new base\n        // update/state.\n        if (!didSkip) {\n          didSkip = true;\n          newBaseUpdate = prevUpdate;\n          newBaseState = newState;\n        }\n        // Update the remaining priority in the queue.\n        if (updateExpirationTime > remainingExpirationTime) {\n          remainingExpirationTime = updateExpirationTime;\n          markUnprocessedUpdateTime(remainingExpirationTime);\n        }\n      } else {\n        // This update does have sufficient priority.\n\n        // Mark the event time of this update as relevant to this render pass.\n        // TODO: This should ideally use the true event time of this update rather than\n        // its priority which is a derived and not reverseable value.\n        // TODO: We should skip this update if it was already committed but currently\n        // we have no way of detecting the difference between a committed and suspended\n        // update here.\n        markRenderEventTimeAndConfig(\n          updateExpirationTime,\n          update.suspenseConfig,\n        );\n\n        // Process this update.\n        if (update.eagerReducer === reducer) {\n          // If this update was processed eagerly, and its reducer matches the\n          // current reducer, we can use the eagerly computed state.\n          newState = ((update.eagerState: any): S);\n        } else {\n          const action = update.action;\n          newState = reducer(newState, action);\n        }\n      }\n      prevUpdate = update;\n      update = update.next;\n    } while (update !== null && update !== first);\n\n    if (!didSkip) {\n      newBaseUpdate = prevUpdate;\n      newBaseState = newState;\n    }\n\n    // Mark that the fiber performed work, but only if the new state is\n    // different from the current state.\n    if (!is(newState, hook.memoizedState)) {\n      markWorkInProgressReceivedUpdate();\n    }\n\n    hook.memoizedState = newState;\n    hook.baseUpdate = newBaseUpdate;\n    hook.baseState = newBaseState;\n\n    queue.lastRenderedState = newState;\n  }\n\n  const dispatch: Dispatch<A> = (queue.dispatch: any);\n  return [hook.memoizedState, dispatch];\n}\n\nfunction mountState<S>(\n  initialState: (() => S) | S,\n): [S, Dispatch<BasicStateAction<S>>] {\n  const hook = mountWorkInProgressHook();\n  if (typeof initialState === 'function') {\n    initialState = initialState();\n  }\n  hook.memoizedState = hook.baseState = initialState;\n  const queue = (hook.queue = {\n    last: null,\n    dispatch: null,\n    lastRenderedReducer: basicStateReducer,\n    lastRenderedState: (initialState: any),\n  });\n  const dispatch: Dispatch<\n    BasicStateAction<S>,\n  > = (queue.dispatch = (dispatchAction.bind(\n    null,\n    // Flow doesn't know this is non-null, but we do.\n    ((currentlyRenderingFiber: any): Fiber),\n    queue,\n  ): any));\n  return [hook.memoizedState, dispatch];\n}\n\nfunction updateState<S>(\n  initialState: (() => S) | S,\n): [S, Dispatch<BasicStateAction<S>>] {\n  return updateReducer(basicStateReducer, (initialState: any));\n}\n\nfunction pushEffect(tag, create, destroy, deps) {\n  const effect: Effect = {\n    tag,\n    create,\n    destroy,\n    deps,\n    // Circular\n    next: (null: any),\n  };\n  if (componentUpdateQueue === null) {\n    componentUpdateQueue = createFunctionComponentUpdateQueue();\n    componentUpdateQueue.lastEffect = effect.next = effect;\n  } else {\n    const lastEffect = componentUpdateQueue.lastEffect;\n    if (lastEffect === null) {\n      componentUpdateQueue.lastEffect = effect.next = effect;\n    } else {\n      const firstEffect = lastEffect.next;\n      lastEffect.next = effect;\n      effect.next = firstEffect;\n      componentUpdateQueue.lastEffect = effect;\n    }\n  }\n  return effect;\n}\n\nfunction mountRef<T>(initialValue: T): {current: T} {\n  const hook = mountWorkInProgressHook();\n  const ref = {current: initialValue};\n  if (__DEV__) {\n    Object.seal(ref);\n  }\n  hook.memoizedState = ref;\n  return ref;\n}\n\nfunction updateRef<T>(initialValue: T): {current: T} {\n  const hook = updateWorkInProgressHook();\n  return hook.memoizedState;\n}\n\nfunction mountEffectImpl(fiberEffectTag, hookEffectTag, create, deps): void {\n  const hook = mountWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  sideEffectTag |= fiberEffectTag;\n  hook.memoizedState = pushEffect(hookEffectTag, create, undefined, nextDeps);\n}\n\nfunction updateEffectImpl(fiberEffectTag, hookEffectTag, create, deps): void {\n  const hook = updateWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  let destroy = undefined;\n\n  if (currentHook !== null) {\n    const prevEffect = currentHook.memoizedState;\n    destroy = prevEffect.destroy;\n    if (nextDeps !== null) {\n      const prevDeps = prevEffect.deps;\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        pushEffect(NoHookEffect, create, destroy, nextDeps);\n        return;\n      }\n    }\n  }\n\n  sideEffectTag |= fiberEffectTag;\n  hook.memoizedState = pushEffect(hookEffectTag, create, destroy, nextDeps);\n}\n\nfunction mountEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  if (__DEV__) {\n    // $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests\n    if ('undefined' !== typeof jest) {\n      warnIfNotCurrentlyActingEffectsInDEV(\n        ((currentlyRenderingFiber: any): Fiber),\n      );\n    }\n  }\n  return mountEffectImpl(\n    UpdateEffect | PassiveEffect,\n    UnmountPassive | MountPassive,\n    create,\n    deps,\n  );\n}\n\nfunction updateEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  if (__DEV__) {\n    // $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests\n    if ('undefined' !== typeof jest) {\n      warnIfNotCurrentlyActingEffectsInDEV(\n        ((currentlyRenderingFiber: any): Fiber),\n      );\n    }\n  }\n  return updateEffectImpl(\n    UpdateEffect | PassiveEffect,\n    UnmountPassive | MountPassive,\n    create,\n    deps,\n  );\n}\n\nfunction mountLayoutEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  return mountEffectImpl(\n    UpdateEffect,\n    UnmountMutation | MountLayout,\n    create,\n    deps,\n  );\n}\n\nfunction updateLayoutEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  return updateEffectImpl(\n    UpdateEffect,\n    UnmountMutation | MountLayout,\n    create,\n    deps,\n  );\n}\n\nfunction imperativeHandleEffect<T>(\n  create: () => T,\n  ref: {current: T | null} | ((inst: T | null) => mixed) | null | void,\n) {\n  if (typeof ref === 'function') {\n    const refCallback = ref;\n    const inst = create();\n    refCallback(inst);\n    return () => {\n      refCallback(null);\n    };\n  } else if (ref !== null && ref !== undefined) {\n    const refObject = ref;\n    if (__DEV__) {\n      warning(\n        refObject.hasOwnProperty('current'),\n        'Expected useImperativeHandle() first argument to either be a ' +\n          'ref callback or React.createRef() object. Instead received: %s.',\n        'an object with keys {' + Object.keys(refObject).join(', ') + '}',\n      );\n    }\n    const inst = create();\n    refObject.current = inst;\n    return () => {\n      refObject.current = null;\n    };\n  }\n}\n\nfunction mountImperativeHandle<T>(\n  ref: {current: T | null} | ((inst: T | null) => mixed) | null | void,\n  create: () => T,\n  deps: Array<mixed> | void | null,\n): void {\n  if (__DEV__) {\n    warning(\n      typeof create === 'function',\n      'Expected useImperativeHandle() second argument to be a function ' +\n        'that creates a handle. Instead received: %s.',\n      create !== null ? typeof create : 'null',\n    );\n  }\n\n  // TODO: If deps are provided, should we skip comparing the ref itself?\n  const effectDeps =\n    deps !== null && deps !== undefined ? deps.concat([ref]) : null;\n\n  return mountEffectImpl(\n    UpdateEffect,\n    UnmountMutation | MountLayout,\n    imperativeHandleEffect.bind(null, create, ref),\n    effectDeps,\n  );\n}\n\nfunction updateImperativeHandle<T>(\n  ref: {current: T | null} | ((inst: T | null) => mixed) | null | void,\n  create: () => T,\n  deps: Array<mixed> | void | null,\n): void {\n  if (__DEV__) {\n    warning(\n      typeof create === 'function',\n      'Expected useImperativeHandle() second argument to be a function ' +\n        'that creates a handle. Instead received: %s.',\n      create !== null ? typeof create : 'null',\n    );\n  }\n\n  // TODO: If deps are provided, should we skip comparing the ref itself?\n  const effectDeps =\n    deps !== null && deps !== undefined ? deps.concat([ref]) : null;\n\n  return updateEffectImpl(\n    UpdateEffect,\n    UnmountMutation | MountLayout,\n    imperativeHandleEffect.bind(null, create, ref),\n    effectDeps,\n  );\n}\n\nfunction mountDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void {\n  // This hook is normally a no-op.\n  // The react-debug-hooks package injects its own implementation\n  // so that e.g. DevTools can display custom hook values.\n}\n\nconst updateDebugValue = mountDebugValue;\n\nfunction mountCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n  const hook = mountWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  hook.memoizedState = [callback, nextDeps];\n  return callback;\n}\n\nfunction updateCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n  const hook = updateWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  const prevState = hook.memoizedState;\n  if (prevState !== null) {\n    if (nextDeps !== null) {\n      const prevDeps: Array<mixed> | null = prevState[1];\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        return prevState[0];\n      }\n    }\n  }\n  hook.memoizedState = [callback, nextDeps];\n  return callback;\n}\n\nfunction mountMemo<T>(\n  nextCreate: () => T,\n  deps: Array<mixed> | void | null,\n): T {\n  const hook = mountWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  const nextValue = nextCreate();\n  hook.memoizedState = [nextValue, nextDeps];\n  return nextValue;\n}\n\nfunction updateMemo<T>(\n  nextCreate: () => T,\n  deps: Array<mixed> | void | null,\n): T {\n  const hook = updateWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  const prevState = hook.memoizedState;\n  if (prevState !== null) {\n    // Assume these are defined. If they're not, areHookInputsEqual will warn.\n    if (nextDeps !== null) {\n      const prevDeps: Array<mixed> | null = prevState[1];\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        return prevState[0];\n      }\n    }\n  }\n  const nextValue = nextCreate();\n  hook.memoizedState = [nextValue, nextDeps];\n  return nextValue;\n}\n\nfunction mountDeferredValue<T>(\n  value: T,\n  config: TimeoutConfig | void | null,\n): T {\n  const [prevValue, setValue] = mountState(value);\n  mountEffect(\n    () => {\n      const previousConfig = ReactCurrentBatchConfig.suspense;\n      ReactCurrentBatchConfig.suspense = config === undefined ? null : config;\n      try {\n        setValue(value);\n      } finally {\n        ReactCurrentBatchConfig.suspense = previousConfig;\n      }\n    },\n    [value, config],\n  );\n  return prevValue;\n}\n\nfunction updateDeferredValue<T>(\n  value: T,\n  config: TimeoutConfig | void | null,\n): T {\n  const [prevValue, setValue] = updateState(value);\n  updateEffect(\n    () => {\n      const previousConfig = ReactCurrentBatchConfig.suspense;\n      ReactCurrentBatchConfig.suspense = config === undefined ? null : config;\n      try {\n        setValue(value);\n      } finally {\n        ReactCurrentBatchConfig.suspense = previousConfig;\n      }\n    },\n    [value, config],\n  );\n  return prevValue;\n}\n\nfunction startTransition(setPending, config, callback) {\n  const priorityLevel = getCurrentPriorityLevel();\n  runWithPriority(\n    priorityLevel < UserBlockingPriority ? UserBlockingPriority : priorityLevel,\n    () => {\n      setPending(true);\n    },\n  );\n  runWithPriority(\n    priorityLevel > NormalPriority ? NormalPriority : priorityLevel,\n    () => {\n      const previousConfig = ReactCurrentBatchConfig.suspense;\n      ReactCurrentBatchConfig.suspense = config === undefined ? null : config;\n      try {\n        setPending(false);\n        callback();\n      } finally {\n        ReactCurrentBatchConfig.suspense = previousConfig;\n      }\n    },\n  );\n}\n\nfunction mountTransition(\n  config: SuspenseConfig | void | null,\n): [(() => void) => void, boolean] {\n  const [isPending, setPending] = mountState(false);\n  const start = mountCallback(startTransition.bind(null, setPending, config), [\n    setPending,\n    config,\n  ]);\n  return [start, isPending];\n}\n\nfunction updateTransition(\n  config: SuspenseConfig | void | null,\n): [(() => void) => void, boolean] {\n  const [isPending, setPending] = updateState(false);\n  const start = updateCallback(startTransition.bind(null, setPending, config), [\n    setPending,\n    config,\n  ]);\n  return [start, isPending];\n}\n\nfunction dispatchAction<S, A>(\n  fiber: Fiber,\n  queue: UpdateQueue<S, A>,\n  action: A,\n) {\n  invariant(\n    numberOfReRenders < RE_RENDER_LIMIT,\n    'Too many re-renders. React limits the number of renders to prevent ' +\n      'an infinite loop.',\n  );\n\n  if (__DEV__) {\n    warning(\n      typeof arguments[3] !== 'function',\n      \"State updates from the useState() and useReducer() Hooks don't support the \" +\n        'second callback argument. To execute a side effect after ' +\n        'rendering, declare it in the component body with useEffect().',\n    );\n  }\n\n  const alternate = fiber.alternate;\n  if (\n    fiber === currentlyRenderingFiber ||\n    (alternate !== null && alternate === currentlyRenderingFiber)\n  ) {\n    // This is a render phase update. Stash it in a lazily-created map of\n    // queue -> linked list of updates. After this render pass, we'll restart\n    // and apply the stashed updates on top of the work-in-progress hook.\n    didScheduleRenderPhaseUpdate = true;\n    const update: Update<S, A> = {\n      expirationTime: renderExpirationTime,\n      suspenseConfig: null,\n      action,\n      eagerReducer: null,\n      eagerState: null,\n      next: null,\n    };\n    if (__DEV__) {\n      update.priority = getCurrentPriorityLevel();\n    }\n    if (renderPhaseUpdates === null) {\n      renderPhaseUpdates = new Map();\n    }\n    const firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);\n    if (firstRenderPhaseUpdate === undefined) {\n      renderPhaseUpdates.set(queue, update);\n    } else {\n      // Append the update to the end of the list.\n      let lastRenderPhaseUpdate = firstRenderPhaseUpdate;\n      while (lastRenderPhaseUpdate.next !== null) {\n        lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;\n      }\n      lastRenderPhaseUpdate.next = update;\n    }\n  } else {\n    const currentTime = requestCurrentTimeForUpdate();\n    const suspenseConfig = requestCurrentSuspenseConfig();\n    const expirationTime = computeExpirationForFiber(\n      currentTime,\n      fiber,\n      suspenseConfig,\n    );\n\n    const update: Update<S, A> = {\n      expirationTime,\n      suspenseConfig,\n      action,\n      eagerReducer: null,\n      eagerState: null,\n      next: null,\n    };\n\n    if (__DEV__) {\n      update.priority = getCurrentPriorityLevel();\n    }\n\n    // Append the update to the end of the list.\n    const last = queue.last;\n    if (last === null) {\n      // This is the first update. Create a circular list.\n      update.next = update;\n    } else {\n      const first = last.next;\n      if (first !== null) {\n        // Still circular.\n        update.next = first;\n      }\n      last.next = update;\n    }\n    queue.last = update;\n\n    if (\n      fiber.expirationTime === NoWork &&\n      (alternate === null || alternate.expirationTime === NoWork)\n    ) {\n      // The queue is currently empty, which means we can eagerly compute the\n      // next state before entering the render phase. If the new state is the\n      // same as the current state, we may be able to bail out entirely.\n      const lastRenderedReducer = queue.lastRenderedReducer;\n      if (lastRenderedReducer !== null) {\n        let prevDispatcher;\n        if (__DEV__) {\n          prevDispatcher = ReactCurrentDispatcher.current;\n          ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n        }\n        try {\n          const currentState: S = (queue.lastRenderedState: any);\n          const eagerState = lastRenderedReducer(currentState, action);\n          // Stash the eagerly computed state, and the reducer used to compute\n          // it, on the update object. If the reducer hasn't changed by the\n          // time we enter the render phase, then the eager state can be used\n          // without calling the reducer again.\n          update.eagerReducer = lastRenderedReducer;\n          update.eagerState = eagerState;\n          if (is(eagerState, currentState)) {\n            // Fast path. We can bail out without scheduling React to re-render.\n            // It's still possible that we'll need to rebase this update later,\n            // if the component re-renders for a different reason and by that\n            // time the reducer has changed.\n            return;\n          }\n        } catch (error) {\n          // Suppress the error. It will throw again in the render phase.\n        } finally {\n          if (__DEV__) {\n            ReactCurrentDispatcher.current = prevDispatcher;\n          }\n        }\n      }\n    }\n    if (__DEV__) {\n      // $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests\n      if ('undefined' !== typeof jest) {\n        warnIfNotScopedWithMatchingAct(fiber);\n        warnIfNotCurrentlyActingUpdatesInDev(fiber);\n      }\n    }\n    scheduleWork(fiber, expirationTime);\n  }\n}\n\nexport const ContextOnlyDispatcher: Dispatcher = {\n  readContext,\n\n  useCallback: throwInvalidHookError,\n  useContext: throwInvalidHookError,\n  useEffect: throwInvalidHookError,\n  useImperativeHandle: throwInvalidHookError,\n  useLayoutEffect: throwInvalidHookError,\n  useMemo: throwInvalidHookError,\n  useReducer: throwInvalidHookError,\n  useRef: throwInvalidHookError,\n  useState: throwInvalidHookError,\n  useDebugValue: throwInvalidHookError,\n  useResponder: throwInvalidHookError,\n  useDeferredValue: throwInvalidHookError,\n  useTransition: throwInvalidHookError,\n};\n\nconst HooksDispatcherOnMount: Dispatcher = {\n  readContext,\n\n  useCallback: mountCallback,\n  useContext: readContext,\n  useEffect: mountEffect,\n  useImperativeHandle: mountImperativeHandle,\n  useLayoutEffect: mountLayoutEffect,\n  useMemo: mountMemo,\n  useReducer: mountReducer,\n  useRef: mountRef,\n  useState: mountState,\n  useDebugValue: mountDebugValue,\n  useResponder: createResponderListener,\n  useDeferredValue: mountDeferredValue,\n  useTransition: mountTransition,\n};\n\nconst HooksDispatcherOnUpdate: Dispatcher = {\n  readContext,\n\n  useCallback: updateCallback,\n  useContext: readContext,\n  useEffect: updateEffect,\n  useImperativeHandle: updateImperativeHandle,\n  useLayoutEffect: updateLayoutEffect,\n  useMemo: updateMemo,\n  useReducer: updateReducer,\n  useRef: updateRef,\n  useState: updateState,\n  useDebugValue: updateDebugValue,\n  useResponder: createResponderListener,\n  useDeferredValue: updateDeferredValue,\n  useTransition: updateTransition,\n};\n\nlet HooksDispatcherOnMountInDEV: Dispatcher | null = null;\nlet HooksDispatcherOnMountWithHookTypesInDEV: Dispatcher | null = null;\nlet HooksDispatcherOnUpdateInDEV: Dispatcher | null = null;\nlet InvalidNestedHooksDispatcherOnMountInDEV: Dispatcher | null = null;\nlet InvalidNestedHooksDispatcherOnUpdateInDEV: Dispatcher | null = null;\n\nif (__DEV__) {\n  const warnInvalidContextAccess = () => {\n    warning(\n      false,\n      'Context can only be read while React is rendering. ' +\n        'In classes, you can read it in the render method or getDerivedStateFromProps. ' +\n        'In function components, you can read it directly in the function body, but not ' +\n        'inside Hooks like useReducer() or useMemo().',\n    );\n  };\n\n  const warnInvalidHookAccess = () => {\n    warning(\n      false,\n      'Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. ' +\n        'You can only call Hooks at the top level of your React function. ' +\n        'For more information, see ' +\n        'https://fb.me/rules-of-hooks',\n    );\n  };\n\n  HooksDispatcherOnMountInDEV = {\n    readContext<T>(\n      context: ReactContext<T>,\n      observedBits: void | number | boolean,\n    ): T {\n      return readContext(context, observedBits);\n    },\n\n    useCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useCallback';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountCallback(callback, deps);\n    },\n    useContext<T>(\n      context: ReactContext<T>,\n      observedBits: void | number | boolean,\n    ): T {\n      currentHookNameInDev = 'useContext';\n      mountHookTypesDev();\n      return readContext(context, observedBits);\n    },\n    useEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useEffect';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountEffect(create, deps);\n    },\n    useImperativeHandle<T>(\n      ref: {current: T | null} | ((inst: T | null) => mixed) | null | void,\n      create: () => T,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useImperativeHandle';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountImperativeHandle(ref, create, deps);\n    },\n    useLayoutEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useLayoutEffect';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountLayoutEffect(create, deps);\n    },\n    useMemo<T>(create: () => T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useMemo';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n      try {\n        return mountMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useReducer<S, I, A>(\n      reducer: (S, A) => S,\n      initialArg: I,\n      init?: I => S,\n    ): [S, Dispatch<A>] {\n      currentHookNameInDev = 'useReducer';\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n      try {\n        return mountReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useRef<T>(initialValue: T): {current: T} {\n      currentHookNameInDev = 'useRef';\n      mountHookTypesDev();\n      return mountRef(initialValue);\n    },\n    useState<S>(\n      initialState: (() => S) | S,\n    ): [S, Dispatch<BasicStateAction<S>>] {\n      currentHookNameInDev = 'useState';\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n      try {\n        return mountState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void {\n      currentHookNameInDev = 'useDebugValue';\n      mountHookTypesDev();\n      return mountDebugValue(value, formatterFn);\n    },\n    useResponder<E, C>(\n      responder: ReactEventResponder<E, C>,\n      props,\n    ): ReactEventResponderListener<E, C> {\n      currentHookNameInDev = 'useResponder';\n      mountHookTypesDev();\n      return createResponderListener(responder, props);\n    },\n    useDeferredValue<T>(value: T, config: TimeoutConfig | void | null): T {\n      currentHookNameInDev = 'useDeferredValue';\n      mountHookTypesDev();\n      return mountDeferredValue(value, config);\n    },\n    useTransition(\n      config: SuspenseConfig | void | null,\n    ): [(() => void) => void, boolean] {\n      currentHookNameInDev = 'useTransition';\n      mountHookTypesDev();\n      return mountTransition(config);\n    },\n  };\n\n  HooksDispatcherOnMountWithHookTypesInDEV = {\n    readContext<T>(\n      context: ReactContext<T>,\n      observedBits: void | number | boolean,\n    ): T {\n      return readContext(context, observedBits);\n    },\n\n    useCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useCallback';\n      updateHookTypesDev();\n      return mountCallback(callback, deps);\n    },\n    useContext<T>(\n      context: ReactContext<T>,\n      observedBits: void | number | boolean,\n    ): T {\n      currentHookNameInDev = 'useContext';\n      updateHookTypesDev();\n      return readContext(context, observedBits);\n    },\n    useEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useEffect';\n      updateHookTypesDev();\n      return mountEffect(create, deps);\n    },\n    useImperativeHandle<T>(\n      ref: {current: T | null} | ((inst: T | null) => mixed) | null | void,\n      create: () => T,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useImperativeHandle';\n      updateHookTypesDev();\n      return mountImperativeHandle(ref, create, deps);\n    },\n    useLayoutEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useLayoutEffect';\n      updateHookTypesDev();\n      return mountLayoutEffect(create, deps);\n    },\n    useMemo<T>(create: () => T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useMemo';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n      try {\n        return mountMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useReducer<S, I, A>(\n      reducer: (S, A) => S,\n      initialArg: I,\n      init?: I => S,\n    ): [S, Dispatch<A>] {\n      currentHookNameInDev = 'useReducer';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n      try {\n        return mountReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useRef<T>(initialValue: T): {current: T} {\n      currentHookNameInDev = 'useRef';\n      updateHookTypesDev();\n      return mountRef(initialValue);\n    },\n    useState<S>(\n      initialState: (() => S) | S,\n    ): [S, Dispatch<BasicStateAction<S>>] {\n      currentHookNameInDev = 'useState';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n      try {\n        return mountState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void {\n      currentHookNameInDev = 'useDebugValue';\n      updateHookTypesDev();\n      return mountDebugValue(value, formatterFn);\n    },\n    useResponder<E, C>(\n      responder: ReactEventResponder<E, C>,\n      props,\n    ): ReactEventResponderListener<E, C> {\n      currentHookNameInDev = 'useResponder';\n      updateHookTypesDev();\n      return createResponderListener(responder, props);\n    },\n    useDeferredValue<T>(value: T, config: TimeoutConfig | void | null): T {\n      currentHookNameInDev = 'useDeferredValue';\n      updateHookTypesDev();\n      return mountDeferredValue(value, config);\n    },\n    useTransition(\n      config: SuspenseConfig | void | null,\n    ): [(() => void) => void, boolean] {\n      currentHookNameInDev = 'useTransition';\n      updateHookTypesDev();\n      return mountTransition(config);\n    },\n  };\n\n  HooksDispatcherOnUpdateInDEV = {\n    readContext<T>(\n      context: ReactContext<T>,\n      observedBits: void | number | boolean,\n    ): T {\n      return readContext(context, observedBits);\n    },\n\n    useCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useCallback';\n      updateHookTypesDev();\n      return updateCallback(callback, deps);\n    },\n    useContext<T>(\n      context: ReactContext<T>,\n      observedBits: void | number | boolean,\n    ): T {\n      currentHookNameInDev = 'useContext';\n      updateHookTypesDev();\n      return readContext(context, observedBits);\n    },\n    useEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useEffect';\n      updateHookTypesDev();\n      return updateEffect(create, deps);\n    },\n    useImperativeHandle<T>(\n      ref: {current: T | null} | ((inst: T | null) => mixed) | null | void,\n      create: () => T,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useImperativeHandle';\n      updateHookTypesDev();\n      return updateImperativeHandle(ref, create, deps);\n    },\n    useLayoutEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useLayoutEffect';\n      updateHookTypesDev();\n      return updateLayoutEffect(create, deps);\n    },\n    useMemo<T>(create: () => T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useMemo';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n      try {\n        return updateMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useReducer<S, I, A>(\n      reducer: (S, A) => S,\n      initialArg: I,\n      init?: I => S,\n    ): [S, Dispatch<A>] {\n      currentHookNameInDev = 'useReducer';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n      try {\n        return updateReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useRef<T>(initialValue: T): {current: T} {\n      currentHookNameInDev = 'useRef';\n      updateHookTypesDev();\n      return updateRef(initialValue);\n    },\n    useState<S>(\n      initialState: (() => S) | S,\n    ): [S, Dispatch<BasicStateAction<S>>] {\n      currentHookNameInDev = 'useState';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n      try {\n        return updateState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void {\n      currentHookNameInDev = 'useDebugValue';\n      updateHookTypesDev();\n      return updateDebugValue(value, formatterFn);\n    },\n    useResponder<E, C>(\n      responder: ReactEventResponder<E, C>,\n      props,\n    ): ReactEventResponderListener<E, C> {\n      currentHookNameInDev = 'useResponder';\n      updateHookTypesDev();\n      return createResponderListener(responder, props);\n    },\n    useDeferredValue<T>(value: T, config: TimeoutConfig | void | null): T {\n      currentHookNameInDev = 'useDeferredValue';\n      updateHookTypesDev();\n      return updateDeferredValue(value, config);\n    },\n    useTransition(\n      config: SuspenseConfig | void | null,\n    ): [(() => void) => void, boolean] {\n      currentHookNameInDev = 'useTransition';\n      updateHookTypesDev();\n      return updateTransition(config);\n    },\n  };\n\n  InvalidNestedHooksDispatcherOnMountInDEV = {\n    readContext<T>(\n      context: ReactContext<T>,\n      observedBits: void | number | boolean,\n    ): T {\n      warnInvalidContextAccess();\n      return readContext(context, observedBits);\n    },\n\n    useCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useCallback';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountCallback(callback, deps);\n    },\n    useContext<T>(\n      context: ReactContext<T>,\n      observedBits: void | number | boolean,\n    ): T {\n      currentHookNameInDev = 'useContext';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return readContext(context, observedBits);\n    },\n    useEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useEffect';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountEffect(create, deps);\n    },\n    useImperativeHandle<T>(\n      ref: {current: T | null} | ((inst: T | null) => mixed) | null | void,\n      create: () => T,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useImperativeHandle';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountImperativeHandle(ref, create, deps);\n    },\n    useLayoutEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useLayoutEffect';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountLayoutEffect(create, deps);\n    },\n    useMemo<T>(create: () => T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useMemo';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n      try {\n        return mountMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useReducer<S, I, A>(\n      reducer: (S, A) => S,\n      initialArg: I,\n      init?: I => S,\n    ): [S, Dispatch<A>] {\n      currentHookNameInDev = 'useReducer';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n      try {\n        return mountReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useRef<T>(initialValue: T): {current: T} {\n      currentHookNameInDev = 'useRef';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountRef(initialValue);\n    },\n    useState<S>(\n      initialState: (() => S) | S,\n    ): [S, Dispatch<BasicStateAction<S>>] {\n      currentHookNameInDev = 'useState';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n      try {\n        return mountState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void {\n      currentHookNameInDev = 'useDebugValue';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountDebugValue(value, formatterFn);\n    },\n    useResponder<E, C>(\n      responder: ReactEventResponder<E, C>,\n      props,\n    ): ReactEventResponderListener<E, C> {\n      currentHookNameInDev = 'useResponder';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return createResponderListener(responder, props);\n    },\n    useDeferredValue<T>(value: T, config: TimeoutConfig | void | null): T {\n      currentHookNameInDev = 'useDeferredValue';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountDeferredValue(value, config);\n    },\n    useTransition(\n      config: SuspenseConfig | void | null,\n    ): [(() => void) => void, boolean] {\n      currentHookNameInDev = 'useTransition';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountTransition(config);\n    },\n  };\n\n  InvalidNestedHooksDispatcherOnUpdateInDEV = {\n    readContext<T>(\n      context: ReactContext<T>,\n      observedBits: void | number | boolean,\n    ): T {\n      warnInvalidContextAccess();\n      return readContext(context, observedBits);\n    },\n\n    useCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useCallback';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateCallback(callback, deps);\n    },\n    useContext<T>(\n      context: ReactContext<T>,\n      observedBits: void | number | boolean,\n    ): T {\n      currentHookNameInDev = 'useContext';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return readContext(context, observedBits);\n    },\n    useEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateEffect(create, deps);\n    },\n    useImperativeHandle<T>(\n      ref: {current: T | null} | ((inst: T | null) => mixed) | null | void,\n      create: () => T,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useImperativeHandle';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateImperativeHandle(ref, create, deps);\n    },\n    useLayoutEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useLayoutEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateLayoutEffect(create, deps);\n    },\n    useMemo<T>(create: () => T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useMemo';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n      try {\n        return updateMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useReducer<S, I, A>(\n      reducer: (S, A) => S,\n      initialArg: I,\n      init?: I => S,\n    ): [S, Dispatch<A>] {\n      currentHookNameInDev = 'useReducer';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n      try {\n        return updateReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useRef<T>(initialValue: T): {current: T} {\n      currentHookNameInDev = 'useRef';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateRef(initialValue);\n    },\n    useState<S>(\n      initialState: (() => S) | S,\n    ): [S, Dispatch<BasicStateAction<S>>] {\n      currentHookNameInDev = 'useState';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n      try {\n        return updateState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void {\n      currentHookNameInDev = 'useDebugValue';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateDebugValue(value, formatterFn);\n    },\n    useResponder<E, C>(\n      responder: ReactEventResponder<E, C>,\n      props,\n    ): ReactEventResponderListener<E, C> {\n      currentHookNameInDev = 'useResponder';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return createResponderListener(responder, props);\n    },\n    useDeferredValue<T>(value: T, config: TimeoutConfig | void | null): T {\n      currentHookNameInDev = 'useDeferredValue';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateDeferredValue(value, config);\n    },\n    useTransition(\n      config: SuspenseConfig | void | null,\n    ): [(() => void) => void, boolean] {\n      currentHookNameInDev = 'useTransition';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateTransition(config);\n    },\n  };\n}\n"]},"metadata":{},"sourceType":"module"}