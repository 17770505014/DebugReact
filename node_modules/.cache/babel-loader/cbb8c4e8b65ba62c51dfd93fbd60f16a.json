{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { getInstanceFromNode, isContainerMarkedAsRoot, unmarkContainerAsRoot } from './ReactDOMComponentTree';\nimport { createLegacyRoot, isValidContainer, warnOnInvalidCallback } from './ReactDOMRoot';\nimport { ROOT_ATTRIBUTE_NAME } from '../shared/DOMProperty';\nimport { DOCUMENT_NODE, ELEMENT_NODE, COMMENT_NODE } from '../shared/HTMLNodeType';\nimport { findHostInstanceWithNoPortals, updateContainer, unbatchedUpdates, getPublicRootInstance, findHostInstance, findHostInstanceWithWarning } from 'react-reconciler/inline.dom';\nimport getComponentName from 'shared/getComponentName';\nimport invariant from 'shared/invariant';\nimport lowPriorityWarningWithoutStack from 'shared/lowPriorityWarningWithoutStack';\nimport warningWithoutStack from 'shared/warningWithoutStack';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport { has as hasInstance } from 'shared/ReactInstanceMap';\nconst ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nlet topLevelUpdateWarnings;\nlet warnedAboutHydrateAPI = false;\n\nif (__DEV__) {\n  topLevelUpdateWarnings = container => {\n    if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {\n      const hostInstance = findHostInstanceWithNoPortals(container._reactRootContainer._internalRoot.current);\n\n      if (hostInstance) {\n        warningWithoutStack(hostInstance.parentNode === container, 'render(...): It looks like the React-rendered content of this ' + 'container was removed without using React. This is not ' + 'supported and will cause errors. Instead, call ' + 'ReactDOM.unmountComponentAtNode to empty a container.');\n      }\n    }\n\n    const isRootRenderedBySomeReact = !!container._reactRootContainer;\n    const rootEl = getReactRootElementInContainer(container);\n    const hasNonRootReactChild = !!(rootEl && getInstanceFromNode(rootEl));\n    warningWithoutStack(!hasNonRootReactChild || isRootRenderedBySomeReact, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.');\n    warningWithoutStack(container.nodeType !== ELEMENT_NODE || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.');\n  };\n}\n\nfunction getReactRootElementInContainer(container) {\n  if (!container) {\n    return null;\n  }\n\n  if (container.nodeType === DOCUMENT_NODE) {\n    return container.documentElement;\n  } else {\n    return container.firstChild;\n  }\n}\n\nfunction shouldHydrateDueToLegacyHeuristic(container) {\n  const rootElement = getReactRootElementInContainer(container);\n  return !!(rootElement && rootElement.nodeType === ELEMENT_NODE && rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));\n}\n\nfunction legacyCreateRootFromDOMContainer(container, forceHydrate) {\n  const shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container); // First clear any existing content.\n\n  if (!shouldHydrate) {\n    let warned = false;\n    let rootSibling;\n\n    while (rootSibling = container.lastChild) {\n      if (__DEV__) {\n        if (!warned && rootSibling.nodeType === ELEMENT_NODE && rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)) {\n          warned = true;\n          warningWithoutStack(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.');\n        }\n      }\n\n      container.removeChild(rootSibling);\n    }\n  }\n\n  if (__DEV__) {\n    if (shouldHydrate && !forceHydrate && !warnedAboutHydrateAPI) {\n      warnedAboutHydrateAPI = true;\n      lowPriorityWarningWithoutStack(false, 'render(): Calling ReactDOM.render() to hydrate server-rendered markup ' + 'will stop working in React v17. Replace the ReactDOM.render() call ' + 'with ReactDOM.hydrate() if you want React to attach to the server HTML.');\n    }\n  }\n\n  return createLegacyRoot(container, shouldHydrate ? {\n    hydrate: true\n  } : undefined);\n}\n\nfunction legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {\n  if (__DEV__) {\n    topLevelUpdateWarnings(container);\n    warnOnInvalidCallback(callback === undefined ? null : callback, 'render');\n  } // TODO: Without `any` type, Flow says \"Property cannot be accessed on any\n  // member of intersection type.\" Whyyyyyy.\n\n\n  let root = container._reactRootContainer;\n  let fiberRoot;\n\n  if (!root) {\n    // Initial mount\n    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(container, forceHydrate);\n    fiberRoot = root._internalRoot;\n\n    if (typeof callback === 'function') {\n      const originalCallback = callback;\n\n      callback = function () {\n        const instance = getPublicRootInstance(fiberRoot);\n        originalCallback.call(instance);\n      };\n    } // Initial mount should not be batched.\n\n\n    unbatchedUpdates(() => {\n      updateContainer(children, fiberRoot, parentComponent, callback);\n    });\n  } else {\n    fiberRoot = root._internalRoot;\n\n    if (typeof callback === 'function') {\n      const originalCallback = callback;\n\n      callback = function () {\n        const instance = getPublicRootInstance(fiberRoot);\n        originalCallback.call(instance);\n      };\n    } // Update\n\n\n    updateContainer(children, fiberRoot, parentComponent, callback);\n  }\n\n  return getPublicRootInstance(fiberRoot);\n}\n\nexport function findDOMNode(componentOrElement) {\n  if (__DEV__) {\n    let owner = ReactCurrentOwner.current;\n\n    if (owner !== null && owner.stateNode !== null) {\n      const warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;\n      warningWithoutStack(warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(owner.type) || 'A component');\n      owner.stateNode._warnedAboutRefsInRender = true;\n    }\n  }\n\n  if (componentOrElement == null) {\n    return null;\n  }\n\n  if (componentOrElement.nodeType === ELEMENT_NODE) {\n    return componentOrElement;\n  }\n\n  if (__DEV__) {\n    return findHostInstanceWithWarning(componentOrElement, 'findDOMNode');\n  }\n\n  return findHostInstance(componentOrElement);\n}\nexport function hydrate(element, container, callback) {\n  invariant(isValidContainer(container), 'Target container is not a DOM element.');\n\n  if (__DEV__) {\n    const isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === undefined;\n\n    if (isModernRoot) {\n      warningWithoutStack(false, 'You are calling ReactDOM.hydrate() on a container that was previously ' + 'passed to ReactDOM.createRoot(). This is not supported. ' + 'Did you mean to call createRoot(container, {hydrate: true}).render(element)?');\n    }\n  } // TODO: throw or warn if we couldn't hydrate?\n\n\n  return legacyRenderSubtreeIntoContainer(null, element, container, true, callback);\n}\nexport function render(element, container, callback) {\n  invariant(isValidContainer(container), 'Target container is not a DOM element.');\n\n  if (__DEV__) {\n    const isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === undefined;\n\n    if (isModernRoot) {\n      warningWithoutStack(false, 'You are calling ReactDOM.render() on a container that was previously ' + 'passed to ReactDOM.createRoot(). This is not supported. ' + 'Did you mean to call root.render(element)?');\n    }\n  }\n\n  return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);\n}\nexport function unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {\n  invariant(isValidContainer(containerNode), 'Target container is not a DOM element.');\n  invariant(parentComponent != null && hasInstance(parentComponent), 'parentComponent must be a valid React Component');\n  return legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);\n}\nexport function unmountComponentAtNode(container) {\n  invariant(isValidContainer(container), 'unmountComponentAtNode(...): Target container is not a DOM element.');\n\n  if (__DEV__) {\n    const isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === undefined;\n\n    if (isModernRoot) {\n      warningWithoutStack(false, 'You are calling ReactDOM.unmountComponentAtNode() on a container that was previously ' + 'passed to ReactDOM.createRoot(). This is not supported. Did you mean to call root.unmount()?');\n    }\n  }\n\n  if (container._reactRootContainer) {\n    if (__DEV__) {\n      const rootEl = getReactRootElementInContainer(container);\n      const renderedByDifferentReact = rootEl && !getInstanceFromNode(rootEl);\n      warningWithoutStack(!renderedByDifferentReact, \"unmountComponentAtNode(): The node you're attempting to unmount \" + 'was rendered by another copy of React.');\n    } // Unmount should not be batched.\n\n\n    unbatchedUpdates(() => {\n      legacyRenderSubtreeIntoContainer(null, null, container, false, () => {\n        container._reactRootContainer = null;\n        unmarkContainerAsRoot(container);\n      });\n    }); // If you call unmountComponentAtNode twice in quick succession, you'll\n    // get `true` twice. That's probably fine?\n\n    return true;\n  } else {\n    if (__DEV__) {\n      const rootEl = getReactRootElementInContainer(container);\n      const hasNonRootReactChild = !!(rootEl && getInstanceFromNode(rootEl)); // Check if the container itself is a React root node.\n\n      const isContainerReactRoot = container.nodeType === ELEMENT_NODE && isValidContainer(container.parentNode) && !!container.parentNode._reactRootContainer;\n      warningWithoutStack(!hasNonRootReactChild, \"unmountComponentAtNode(): The node you're attempting to unmount \" + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.');\n    }\n\n    return false;\n  }\n}","map":{"version":3,"sources":["/Users/gaoshaoyun/Documents/library/debug-react/src/react/packages/react-dom/src/client/ReactDOMLegacy.js"],"names":["getInstanceFromNode","isContainerMarkedAsRoot","unmarkContainerAsRoot","createLegacyRoot","isValidContainer","warnOnInvalidCallback","ROOT_ATTRIBUTE_NAME","DOCUMENT_NODE","ELEMENT_NODE","COMMENT_NODE","findHostInstanceWithNoPortals","updateContainer","unbatchedUpdates","getPublicRootInstance","findHostInstance","findHostInstanceWithWarning","getComponentName","invariant","lowPriorityWarningWithoutStack","warningWithoutStack","ReactSharedInternals","has","hasInstance","ReactCurrentOwner","topLevelUpdateWarnings","warnedAboutHydrateAPI","__DEV__","container","_reactRootContainer","nodeType","hostInstance","_internalRoot","current","parentNode","isRootRenderedBySomeReact","rootEl","getReactRootElementInContainer","hasNonRootReactChild","tagName","toUpperCase","documentElement","firstChild","shouldHydrateDueToLegacyHeuristic","rootElement","hasAttribute","legacyCreateRootFromDOMContainer","forceHydrate","shouldHydrate","warned","rootSibling","lastChild","removeChild","hydrate","undefined","legacyRenderSubtreeIntoContainer","parentComponent","children","callback","root","fiberRoot","originalCallback","instance","call","findDOMNode","componentOrElement","owner","stateNode","warnedAboutRefsInRender","_warnedAboutRefsInRender","type","element","isModernRoot","render","unstable_renderSubtreeIntoContainer","containerNode","unmountComponentAtNode","renderedByDifferentReact","isContainerReactRoot"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {DOMContainer} from './ReactDOM';\nimport type {RootType} from './ReactDOMRoot';\nimport type {ReactNodeList} from 'shared/ReactTypes';\n\nimport {\n  getInstanceFromNode,\n  isContainerMarkedAsRoot,\n  unmarkContainerAsRoot,\n} from './ReactDOMComponentTree';\nimport {\n  createLegacyRoot,\n  isValidContainer,\n  warnOnInvalidCallback,\n} from './ReactDOMRoot';\nimport {ROOT_ATTRIBUTE_NAME} from '../shared/DOMProperty';\nimport {\n  DOCUMENT_NODE,\n  ELEMENT_NODE,\n  COMMENT_NODE,\n} from '../shared/HTMLNodeType';\n\nimport {\n  findHostInstanceWithNoPortals,\n  updateContainer,\n  unbatchedUpdates,\n  getPublicRootInstance,\n  findHostInstance,\n  findHostInstanceWithWarning,\n} from 'react-reconciler/inline.dom';\nimport getComponentName from 'shared/getComponentName';\nimport invariant from 'shared/invariant';\nimport lowPriorityWarningWithoutStack from 'shared/lowPriorityWarningWithoutStack';\nimport warningWithoutStack from 'shared/warningWithoutStack';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport {has as hasInstance} from 'shared/ReactInstanceMap';\n\nconst ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n\nlet topLevelUpdateWarnings;\nlet warnedAboutHydrateAPI = false;\n\nif (__DEV__) {\n  topLevelUpdateWarnings = (container: DOMContainer) => {\n    if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {\n      const hostInstance = findHostInstanceWithNoPortals(\n        container._reactRootContainer._internalRoot.current,\n      );\n      if (hostInstance) {\n        warningWithoutStack(\n          hostInstance.parentNode === container,\n          'render(...): It looks like the React-rendered content of this ' +\n            'container was removed without using React. This is not ' +\n            'supported and will cause errors. Instead, call ' +\n            'ReactDOM.unmountComponentAtNode to empty a container.',\n        );\n      }\n    }\n\n    const isRootRenderedBySomeReact = !!container._reactRootContainer;\n    const rootEl = getReactRootElementInContainer(container);\n    const hasNonRootReactChild = !!(rootEl && getInstanceFromNode(rootEl));\n\n    warningWithoutStack(\n      !hasNonRootReactChild || isRootRenderedBySomeReact,\n      'render(...): Replacing React-rendered children with a new root ' +\n        'component. If you intended to update the children of this node, ' +\n        'you should instead have the existing children update their state ' +\n        'and render the new components instead of calling ReactDOM.render.',\n    );\n\n    warningWithoutStack(\n      container.nodeType !== ELEMENT_NODE ||\n        !((container: any): Element).tagName ||\n        ((container: any): Element).tagName.toUpperCase() !== 'BODY',\n      'render(): Rendering components directly into document.body is ' +\n        'discouraged, since its children are often manipulated by third-party ' +\n        'scripts and browser extensions. This may lead to subtle ' +\n        'reconciliation issues. Try rendering into a container element created ' +\n        'for your app.',\n    );\n  };\n}\n\nfunction getReactRootElementInContainer(container: any) {\n  if (!container) {\n    return null;\n  }\n\n  if (container.nodeType === DOCUMENT_NODE) {\n    return container.documentElement;\n  } else {\n    return container.firstChild;\n  }\n}\n\nfunction shouldHydrateDueToLegacyHeuristic(container) {\n  const rootElement = getReactRootElementInContainer(container);\n  return !!(\n    rootElement &&\n    rootElement.nodeType === ELEMENT_NODE &&\n    rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME)\n  );\n}\n\nfunction legacyCreateRootFromDOMContainer(\n  container: DOMContainer,\n  forceHydrate: boolean,\n): RootType {\n  const shouldHydrate =\n    forceHydrate || shouldHydrateDueToLegacyHeuristic(container);\n  // First clear any existing content.\n  if (!shouldHydrate) {\n    let warned = false;\n    let rootSibling;\n    while ((rootSibling = container.lastChild)) {\n      if (__DEV__) {\n        if (\n          !warned &&\n          rootSibling.nodeType === ELEMENT_NODE &&\n          (rootSibling: any).hasAttribute(ROOT_ATTRIBUTE_NAME)\n        ) {\n          warned = true;\n          warningWithoutStack(\n            false,\n            'render(): Target node has markup rendered by React, but there ' +\n              'are unrelated nodes as well. This is most commonly caused by ' +\n              'white-space inserted around server-rendered markup.',\n          );\n        }\n      }\n      container.removeChild(rootSibling);\n    }\n  }\n  if (__DEV__) {\n    if (shouldHydrate && !forceHydrate && !warnedAboutHydrateAPI) {\n      warnedAboutHydrateAPI = true;\n      lowPriorityWarningWithoutStack(\n        false,\n        'render(): Calling ReactDOM.render() to hydrate server-rendered markup ' +\n          'will stop working in React v17. Replace the ReactDOM.render() call ' +\n          'with ReactDOM.hydrate() if you want React to attach to the server HTML.',\n      );\n    }\n  }\n\n  return createLegacyRoot(\n    container,\n    shouldHydrate\n      ? {\n          hydrate: true,\n        }\n      : undefined,\n  );\n}\n\nfunction legacyRenderSubtreeIntoContainer(\n  parentComponent: ?React$Component<any, any>,\n  children: ReactNodeList,\n  container: DOMContainer,\n  forceHydrate: boolean,\n  callback: ?Function,\n) {\n  if (__DEV__) {\n    topLevelUpdateWarnings(container);\n    warnOnInvalidCallback(callback === undefined ? null : callback, 'render');\n  }\n\n  // TODO: Without `any` type, Flow says \"Property cannot be accessed on any\n  // member of intersection type.\" Whyyyyyy.\n  let root: RootType = (container._reactRootContainer: any);\n  let fiberRoot;\n  if (!root) {\n    // Initial mount\n    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(\n      container,\n      forceHydrate,\n    );\n    fiberRoot = root._internalRoot;\n    if (typeof callback === 'function') {\n      const originalCallback = callback;\n      callback = function() {\n        const instance = getPublicRootInstance(fiberRoot);\n        originalCallback.call(instance);\n      };\n    }\n    // Initial mount should not be batched.\n    unbatchedUpdates(() => {\n      updateContainer(children, fiberRoot, parentComponent, callback);\n    });\n  } else {\n    fiberRoot = root._internalRoot;\n    if (typeof callback === 'function') {\n      const originalCallback = callback;\n      callback = function() {\n        const instance = getPublicRootInstance(fiberRoot);\n        originalCallback.call(instance);\n      };\n    }\n    // Update\n    updateContainer(children, fiberRoot, parentComponent, callback);\n  }\n  return getPublicRootInstance(fiberRoot);\n}\n\nexport function findDOMNode(\n  componentOrElement: Element | ?React$Component<any, any>,\n): null | Element | Text {\n  if (__DEV__) {\n    let owner = (ReactCurrentOwner.current: any);\n    if (owner !== null && owner.stateNode !== null) {\n      const warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;\n      warningWithoutStack(\n        warnedAboutRefsInRender,\n        '%s is accessing findDOMNode inside its render(). ' +\n          'render() should be a pure function of props and state. It should ' +\n          'never access something that requires stale data from the previous ' +\n          'render, such as refs. Move this logic to componentDidMount and ' +\n          'componentDidUpdate instead.',\n        getComponentName(owner.type) || 'A component',\n      );\n      owner.stateNode._warnedAboutRefsInRender = true;\n    }\n  }\n  if (componentOrElement == null) {\n    return null;\n  }\n  if ((componentOrElement: any).nodeType === ELEMENT_NODE) {\n    return (componentOrElement: any);\n  }\n  if (__DEV__) {\n    return findHostInstanceWithWarning(componentOrElement, 'findDOMNode');\n  }\n  return findHostInstance(componentOrElement);\n}\n\nexport function hydrate(\n  element: React$Node,\n  container: DOMContainer,\n  callback: ?Function,\n) {\n  invariant(\n    isValidContainer(container),\n    'Target container is not a DOM element.',\n  );\n  if (__DEV__) {\n    const isModernRoot =\n      isContainerMarkedAsRoot(container) &&\n      container._reactRootContainer === undefined;\n    if (isModernRoot) {\n      warningWithoutStack(\n        false,\n        'You are calling ReactDOM.hydrate() on a container that was previously ' +\n          'passed to ReactDOM.createRoot(). This is not supported. ' +\n          'Did you mean to call createRoot(container, {hydrate: true}).render(element)?',\n      );\n    }\n  }\n  // TODO: throw or warn if we couldn't hydrate?\n  return legacyRenderSubtreeIntoContainer(\n    null,\n    element,\n    container,\n    true,\n    callback,\n  );\n}\n\nexport function render(\n  element: React$Element<any>,\n  container: DOMContainer,\n  callback: ?Function,\n) {\n  invariant(\n    isValidContainer(container),\n    'Target container is not a DOM element.',\n  );\n  if (__DEV__) {\n    const isModernRoot =\n      isContainerMarkedAsRoot(container) &&\n      container._reactRootContainer === undefined;\n    if (isModernRoot) {\n      warningWithoutStack(\n        false,\n        'You are calling ReactDOM.render() on a container that was previously ' +\n          'passed to ReactDOM.createRoot(). This is not supported. ' +\n          'Did you mean to call root.render(element)?',\n      );\n    }\n  }\n  return legacyRenderSubtreeIntoContainer(\n    null,\n    element,\n    container,\n    false,\n    callback,\n  );\n}\n\nexport function unstable_renderSubtreeIntoContainer(\n  parentComponent: React$Component<any, any>,\n  element: React$Element<any>,\n  containerNode: DOMContainer,\n  callback: ?Function,\n) {\n  invariant(\n    isValidContainer(containerNode),\n    'Target container is not a DOM element.',\n  );\n  invariant(\n    parentComponent != null && hasInstance(parentComponent),\n    'parentComponent must be a valid React Component',\n  );\n  return legacyRenderSubtreeIntoContainer(\n    parentComponent,\n    element,\n    containerNode,\n    false,\n    callback,\n  );\n}\n\nexport function unmountComponentAtNode(container: DOMContainer) {\n  invariant(\n    isValidContainer(container),\n    'unmountComponentAtNode(...): Target container is not a DOM element.',\n  );\n\n  if (__DEV__) {\n    const isModernRoot =\n      isContainerMarkedAsRoot(container) &&\n      container._reactRootContainer === undefined;\n    if (isModernRoot) {\n      warningWithoutStack(\n        false,\n        'You are calling ReactDOM.unmountComponentAtNode() on a container that was previously ' +\n          'passed to ReactDOM.createRoot(). This is not supported. Did you mean to call root.unmount()?',\n      );\n    }\n  }\n\n  if (container._reactRootContainer) {\n    if (__DEV__) {\n      const rootEl = getReactRootElementInContainer(container);\n      const renderedByDifferentReact = rootEl && !getInstanceFromNode(rootEl);\n      warningWithoutStack(\n        !renderedByDifferentReact,\n        \"unmountComponentAtNode(): The node you're attempting to unmount \" +\n          'was rendered by another copy of React.',\n      );\n    }\n\n    // Unmount should not be batched.\n    unbatchedUpdates(() => {\n      legacyRenderSubtreeIntoContainer(null, null, container, false, () => {\n        container._reactRootContainer = null;\n        unmarkContainerAsRoot(container);\n      });\n    });\n    // If you call unmountComponentAtNode twice in quick succession, you'll\n    // get `true` twice. That's probably fine?\n    return true;\n  } else {\n    if (__DEV__) {\n      const rootEl = getReactRootElementInContainer(container);\n      const hasNonRootReactChild = !!(rootEl && getInstanceFromNode(rootEl));\n\n      // Check if the container itself is a React root node.\n      const isContainerReactRoot =\n        container.nodeType === ELEMENT_NODE &&\n        isValidContainer(container.parentNode) &&\n        !!container.parentNode._reactRootContainer;\n\n      warningWithoutStack(\n        !hasNonRootReactChild,\n        \"unmountComponentAtNode(): The node you're attempting to unmount \" +\n          'was rendered by React and is not a top-level container. %s',\n        isContainerReactRoot\n          ? 'You may have accidentally passed in a React root node instead ' +\n            'of its container.'\n          : 'Instead, have the parent component update its state and ' +\n            'rerender in order to remove this component.',\n      );\n    }\n\n    return false;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}