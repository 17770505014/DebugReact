{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { unstable_wrap as Schedule_tracing_wrap } from 'scheduler/tracing';\nimport { enableSchedulerTracing, enableProfilerTimer, enableSuspenseServerRenderer, enableFlareAPI, enableFundamentalAPI, enableSuspenseCallback, enableScopeAPI } from 'shared/ReactFeatureFlags';\nimport { FunctionComponent, ForwardRef, ClassComponent, HostRoot, HostComponent, HostText, HostPortal, Profiler, SuspenseComponent, DehydratedFragment, IncompleteClassComponent, MemoComponent, SimpleMemoComponent, SuspenseListComponent, FundamentalComponent, ScopeComponent } from 'shared/ReactWorkTags';\nimport { invokeGuardedCallback, hasCaughtError, clearCaughtError } from 'shared/ReactErrorUtils';\nimport { NoEffect, ContentReset, Placement, Snapshot, Update, Passive } from 'shared/ReactSideEffectTags';\nimport getComponentName from 'shared/getComponentName';\nimport invariant from 'shared/invariant';\nimport warningWithoutStack from 'shared/warningWithoutStack';\nimport warning from 'shared/warning';\nimport { onCommitUnmount } from './ReactFiberDevToolsHook';\nimport { startPhaseTimer, stopPhaseTimer } from './ReactDebugFiberPerf';\nimport { getStackByFiberInDevAndProd } from './ReactCurrentFiber';\nimport { logCapturedError } from './ReactFiberErrorLogger';\nimport { resolveDefaultProps } from './ReactFiberLazyComponent';\nimport { getCommitTime } from './ReactProfilerTimer';\nimport { commitUpdateQueue } from './ReactUpdateQueue';\nimport { getPublicInstance, supportsMutation, supportsPersistence, supportsHydration, commitMount, commitUpdate, resetTextContent, commitTextUpdate, appendChild, appendChildToContainer, insertBefore, insertInContainerBefore, removeChild, removeChildFromContainer, clearSuspenseBoundary, clearSuspenseBoundaryFromContainer, replaceContainerChildren, createContainerChildSet, hideInstance, hideTextInstance, unhideInstance, unhideTextInstance, unmountResponderInstance, unmountFundamentalComponent, updateFundamentalComponent } from './ReactFiberHostConfig';\nimport { captureCommitPhaseError, resolveRetryThenable, markCommitTimeOfFallback } from './ReactFiberWorkLoop';\nimport { NoEffect as NoHookEffect, UnmountSnapshot, UnmountMutation, MountMutation, UnmountLayout, MountLayout, UnmountPassive, MountPassive } from './ReactHookEffectTags';\nimport { didWarnAboutReassigningProps } from './ReactFiberBeginWork';\nimport { runWithPriority, NormalPriority } from './SchedulerWithReactIntegration';\nimport { updateEventListeners } from './ReactFiberEvents';\nlet didWarnAboutUndefinedSnapshotBeforeUpdate = null;\n\nif (__DEV__) {\n  didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();\n}\n\nconst PossiblyWeakSet = typeof WeakSet === 'function' ? WeakSet : Set;\nexport function logError(boundary, errorInfo) {\n  const source = errorInfo.source;\n  let stack = errorInfo.stack;\n\n  if (stack === null && source !== null) {\n    stack = getStackByFiberInDevAndProd(source);\n  }\n\n  const capturedError = {\n    componentName: source !== null ? getComponentName(source.type) : null,\n    componentStack: stack !== null ? stack : '',\n    error: errorInfo.value,\n    errorBoundary: null,\n    errorBoundaryName: null,\n    errorBoundaryFound: false,\n    willRetry: false\n  };\n\n  if (boundary !== null && boundary.tag === ClassComponent) {\n    capturedError.errorBoundary = boundary.stateNode;\n    capturedError.errorBoundaryName = getComponentName(boundary.type);\n    capturedError.errorBoundaryFound = true;\n    capturedError.willRetry = true;\n  }\n\n  try {\n    logCapturedError(capturedError);\n  } catch (e) {\n    // This method must not throw, or React internal state will get messed up.\n    // If console.error is overridden, or logCapturedError() shows a dialog that throws,\n    // we want to report this error outside of the normal stack as a last resort.\n    // https://github.com/facebook/react/issues/13188\n    setTimeout(() => {\n      throw e;\n    });\n  }\n}\n\nconst callComponentWillUnmountWithTimer = function (current, instance) {\n  startPhaseTimer(current, 'componentWillUnmount');\n  instance.props = current.memoizedProps;\n  instance.state = current.memoizedState;\n  instance.componentWillUnmount();\n  stopPhaseTimer();\n}; // Capture errors so they don't interrupt unmounting.\n\n\nfunction safelyCallComponentWillUnmount(current, instance) {\n  if (__DEV__) {\n    invokeGuardedCallback(null, callComponentWillUnmountWithTimer, null, current, instance);\n\n    if (hasCaughtError()) {\n      const unmountError = clearCaughtError();\n      captureCommitPhaseError(current, unmountError);\n    }\n  } else {\n    try {\n      callComponentWillUnmountWithTimer(current, instance);\n    } catch (unmountError) {\n      captureCommitPhaseError(current, unmountError);\n    }\n  }\n}\n\nfunction safelyDetachRef(current) {\n  const ref = current.ref;\n\n  if (ref !== null) {\n    if (typeof ref === 'function') {\n      if (__DEV__) {\n        invokeGuardedCallback(null, ref, null, null);\n\n        if (hasCaughtError()) {\n          const refError = clearCaughtError();\n          captureCommitPhaseError(current, refError);\n        }\n      } else {\n        try {\n          ref(null);\n        } catch (refError) {\n          captureCommitPhaseError(current, refError);\n        }\n      }\n    } else {\n      ref.current = null;\n    }\n  }\n}\n\nfunction safelyCallDestroy(current, destroy) {\n  if (__DEV__) {\n    invokeGuardedCallback(null, destroy, null);\n\n    if (hasCaughtError()) {\n      const error = clearCaughtError();\n      captureCommitPhaseError(current, error);\n    }\n  } else {\n    try {\n      destroy();\n    } catch (error) {\n      captureCommitPhaseError(current, error);\n    }\n  }\n}\n\nfunction commitBeforeMutationLifeCycles(current, finishedWork) {\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent:\n      {\n        commitHookEffectList(UnmountSnapshot, NoHookEffect, finishedWork);\n        return;\n      }\n\n    case ClassComponent:\n      {\n        if (finishedWork.effectTag & Snapshot) {\n          if (current !== null) {\n            const prevProps = current.memoizedProps;\n            const prevState = current.memoizedState;\n            startPhaseTimer(finishedWork, 'getSnapshotBeforeUpdate');\n            const instance = finishedWork.stateNode; // We could update instance props and state here,\n            // but instead we rely on them being set during last render.\n            // TODO: revisit this when we implement resuming.\n\n            if (__DEV__) {\n              if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                warning(instance.props === finishedWork.memoizedProps, 'Expected %s props to match memoized props before ' + 'getSnapshotBeforeUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');\n                warning(instance.state === finishedWork.memoizedState, 'Expected %s state to match memoized state before ' + 'getSnapshotBeforeUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');\n              }\n            }\n\n            const snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);\n\n            if (__DEV__) {\n              const didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;\n\n              if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {\n                didWarnSet.add(finishedWork.type);\n                warningWithoutStack(false, '%s.getSnapshotBeforeUpdate(): A snapshot value (or null) ' + 'must be returned. You have returned undefined.', getComponentName(finishedWork.type));\n              }\n            }\n\n            instance.__reactInternalSnapshotBeforeUpdate = snapshot;\n            stopPhaseTimer();\n          }\n        }\n\n        return;\n      }\n\n    case HostRoot:\n    case HostComponent:\n    case HostText:\n    case HostPortal:\n    case IncompleteClassComponent:\n      // Nothing to do for these component types\n      return;\n\n    default:\n      {\n        invariant(false, 'This unit of work tag should not have side-effects. This error is ' + 'likely caused by a bug in React. Please file an issue.');\n      }\n  }\n}\n\nfunction commitHookEffectList(unmountTag, mountTag, finishedWork) {\n  const updateQueue = finishedWork.updateQueue;\n  let lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n\n  if (lastEffect !== null) {\n    const firstEffect = lastEffect.next;\n    let effect = firstEffect;\n\n    do {\n      if ((effect.tag & unmountTag) !== NoHookEffect) {\n        // Unmount\n        const destroy = effect.destroy;\n        effect.destroy = undefined;\n\n        if (destroy !== undefined) {\n          destroy();\n        }\n      }\n\n      if ((effect.tag & mountTag) !== NoHookEffect) {\n        // Mount\n        const create = effect.create;\n        effect.destroy = create();\n\n        if (__DEV__) {\n          const destroy = effect.destroy;\n\n          if (destroy !== undefined && typeof destroy !== 'function') {\n            let addendum;\n\n            if (destroy === null) {\n              addendum = ' You returned null. If your effect does not require clean ' + 'up, return undefined (or nothing).';\n            } else if (typeof destroy.then === 'function') {\n              addendum = '\\n\\nIt looks like you wrote useEffect(async () => ...) or returned a Promise. ' + 'Instead, write the async function inside your effect ' + 'and call it immediately:\\n\\n' + 'useEffect(() => {\\n' + '  async function fetchData() {\\n' + '    // You can await here\\n' + '    const response = await MyAPI.getData(someId);\\n' + '    // ...\\n' + '  }\\n' + '  fetchData();\\n' + `}, [someId]); // Or [] if effect doesn't need props or state\\n\\n` + 'Learn more about data fetching with Hooks: https://fb.me/react-hooks-data-fetching';\n            } else {\n              addendum = ' You returned: ' + destroy;\n            }\n\n            warningWithoutStack(false, 'An effect function must not return anything besides a function, ' + 'which is used for clean-up.%s%s', addendum, getStackByFiberInDevAndProd(finishedWork));\n          }\n        }\n      }\n\n      effect = effect.next;\n    } while (effect !== firstEffect);\n  }\n}\n\nexport function commitPassiveHookEffects(finishedWork) {\n  if ((finishedWork.effectTag & Passive) !== NoEffect) {\n    switch (finishedWork.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent:\n        {\n          commitHookEffectList(UnmountPassive, NoHookEffect, finishedWork);\n          commitHookEffectList(NoHookEffect, MountPassive, finishedWork);\n          break;\n        }\n\n      default:\n        break;\n    }\n  }\n}\n\nfunction commitLifeCycles(finishedRoot, current, finishedWork, committedExpirationTime) {\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent:\n      {\n        commitHookEffectList(UnmountLayout, MountLayout, finishedWork);\n        break;\n      }\n\n    case ClassComponent:\n      {\n        const instance = finishedWork.stateNode;\n\n        if (finishedWork.effectTag & Update) {\n          if (current === null) {\n            startPhaseTimer(finishedWork, 'componentDidMount'); // We could update instance props and state here,\n            // but instead we rely on them being set during last render.\n            // TODO: revisit this when we implement resuming.\n\n            if (__DEV__) {\n              if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                warning(instance.props === finishedWork.memoizedProps, 'Expected %s props to match memoized props before ' + 'componentDidMount. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');\n                warning(instance.state === finishedWork.memoizedState, 'Expected %s state to match memoized state before ' + 'componentDidMount. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');\n              }\n            }\n\n            instance.componentDidMount();\n            stopPhaseTimer();\n          } else {\n            const prevProps = finishedWork.elementType === finishedWork.type ? current.memoizedProps : resolveDefaultProps(finishedWork.type, current.memoizedProps);\n            const prevState = current.memoizedState;\n            startPhaseTimer(finishedWork, 'componentDidUpdate'); // We could update instance props and state here,\n            // but instead we rely on them being set during last render.\n            // TODO: revisit this when we implement resuming.\n\n            if (__DEV__) {\n              if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                warning(instance.props === finishedWork.memoizedProps, 'Expected %s props to match memoized props before ' + 'componentDidUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');\n                warning(instance.state === finishedWork.memoizedState, 'Expected %s state to match memoized state before ' + 'componentDidUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');\n              }\n            }\n\n            instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);\n            stopPhaseTimer();\n          }\n        }\n\n        const updateQueue = finishedWork.updateQueue;\n\n        if (updateQueue !== null) {\n          if (__DEV__) {\n            if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n              warning(instance.props === finishedWork.memoizedProps, 'Expected %s props to match memoized props before ' + 'processing the update queue. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');\n              warning(instance.state === finishedWork.memoizedState, 'Expected %s state to match memoized state before ' + 'processing the update queue. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');\n            }\n          } // We could update instance props and state here,\n          // but instead we rely on them being set during last render.\n          // TODO: revisit this when we implement resuming.\n\n\n          commitUpdateQueue(finishedWork, updateQueue, instance, committedExpirationTime);\n        }\n\n        return;\n      }\n\n    case HostRoot:\n      {\n        const updateQueue = finishedWork.updateQueue;\n\n        if (updateQueue !== null) {\n          let instance = null;\n\n          if (finishedWork.child !== null) {\n            switch (finishedWork.child.tag) {\n              case HostComponent:\n                instance = getPublicInstance(finishedWork.child.stateNode);\n                break;\n\n              case ClassComponent:\n                instance = finishedWork.child.stateNode;\n                break;\n            }\n          }\n\n          commitUpdateQueue(finishedWork, updateQueue, instance, committedExpirationTime);\n        }\n\n        return;\n      }\n\n    case HostComponent:\n      {\n        const instance = finishedWork.stateNode; // Renderers may schedule work to be done after host components are mounted\n        // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n        // These effects should only be committed when components are first mounted,\n        // aka when there is no current/alternate.\n\n        if (current === null && finishedWork.effectTag & Update) {\n          const type = finishedWork.type;\n          const props = finishedWork.memoizedProps;\n          commitMount(instance, type, props, finishedWork);\n        }\n\n        return;\n      }\n\n    case HostText:\n      {\n        // We have no life-cycles associated with text.\n        return;\n      }\n\n    case HostPortal:\n      {\n        // We have no life-cycles associated with portals.\n        return;\n      }\n\n    case Profiler:\n      {\n        if (enableProfilerTimer) {\n          const onRender = finishedWork.memoizedProps.onRender;\n\n          if (typeof onRender === 'function') {\n            if (enableSchedulerTracing) {\n              onRender(finishedWork.memoizedProps.id, current === null ? 'mount' : 'update', finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, getCommitTime(), finishedRoot.memoizedInteractions);\n            } else {\n              onRender(finishedWork.memoizedProps.id, current === null ? 'mount' : 'update', finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, getCommitTime());\n            }\n          }\n        }\n\n        return;\n      }\n\n    case SuspenseComponent:\n      {\n        if (enableSuspenseCallback) {\n          commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n        }\n\n        return;\n      }\n\n    case SuspenseListComponent:\n    case IncompleteClassComponent:\n    case FundamentalComponent:\n    case ScopeComponent:\n      return;\n\n    default:\n      {\n        invariant(false, 'This unit of work tag should not have side-effects. This error is ' + 'likely caused by a bug in React. Please file an issue.');\n      }\n  }\n}\n\nfunction hideOrUnhideAllChildren(finishedWork, isHidden) {\n  if (supportsMutation) {\n    // We only have the top Fiber that was inserted but we need to recurse down its\n    // children to find all the terminal nodes.\n    let node = finishedWork;\n\n    while (true) {\n      if (node.tag === HostComponent) {\n        const instance = node.stateNode;\n\n        if (isHidden) {\n          hideInstance(instance);\n        } else {\n          unhideInstance(node.stateNode, node.memoizedProps);\n        }\n      } else if (node.tag === HostText) {\n        const instance = node.stateNode;\n\n        if (isHidden) {\n          hideTextInstance(instance);\n        } else {\n          unhideTextInstance(instance, node.memoizedProps);\n        }\n      } else if (node.tag === SuspenseComponent && node.memoizedState !== null && node.memoizedState.dehydrated === null) {\n        // Found a nested Suspense component that timed out. Skip over the\n        // primary child fragment, which should remain hidden.\n        const fallbackChildFragment = node.child.sibling;\n        fallbackChildFragment.return = node;\n        node = fallbackChildFragment;\n        continue;\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n\n      if (node === finishedWork) {\n        return;\n      }\n\n      while (node.sibling === null) {\n        if (node.return === null || node.return === finishedWork) {\n          return;\n        }\n\n        node = node.return;\n      }\n\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  }\n}\n\nfunction commitAttachRef(finishedWork) {\n  const ref = finishedWork.ref;\n\n  if (ref !== null) {\n    const instance = finishedWork.stateNode;\n    let instanceToUse;\n\n    switch (finishedWork.tag) {\n      case HostComponent:\n        instanceToUse = getPublicInstance(instance);\n        break;\n\n      default:\n        instanceToUse = instance;\n    } // Moved outside to ensure DCE works with this flag\n\n\n    if (enableScopeAPI && finishedWork.tag === ScopeComponent) {\n      instanceToUse = instance.methods;\n    }\n\n    if (typeof ref === 'function') {\n      ref(instanceToUse);\n    } else {\n      if (__DEV__) {\n        if (!ref.hasOwnProperty('current')) {\n          warningWithoutStack(false, 'Unexpected ref object provided for %s. ' + 'Use either a ref-setter function or React.createRef().%s', getComponentName(finishedWork.type), getStackByFiberInDevAndProd(finishedWork));\n        }\n      }\n\n      ref.current = instanceToUse;\n    }\n  }\n}\n\nfunction commitDetachRef(current) {\n  const currentRef = current.ref;\n\n  if (currentRef !== null) {\n    if (typeof currentRef === 'function') {\n      currentRef(null);\n    } else {\n      currentRef.current = null;\n    }\n  }\n} // User-originating errors (lifecycles and refs) should not interrupt\n// deletion, so don't let them throw. Host-originating errors should\n// interrupt deletion, so it's okay\n\n\nfunction commitUnmount(finishedRoot, current, renderPriorityLevel) {\n  onCommitUnmount(current);\n\n  switch (current.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case MemoComponent:\n    case SimpleMemoComponent:\n      {\n        const updateQueue = current.updateQueue;\n\n        if (updateQueue !== null) {\n          const lastEffect = updateQueue.lastEffect;\n\n          if (lastEffect !== null) {\n            const firstEffect = lastEffect.next; // When the owner fiber is deleted, the destroy function of a passive\n            // effect hook is called during the synchronous commit phase. This is\n            // a concession to implementation complexity. Calling it in the\n            // passive effect phase (like they usually are, when dependencies\n            // change during an update) would require either traversing the\n            // children of the deleted fiber again, or including unmount effects\n            // as part of the fiber effect list.\n            //\n            // Because this is during the sync commit phase, we need to change\n            // the priority.\n            //\n            // TODO: Reconsider this implementation trade off.\n\n            const priorityLevel = renderPriorityLevel > NormalPriority ? NormalPriority : renderPriorityLevel;\n            runWithPriority(priorityLevel, () => {\n              let effect = firstEffect;\n\n              do {\n                const destroy = effect.destroy;\n\n                if (destroy !== undefined) {\n                  safelyCallDestroy(current, destroy);\n                }\n\n                effect = effect.next;\n              } while (effect !== firstEffect);\n            });\n          }\n        }\n\n        break;\n      }\n\n    case ClassComponent:\n      {\n        safelyDetachRef(current);\n        const instance = current.stateNode;\n\n        if (typeof instance.componentWillUnmount === 'function') {\n          safelyCallComponentWillUnmount(current, instance);\n        }\n\n        return;\n      }\n\n    case HostComponent:\n      {\n        if (enableFlareAPI) {\n          const dependencies = current.dependencies;\n\n          if (dependencies !== null) {\n            const respondersMap = dependencies.responders;\n\n            if (respondersMap !== null) {\n              const responderInstances = Array.from(respondersMap.values());\n\n              for (let i = 0, length = responderInstances.length; i < length; i++) {\n                const responderInstance = responderInstances[i];\n                unmountResponderInstance(responderInstance);\n              }\n\n              dependencies.responders = null;\n            }\n          }\n        }\n\n        safelyDetachRef(current);\n        return;\n      }\n\n    case HostPortal:\n      {\n        // TODO: this is recursive.\n        // We are also not using this parent because\n        // the portal will get pushed immediately.\n        if (supportsMutation) {\n          unmountHostComponents(finishedRoot, current, renderPriorityLevel);\n        } else if (supportsPersistence) {\n          emptyPortalContainer(current);\n        }\n\n        return;\n      }\n\n    case FundamentalComponent:\n      {\n        if (enableFundamentalAPI) {\n          const fundamentalInstance = current.stateNode;\n\n          if (fundamentalInstance !== null) {\n            unmountFundamentalComponent(fundamentalInstance);\n            current.stateNode = null;\n          }\n        }\n\n        return;\n      }\n\n    case DehydratedFragment:\n      {\n        if (enableSuspenseCallback) {\n          const hydrationCallbacks = finishedRoot.hydrationCallbacks;\n\n          if (hydrationCallbacks !== null) {\n            const onDeleted = hydrationCallbacks.onDeleted;\n\n            if (onDeleted) {\n              onDeleted(current.stateNode);\n            }\n          }\n        }\n\n        return;\n      }\n\n    case ScopeComponent:\n      {\n        if (enableScopeAPI) {\n          safelyDetachRef(current);\n        }\n      }\n  }\n}\n\nfunction commitNestedUnmounts(finishedRoot, root, renderPriorityLevel) {\n  // While we're inside a removed host node we don't want to call\n  // removeChild on the inner nodes because they're removed by the top\n  // call anyway. We also want to call componentWillUnmount on all\n  // composites before this host node is removed from the tree. Therefore\n  // we do an inner loop while we're still inside the host node.\n  let node = root;\n\n  while (true) {\n    commitUnmount(finishedRoot, node, renderPriorityLevel); // Visit children because they may contain more composite or host nodes.\n    // Skip portals because commitUnmount() currently visits them recursively.\n\n    if (node.child !== null && ( // If we use mutation we drill down into portals using commitUnmount above.\n    // If we don't use mutation we drill down into portals here instead.\n    !supportsMutation || node.tag !== HostPortal)) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n\n    if (node === root) {\n      return;\n    }\n\n    while (node.sibling === null) {\n      if (node.return === null || node.return === root) {\n        return;\n      }\n\n      node = node.return;\n    }\n\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction detachFiber(current) {\n  // Cut off the return pointers to disconnect it from the tree. Ideally, we\n  // should clear the child pointer of the parent alternate to let this\n  // get GC:ed but we don't know which for sure which parent is the current\n  // one so we'll settle for GC:ing the subtree of this child. This child\n  // itself will be GC:ed when the parent updates the next time.\n  current.return = null;\n  current.child = null;\n  current.memoizedState = null;\n  current.updateQueue = null;\n  current.dependencies = null;\n  const alternate = current.alternate;\n\n  if (alternate !== null) {\n    alternate.return = null;\n    alternate.child = null;\n    alternate.memoizedState = null;\n    alternate.updateQueue = null;\n    alternate.dependencies = null;\n  }\n}\n\nfunction emptyPortalContainer(current) {\n  if (!supportsPersistence) {\n    return;\n  }\n\n  const portal = current.stateNode;\n  const {\n    containerInfo\n  } = portal;\n  const emptyChildSet = createContainerChildSet(containerInfo);\n  replaceContainerChildren(containerInfo, emptyChildSet);\n}\n\nfunction commitContainer(finishedWork) {\n  if (!supportsPersistence) {\n    return;\n  }\n\n  switch (finishedWork.tag) {\n    case ClassComponent:\n    case HostComponent:\n    case HostText:\n    case FundamentalComponent:\n      {\n        return;\n      }\n\n    case HostRoot:\n    case HostPortal:\n      {\n        const portalOrRoot = finishedWork.stateNode;\n        const {\n          containerInfo,\n          pendingChildren\n        } = portalOrRoot;\n        replaceContainerChildren(containerInfo, pendingChildren);\n        return;\n      }\n\n    default:\n      {\n        invariant(false, 'This unit of work tag should not have side-effects. This error is ' + 'likely caused by a bug in React. Please file an issue.');\n      }\n  }\n}\n\nfunction getHostParentFiber(fiber) {\n  let parent = fiber.return;\n\n  while (parent !== null) {\n    if (isHostParent(parent)) {\n      return parent;\n    }\n\n    parent = parent.return;\n  }\n\n  invariant(false, 'Expected to find a host parent. This error is likely caused by a bug ' + 'in React. Please file an issue.');\n}\n\nfunction isHostParent(fiber) {\n  return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;\n}\n\nfunction getHostSibling(fiber) {\n  // We're going to search forward into the tree until we find a sibling host\n  // node. Unfortunately, if multiple insertions are done in a row we have to\n  // search past them. This leads to exponential search for the next sibling.\n  // TODO: Find a more efficient way to do this.\n  let node = fiber;\n\n  siblings: while (true) {\n    // If we didn't find anything, let's try the next sibling.\n    while (node.sibling === null) {\n      if (node.return === null || isHostParent(node.return)) {\n        // If we pop out of the root or hit the parent the fiber we are the\n        // last sibling.\n        return null;\n      }\n\n      node = node.return;\n    }\n\n    node.sibling.return = node.return;\n    node = node.sibling;\n\n    while (node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedFragment) {\n      // If it is not host node and, we might have a host node inside it.\n      // Try to search down until we find one.\n      if (node.effectTag & Placement) {\n        // If we don't have a child, try the siblings instead.\n        continue siblings;\n      } // If we don't have a child, try the siblings instead.\n      // We also skip portals because they are not part of this host tree.\n\n\n      if (node.child === null || node.tag === HostPortal) {\n        continue siblings;\n      } else {\n        node.child.return = node;\n        node = node.child;\n      }\n    } // Check if this host node is stable or about to be placed.\n\n\n    if (!(node.effectTag & Placement)) {\n      // Found it!\n      return node.stateNode;\n    }\n  }\n}\n\nfunction commitPlacement(finishedWork) {\n  if (!supportsMutation) {\n    return;\n  } // Recursively insert all host nodes into the parent.\n\n\n  const parentFiber = getHostParentFiber(finishedWork); // Note: these two variables *must* always be updated together.\n\n  let parent;\n  let isContainer;\n  const parentStateNode = parentFiber.stateNode;\n\n  switch (parentFiber.tag) {\n    case HostComponent:\n      parent = parentStateNode;\n      isContainer = false;\n      break;\n\n    case HostRoot:\n      parent = parentStateNode.containerInfo;\n      isContainer = true;\n      break;\n\n    case HostPortal:\n      parent = parentStateNode.containerInfo;\n      isContainer = true;\n      break;\n\n    case FundamentalComponent:\n      if (enableFundamentalAPI) {\n        parent = parentStateNode.instance;\n        isContainer = false;\n      }\n\n    // eslint-disable-next-line-no-fallthrough\n\n    default:\n      invariant(false, 'Invalid host parent fiber. This error is likely caused by a bug ' + 'in React. Please file an issue.');\n  }\n\n  if (parentFiber.effectTag & ContentReset) {\n    // Reset the text content of the parent before doing any insertions\n    resetTextContent(parent); // Clear ContentReset from the effect tag\n\n    parentFiber.effectTag &= ~ContentReset;\n  }\n\n  const before = getHostSibling(finishedWork); // We only have the top Fiber that was inserted but we need to recurse down its\n  // children to find all the terminal nodes.\n\n  let node = finishedWork;\n\n  while (true) {\n    const isHost = node.tag === HostComponent || node.tag === HostText;\n\n    if (isHost || enableFundamentalAPI && node.tag === FundamentalComponent) {\n      const stateNode = isHost ? node.stateNode : node.stateNode.instance;\n\n      if (before) {\n        if (isContainer) {\n          insertInContainerBefore(parent, stateNode, before);\n        } else {\n          insertBefore(parent, stateNode, before);\n        }\n      } else {\n        if (isContainer) {\n          appendChildToContainer(parent, stateNode);\n        } else {\n          appendChild(parent, stateNode);\n        }\n      }\n    } else if (node.tag === HostPortal) {// If the insertion itself is a portal, then we don't want to traverse\n      // down its children. Instead, we'll get insertions from each child in\n      // the portal directly.\n    } else if (node.child !== null) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n\n    if (node === finishedWork) {\n      return;\n    }\n\n    while (node.sibling === null) {\n      if (node.return === null || node.return === finishedWork) {\n        return;\n      }\n\n      node = node.return;\n    }\n\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction unmountHostComponents(finishedRoot, current, renderPriorityLevel) {\n  // We only have the top Fiber that was deleted but we need to recurse down its\n  // children to find all the terminal nodes.\n  let node = current; // Each iteration, currentParent is populated with node's host parent if not\n  // currentParentIsValid.\n\n  let currentParentIsValid = false; // Note: these two variables *must* always be updated together.\n\n  let currentParent;\n  let currentParentIsContainer;\n\n  while (true) {\n    if (!currentParentIsValid) {\n      let parent = node.return;\n\n      findParent: while (true) {\n        invariant(parent !== null, 'Expected to find a host parent. This error is likely caused by ' + 'a bug in React. Please file an issue.');\n        const parentStateNode = parent.stateNode;\n\n        switch (parent.tag) {\n          case HostComponent:\n            currentParent = parentStateNode;\n            currentParentIsContainer = false;\n            break findParent;\n\n          case HostRoot:\n            currentParent = parentStateNode.containerInfo;\n            currentParentIsContainer = true;\n            break findParent;\n\n          case HostPortal:\n            currentParent = parentStateNode.containerInfo;\n            currentParentIsContainer = true;\n            break findParent;\n\n          case FundamentalComponent:\n            if (enableFundamentalAPI) {\n              currentParent = parentStateNode.instance;\n              currentParentIsContainer = false;\n            }\n\n        }\n\n        parent = parent.return;\n      }\n\n      currentParentIsValid = true;\n    }\n\n    if (node.tag === HostComponent || node.tag === HostText) {\n      commitNestedUnmounts(finishedRoot, node, renderPriorityLevel); // After all the children have unmounted, it is now safe to remove the\n      // node from the tree.\n\n      if (currentParentIsContainer) {\n        removeChildFromContainer(currentParent, node.stateNode);\n      } else {\n        removeChild(currentParent, node.stateNode);\n      } // Don't visit children because we already visited them.\n\n    } else if (enableFundamentalAPI && node.tag === FundamentalComponent) {\n      const fundamentalNode = node.stateNode.instance;\n      commitNestedUnmounts(finishedRoot, node, renderPriorityLevel); // After all the children have unmounted, it is now safe to remove the\n      // node from the tree.\n\n      if (currentParentIsContainer) {\n        removeChildFromContainer(currentParent, fundamentalNode);\n      } else {\n        removeChild(currentParent, fundamentalNode);\n      }\n    } else if (enableSuspenseServerRenderer && node.tag === DehydratedFragment) {\n      if (enableSuspenseCallback) {\n        const hydrationCallbacks = finishedRoot.hydrationCallbacks;\n\n        if (hydrationCallbacks !== null) {\n          const onDeleted = hydrationCallbacks.onDeleted;\n\n          if (onDeleted) {\n            onDeleted(node.stateNode);\n          }\n        }\n      } // Delete the dehydrated suspense boundary and all of its content.\n\n\n      if (currentParentIsContainer) {\n        clearSuspenseBoundaryFromContainer(currentParent, node.stateNode);\n      } else {\n        clearSuspenseBoundary(currentParent, node.stateNode);\n      }\n    } else if (node.tag === HostPortal) {\n      if (node.child !== null) {\n        // When we go into a portal, it becomes the parent to remove from.\n        // We will reassign it back when we pop the portal on the way up.\n        currentParent = node.stateNode.containerInfo;\n        currentParentIsContainer = true; // Visit children because portals might contain host components.\n\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n    } else {\n      commitUnmount(finishedRoot, node, renderPriorityLevel); // Visit children because we may find more host components below.\n\n      if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n    }\n\n    if (node === current) {\n      return;\n    }\n\n    while (node.sibling === null) {\n      if (node.return === null || node.return === current) {\n        return;\n      }\n\n      node = node.return;\n\n      if (node.tag === HostPortal) {\n        // When we go out of the portal, we need to restore the parent.\n        // Since we don't keep a stack of them, we will search for it.\n        currentParentIsValid = false;\n      }\n    }\n\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction commitDeletion(finishedRoot, current, renderPriorityLevel) {\n  if (supportsMutation) {\n    // Recursively delete all host nodes from the parent.\n    // Detach refs and call componentWillUnmount() on the whole subtree.\n    unmountHostComponents(finishedRoot, current, renderPriorityLevel);\n  } else {\n    // Detach refs and call componentWillUnmount() on the whole subtree.\n    commitNestedUnmounts(finishedRoot, current, renderPriorityLevel);\n  }\n\n  detachFiber(current);\n}\n\nfunction commitWork(current, finishedWork) {\n  if (!supportsMutation) {\n    switch (finishedWork.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case MemoComponent:\n      case SimpleMemoComponent:\n        {\n          // Note: We currently never use MountMutation, but useLayout uses\n          // UnmountMutation.\n          commitHookEffectList(UnmountMutation, MountMutation, finishedWork);\n          return;\n        }\n\n      case Profiler:\n        {\n          return;\n        }\n\n      case SuspenseComponent:\n        {\n          commitSuspenseComponent(finishedWork);\n          attachSuspenseRetryListeners(finishedWork);\n          return;\n        }\n\n      case SuspenseListComponent:\n        {\n          attachSuspenseRetryListeners(finishedWork);\n          return;\n        }\n\n      case HostRoot:\n        {\n          const root = finishedWork.stateNode;\n\n          if (supportsHydration) {\n            if (root.hydrate) {\n              // We've just hydrated. No need to hydrate again.\n              root.hydrate = false;\n            }\n          }\n\n          break;\n        }\n    }\n\n    commitContainer(finishedWork);\n    return;\n  }\n\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case MemoComponent:\n    case SimpleMemoComponent:\n      {\n        // Note: We currently never use MountMutation, but useLayout uses\n        // UnmountMutation.\n        commitHookEffectList(UnmountMutation, MountMutation, finishedWork);\n        return;\n      }\n\n    case ClassComponent:\n      {\n        return;\n      }\n\n    case HostComponent:\n      {\n        const instance = finishedWork.stateNode;\n\n        if (instance != null) {\n          // Commit the work prepared earlier.\n          const newProps = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps\n          // as the newProps. The updatePayload will contain the real change in\n          // this case.\n\n          const oldProps = current !== null ? current.memoizedProps : newProps;\n          const type = finishedWork.type; // TODO: Type the updateQueue to be specific to host components.\n\n          const updatePayload = finishedWork.updateQueue;\n          finishedWork.updateQueue = null;\n\n          if (updatePayload !== null) {\n            commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);\n          }\n\n          if (enableFlareAPI) {\n            const prevListeners = oldProps.listeners;\n            const nextListeners = newProps.listeners;\n\n            if (prevListeners !== nextListeners) {\n              updateEventListeners(nextListeners, finishedWork, null);\n            }\n          }\n        }\n\n        return;\n      }\n\n    case HostText:\n      {\n        invariant(finishedWork.stateNode !== null, 'This should have a text node initialized. This error is likely ' + 'caused by a bug in React. Please file an issue.');\n        const textInstance = finishedWork.stateNode;\n        const newText = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps\n        // as the newProps. The updatePayload will contain the real change in\n        // this case.\n\n        const oldText = current !== null ? current.memoizedProps : newText;\n        commitTextUpdate(textInstance, oldText, newText);\n        return;\n      }\n\n    case HostRoot:\n      {\n        const root = finishedWork.stateNode;\n\n        if (supportsHydration) {\n          if (root.hydrate) {\n            // We've just hydrated. No need to hydrate again.\n            root.hydrate = false;\n          }\n        }\n\n        return;\n      }\n\n    case Profiler:\n      {\n        return;\n      }\n\n    case SuspenseComponent:\n      {\n        commitSuspenseComponent(finishedWork);\n        attachSuspenseRetryListeners(finishedWork);\n        return;\n      }\n\n    case SuspenseListComponent:\n      {\n        attachSuspenseRetryListeners(finishedWork);\n        return;\n      }\n\n    case IncompleteClassComponent:\n      {\n        return;\n      }\n\n    case FundamentalComponent:\n      {\n        if (enableFundamentalAPI) {\n          const fundamentalInstance = finishedWork.stateNode;\n          updateFundamentalComponent(fundamentalInstance);\n        }\n\n        return;\n      }\n\n    case ScopeComponent:\n      {\n        if (enableScopeAPI) {\n          const scopeInstance = finishedWork.stateNode;\n          scopeInstance.fiber = finishedWork;\n\n          if (enableFlareAPI) {\n            const newProps = finishedWork.memoizedProps;\n            const oldProps = current !== null ? current.memoizedProps : newProps;\n            const prevListeners = oldProps.listeners;\n            const nextListeners = newProps.listeners;\n\n            if (prevListeners !== nextListeners) {\n              updateEventListeners(nextListeners, finishedWork, null);\n            }\n          }\n        }\n\n        return;\n      }\n\n    default:\n      {\n        invariant(false, 'This unit of work tag should not have side-effects. This error is ' + 'likely caused by a bug in React. Please file an issue.');\n      }\n  }\n}\n\nfunction commitSuspenseComponent(finishedWork) {\n  let newState = finishedWork.memoizedState;\n  let newDidTimeout;\n  let primaryChildParent = finishedWork;\n\n  if (newState === null) {\n    newDidTimeout = false;\n  } else {\n    newDidTimeout = true;\n    primaryChildParent = finishedWork.child;\n    markCommitTimeOfFallback();\n  }\n\n  if (supportsMutation && primaryChildParent !== null) {\n    hideOrUnhideAllChildren(primaryChildParent, newDidTimeout);\n  }\n\n  if (enableSuspenseCallback && newState !== null) {\n    const suspenseCallback = finishedWork.memoizedProps.suspenseCallback;\n\n    if (typeof suspenseCallback === 'function') {\n      const thenables = finishedWork.updateQueue;\n\n      if (thenables !== null) {\n        suspenseCallback(new Set(thenables));\n      }\n    } else if (__DEV__) {\n      if (suspenseCallback !== undefined) {\n        warning(false, 'Unexpected type for suspenseCallback.');\n      }\n    }\n  }\n}\n\nfunction commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {\n  if (enableSuspenseCallback) {\n    const hydrationCallbacks = finishedRoot.hydrationCallbacks;\n\n    if (hydrationCallbacks !== null) {\n      const onHydrated = hydrationCallbacks.onHydrated;\n\n      if (onHydrated) {\n        const newState = finishedWork.memoizedState;\n\n        if (newState === null) {\n          const current = finishedWork.alternate;\n\n          if (current !== null) {\n            const prevState = current.memoizedState;\n\n            if (prevState !== null && prevState.dehydrated !== null) {\n              onHydrated(prevState.dehydrated);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction attachSuspenseRetryListeners(finishedWork) {\n  // If this boundary just timed out, then it will have a set of thenables.\n  // For each thenable, attach a listener so that when it resolves, React\n  // attempts to re-render the boundary in the primary (pre-timeout) state.\n  const thenables = finishedWork.updateQueue;\n\n  if (thenables !== null) {\n    finishedWork.updateQueue = null;\n    let retryCache = finishedWork.stateNode;\n\n    if (retryCache === null) {\n      retryCache = finishedWork.stateNode = new PossiblyWeakSet();\n    }\n\n    thenables.forEach(thenable => {\n      // Memoize using the boundary fiber to prevent redundant listeners.\n      let retry = resolveRetryThenable.bind(null, finishedWork, thenable);\n\n      if (!retryCache.has(thenable)) {\n        if (enableSchedulerTracing) {\n          if (thenable.__reactDoNotTraceInteractions !== true) {\n            retry = Schedule_tracing_wrap(retry);\n          }\n        }\n\n        retryCache.add(thenable);\n        thenable.then(retry, retry);\n      }\n    });\n  }\n}\n\nfunction commitResetTextContent(current) {\n  if (!supportsMutation) {\n    return;\n  }\n\n  resetTextContent(current.stateNode);\n}\n\nexport { commitBeforeMutationLifeCycles, commitResetTextContent, commitPlacement, commitDeletion, commitWork, commitLifeCycles, commitAttachRef, commitDetachRef };","map":{"version":3,"sources":["/Users/gaoshaoyun/Documents/library/debug-react/src/react/packages/react-reconciler/src/ReactFiberCommitWork.js"],"names":["unstable_wrap","Schedule_tracing_wrap","enableSchedulerTracing","enableProfilerTimer","enableSuspenseServerRenderer","enableFlareAPI","enableFundamentalAPI","enableSuspenseCallback","enableScopeAPI","FunctionComponent","ForwardRef","ClassComponent","HostRoot","HostComponent","HostText","HostPortal","Profiler","SuspenseComponent","DehydratedFragment","IncompleteClassComponent","MemoComponent","SimpleMemoComponent","SuspenseListComponent","FundamentalComponent","ScopeComponent","invokeGuardedCallback","hasCaughtError","clearCaughtError","NoEffect","ContentReset","Placement","Snapshot","Update","Passive","getComponentName","invariant","warningWithoutStack","warning","onCommitUnmount","startPhaseTimer","stopPhaseTimer","getStackByFiberInDevAndProd","logCapturedError","resolveDefaultProps","getCommitTime","commitUpdateQueue","getPublicInstance","supportsMutation","supportsPersistence","supportsHydration","commitMount","commitUpdate","resetTextContent","commitTextUpdate","appendChild","appendChildToContainer","insertBefore","insertInContainerBefore","removeChild","removeChildFromContainer","clearSuspenseBoundary","clearSuspenseBoundaryFromContainer","replaceContainerChildren","createContainerChildSet","hideInstance","hideTextInstance","unhideInstance","unhideTextInstance","unmountResponderInstance","unmountFundamentalComponent","updateFundamentalComponent","captureCommitPhaseError","resolveRetryThenable","markCommitTimeOfFallback","NoHookEffect","UnmountSnapshot","UnmountMutation","MountMutation","UnmountLayout","MountLayout","UnmountPassive","MountPassive","didWarnAboutReassigningProps","runWithPriority","NormalPriority","updateEventListeners","didWarnAboutUndefinedSnapshotBeforeUpdate","__DEV__","Set","PossiblyWeakSet","WeakSet","logError","boundary","errorInfo","source","stack","capturedError","componentName","type","componentStack","error","value","errorBoundary","errorBoundaryName","errorBoundaryFound","willRetry","tag","stateNode","e","setTimeout","callComponentWillUnmountWithTimer","current","instance","props","memoizedProps","state","memoizedState","componentWillUnmount","safelyCallComponentWillUnmount","unmountError","safelyDetachRef","ref","refError","safelyCallDestroy","destroy","commitBeforeMutationLifeCycles","finishedWork","commitHookEffectList","effectTag","prevProps","prevState","elementType","snapshot","getSnapshotBeforeUpdate","didWarnSet","undefined","has","add","__reactInternalSnapshotBeforeUpdate","unmountTag","mountTag","updateQueue","lastEffect","firstEffect","next","effect","create","addendum","then","commitPassiveHookEffects","commitLifeCycles","finishedRoot","committedExpirationTime","componentDidMount","componentDidUpdate","child","onRender","id","actualDuration","treeBaseDuration","actualStartTime","memoizedInteractions","commitSuspenseHydrationCallbacks","hideOrUnhideAllChildren","isHidden","node","dehydrated","fallbackChildFragment","sibling","return","commitAttachRef","instanceToUse","methods","hasOwnProperty","commitDetachRef","currentRef","commitUnmount","renderPriorityLevel","priorityLevel","dependencies","respondersMap","responders","responderInstances","Array","from","values","i","length","responderInstance","unmountHostComponents","emptyPortalContainer","fundamentalInstance","hydrationCallbacks","onDeleted","commitNestedUnmounts","root","detachFiber","alternate","portal","containerInfo","emptyChildSet","commitContainer","portalOrRoot","pendingChildren","getHostParentFiber","fiber","parent","isHostParent","getHostSibling","siblings","commitPlacement","parentFiber","isContainer","parentStateNode","before","isHost","currentParentIsValid","currentParent","currentParentIsContainer","findParent","fundamentalNode","commitDeletion","commitWork","commitSuspenseComponent","attachSuspenseRetryListeners","hydrate","newProps","oldProps","updatePayload","prevListeners","listeners","nextListeners","textInstance","newText","oldText","scopeInstance","newState","newDidTimeout","primaryChildParent","suspenseCallback","thenables","onHydrated","retryCache","forEach","thenable","retry","bind","__reactDoNotTraceInteractions","commitResetTextContent"],"mappings":"AAAA;;;;;;;;AA0BA,SAAQA,aAAa,IAAIC,qBAAzB,QAAqD,mBAArD;AACA,SACEC,sBADF,EAEEC,mBAFF,EAGEC,4BAHF,EAIEC,cAJF,EAKEC,oBALF,EAMEC,sBANF,EAOEC,cAPF,QAQO,0BARP;AASA,SACEC,iBADF,EAEEC,UAFF,EAGEC,cAHF,EAIEC,QAJF,EAKEC,aALF,EAMEC,QANF,EAOEC,UAPF,EAQEC,QARF,EASEC,iBATF,EAUEC,kBAVF,EAWEC,wBAXF,EAYEC,aAZF,EAaEC,mBAbF,EAcEC,qBAdF,EAeEC,oBAfF,EAgBEC,cAhBF,QAiBO,sBAjBP;AAkBA,SACEC,qBADF,EAEEC,cAFF,EAGEC,gBAHF,QAIO,wBAJP;AAKA,SACEC,QADF,EAEEC,YAFF,EAGEC,SAHF,EAIEC,QAJF,EAKEC,MALF,EAMEC,OANF,QAOO,4BAPP;AAQA,OAAOC,gBAAP,MAA6B,yBAA7B;AACA,OAAOC,SAAP,MAAsB,kBAAtB;AACA,OAAOC,mBAAP,MAAgC,4BAAhC;AACA,OAAOC,OAAP,MAAoB,gBAApB;AAEA,SAAQC,eAAR,QAA8B,0BAA9B;AACA,SAAQC,eAAR,EAAyBC,cAAzB,QAA8C,uBAA9C;AACA,SAAQC,2BAAR,QAA0C,qBAA1C;AACA,SAAQC,gBAAR,QAA+B,yBAA/B;AACA,SAAQC,mBAAR,QAAkC,2BAAlC;AACA,SAAQC,aAAR,QAA4B,sBAA5B;AACA,SAAQC,iBAAR,QAAgC,oBAAhC;AACA,SACEC,iBADF,EAEEC,gBAFF,EAGEC,mBAHF,EAIEC,iBAJF,EAKEC,WALF,EAMEC,YANF,EAOEC,gBAPF,EAQEC,gBARF,EASEC,WATF,EAUEC,sBAVF,EAWEC,YAXF,EAYEC,uBAZF,EAaEC,WAbF,EAcEC,wBAdF,EAeEC,qBAfF,EAgBEC,kCAhBF,EAiBEC,wBAjBF,EAkBEC,uBAlBF,EAmBEC,YAnBF,EAoBEC,gBApBF,EAqBEC,cArBF,EAsBEC,kBAtBF,EAuBEC,wBAvBF,EAwBEC,2BAxBF,EAyBEC,0BAzBF,QA0BO,wBA1BP;AA2BA,SACEC,uBADF,EAEEC,oBAFF,EAGEC,wBAHF,QAIO,sBAJP;AAKA,SACE7C,QAAQ,IAAI8C,YADd,EAEEC,eAFF,EAGEC,eAHF,EAIEC,aAJF,EAKEC,aALF,EAMEC,WANF,EAOEC,cAPF,EAQEC,YARF,QASO,uBATP;AAUA,SAAQC,4BAAR,QAA2C,uBAA3C;AACA,SAAQC,eAAR,EAAyBC,cAAzB,QAA8C,iCAA9C;AACA,SAAQC,oBAAR,QAAmC,oBAAnC;AAEA,IAAIC,yCAA4D,GAAG,IAAnE;;AACA,IAAIC,OAAJ,EAAa;AACXD,EAAAA,yCAAyC,GAAG,IAAIE,GAAJ,EAA5C;AACD;;AAED,MAAMC,eAAe,GAAG,OAAOC,OAAP,KAAmB,UAAnB,GAAgCA,OAAhC,GAA0CF,GAAlE;AAEA,OAAO,SAASG,QAAT,CAAkBC,QAAlB,EAAmCC,SAAnC,EAAoE;AACzE,QAAMC,MAAM,GAAGD,SAAS,CAACC,MAAzB;AACA,MAAIC,KAAK,GAAGF,SAAS,CAACE,KAAtB;;AACA,MAAIA,KAAK,KAAK,IAAV,IAAkBD,MAAM,KAAK,IAAjC,EAAuC;AACrCC,IAAAA,KAAK,GAAGtD,2BAA2B,CAACqD,MAAD,CAAnC;AACD;;AAED,QAAME,aAA4B,GAAG;AACnCC,IAAAA,aAAa,EAAEH,MAAM,KAAK,IAAX,GAAkB5D,gBAAgB,CAAC4D,MAAM,CAACI,IAAR,CAAlC,GAAkD,IAD9B;AAEnCC,IAAAA,cAAc,EAAEJ,KAAK,KAAK,IAAV,GAAiBA,KAAjB,GAAyB,EAFN;AAGnCK,IAAAA,KAAK,EAAEP,SAAS,CAACQ,KAHkB;AAInCC,IAAAA,aAAa,EAAE,IAJoB;AAKnCC,IAAAA,iBAAiB,EAAE,IALgB;AAMnCC,IAAAA,kBAAkB,EAAE,KANe;AAOnCC,IAAAA,SAAS,EAAE;AAPwB,GAArC;;AAUA,MAAIb,QAAQ,KAAK,IAAb,IAAqBA,QAAQ,CAACc,GAAT,KAAiB/F,cAA1C,EAA0D;AACxDqF,IAAAA,aAAa,CAACM,aAAd,GAA8BV,QAAQ,CAACe,SAAvC;AACAX,IAAAA,aAAa,CAACO,iBAAd,GAAkCrE,gBAAgB,CAAC0D,QAAQ,CAACM,IAAV,CAAlD;AACAF,IAAAA,aAAa,CAACQ,kBAAd,GAAmC,IAAnC;AACAR,IAAAA,aAAa,CAACS,SAAd,GAA0B,IAA1B;AACD;;AAED,MAAI;AACF/D,IAAAA,gBAAgB,CAACsD,aAAD,CAAhB;AACD,GAFD,CAEE,OAAOY,CAAP,EAAU;AACV;AACA;AACA;AACA;AACAC,IAAAA,UAAU,CAAC,MAAM;AACf,YAAMD,CAAN;AACD,KAFS,CAAV;AAGD;AACF;;AAED,MAAME,iCAAiC,GAAG,UAASC,OAAT,EAAkBC,QAAlB,EAA4B;AACpEzE,EAAAA,eAAe,CAACwE,OAAD,EAAU,sBAAV,CAAf;AACAC,EAAAA,QAAQ,CAACC,KAAT,GAAiBF,OAAO,CAACG,aAAzB;AACAF,EAAAA,QAAQ,CAACG,KAAT,GAAiBJ,OAAO,CAACK,aAAzB;AACAJ,EAAAA,QAAQ,CAACK,oBAAT;AACA7E,EAAAA,cAAc;AACf,CAND,C,CAQA;;;AACA,SAAS8E,8BAAT,CAAwCP,OAAxC,EAAiDC,QAAjD,EAA2D;AACzD,MAAIzB,OAAJ,EAAa;AACX9D,IAAAA,qBAAqB,CACnB,IADmB,EAEnBqF,iCAFmB,EAGnB,IAHmB,EAInBC,OAJmB,EAKnBC,QALmB,CAArB;;AAOA,QAAItF,cAAc,EAAlB,EAAsB;AACpB,YAAM6F,YAAY,GAAG5F,gBAAgB,EAArC;AACA4C,MAAAA,uBAAuB,CAACwC,OAAD,EAAUQ,YAAV,CAAvB;AACD;AACF,GAZD,MAYO;AACL,QAAI;AACFT,MAAAA,iCAAiC,CAACC,OAAD,EAAUC,QAAV,CAAjC;AACD,KAFD,CAEE,OAAOO,YAAP,EAAqB;AACrBhD,MAAAA,uBAAuB,CAACwC,OAAD,EAAUQ,YAAV,CAAvB;AACD;AACF;AACF;;AAED,SAASC,eAAT,CAAyBT,OAAzB,EAAyC;AACvC,QAAMU,GAAG,GAAGV,OAAO,CAACU,GAApB;;AACA,MAAIA,GAAG,KAAK,IAAZ,EAAkB;AAChB,QAAI,OAAOA,GAAP,KAAe,UAAnB,EAA+B;AAC7B,UAAIlC,OAAJ,EAAa;AACX9D,QAAAA,qBAAqB,CAAC,IAAD,EAAOgG,GAAP,EAAY,IAAZ,EAAkB,IAAlB,CAArB;;AACA,YAAI/F,cAAc,EAAlB,EAAsB;AACpB,gBAAMgG,QAAQ,GAAG/F,gBAAgB,EAAjC;AACA4C,UAAAA,uBAAuB,CAACwC,OAAD,EAAUW,QAAV,CAAvB;AACD;AACF,OAND,MAMO;AACL,YAAI;AACFD,UAAAA,GAAG,CAAC,IAAD,CAAH;AACD,SAFD,CAEE,OAAOC,QAAP,EAAiB;AACjBnD,UAAAA,uBAAuB,CAACwC,OAAD,EAAUW,QAAV,CAAvB;AACD;AACF;AACF,KAdD,MAcO;AACLD,MAAAA,GAAG,CAACV,OAAJ,GAAc,IAAd;AACD;AACF;AACF;;AAED,SAASY,iBAAT,CAA2BZ,OAA3B,EAAoCa,OAApC,EAA6C;AAC3C,MAAIrC,OAAJ,EAAa;AACX9D,IAAAA,qBAAqB,CAAC,IAAD,EAAOmG,OAAP,EAAgB,IAAhB,CAArB;;AACA,QAAIlG,cAAc,EAAlB,EAAsB;AACpB,YAAM0E,KAAK,GAAGzE,gBAAgB,EAA9B;AACA4C,MAAAA,uBAAuB,CAACwC,OAAD,EAAUX,KAAV,CAAvB;AACD;AACF,GAND,MAMO;AACL,QAAI;AACFwB,MAAAA,OAAO;AACR,KAFD,CAEE,OAAOxB,KAAP,EAAc;AACd7B,MAAAA,uBAAuB,CAACwC,OAAD,EAAUX,KAAV,CAAvB;AACD;AACF;AACF;;AAED,SAASyB,8BAAT,CACEd,OADF,EAEEe,YAFF,EAGQ;AACN,UAAQA,YAAY,CAACpB,GAArB;AACE,SAAKjG,iBAAL;AACA,SAAKC,UAAL;AACA,SAAKW,mBAAL;AAA0B;AACxB0G,QAAAA,oBAAoB,CAACpD,eAAD,EAAkBD,YAAlB,EAAgCoD,YAAhC,CAApB;AACA;AACD;;AACD,SAAKnH,cAAL;AAAqB;AACnB,YAAImH,YAAY,CAACE,SAAb,GAAyBjG,QAA7B,EAAuC;AACrC,cAAIgF,OAAO,KAAK,IAAhB,EAAsB;AACpB,kBAAMkB,SAAS,GAAGlB,OAAO,CAACG,aAA1B;AACA,kBAAMgB,SAAS,GAAGnB,OAAO,CAACK,aAA1B;AACA7E,YAAAA,eAAe,CAACuF,YAAD,EAAe,yBAAf,CAAf;AACA,kBAAMd,QAAQ,GAAGc,YAAY,CAACnB,SAA9B,CAJoB,CAKpB;AACA;AACA;;AACA,gBAAIpB,OAAJ,EAAa;AACX,kBACEuC,YAAY,CAAC5B,IAAb,KAAsB4B,YAAY,CAACK,WAAnC,IACA,CAACjD,4BAFH,EAGE;AACA7C,gBAAAA,OAAO,CACL2E,QAAQ,CAACC,KAAT,KAAmBa,YAAY,CAACZ,aAD3B,EAEL,sDACE,2BADF,GAEE,6DAFF,GAGE,8CAHF,GAIE,uBANG,EAOLhF,gBAAgB,CAAC4F,YAAY,CAAC5B,IAAd,CAAhB,IAAuC,UAPlC,CAAP;AASA7D,gBAAAA,OAAO,CACL2E,QAAQ,CAACG,KAAT,KAAmBW,YAAY,CAACV,aAD3B,EAEL,sDACE,2BADF,GAEE,6DAFF,GAGE,8CAHF,GAIE,uBANG,EAOLlF,gBAAgB,CAAC4F,YAAY,CAAC5B,IAAd,CAAhB,IAAuC,UAPlC,CAAP;AASD;AACF;;AACD,kBAAMkC,QAAQ,GAAGpB,QAAQ,CAACqB,uBAAT,CACfP,YAAY,CAACK,WAAb,KAA6BL,YAAY,CAAC5B,IAA1C,GACI+B,SADJ,GAEItF,mBAAmB,CAACmF,YAAY,CAAC5B,IAAd,EAAoB+B,SAApB,CAHR,EAIfC,SAJe,CAAjB;;AAMA,gBAAI3C,OAAJ,EAAa;AACX,oBAAM+C,UAAU,GAAKhD,yCAArB;;AAGA,kBAAI8C,QAAQ,KAAKG,SAAb,IAA0B,CAACD,UAAU,CAACE,GAAX,CAAeV,YAAY,CAAC5B,IAA5B,CAA/B,EAAkE;AAChEoC,gBAAAA,UAAU,CAACG,GAAX,CAAeX,YAAY,CAAC5B,IAA5B;AACA9D,gBAAAA,mBAAmB,CACjB,KADiB,EAEjB,8DACE,gDAHe,EAIjBF,gBAAgB,CAAC4F,YAAY,CAAC5B,IAAd,CAJC,CAAnB;AAMD;AACF;;AACDc,YAAAA,QAAQ,CAAC0B,mCAAT,GAA+CN,QAA/C;AACA5F,YAAAA,cAAc;AACf;AACF;;AACD;AACD;;AACD,SAAK5B,QAAL;AACA,SAAKC,aAAL;AACA,SAAKC,QAAL;AACA,SAAKC,UAAL;AACA,SAAKI,wBAAL;AACE;AACA;;AACF;AAAS;AACPgB,QAAAA,SAAS,CACP,KADO,EAEP,uEACE,wDAHK,CAAT;AAKD;AAjFH;AAmFD;;AAED,SAAS4F,oBAAT,CACEY,UADF,EAEEC,QAFF,EAGEd,YAHF,EAIE;AACA,QAAMe,WAAgD,GAAIf,YAAY,CAACe,WAAvE;AACA,MAAIC,UAAU,GAAGD,WAAW,KAAK,IAAhB,GAAuBA,WAAW,CAACC,UAAnC,GAAgD,IAAjE;;AACA,MAAIA,UAAU,KAAK,IAAnB,EAAyB;AACvB,UAAMC,WAAW,GAAGD,UAAU,CAACE,IAA/B;AACA,QAAIC,MAAM,GAAGF,WAAb;;AACA,OAAG;AACD,UAAI,CAACE,MAAM,CAACvC,GAAP,GAAaiC,UAAd,MAA8BjE,YAAlC,EAAgD;AAC9C;AACA,cAAMkD,OAAO,GAAGqB,MAAM,CAACrB,OAAvB;AACAqB,QAAAA,MAAM,CAACrB,OAAP,GAAiBW,SAAjB;;AACA,YAAIX,OAAO,KAAKW,SAAhB,EAA2B;AACzBX,UAAAA,OAAO;AACR;AACF;;AACD,UAAI,CAACqB,MAAM,CAACvC,GAAP,GAAakC,QAAd,MAA4BlE,YAAhC,EAA8C;AAC5C;AACA,cAAMwE,MAAM,GAAGD,MAAM,CAACC,MAAtB;AACAD,QAAAA,MAAM,CAACrB,OAAP,GAAiBsB,MAAM,EAAvB;;AAEA,YAAI3D,OAAJ,EAAa;AACX,gBAAMqC,OAAO,GAAGqB,MAAM,CAACrB,OAAvB;;AACA,cAAIA,OAAO,KAAKW,SAAZ,IAAyB,OAAOX,OAAP,KAAmB,UAAhD,EAA4D;AAC1D,gBAAIuB,QAAJ;;AACA,gBAAIvB,OAAO,KAAK,IAAhB,EAAsB;AACpBuB,cAAAA,QAAQ,GACN,+DACA,oCAFF;AAGD,aAJD,MAIO,IAAI,OAAOvB,OAAO,CAACwB,IAAf,KAAwB,UAA5B,EAAwC;AAC7CD,cAAAA,QAAQ,GACN,mFACA,uDADA,GAEA,8BAFA,GAGA,qBAHA,GAIA,kCAJA,GAKA,6BALA,GAMA,qDANA,GAOA,cAPA,GAQA,OARA,GASA,kBATA,GAUC,kEAVD,GAWA,oFAZF;AAaD,aAdM,MAcA;AACLA,cAAAA,QAAQ,GAAG,oBAAoBvB,OAA/B;AACD;;AACDxF,YAAAA,mBAAmB,CACjB,KADiB,EAEjB,qEACE,iCAHe,EAIjB+G,QAJiB,EAKjB1G,2BAA2B,CAACqF,YAAD,CALV,CAAnB;AAOD;AACF;AACF;;AACDmB,MAAAA,MAAM,GAAGA,MAAM,CAACD,IAAhB;AACD,KAlDD,QAkDSC,MAAM,KAAKF,WAlDpB;AAmDD;AACF;;AAED,OAAO,SAASM,wBAAT,CAAkCvB,YAAlC,EAA6D;AAClE,MAAI,CAACA,YAAY,CAACE,SAAb,GAAyB/F,OAA1B,MAAuCL,QAA3C,EAAqD;AACnD,YAAQkG,YAAY,CAACpB,GAArB;AACE,WAAKjG,iBAAL;AACA,WAAKC,UAAL;AACA,WAAKW,mBAAL;AAA0B;AACxB0G,UAAAA,oBAAoB,CAAC/C,cAAD,EAAiBN,YAAjB,EAA+BoD,YAA/B,CAApB;AACAC,UAAAA,oBAAoB,CAACrD,YAAD,EAAeO,YAAf,EAA6B6C,YAA7B,CAApB;AACA;AACD;;AACD;AACE;AATJ;AAWD;AACF;;AAED,SAASwB,gBAAT,CACEC,YADF,EAEExC,OAFF,EAGEe,YAHF,EAIE0B,uBAJF,EAKQ;AACN,UAAQ1B,YAAY,CAACpB,GAArB;AACE,SAAKjG,iBAAL;AACA,SAAKC,UAAL;AACA,SAAKW,mBAAL;AAA0B;AACxB0G,QAAAA,oBAAoB,CAACjD,aAAD,EAAgBC,WAAhB,EAA6B+C,YAA7B,CAApB;AACA;AACD;;AACD,SAAKnH,cAAL;AAAqB;AACnB,cAAMqG,QAAQ,GAAGc,YAAY,CAACnB,SAA9B;;AACA,YAAImB,YAAY,CAACE,SAAb,GAAyBhG,MAA7B,EAAqC;AACnC,cAAI+E,OAAO,KAAK,IAAhB,EAAsB;AACpBxE,YAAAA,eAAe,CAACuF,YAAD,EAAe,mBAAf,CAAf,CADoB,CAEpB;AACA;AACA;;AACA,gBAAIvC,OAAJ,EAAa;AACX,kBACEuC,YAAY,CAAC5B,IAAb,KAAsB4B,YAAY,CAACK,WAAnC,IACA,CAACjD,4BAFH,EAGE;AACA7C,gBAAAA,OAAO,CACL2E,QAAQ,CAACC,KAAT,KAAmBa,YAAY,CAACZ,aAD3B,EAEL,sDACE,qBADF,GAEE,6DAFF,GAGE,8CAHF,GAIE,uBANG,EAOLhF,gBAAgB,CAAC4F,YAAY,CAAC5B,IAAd,CAAhB,IAAuC,UAPlC,CAAP;AASA7D,gBAAAA,OAAO,CACL2E,QAAQ,CAACG,KAAT,KAAmBW,YAAY,CAACV,aAD3B,EAEL,sDACE,qBADF,GAEE,6DAFF,GAGE,8CAHF,GAIE,uBANG,EAOLlF,gBAAgB,CAAC4F,YAAY,CAAC5B,IAAd,CAAhB,IAAuC,UAPlC,CAAP;AASD;AACF;;AACDc,YAAAA,QAAQ,CAACyC,iBAAT;AACAjH,YAAAA,cAAc;AACf,WAhCD,MAgCO;AACL,kBAAMyF,SAAS,GACbH,YAAY,CAACK,WAAb,KAA6BL,YAAY,CAAC5B,IAA1C,GACIa,OAAO,CAACG,aADZ,GAEIvE,mBAAmB,CAACmF,YAAY,CAAC5B,IAAd,EAAoBa,OAAO,CAACG,aAA5B,CAHzB;AAIA,kBAAMgB,SAAS,GAAGnB,OAAO,CAACK,aAA1B;AACA7E,YAAAA,eAAe,CAACuF,YAAD,EAAe,oBAAf,CAAf,CANK,CAOL;AACA;AACA;;AACA,gBAAIvC,OAAJ,EAAa;AACX,kBACEuC,YAAY,CAAC5B,IAAb,KAAsB4B,YAAY,CAACK,WAAnC,IACA,CAACjD,4BAFH,EAGE;AACA7C,gBAAAA,OAAO,CACL2E,QAAQ,CAACC,KAAT,KAAmBa,YAAY,CAACZ,aAD3B,EAEL,sDACE,sBADF,GAEE,6DAFF,GAGE,8CAHF,GAIE,uBANG,EAOLhF,gBAAgB,CAAC4F,YAAY,CAAC5B,IAAd,CAAhB,IAAuC,UAPlC,CAAP;AASA7D,gBAAAA,OAAO,CACL2E,QAAQ,CAACG,KAAT,KAAmBW,YAAY,CAACV,aAD3B,EAEL,sDACE,sBADF,GAEE,6DAFF,GAGE,8CAHF,GAIE,uBANG,EAOLlF,gBAAgB,CAAC4F,YAAY,CAAC5B,IAAd,CAAhB,IAAuC,UAPlC,CAAP;AASD;AACF;;AACDc,YAAAA,QAAQ,CAAC0C,kBAAT,CACEzB,SADF,EAEEC,SAFF,EAGElB,QAAQ,CAAC0B,mCAHX;AAKAlG,YAAAA,cAAc;AACf;AACF;;AACD,cAAMqG,WAAW,GAAGf,YAAY,CAACe,WAAjC;;AACA,YAAIA,WAAW,KAAK,IAApB,EAA0B;AACxB,cAAItD,OAAJ,EAAa;AACX,gBACEuC,YAAY,CAAC5B,IAAb,KAAsB4B,YAAY,CAACK,WAAnC,IACA,CAACjD,4BAFH,EAGE;AACA7C,cAAAA,OAAO,CACL2E,QAAQ,CAACC,KAAT,KAAmBa,YAAY,CAACZ,aAD3B,EAEL,sDACE,+BADF,GAEE,6DAFF,GAGE,8CAHF,GAIE,uBANG,EAOLhF,gBAAgB,CAAC4F,YAAY,CAAC5B,IAAd,CAAhB,IAAuC,UAPlC,CAAP;AASA7D,cAAAA,OAAO,CACL2E,QAAQ,CAACG,KAAT,KAAmBW,YAAY,CAACV,aAD3B,EAEL,sDACE,+BADF,GAEE,6DAFF,GAGE,8CAHF,GAIE,uBANG,EAOLlF,gBAAgB,CAAC4F,YAAY,CAAC5B,IAAd,CAAhB,IAAuC,UAPlC,CAAP;AASD;AACF,WAzBuB,CA0BxB;AACA;AACA;;;AACArD,UAAAA,iBAAiB,CACfiF,YADe,EAEfe,WAFe,EAGf7B,QAHe,EAIfwC,uBAJe,CAAjB;AAMD;;AACD;AACD;;AACD,SAAK5I,QAAL;AAAe;AACb,cAAMiI,WAAW,GAAGf,YAAY,CAACe,WAAjC;;AACA,YAAIA,WAAW,KAAK,IAApB,EAA0B;AACxB,cAAI7B,QAAQ,GAAG,IAAf;;AACA,cAAIc,YAAY,CAAC6B,KAAb,KAAuB,IAA3B,EAAiC;AAC/B,oBAAQ7B,YAAY,CAAC6B,KAAb,CAAmBjD,GAA3B;AACE,mBAAK7F,aAAL;AACEmG,gBAAAA,QAAQ,GAAGlE,iBAAiB,CAACgF,YAAY,CAAC6B,KAAb,CAAmBhD,SAApB,CAA5B;AACA;;AACF,mBAAKhG,cAAL;AACEqG,gBAAAA,QAAQ,GAAGc,YAAY,CAAC6B,KAAb,CAAmBhD,SAA9B;AACA;AANJ;AAQD;;AACD9D,UAAAA,iBAAiB,CACfiF,YADe,EAEfe,WAFe,EAGf7B,QAHe,EAIfwC,uBAJe,CAAjB;AAMD;;AACD;AACD;;AACD,SAAK3I,aAAL;AAAoB;AAClB,cAAMmG,QAAkB,GAAGc,YAAY,CAACnB,SAAxC,CADkB,CAGlB;AACA;AACA;AACA;;AACA,YAAII,OAAO,KAAK,IAAZ,IAAoBe,YAAY,CAACE,SAAb,GAAyBhG,MAAjD,EAAyD;AACvD,gBAAMkE,IAAI,GAAG4B,YAAY,CAAC5B,IAA1B;AACA,gBAAMe,KAAK,GAAGa,YAAY,CAACZ,aAA3B;AACAhE,UAAAA,WAAW,CAAC8D,QAAD,EAAWd,IAAX,EAAiBe,KAAjB,EAAwBa,YAAxB,CAAX;AACD;;AAED;AACD;;AACD,SAAKhH,QAAL;AAAe;AACb;AACA;AACD;;AACD,SAAKC,UAAL;AAAiB;AACf;AACA;AACD;;AACD,SAAKC,QAAL;AAAe;AACb,YAAIb,mBAAJ,EAAyB;AACvB,gBAAMyJ,QAAQ,GAAG9B,YAAY,CAACZ,aAAb,CAA2B0C,QAA5C;;AAEA,cAAI,OAAOA,QAAP,KAAoB,UAAxB,EAAoC;AAClC,gBAAI1J,sBAAJ,EAA4B;AAC1B0J,cAAAA,QAAQ,CACN9B,YAAY,CAACZ,aAAb,CAA2B2C,EADrB,EAEN9C,OAAO,KAAK,IAAZ,GAAmB,OAAnB,GAA6B,QAFvB,EAGNe,YAAY,CAACgC,cAHP,EAINhC,YAAY,CAACiC,gBAJP,EAKNjC,YAAY,CAACkC,eALP,EAMNpH,aAAa,EANP,EAON2G,YAAY,CAACU,oBAPP,CAAR;AASD,aAVD,MAUO;AACLL,cAAAA,QAAQ,CACN9B,YAAY,CAACZ,aAAb,CAA2B2C,EADrB,EAEN9C,OAAO,KAAK,IAAZ,GAAmB,OAAnB,GAA6B,QAFvB,EAGNe,YAAY,CAACgC,cAHP,EAINhC,YAAY,CAACiC,gBAJP,EAKNjC,YAAY,CAACkC,eALP,EAMNpH,aAAa,EANP,CAAR;AAQD;AACF;AACF;;AACD;AACD;;AACD,SAAK3B,iBAAL;AAAwB;AACtB,YAAIV,sBAAJ,EAA4B;AAC1B2J,UAAAA,gCAAgC,CAACX,YAAD,EAAezB,YAAf,CAAhC;AACD;;AACD;AACD;;AACD,SAAKxG,qBAAL;AACA,SAAKH,wBAAL;AACA,SAAKI,oBAAL;AACA,SAAKC,cAAL;AACE;;AACF;AAAS;AACPW,QAAAA,SAAS,CACP,KADO,EAEP,uEACE,wDAHK,CAAT;AAKD;AAxNH;AA0ND;;AAED,SAASgI,uBAAT,CAAiCrC,YAAjC,EAA+CsC,QAA/C,EAAyD;AACvD,MAAIrH,gBAAJ,EAAsB;AACpB;AACA;AACA,QAAIsH,IAAW,GAAGvC,YAAlB;;AACA,WAAO,IAAP,EAAa;AACX,UAAIuC,IAAI,CAAC3D,GAAL,KAAa7F,aAAjB,EAAgC;AAC9B,cAAMmG,QAAQ,GAAGqD,IAAI,CAAC1D,SAAtB;;AACA,YAAIyD,QAAJ,EAAc;AACZpG,UAAAA,YAAY,CAACgD,QAAD,CAAZ;AACD,SAFD,MAEO;AACL9C,UAAAA,cAAc,CAACmG,IAAI,CAAC1D,SAAN,EAAiB0D,IAAI,CAACnD,aAAtB,CAAd;AACD;AACF,OAPD,MAOO,IAAImD,IAAI,CAAC3D,GAAL,KAAa5F,QAAjB,EAA2B;AAChC,cAAMkG,QAAQ,GAAGqD,IAAI,CAAC1D,SAAtB;;AACA,YAAIyD,QAAJ,EAAc;AACZnG,UAAAA,gBAAgB,CAAC+C,QAAD,CAAhB;AACD,SAFD,MAEO;AACL7C,UAAAA,kBAAkB,CAAC6C,QAAD,EAAWqD,IAAI,CAACnD,aAAhB,CAAlB;AACD;AACF,OAPM,MAOA,IACLmD,IAAI,CAAC3D,GAAL,KAAazF,iBAAb,IACAoJ,IAAI,CAACjD,aAAL,KAAuB,IADvB,IAEAiD,IAAI,CAACjD,aAAL,CAAmBkD,UAAnB,KAAkC,IAH7B,EAIL;AACA;AACA;AACA,cAAMC,qBAA4B,GAAIF,IAAI,CAACV,KAAN,CAAkBa,OAAvD;AACAD,QAAAA,qBAAqB,CAACE,MAAtB,GAA+BJ,IAA/B;AACAA,QAAAA,IAAI,GAAGE,qBAAP;AACA;AACD,OAXM,MAWA,IAAIF,IAAI,CAACV,KAAL,KAAe,IAAnB,EAAyB;AAC9BU,QAAAA,IAAI,CAACV,KAAL,CAAWc,MAAX,GAAoBJ,IAApB;AACAA,QAAAA,IAAI,GAAGA,IAAI,CAACV,KAAZ;AACA;AACD;;AACD,UAAIU,IAAI,KAAKvC,YAAb,EAA2B;AACzB;AACD;;AACD,aAAOuC,IAAI,CAACG,OAAL,KAAiB,IAAxB,EAA8B;AAC5B,YAAIH,IAAI,CAACI,MAAL,KAAgB,IAAhB,IAAwBJ,IAAI,CAACI,MAAL,KAAgB3C,YAA5C,EAA0D;AACxD;AACD;;AACDuC,QAAAA,IAAI,GAAGA,IAAI,CAACI,MAAZ;AACD;;AACDJ,MAAAA,IAAI,CAACG,OAAL,CAAaC,MAAb,GAAsBJ,IAAI,CAACI,MAA3B;AACAJ,MAAAA,IAAI,GAAGA,IAAI,CAACG,OAAZ;AACD;AACF;AACF;;AAED,SAASE,eAAT,CAAyB5C,YAAzB,EAA8C;AAC5C,QAAML,GAAG,GAAGK,YAAY,CAACL,GAAzB;;AACA,MAAIA,GAAG,KAAK,IAAZ,EAAkB;AAChB,UAAMT,QAAQ,GAAGc,YAAY,CAACnB,SAA9B;AACA,QAAIgE,aAAJ;;AACA,YAAQ7C,YAAY,CAACpB,GAArB;AACE,WAAK7F,aAAL;AACE8J,QAAAA,aAAa,GAAG7H,iBAAiB,CAACkE,QAAD,CAAjC;AACA;;AACF;AACE2D,QAAAA,aAAa,GAAG3D,QAAhB;AALJ,KAHgB,CAUhB;;;AACA,QAAIxG,cAAc,IAAIsH,YAAY,CAACpB,GAAb,KAAqBlF,cAA3C,EAA2D;AACzDmJ,MAAAA,aAAa,GAAG3D,QAAQ,CAAC4D,OAAzB;AACD;;AACD,QAAI,OAAOnD,GAAP,KAAe,UAAnB,EAA+B;AAC7BA,MAAAA,GAAG,CAACkD,aAAD,CAAH;AACD,KAFD,MAEO;AACL,UAAIpF,OAAJ,EAAa;AACX,YAAI,CAACkC,GAAG,CAACoD,cAAJ,CAAmB,SAAnB,CAAL,EAAoC;AAClCzI,UAAAA,mBAAmB,CACjB,KADiB,EAEjB,4CACE,0DAHe,EAIjBF,gBAAgB,CAAC4F,YAAY,CAAC5B,IAAd,CAJC,EAKjBzD,2BAA2B,CAACqF,YAAD,CALV,CAAnB;AAOD;AACF;;AAEDL,MAAAA,GAAG,CAACV,OAAJ,GAAc4D,aAAd;AACD;AACF;AACF;;AAED,SAASG,eAAT,CAAyB/D,OAAzB,EAAyC;AACvC,QAAMgE,UAAU,GAAGhE,OAAO,CAACU,GAA3B;;AACA,MAAIsD,UAAU,KAAK,IAAnB,EAAyB;AACvB,QAAI,OAAOA,UAAP,KAAsB,UAA1B,EAAsC;AACpCA,MAAAA,UAAU,CAAC,IAAD,CAAV;AACD,KAFD,MAEO;AACLA,MAAAA,UAAU,CAAChE,OAAX,GAAqB,IAArB;AACD;AACF;AACF,C,CAED;AACA;AACA;;;AACA,SAASiE,aAAT,CACEzB,YADF,EAEExC,OAFF,EAGEkE,mBAHF,EAIQ;AACN3I,EAAAA,eAAe,CAACyE,OAAD,CAAf;;AAEA,UAAQA,OAAO,CAACL,GAAhB;AACE,SAAKjG,iBAAL;AACA,SAAKC,UAAL;AACA,SAAKU,aAAL;AACA,SAAKC,mBAAL;AAA0B;AACxB,cAAMwH,WAAgD,GAAI9B,OAAO,CAAC8B,WAAlE;;AACA,YAAIA,WAAW,KAAK,IAApB,EAA0B;AACxB,gBAAMC,UAAU,GAAGD,WAAW,CAACC,UAA/B;;AACA,cAAIA,UAAU,KAAK,IAAnB,EAAyB;AACvB,kBAAMC,WAAW,GAAGD,UAAU,CAACE,IAA/B,CADuB,CAGvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,kBAAMkC,aAAa,GACjBD,mBAAmB,GAAG7F,cAAtB,GACIA,cADJ,GAEI6F,mBAHN;AAIA9F,YAAAA,eAAe,CAAC+F,aAAD,EAAgB,MAAM;AACnC,kBAAIjC,MAAM,GAAGF,WAAb;;AACA,iBAAG;AACD,sBAAMnB,OAAO,GAAGqB,MAAM,CAACrB,OAAvB;;AACA,oBAAIA,OAAO,KAAKW,SAAhB,EAA2B;AACzBZ,kBAAAA,iBAAiB,CAACZ,OAAD,EAAUa,OAAV,CAAjB;AACD;;AACDqB,gBAAAA,MAAM,GAAGA,MAAM,CAACD,IAAhB;AACD,eAND,QAMSC,MAAM,KAAKF,WANpB;AAOD,aATc,CAAf;AAUD;AACF;;AACD;AACD;;AACD,SAAKpI,cAAL;AAAqB;AACnB6G,QAAAA,eAAe,CAACT,OAAD,CAAf;AACA,cAAMC,QAAQ,GAAGD,OAAO,CAACJ,SAAzB;;AACA,YAAI,OAAOK,QAAQ,CAACK,oBAAhB,KAAyC,UAA7C,EAAyD;AACvDC,UAAAA,8BAA8B,CAACP,OAAD,EAAUC,QAAV,CAA9B;AACD;;AACD;AACD;;AACD,SAAKnG,aAAL;AAAoB;AAClB,YAAIR,cAAJ,EAAoB;AAClB,gBAAM8K,YAAY,GAAGpE,OAAO,CAACoE,YAA7B;;AAEA,cAAIA,YAAY,KAAK,IAArB,EAA2B;AACzB,kBAAMC,aAAa,GAAGD,YAAY,CAACE,UAAnC;;AACA,gBAAID,aAAa,KAAK,IAAtB,EAA4B;AAC1B,oBAAME,kBAAkB,GAAGC,KAAK,CAACC,IAAN,CAAWJ,aAAa,CAACK,MAAd,EAAX,CAA3B;;AACA,mBACE,IAAIC,CAAC,GAAG,CAAR,EAAWC,MAAM,GAAGL,kBAAkB,CAACK,MADzC,EAEED,CAAC,GAAGC,MAFN,EAGED,CAAC,EAHH,EAIE;AACA,sBAAME,iBAAiB,GAAGN,kBAAkB,CAACI,CAAD,CAA5C;AACAtH,gBAAAA,wBAAwB,CAACwH,iBAAD,CAAxB;AACD;;AACDT,cAAAA,YAAY,CAACE,UAAb,GAA0B,IAA1B;AACD;AACF;AACF;;AACD7D,QAAAA,eAAe,CAACT,OAAD,CAAf;AACA;AACD;;AACD,SAAKhG,UAAL;AAAiB;AACf;AACA;AACA;AACA,YAAIgC,gBAAJ,EAAsB;AACpB8I,UAAAA,qBAAqB,CAACtC,YAAD,EAAexC,OAAf,EAAwBkE,mBAAxB,CAArB;AACD,SAFD,MAEO,IAAIjI,mBAAJ,EAAyB;AAC9B8I,UAAAA,oBAAoB,CAAC/E,OAAD,CAApB;AACD;;AACD;AACD;;AACD,SAAKxF,oBAAL;AAA2B;AACzB,YAAIjB,oBAAJ,EAA0B;AACxB,gBAAMyL,mBAAmB,GAAGhF,OAAO,CAACJ,SAApC;;AACA,cAAIoF,mBAAmB,KAAK,IAA5B,EAAkC;AAChC1H,YAAAA,2BAA2B,CAAC0H,mBAAD,CAA3B;AACAhF,YAAAA,OAAO,CAACJ,SAAR,GAAoB,IAApB;AACD;AACF;;AACD;AACD;;AACD,SAAKzF,kBAAL;AAAyB;AACvB,YAAIX,sBAAJ,EAA4B;AAC1B,gBAAMyL,kBAAkB,GAAGzC,YAAY,CAACyC,kBAAxC;;AACA,cAAIA,kBAAkB,KAAK,IAA3B,EAAiC;AAC/B,kBAAMC,SAAS,GAAGD,kBAAkB,CAACC,SAArC;;AACA,gBAAIA,SAAJ,EAAe;AACbA,cAAAA,SAAS,CAAElF,OAAO,CAACJ,SAAV,CAAT;AACD;AACF;AACF;;AACD;AACD;;AACD,SAAKnF,cAAL;AAAqB;AACnB,YAAIhB,cAAJ,EAAoB;AAClBgH,UAAAA,eAAe,CAACT,OAAD,CAAf;AACD;AACF;AA7GH;AA+GD;;AAED,SAASmF,oBAAT,CACE3C,YADF,EAEE4C,IAFF,EAGElB,mBAHF,EAIQ;AACN;AACA;AACA;AACA;AACA;AACA,MAAIZ,IAAW,GAAG8B,IAAlB;;AACA,SAAO,IAAP,EAAa;AACXnB,IAAAA,aAAa,CAACzB,YAAD,EAAec,IAAf,EAAqBY,mBAArB,CAAb,CADW,CAEX;AACA;;AACA,QACEZ,IAAI,CAACV,KAAL,KAAe,IAAf,MACA;AACA;AACC,KAAC5G,gBAAD,IAAqBsH,IAAI,CAAC3D,GAAL,KAAa3F,UAHnC,CADF,EAKE;AACAsJ,MAAAA,IAAI,CAACV,KAAL,CAAWc,MAAX,GAAoBJ,IAApB;AACAA,MAAAA,IAAI,GAAGA,IAAI,CAACV,KAAZ;AACA;AACD;;AACD,QAAIU,IAAI,KAAK8B,IAAb,EAAmB;AACjB;AACD;;AACD,WAAO9B,IAAI,CAACG,OAAL,KAAiB,IAAxB,EAA8B;AAC5B,UAAIH,IAAI,CAACI,MAAL,KAAgB,IAAhB,IAAwBJ,IAAI,CAACI,MAAL,KAAgB0B,IAA5C,EAAkD;AAChD;AACD;;AACD9B,MAAAA,IAAI,GAAGA,IAAI,CAACI,MAAZ;AACD;;AACDJ,IAAAA,IAAI,CAACG,OAAL,CAAaC,MAAb,GAAsBJ,IAAI,CAACI,MAA3B;AACAJ,IAAAA,IAAI,GAAGA,IAAI,CAACG,OAAZ;AACD;AACF;;AAED,SAAS4B,WAAT,CAAqBrF,OAArB,EAAqC;AACnC;AACA;AACA;AACA;AACA;AACAA,EAAAA,OAAO,CAAC0D,MAAR,GAAiB,IAAjB;AACA1D,EAAAA,OAAO,CAAC4C,KAAR,GAAgB,IAAhB;AACA5C,EAAAA,OAAO,CAACK,aAAR,GAAwB,IAAxB;AACAL,EAAAA,OAAO,CAAC8B,WAAR,GAAsB,IAAtB;AACA9B,EAAAA,OAAO,CAACoE,YAAR,GAAuB,IAAvB;AACA,QAAMkB,SAAS,GAAGtF,OAAO,CAACsF,SAA1B;;AACA,MAAIA,SAAS,KAAK,IAAlB,EAAwB;AACtBA,IAAAA,SAAS,CAAC5B,MAAV,GAAmB,IAAnB;AACA4B,IAAAA,SAAS,CAAC1C,KAAV,GAAkB,IAAlB;AACA0C,IAAAA,SAAS,CAACjF,aAAV,GAA0B,IAA1B;AACAiF,IAAAA,SAAS,CAACxD,WAAV,GAAwB,IAAxB;AACAwD,IAAAA,SAAS,CAAClB,YAAV,GAAyB,IAAzB;AACD;AACF;;AAED,SAASW,oBAAT,CAA8B/E,OAA9B,EAA8C;AAC5C,MAAI,CAAC/D,mBAAL,EAA0B;AACxB;AACD;;AAED,QAAMsJ,MAA6D,GACjEvF,OAAO,CAACJ,SADV;AAEA,QAAM;AAAC4F,IAAAA;AAAD,MAAkBD,MAAxB;AACA,QAAME,aAAa,GAAGzI,uBAAuB,CAACwI,aAAD,CAA7C;AACAzI,EAAAA,wBAAwB,CAACyI,aAAD,EAAgBC,aAAhB,CAAxB;AACD;;AAED,SAASC,eAAT,CAAyB3E,YAAzB,EAA8C;AAC5C,MAAI,CAAC9E,mBAAL,EAA0B;AACxB;AACD;;AAED,UAAQ8E,YAAY,CAACpB,GAArB;AACE,SAAK/F,cAAL;AACA,SAAKE,aAAL;AACA,SAAKC,QAAL;AACA,SAAKS,oBAAL;AAA2B;AACzB;AACD;;AACD,SAAKX,QAAL;AACA,SAAKG,UAAL;AAAiB;AACf,cAAM2L,YAGL,GACC5E,YAAY,CAACnB,SAJf;AAKA,cAAM;AAAC4F,UAAAA,aAAD;AAAgBI,UAAAA;AAAhB,YAAmCD,YAAzC;AACA5I,QAAAA,wBAAwB,CAACyI,aAAD,EAAgBI,eAAhB,CAAxB;AACA;AACD;;AACD;AAAS;AACPxK,QAAAA,SAAS,CACP,KADO,EAEP,uEACE,wDAHK,CAAT;AAKD;AAxBH;AA0BD;;AAED,SAASyK,kBAAT,CAA4BC,KAA5B,EAAiD;AAC/C,MAAIC,MAAM,GAAGD,KAAK,CAACpC,MAAnB;;AACA,SAAOqC,MAAM,KAAK,IAAlB,EAAwB;AACtB,QAAIC,YAAY,CAACD,MAAD,CAAhB,EAA0B;AACxB,aAAOA,MAAP;AACD;;AACDA,IAAAA,MAAM,GAAGA,MAAM,CAACrC,MAAhB;AACD;;AACDtI,EAAAA,SAAS,CACP,KADO,EAEP,0EACE,iCAHK,CAAT;AAKD;;AAED,SAAS4K,YAAT,CAAsBF,KAAtB,EAA6C;AAC3C,SACEA,KAAK,CAACnG,GAAN,KAAc7F,aAAd,IACAgM,KAAK,CAACnG,GAAN,KAAc9F,QADd,IAEAiM,KAAK,CAACnG,GAAN,KAAc3F,UAHhB;AAKD;;AAED,SAASiM,cAAT,CAAwBH,KAAxB,EAAiD;AAC/C;AACA;AACA;AACA;AACA,MAAIxC,IAAW,GAAGwC,KAAlB;;AACAI,EAAAA,QAAQ,EAAE,OAAO,IAAP,EAAa;AACrB;AACA,WAAO5C,IAAI,CAACG,OAAL,KAAiB,IAAxB,EAA8B;AAC5B,UAAIH,IAAI,CAACI,MAAL,KAAgB,IAAhB,IAAwBsC,YAAY,CAAC1C,IAAI,CAACI,MAAN,CAAxC,EAAuD;AACrD;AACA;AACA,eAAO,IAAP;AACD;;AACDJ,MAAAA,IAAI,GAAGA,IAAI,CAACI,MAAZ;AACD;;AACDJ,IAAAA,IAAI,CAACG,OAAL,CAAaC,MAAb,GAAsBJ,IAAI,CAACI,MAA3B;AACAJ,IAAAA,IAAI,GAAGA,IAAI,CAACG,OAAZ;;AACA,WACEH,IAAI,CAAC3D,GAAL,KAAa7F,aAAb,IACAwJ,IAAI,CAAC3D,GAAL,KAAa5F,QADb,IAEAuJ,IAAI,CAAC3D,GAAL,KAAaxF,kBAHf,EAIE;AACA;AACA;AACA,UAAImJ,IAAI,CAACrC,SAAL,GAAiBlG,SAArB,EAAgC;AAC9B;AACA,iBAASmL,QAAT;AACD,OAND,CAOA;AACA;;;AACA,UAAI5C,IAAI,CAACV,KAAL,KAAe,IAAf,IAAuBU,IAAI,CAAC3D,GAAL,KAAa3F,UAAxC,EAAoD;AAClD,iBAASkM,QAAT;AACD,OAFD,MAEO;AACL5C,QAAAA,IAAI,CAACV,KAAL,CAAWc,MAAX,GAAoBJ,IAApB;AACAA,QAAAA,IAAI,GAAGA,IAAI,CAACV,KAAZ;AACD;AACF,KA/BoB,CAgCrB;;;AACA,QAAI,EAAEU,IAAI,CAACrC,SAAL,GAAiBlG,SAAnB,CAAJ,EAAmC;AACjC;AACA,aAAOuI,IAAI,CAAC1D,SAAZ;AACD;AACF;AACF;;AAED,SAASuG,eAAT,CAAyBpF,YAAzB,EAAoD;AAClD,MAAI,CAAC/E,gBAAL,EAAuB;AACrB;AACD,GAHiD,CAKlD;;;AACA,QAAMoK,WAAW,GAAGP,kBAAkB,CAAC9E,YAAD,CAAtC,CANkD,CAQlD;;AACA,MAAIgF,MAAJ;AACA,MAAIM,WAAJ;AACA,QAAMC,eAAe,GAAGF,WAAW,CAACxG,SAApC;;AACA,UAAQwG,WAAW,CAACzG,GAApB;AACE,SAAK7F,aAAL;AACEiM,MAAAA,MAAM,GAAGO,eAAT;AACAD,MAAAA,WAAW,GAAG,KAAd;AACA;;AACF,SAAKxM,QAAL;AACEkM,MAAAA,MAAM,GAAGO,eAAe,CAACd,aAAzB;AACAa,MAAAA,WAAW,GAAG,IAAd;AACA;;AACF,SAAKrM,UAAL;AACE+L,MAAAA,MAAM,GAAGO,eAAe,CAACd,aAAzB;AACAa,MAAAA,WAAW,GAAG,IAAd;AACA;;AACF,SAAK7L,oBAAL;AACE,UAAIjB,oBAAJ,EAA0B;AACxBwM,QAAAA,MAAM,GAAGO,eAAe,CAACrG,QAAzB;AACAoG,QAAAA,WAAW,GAAG,KAAd;AACD;;AACH;;AACA;AACEjL,MAAAA,SAAS,CACP,KADO,EAEP,qEACE,iCAHK,CAAT;AApBJ;;AA0BA,MAAIgL,WAAW,CAACnF,SAAZ,GAAwBnG,YAA5B,EAA0C;AACxC;AACAuB,IAAAA,gBAAgB,CAAC0J,MAAD,CAAhB,CAFwC,CAGxC;;AACAK,IAAAA,WAAW,CAACnF,SAAZ,IAAyB,CAACnG,YAA1B;AACD;;AAED,QAAMyL,MAAM,GAAGN,cAAc,CAAClF,YAAD,CAA7B,CA7CkD,CA8ClD;AACA;;AACA,MAAIuC,IAAW,GAAGvC,YAAlB;;AACA,SAAO,IAAP,EAAa;AACX,UAAMyF,MAAM,GAAGlD,IAAI,CAAC3D,GAAL,KAAa7F,aAAb,IAA8BwJ,IAAI,CAAC3D,GAAL,KAAa5F,QAA1D;;AACA,QAAIyM,MAAM,IAAKjN,oBAAoB,IAAI+J,IAAI,CAAC3D,GAAL,KAAanF,oBAApD,EAA2E;AACzE,YAAMoF,SAAS,GAAG4G,MAAM,GAAGlD,IAAI,CAAC1D,SAAR,GAAoB0D,IAAI,CAAC1D,SAAL,CAAeK,QAA3D;;AACA,UAAIsG,MAAJ,EAAY;AACV,YAAIF,WAAJ,EAAiB;AACf3J,UAAAA,uBAAuB,CAACqJ,MAAD,EAASnG,SAAT,EAAoB2G,MAApB,CAAvB;AACD,SAFD,MAEO;AACL9J,UAAAA,YAAY,CAACsJ,MAAD,EAASnG,SAAT,EAAoB2G,MAApB,CAAZ;AACD;AACF,OAND,MAMO;AACL,YAAIF,WAAJ,EAAiB;AACf7J,UAAAA,sBAAsB,CAACuJ,MAAD,EAASnG,SAAT,CAAtB;AACD,SAFD,MAEO;AACLrD,UAAAA,WAAW,CAACwJ,MAAD,EAASnG,SAAT,CAAX;AACD;AACF;AACF,KAfD,MAeO,IAAI0D,IAAI,CAAC3D,GAAL,KAAa3F,UAAjB,EAA6B,CAClC;AACA;AACA;AACD,KAJM,MAIA,IAAIsJ,IAAI,CAACV,KAAL,KAAe,IAAnB,EAAyB;AAC9BU,MAAAA,IAAI,CAACV,KAAL,CAAWc,MAAX,GAAoBJ,IAApB;AACAA,MAAAA,IAAI,GAAGA,IAAI,CAACV,KAAZ;AACA;AACD;;AACD,QAAIU,IAAI,KAAKvC,YAAb,EAA2B;AACzB;AACD;;AACD,WAAOuC,IAAI,CAACG,OAAL,KAAiB,IAAxB,EAA8B;AAC5B,UAAIH,IAAI,CAACI,MAAL,KAAgB,IAAhB,IAAwBJ,IAAI,CAACI,MAAL,KAAgB3C,YAA5C,EAA0D;AACxD;AACD;;AACDuC,MAAAA,IAAI,GAAGA,IAAI,CAACI,MAAZ;AACD;;AACDJ,IAAAA,IAAI,CAACG,OAAL,CAAaC,MAAb,GAAsBJ,IAAI,CAACI,MAA3B;AACAJ,IAAAA,IAAI,GAAGA,IAAI,CAACG,OAAZ;AACD;AACF;;AAED,SAASqB,qBAAT,CACEtC,YADF,EAEExC,OAFF,EAGEkE,mBAHF,EAIQ;AACN;AACA;AACA,MAAIZ,IAAW,GAAGtD,OAAlB,CAHM,CAKN;AACA;;AACA,MAAIyG,oBAAoB,GAAG,KAA3B,CAPM,CASN;;AACA,MAAIC,aAAJ;AACA,MAAIC,wBAAJ;;AAEA,SAAO,IAAP,EAAa;AACX,QAAI,CAACF,oBAAL,EAA2B;AACzB,UAAIV,MAAM,GAAGzC,IAAI,CAACI,MAAlB;;AACAkD,MAAAA,UAAU,EAAE,OAAO,IAAP,EAAa;AACvBxL,QAAAA,SAAS,CACP2K,MAAM,KAAK,IADJ,EAEP,oEACE,uCAHK,CAAT;AAKA,cAAMO,eAAe,GAAGP,MAAM,CAACnG,SAA/B;;AACA,gBAAQmG,MAAM,CAACpG,GAAf;AACE,eAAK7F,aAAL;AACE4M,YAAAA,aAAa,GAAGJ,eAAhB;AACAK,YAAAA,wBAAwB,GAAG,KAA3B;AACA,kBAAMC,UAAN;;AACF,eAAK/M,QAAL;AACE6M,YAAAA,aAAa,GAAGJ,eAAe,CAACd,aAAhC;AACAmB,YAAAA,wBAAwB,GAAG,IAA3B;AACA,kBAAMC,UAAN;;AACF,eAAK5M,UAAL;AACE0M,YAAAA,aAAa,GAAGJ,eAAe,CAACd,aAAhC;AACAmB,YAAAA,wBAAwB,GAAG,IAA3B;AACA,kBAAMC,UAAN;;AACF,eAAKpM,oBAAL;AACE,gBAAIjB,oBAAJ,EAA0B;AACxBmN,cAAAA,aAAa,GAAGJ,eAAe,CAACrG,QAAhC;AACA0G,cAAAA,wBAAwB,GAAG,KAA3B;AACD;;AAjBL;;AAmBAZ,QAAAA,MAAM,GAAGA,MAAM,CAACrC,MAAhB;AACD;;AACD+C,MAAAA,oBAAoB,GAAG,IAAvB;AACD;;AAED,QAAInD,IAAI,CAAC3D,GAAL,KAAa7F,aAAb,IAA8BwJ,IAAI,CAAC3D,GAAL,KAAa5F,QAA/C,EAAyD;AACvDoL,MAAAA,oBAAoB,CAAC3C,YAAD,EAAec,IAAf,EAAqBY,mBAArB,CAApB,CADuD,CAEvD;AACA;;AACA,UAAIyC,wBAAJ,EAA8B;AAC5B/J,QAAAA,wBAAwB,CACpB8J,aADoB,EAErBpD,IAAI,CAAC1D,SAFgB,CAAxB;AAID,OALD,MAKO;AACLjD,QAAAA,WAAW,CACP+J,aADO,EAERpD,IAAI,CAAC1D,SAFG,CAAX;AAID,OAdsD,CAevD;;AACD,KAhBD,MAgBO,IAAIrG,oBAAoB,IAAI+J,IAAI,CAAC3D,GAAL,KAAanF,oBAAzC,EAA+D;AACpE,YAAMqM,eAAe,GAAGvD,IAAI,CAAC1D,SAAL,CAAeK,QAAvC;AACAkF,MAAAA,oBAAoB,CAAC3C,YAAD,EAAec,IAAf,EAAqBY,mBAArB,CAApB,CAFoE,CAGpE;AACA;;AACA,UAAIyC,wBAAJ,EAA8B;AAC5B/J,QAAAA,wBAAwB,CACpB8J,aADoB,EAErBG,eAFqB,CAAxB;AAID,OALD,MAKO;AACLlK,QAAAA,WAAW,CACP+J,aADO,EAERG,eAFQ,CAAX;AAID;AACF,KAhBM,MAgBA,IACLxN,4BAA4B,IAC5BiK,IAAI,CAAC3D,GAAL,KAAaxF,kBAFR,EAGL;AACA,UAAIX,sBAAJ,EAA4B;AAC1B,cAAMyL,kBAAkB,GAAGzC,YAAY,CAACyC,kBAAxC;;AACA,YAAIA,kBAAkB,KAAK,IAA3B,EAAiC;AAC/B,gBAAMC,SAAS,GAAGD,kBAAkB,CAACC,SAArC;;AACA,cAAIA,SAAJ,EAAe;AACbA,YAAAA,SAAS,CAAE5B,IAAI,CAAC1D,SAAP,CAAT;AACD;AACF;AACF,OATD,CAWA;;;AACA,UAAI+G,wBAAJ,EAA8B;AAC5B7J,QAAAA,kCAAkC,CAC9B4J,aAD8B,EAE/BpD,IAAI,CAAC1D,SAF0B,CAAlC;AAID,OALD,MAKO;AACL/C,QAAAA,qBAAqB,CACjB6J,aADiB,EAElBpD,IAAI,CAAC1D,SAFa,CAArB;AAID;AACF,KA1BM,MA0BA,IAAI0D,IAAI,CAAC3D,GAAL,KAAa3F,UAAjB,EAA6B;AAClC,UAAIsJ,IAAI,CAACV,KAAL,KAAe,IAAnB,EAAyB;AACvB;AACA;AACA8D,QAAAA,aAAa,GAAGpD,IAAI,CAAC1D,SAAL,CAAe4F,aAA/B;AACAmB,QAAAA,wBAAwB,GAAG,IAA3B,CAJuB,CAKvB;;AACArD,QAAAA,IAAI,CAACV,KAAL,CAAWc,MAAX,GAAoBJ,IAApB;AACAA,QAAAA,IAAI,GAAGA,IAAI,CAACV,KAAZ;AACA;AACD;AACF,KAXM,MAWA;AACLqB,MAAAA,aAAa,CAACzB,YAAD,EAAec,IAAf,EAAqBY,mBAArB,CAAb,CADK,CAEL;;AACA,UAAIZ,IAAI,CAACV,KAAL,KAAe,IAAnB,EAAyB;AACvBU,QAAAA,IAAI,CAACV,KAAL,CAAWc,MAAX,GAAoBJ,IAApB;AACAA,QAAAA,IAAI,GAAGA,IAAI,CAACV,KAAZ;AACA;AACD;AACF;;AACD,QAAIU,IAAI,KAAKtD,OAAb,EAAsB;AACpB;AACD;;AACD,WAAOsD,IAAI,CAACG,OAAL,KAAiB,IAAxB,EAA8B;AAC5B,UAAIH,IAAI,CAACI,MAAL,KAAgB,IAAhB,IAAwBJ,IAAI,CAACI,MAAL,KAAgB1D,OAA5C,EAAqD;AACnD;AACD;;AACDsD,MAAAA,IAAI,GAAGA,IAAI,CAACI,MAAZ;;AACA,UAAIJ,IAAI,CAAC3D,GAAL,KAAa3F,UAAjB,EAA6B;AAC3B;AACA;AACAyM,QAAAA,oBAAoB,GAAG,KAAvB;AACD;AACF;;AACDnD,IAAAA,IAAI,CAACG,OAAL,CAAaC,MAAb,GAAsBJ,IAAI,CAACI,MAA3B;AACAJ,IAAAA,IAAI,GAAGA,IAAI,CAACG,OAAZ;AACD;AACF;;AAED,SAASqD,cAAT,CACEtE,YADF,EAEExC,OAFF,EAGEkE,mBAHF,EAIQ;AACN,MAAIlI,gBAAJ,EAAsB;AACpB;AACA;AACA8I,IAAAA,qBAAqB,CAACtC,YAAD,EAAexC,OAAf,EAAwBkE,mBAAxB,CAArB;AACD,GAJD,MAIO;AACL;AACAiB,IAAAA,oBAAoB,CAAC3C,YAAD,EAAexC,OAAf,EAAwBkE,mBAAxB,CAApB;AACD;;AACDmB,EAAAA,WAAW,CAACrF,OAAD,CAAX;AACD;;AAED,SAAS+G,UAAT,CAAoB/G,OAApB,EAA2Ce,YAA3C,EAAsE;AACpE,MAAI,CAAC/E,gBAAL,EAAuB;AACrB,YAAQ+E,YAAY,CAACpB,GAArB;AACE,WAAKjG,iBAAL;AACA,WAAKC,UAAL;AACA,WAAKU,aAAL;AACA,WAAKC,mBAAL;AAA0B;AACxB;AACA;AACA0G,UAAAA,oBAAoB,CAACnD,eAAD,EAAkBC,aAAlB,EAAiCiD,YAAjC,CAApB;AACA;AACD;;AACD,WAAK9G,QAAL;AAAe;AACb;AACD;;AACD,WAAKC,iBAAL;AAAwB;AACtB8M,UAAAA,uBAAuB,CAACjG,YAAD,CAAvB;AACAkG,UAAAA,4BAA4B,CAAClG,YAAD,CAA5B;AACA;AACD;;AACD,WAAKxG,qBAAL;AAA4B;AAC1B0M,UAAAA,4BAA4B,CAAClG,YAAD,CAA5B;AACA;AACD;;AACD,WAAKlH,QAAL;AAAe;AACb,gBAAMuL,IAAe,GAAGrE,YAAY,CAACnB,SAArC;;AACA,cAAI1D,iBAAJ,EAAuB;AACrB,gBAAIkJ,IAAI,CAAC8B,OAAT,EAAkB;AAChB;AACA9B,cAAAA,IAAI,CAAC8B,OAAL,GAAe,KAAf;AACD;AACF;;AACD;AACD;AA/BH;;AAkCAxB,IAAAA,eAAe,CAAC3E,YAAD,CAAf;AACA;AACD;;AAED,UAAQA,YAAY,CAACpB,GAArB;AACE,SAAKjG,iBAAL;AACA,SAAKC,UAAL;AACA,SAAKU,aAAL;AACA,SAAKC,mBAAL;AAA0B;AACxB;AACA;AACA0G,QAAAA,oBAAoB,CAACnD,eAAD,EAAkBC,aAAlB,EAAiCiD,YAAjC,CAApB;AACA;AACD;;AACD,SAAKnH,cAAL;AAAqB;AACnB;AACD;;AACD,SAAKE,aAAL;AAAoB;AAClB,cAAMmG,QAAkB,GAAGc,YAAY,CAACnB,SAAxC;;AACA,YAAIK,QAAQ,IAAI,IAAhB,EAAsB;AACpB;AACA,gBAAMkH,QAAQ,GAAGpG,YAAY,CAACZ,aAA9B,CAFoB,CAGpB;AACA;AACA;;AACA,gBAAMiH,QAAQ,GAAGpH,OAAO,KAAK,IAAZ,GAAmBA,OAAO,CAACG,aAA3B,GAA2CgH,QAA5D;AACA,gBAAMhI,IAAI,GAAG4B,YAAY,CAAC5B,IAA1B,CAPoB,CAQpB;;AACA,gBAAMkI,aAAmC,GAAItG,YAAY,CAACe,WAA1D;AACAf,UAAAA,YAAY,CAACe,WAAb,GAA2B,IAA3B;;AACA,cAAIuF,aAAa,KAAK,IAAtB,EAA4B;AAC1BjL,YAAAA,YAAY,CACV6D,QADU,EAEVoH,aAFU,EAGVlI,IAHU,EAIViI,QAJU,EAKVD,QALU,EAMVpG,YANU,CAAZ;AAQD;;AACD,cAAIzH,cAAJ,EAAoB;AAClB,kBAAMgO,aAAa,GAAGF,QAAQ,CAACG,SAA/B;AACA,kBAAMC,aAAa,GAAGL,QAAQ,CAACI,SAA/B;;AACA,gBAAID,aAAa,KAAKE,aAAtB,EAAqC;AACnClJ,cAAAA,oBAAoB,CAACkJ,aAAD,EAAgBzG,YAAhB,EAA8B,IAA9B,CAApB;AACD;AACF;AACF;;AACD;AACD;;AACD,SAAKhH,QAAL;AAAe;AACbqB,QAAAA,SAAS,CACP2F,YAAY,CAACnB,SAAb,KAA2B,IADpB,EAEP,oEACE,iDAHK,CAAT;AAKA,cAAM6H,YAA0B,GAAG1G,YAAY,CAACnB,SAAhD;AACA,cAAM8H,OAAe,GAAG3G,YAAY,CAACZ,aAArC,CAPa,CAQb;AACA;AACA;;AACA,cAAMwH,OAAe,GACnB3H,OAAO,KAAK,IAAZ,GAAmBA,OAAO,CAACG,aAA3B,GAA2CuH,OAD7C;AAEApL,QAAAA,gBAAgB,CAACmL,YAAD,EAAeE,OAAf,EAAwBD,OAAxB,CAAhB;AACA;AACD;;AACD,SAAK7N,QAAL;AAAe;AACb,cAAMuL,IAAe,GAAGrE,YAAY,CAACnB,SAArC;;AACA,YAAI1D,iBAAJ,EAAuB;AACrB,cAAIkJ,IAAI,CAAC8B,OAAT,EAAkB;AAChB;AACA9B,YAAAA,IAAI,CAAC8B,OAAL,GAAe,KAAf;AACD;AACF;;AACD;AACD;;AACD,SAAKjN,QAAL;AAAe;AACb;AACD;;AACD,SAAKC,iBAAL;AAAwB;AACtB8M,QAAAA,uBAAuB,CAACjG,YAAD,CAAvB;AACAkG,QAAAA,4BAA4B,CAAClG,YAAD,CAA5B;AACA;AACD;;AACD,SAAKxG,qBAAL;AAA4B;AAC1B0M,QAAAA,4BAA4B,CAAClG,YAAD,CAA5B;AACA;AACD;;AACD,SAAK3G,wBAAL;AAA+B;AAC7B;AACD;;AACD,SAAKI,oBAAL;AAA2B;AACzB,YAAIjB,oBAAJ,EAA0B;AACxB,gBAAMyL,mBAAmB,GAAGjE,YAAY,CAACnB,SAAzC;AACArC,UAAAA,0BAA0B,CAACyH,mBAAD,CAA1B;AACD;;AACD;AACD;;AACD,SAAKvK,cAAL;AAAqB;AACnB,YAAIhB,cAAJ,EAAoB;AAClB,gBAAMmO,aAAa,GAAG7G,YAAY,CAACnB,SAAnC;AACAgI,UAAAA,aAAa,CAAC9B,KAAd,GAAsB/E,YAAtB;;AACA,cAAIzH,cAAJ,EAAoB;AAClB,kBAAM6N,QAAQ,GAAGpG,YAAY,CAACZ,aAA9B;AACA,kBAAMiH,QAAQ,GAAGpH,OAAO,KAAK,IAAZ,GAAmBA,OAAO,CAACG,aAA3B,GAA2CgH,QAA5D;AACA,kBAAMG,aAAa,GAAGF,QAAQ,CAACG,SAA/B;AACA,kBAAMC,aAAa,GAAGL,QAAQ,CAACI,SAA/B;;AACA,gBAAID,aAAa,KAAKE,aAAtB,EAAqC;AACnClJ,cAAAA,oBAAoB,CAACkJ,aAAD,EAAgBzG,YAAhB,EAA8B,IAA9B,CAApB;AACD;AACF;AACF;;AACD;AACD;;AACD;AAAS;AACP3F,QAAAA,SAAS,CACP,KADO,EAEP,uEACE,wDAHK,CAAT;AAKD;AApHH;AAsHD;;AAED,SAAS4L,uBAAT,CAAiCjG,YAAjC,EAAsD;AACpD,MAAI8G,QAA8B,GAAG9G,YAAY,CAACV,aAAlD;AAEA,MAAIyH,aAAJ;AACA,MAAIC,kBAAkB,GAAGhH,YAAzB;;AACA,MAAI8G,QAAQ,KAAK,IAAjB,EAAuB;AACrBC,IAAAA,aAAa,GAAG,KAAhB;AACD,GAFD,MAEO;AACLA,IAAAA,aAAa,GAAG,IAAhB;AACAC,IAAAA,kBAAkB,GAAGhH,YAAY,CAAC6B,KAAlC;AACAlF,IAAAA,wBAAwB;AACzB;;AAED,MAAI1B,gBAAgB,IAAI+L,kBAAkB,KAAK,IAA/C,EAAqD;AACnD3E,IAAAA,uBAAuB,CAAC2E,kBAAD,EAAqBD,aAArB,CAAvB;AACD;;AAED,MAAItO,sBAAsB,IAAIqO,QAAQ,KAAK,IAA3C,EAAiD;AAC/C,UAAMG,gBAAgB,GAAGjH,YAAY,CAACZ,aAAb,CAA2B6H,gBAApD;;AACA,QAAI,OAAOA,gBAAP,KAA4B,UAAhC,EAA4C;AAC1C,YAAMC,SAA+B,GAAIlH,YAAY,CAACe,WAAtD;;AACA,UAAImG,SAAS,KAAK,IAAlB,EAAwB;AACtBD,QAAAA,gBAAgB,CAAC,IAAIvJ,GAAJ,CAAQwJ,SAAR,CAAD,CAAhB;AACD;AACF,KALD,MAKO,IAAIzJ,OAAJ,EAAa;AAClB,UAAIwJ,gBAAgB,KAAKxG,SAAzB,EAAoC;AAClClG,QAAAA,OAAO,CAAC,KAAD,EAAQ,uCAAR,CAAP;AACD;AACF;AACF;AACF;;AAED,SAAS6H,gCAAT,CACEX,YADF,EAEEzB,YAFF,EAGE;AACA,MAAIvH,sBAAJ,EAA4B;AAC1B,UAAMyL,kBAAkB,GAAGzC,YAAY,CAACyC,kBAAxC;;AACA,QAAIA,kBAAkB,KAAK,IAA3B,EAAiC;AAC/B,YAAMiD,UAAU,GAAGjD,kBAAkB,CAACiD,UAAtC;;AACA,UAAIA,UAAJ,EAAgB;AACd,cAAML,QAA8B,GAAG9G,YAAY,CAACV,aAApD;;AACA,YAAIwH,QAAQ,KAAK,IAAjB,EAAuB;AACrB,gBAAM7H,OAAO,GAAGe,YAAY,CAACuE,SAA7B;;AACA,cAAItF,OAAO,KAAK,IAAhB,EAAsB;AACpB,kBAAMmB,SAA+B,GAAGnB,OAAO,CAACK,aAAhD;;AACA,gBAAIc,SAAS,KAAK,IAAd,IAAsBA,SAAS,CAACoC,UAAV,KAAyB,IAAnD,EAAyD;AACvD2E,cAAAA,UAAU,CAAC/G,SAAS,CAACoC,UAAX,CAAV;AACD;AACF;AACF;AACF;AACF;AACF;AACF;;AAED,SAAS0D,4BAAT,CAAsClG,YAAtC,EAA2D;AACzD;AACA;AACA;AACA,QAAMkH,SAA+B,GAAIlH,YAAY,CAACe,WAAtD;;AACA,MAAImG,SAAS,KAAK,IAAlB,EAAwB;AACtBlH,IAAAA,YAAY,CAACe,WAAb,GAA2B,IAA3B;AACA,QAAIqG,UAAU,GAAGpH,YAAY,CAACnB,SAA9B;;AACA,QAAIuI,UAAU,KAAK,IAAnB,EAAyB;AACvBA,MAAAA,UAAU,GAAGpH,YAAY,CAACnB,SAAb,GAAyB,IAAIlB,eAAJ,EAAtC;AACD;;AACDuJ,IAAAA,SAAS,CAACG,OAAV,CAAkBC,QAAQ,IAAI;AAC5B;AACA,UAAIC,KAAK,GAAG7K,oBAAoB,CAAC8K,IAArB,CAA0B,IAA1B,EAAgCxH,YAAhC,EAA8CsH,QAA9C,CAAZ;;AACA,UAAI,CAACF,UAAU,CAAC1G,GAAX,CAAe4G,QAAf,CAAL,EAA+B;AAC7B,YAAIlP,sBAAJ,EAA4B;AAC1B,cAAIkP,QAAQ,CAACG,6BAAT,KAA2C,IAA/C,EAAqD;AACnDF,YAAAA,KAAK,GAAGpP,qBAAqB,CAACoP,KAAD,CAA7B;AACD;AACF;;AACDH,QAAAA,UAAU,CAACzG,GAAX,CAAe2G,QAAf;AACAA,QAAAA,QAAQ,CAAChG,IAAT,CAAciG,KAAd,EAAqBA,KAArB;AACD;AACF,KAZD;AAaD;AACF;;AAED,SAASG,sBAAT,CAAgCzI,OAAhC,EAAgD;AAC9C,MAAI,CAAChE,gBAAL,EAAuB;AACrB;AACD;;AACDK,EAAAA,gBAAgB,CAAC2D,OAAO,CAACJ,SAAT,CAAhB;AACD;;AAED,SACEkB,8BADF,EAEE2H,sBAFF,EAGEtC,eAHF,EAIEW,cAJF,EAKEC,UALF,EAMExE,gBANF,EAOEoB,eAPF,EAQEI,eARF","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {\n  Instance,\n  TextInstance,\n  SuspenseInstance,\n  Container,\n  ChildSet,\n  UpdatePayload,\n} from './ReactFiberHostConfig';\nimport type {Fiber} from './ReactFiber';\nimport type {FiberRoot} from './ReactFiberRoot';\nimport type {ExpirationTime} from './ReactFiberExpirationTime';\nimport type {CapturedValue, CapturedError} from './ReactCapturedValue';\nimport type {SuspenseState} from './ReactFiberSuspenseComponent';\nimport type {FunctionComponentUpdateQueue} from './ReactFiberHooks';\nimport type {Thenable} from './ReactFiberWorkLoop';\nimport type {ReactPriorityLevel} from './SchedulerWithReactIntegration';\n\nimport {unstable_wrap as Schedule_tracing_wrap} from 'scheduler/tracing';\nimport {\n  enableSchedulerTracing,\n  enableProfilerTimer,\n  enableSuspenseServerRenderer,\n  enableFlareAPI,\n  enableFundamentalAPI,\n  enableSuspenseCallback,\n  enableScopeAPI,\n} from 'shared/ReactFeatureFlags';\nimport {\n  FunctionComponent,\n  ForwardRef,\n  ClassComponent,\n  HostRoot,\n  HostComponent,\n  HostText,\n  HostPortal,\n  Profiler,\n  SuspenseComponent,\n  DehydratedFragment,\n  IncompleteClassComponent,\n  MemoComponent,\n  SimpleMemoComponent,\n  SuspenseListComponent,\n  FundamentalComponent,\n  ScopeComponent,\n} from 'shared/ReactWorkTags';\nimport {\n  invokeGuardedCallback,\n  hasCaughtError,\n  clearCaughtError,\n} from 'shared/ReactErrorUtils';\nimport {\n  NoEffect,\n  ContentReset,\n  Placement,\n  Snapshot,\n  Update,\n  Passive,\n} from 'shared/ReactSideEffectTags';\nimport getComponentName from 'shared/getComponentName';\nimport invariant from 'shared/invariant';\nimport warningWithoutStack from 'shared/warningWithoutStack';\nimport warning from 'shared/warning';\n\nimport {onCommitUnmount} from './ReactFiberDevToolsHook';\nimport {startPhaseTimer, stopPhaseTimer} from './ReactDebugFiberPerf';\nimport {getStackByFiberInDevAndProd} from './ReactCurrentFiber';\nimport {logCapturedError} from './ReactFiberErrorLogger';\nimport {resolveDefaultProps} from './ReactFiberLazyComponent';\nimport {getCommitTime} from './ReactProfilerTimer';\nimport {commitUpdateQueue} from './ReactUpdateQueue';\nimport {\n  getPublicInstance,\n  supportsMutation,\n  supportsPersistence,\n  supportsHydration,\n  commitMount,\n  commitUpdate,\n  resetTextContent,\n  commitTextUpdate,\n  appendChild,\n  appendChildToContainer,\n  insertBefore,\n  insertInContainerBefore,\n  removeChild,\n  removeChildFromContainer,\n  clearSuspenseBoundary,\n  clearSuspenseBoundaryFromContainer,\n  replaceContainerChildren,\n  createContainerChildSet,\n  hideInstance,\n  hideTextInstance,\n  unhideInstance,\n  unhideTextInstance,\n  unmountResponderInstance,\n  unmountFundamentalComponent,\n  updateFundamentalComponent,\n} from './ReactFiberHostConfig';\nimport {\n  captureCommitPhaseError,\n  resolveRetryThenable,\n  markCommitTimeOfFallback,\n} from './ReactFiberWorkLoop';\nimport {\n  NoEffect as NoHookEffect,\n  UnmountSnapshot,\n  UnmountMutation,\n  MountMutation,\n  UnmountLayout,\n  MountLayout,\n  UnmountPassive,\n  MountPassive,\n} from './ReactHookEffectTags';\nimport {didWarnAboutReassigningProps} from './ReactFiberBeginWork';\nimport {runWithPriority, NormalPriority} from './SchedulerWithReactIntegration';\nimport {updateEventListeners} from './ReactFiberEvents';\n\nlet didWarnAboutUndefinedSnapshotBeforeUpdate: Set<mixed> | null = null;\nif (__DEV__) {\n  didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();\n}\n\nconst PossiblyWeakSet = typeof WeakSet === 'function' ? WeakSet : Set;\n\nexport function logError(boundary: Fiber, errorInfo: CapturedValue<mixed>) {\n  const source = errorInfo.source;\n  let stack = errorInfo.stack;\n  if (stack === null && source !== null) {\n    stack = getStackByFiberInDevAndProd(source);\n  }\n\n  const capturedError: CapturedError = {\n    componentName: source !== null ? getComponentName(source.type) : null,\n    componentStack: stack !== null ? stack : '',\n    error: errorInfo.value,\n    errorBoundary: null,\n    errorBoundaryName: null,\n    errorBoundaryFound: false,\n    willRetry: false,\n  };\n\n  if (boundary !== null && boundary.tag === ClassComponent) {\n    capturedError.errorBoundary = boundary.stateNode;\n    capturedError.errorBoundaryName = getComponentName(boundary.type);\n    capturedError.errorBoundaryFound = true;\n    capturedError.willRetry = true;\n  }\n\n  try {\n    logCapturedError(capturedError);\n  } catch (e) {\n    // This method must not throw, or React internal state will get messed up.\n    // If console.error is overridden, or logCapturedError() shows a dialog that throws,\n    // we want to report this error outside of the normal stack as a last resort.\n    // https://github.com/facebook/react/issues/13188\n    setTimeout(() => {\n      throw e;\n    });\n  }\n}\n\nconst callComponentWillUnmountWithTimer = function(current, instance) {\n  startPhaseTimer(current, 'componentWillUnmount');\n  instance.props = current.memoizedProps;\n  instance.state = current.memoizedState;\n  instance.componentWillUnmount();\n  stopPhaseTimer();\n};\n\n// Capture errors so they don't interrupt unmounting.\nfunction safelyCallComponentWillUnmount(current, instance) {\n  if (__DEV__) {\n    invokeGuardedCallback(\n      null,\n      callComponentWillUnmountWithTimer,\n      null,\n      current,\n      instance,\n    );\n    if (hasCaughtError()) {\n      const unmountError = clearCaughtError();\n      captureCommitPhaseError(current, unmountError);\n    }\n  } else {\n    try {\n      callComponentWillUnmountWithTimer(current, instance);\n    } catch (unmountError) {\n      captureCommitPhaseError(current, unmountError);\n    }\n  }\n}\n\nfunction safelyDetachRef(current: Fiber) {\n  const ref = current.ref;\n  if (ref !== null) {\n    if (typeof ref === 'function') {\n      if (__DEV__) {\n        invokeGuardedCallback(null, ref, null, null);\n        if (hasCaughtError()) {\n          const refError = clearCaughtError();\n          captureCommitPhaseError(current, refError);\n        }\n      } else {\n        try {\n          ref(null);\n        } catch (refError) {\n          captureCommitPhaseError(current, refError);\n        }\n      }\n    } else {\n      ref.current = null;\n    }\n  }\n}\n\nfunction safelyCallDestroy(current, destroy) {\n  if (__DEV__) {\n    invokeGuardedCallback(null, destroy, null);\n    if (hasCaughtError()) {\n      const error = clearCaughtError();\n      captureCommitPhaseError(current, error);\n    }\n  } else {\n    try {\n      destroy();\n    } catch (error) {\n      captureCommitPhaseError(current, error);\n    }\n  }\n}\n\nfunction commitBeforeMutationLifeCycles(\n  current: Fiber | null,\n  finishedWork: Fiber,\n): void {\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent: {\n      commitHookEffectList(UnmountSnapshot, NoHookEffect, finishedWork);\n      return;\n    }\n    case ClassComponent: {\n      if (finishedWork.effectTag & Snapshot) {\n        if (current !== null) {\n          const prevProps = current.memoizedProps;\n          const prevState = current.memoizedState;\n          startPhaseTimer(finishedWork, 'getSnapshotBeforeUpdate');\n          const instance = finishedWork.stateNode;\n          // We could update instance props and state here,\n          // but instead we rely on them being set during last render.\n          // TODO: revisit this when we implement resuming.\n          if (__DEV__) {\n            if (\n              finishedWork.type === finishedWork.elementType &&\n              !didWarnAboutReassigningProps\n            ) {\n              warning(\n                instance.props === finishedWork.memoizedProps,\n                'Expected %s props to match memoized props before ' +\n                  'getSnapshotBeforeUpdate. ' +\n                  'This might either be because of a bug in React, or because ' +\n                  'a component reassigns its own `this.props`. ' +\n                  'Please file an issue.',\n                getComponentName(finishedWork.type) || 'instance',\n              );\n              warning(\n                instance.state === finishedWork.memoizedState,\n                'Expected %s state to match memoized state before ' +\n                  'getSnapshotBeforeUpdate. ' +\n                  'This might either be because of a bug in React, or because ' +\n                  'a component reassigns its own `this.props`. ' +\n                  'Please file an issue.',\n                getComponentName(finishedWork.type) || 'instance',\n              );\n            }\n          }\n          const snapshot = instance.getSnapshotBeforeUpdate(\n            finishedWork.elementType === finishedWork.type\n              ? prevProps\n              : resolveDefaultProps(finishedWork.type, prevProps),\n            prevState,\n          );\n          if (__DEV__) {\n            const didWarnSet = ((didWarnAboutUndefinedSnapshotBeforeUpdate: any): Set<\n              mixed,\n            >);\n            if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {\n              didWarnSet.add(finishedWork.type);\n              warningWithoutStack(\n                false,\n                '%s.getSnapshotBeforeUpdate(): A snapshot value (or null) ' +\n                  'must be returned. You have returned undefined.',\n                getComponentName(finishedWork.type),\n              );\n            }\n          }\n          instance.__reactInternalSnapshotBeforeUpdate = snapshot;\n          stopPhaseTimer();\n        }\n      }\n      return;\n    }\n    case HostRoot:\n    case HostComponent:\n    case HostText:\n    case HostPortal:\n    case IncompleteClassComponent:\n      // Nothing to do for these component types\n      return;\n    default: {\n      invariant(\n        false,\n        'This unit of work tag should not have side-effects. This error is ' +\n          'likely caused by a bug in React. Please file an issue.',\n      );\n    }\n  }\n}\n\nfunction commitHookEffectList(\n  unmountTag: number,\n  mountTag: number,\n  finishedWork: Fiber,\n) {\n  const updateQueue: FunctionComponentUpdateQueue | null = (finishedWork.updateQueue: any);\n  let lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n  if (lastEffect !== null) {\n    const firstEffect = lastEffect.next;\n    let effect = firstEffect;\n    do {\n      if ((effect.tag & unmountTag) !== NoHookEffect) {\n        // Unmount\n        const destroy = effect.destroy;\n        effect.destroy = undefined;\n        if (destroy !== undefined) {\n          destroy();\n        }\n      }\n      if ((effect.tag & mountTag) !== NoHookEffect) {\n        // Mount\n        const create = effect.create;\n        effect.destroy = create();\n\n        if (__DEV__) {\n          const destroy = effect.destroy;\n          if (destroy !== undefined && typeof destroy !== 'function') {\n            let addendum;\n            if (destroy === null) {\n              addendum =\n                ' You returned null. If your effect does not require clean ' +\n                'up, return undefined (or nothing).';\n            } else if (typeof destroy.then === 'function') {\n              addendum =\n                '\\n\\nIt looks like you wrote useEffect(async () => ...) or returned a Promise. ' +\n                'Instead, write the async function inside your effect ' +\n                'and call it immediately:\\n\\n' +\n                'useEffect(() => {\\n' +\n                '  async function fetchData() {\\n' +\n                '    // You can await here\\n' +\n                '    const response = await MyAPI.getData(someId);\\n' +\n                '    // ...\\n' +\n                '  }\\n' +\n                '  fetchData();\\n' +\n                `}, [someId]); // Or [] if effect doesn't need props or state\\n\\n` +\n                'Learn more about data fetching with Hooks: https://fb.me/react-hooks-data-fetching';\n            } else {\n              addendum = ' You returned: ' + destroy;\n            }\n            warningWithoutStack(\n              false,\n              'An effect function must not return anything besides a function, ' +\n                'which is used for clean-up.%s%s',\n              addendum,\n              getStackByFiberInDevAndProd(finishedWork),\n            );\n          }\n        }\n      }\n      effect = effect.next;\n    } while (effect !== firstEffect);\n  }\n}\n\nexport function commitPassiveHookEffects(finishedWork: Fiber): void {\n  if ((finishedWork.effectTag & Passive) !== NoEffect) {\n    switch (finishedWork.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent: {\n        commitHookEffectList(UnmountPassive, NoHookEffect, finishedWork);\n        commitHookEffectList(NoHookEffect, MountPassive, finishedWork);\n        break;\n      }\n      default:\n        break;\n    }\n  }\n}\n\nfunction commitLifeCycles(\n  finishedRoot: FiberRoot,\n  current: Fiber | null,\n  finishedWork: Fiber,\n  committedExpirationTime: ExpirationTime,\n): void {\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent: {\n      commitHookEffectList(UnmountLayout, MountLayout, finishedWork);\n      break;\n    }\n    case ClassComponent: {\n      const instance = finishedWork.stateNode;\n      if (finishedWork.effectTag & Update) {\n        if (current === null) {\n          startPhaseTimer(finishedWork, 'componentDidMount');\n          // We could update instance props and state here,\n          // but instead we rely on them being set during last render.\n          // TODO: revisit this when we implement resuming.\n          if (__DEV__) {\n            if (\n              finishedWork.type === finishedWork.elementType &&\n              !didWarnAboutReassigningProps\n            ) {\n              warning(\n                instance.props === finishedWork.memoizedProps,\n                'Expected %s props to match memoized props before ' +\n                  'componentDidMount. ' +\n                  'This might either be because of a bug in React, or because ' +\n                  'a component reassigns its own `this.props`. ' +\n                  'Please file an issue.',\n                getComponentName(finishedWork.type) || 'instance',\n              );\n              warning(\n                instance.state === finishedWork.memoizedState,\n                'Expected %s state to match memoized state before ' +\n                  'componentDidMount. ' +\n                  'This might either be because of a bug in React, or because ' +\n                  'a component reassigns its own `this.props`. ' +\n                  'Please file an issue.',\n                getComponentName(finishedWork.type) || 'instance',\n              );\n            }\n          }\n          instance.componentDidMount();\n          stopPhaseTimer();\n        } else {\n          const prevProps =\n            finishedWork.elementType === finishedWork.type\n              ? current.memoizedProps\n              : resolveDefaultProps(finishedWork.type, current.memoizedProps);\n          const prevState = current.memoizedState;\n          startPhaseTimer(finishedWork, 'componentDidUpdate');\n          // We could update instance props and state here,\n          // but instead we rely on them being set during last render.\n          // TODO: revisit this when we implement resuming.\n          if (__DEV__) {\n            if (\n              finishedWork.type === finishedWork.elementType &&\n              !didWarnAboutReassigningProps\n            ) {\n              warning(\n                instance.props === finishedWork.memoizedProps,\n                'Expected %s props to match memoized props before ' +\n                  'componentDidUpdate. ' +\n                  'This might either be because of a bug in React, or because ' +\n                  'a component reassigns its own `this.props`. ' +\n                  'Please file an issue.',\n                getComponentName(finishedWork.type) || 'instance',\n              );\n              warning(\n                instance.state === finishedWork.memoizedState,\n                'Expected %s state to match memoized state before ' +\n                  'componentDidUpdate. ' +\n                  'This might either be because of a bug in React, or because ' +\n                  'a component reassigns its own `this.props`. ' +\n                  'Please file an issue.',\n                getComponentName(finishedWork.type) || 'instance',\n              );\n            }\n          }\n          instance.componentDidUpdate(\n            prevProps,\n            prevState,\n            instance.__reactInternalSnapshotBeforeUpdate,\n          );\n          stopPhaseTimer();\n        }\n      }\n      const updateQueue = finishedWork.updateQueue;\n      if (updateQueue !== null) {\n        if (__DEV__) {\n          if (\n            finishedWork.type === finishedWork.elementType &&\n            !didWarnAboutReassigningProps\n          ) {\n            warning(\n              instance.props === finishedWork.memoizedProps,\n              'Expected %s props to match memoized props before ' +\n                'processing the update queue. ' +\n                'This might either be because of a bug in React, or because ' +\n                'a component reassigns its own `this.props`. ' +\n                'Please file an issue.',\n              getComponentName(finishedWork.type) || 'instance',\n            );\n            warning(\n              instance.state === finishedWork.memoizedState,\n              'Expected %s state to match memoized state before ' +\n                'processing the update queue. ' +\n                'This might either be because of a bug in React, or because ' +\n                'a component reassigns its own `this.props`. ' +\n                'Please file an issue.',\n              getComponentName(finishedWork.type) || 'instance',\n            );\n          }\n        }\n        // We could update instance props and state here,\n        // but instead we rely on them being set during last render.\n        // TODO: revisit this when we implement resuming.\n        commitUpdateQueue(\n          finishedWork,\n          updateQueue,\n          instance,\n          committedExpirationTime,\n        );\n      }\n      return;\n    }\n    case HostRoot: {\n      const updateQueue = finishedWork.updateQueue;\n      if (updateQueue !== null) {\n        let instance = null;\n        if (finishedWork.child !== null) {\n          switch (finishedWork.child.tag) {\n            case HostComponent:\n              instance = getPublicInstance(finishedWork.child.stateNode);\n              break;\n            case ClassComponent:\n              instance = finishedWork.child.stateNode;\n              break;\n          }\n        }\n        commitUpdateQueue(\n          finishedWork,\n          updateQueue,\n          instance,\n          committedExpirationTime,\n        );\n      }\n      return;\n    }\n    case HostComponent: {\n      const instance: Instance = finishedWork.stateNode;\n\n      // Renderers may schedule work to be done after host components are mounted\n      // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n      // These effects should only be committed when components are first mounted,\n      // aka when there is no current/alternate.\n      if (current === null && finishedWork.effectTag & Update) {\n        const type = finishedWork.type;\n        const props = finishedWork.memoizedProps;\n        commitMount(instance, type, props, finishedWork);\n      }\n\n      return;\n    }\n    case HostText: {\n      // We have no life-cycles associated with text.\n      return;\n    }\n    case HostPortal: {\n      // We have no life-cycles associated with portals.\n      return;\n    }\n    case Profiler: {\n      if (enableProfilerTimer) {\n        const onRender = finishedWork.memoizedProps.onRender;\n\n        if (typeof onRender === 'function') {\n          if (enableSchedulerTracing) {\n            onRender(\n              finishedWork.memoizedProps.id,\n              current === null ? 'mount' : 'update',\n              finishedWork.actualDuration,\n              finishedWork.treeBaseDuration,\n              finishedWork.actualStartTime,\n              getCommitTime(),\n              finishedRoot.memoizedInteractions,\n            );\n          } else {\n            onRender(\n              finishedWork.memoizedProps.id,\n              current === null ? 'mount' : 'update',\n              finishedWork.actualDuration,\n              finishedWork.treeBaseDuration,\n              finishedWork.actualStartTime,\n              getCommitTime(),\n            );\n          }\n        }\n      }\n      return;\n    }\n    case SuspenseComponent: {\n      if (enableSuspenseCallback) {\n        commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n      }\n      return;\n    }\n    case SuspenseListComponent:\n    case IncompleteClassComponent:\n    case FundamentalComponent:\n    case ScopeComponent:\n      return;\n    default: {\n      invariant(\n        false,\n        'This unit of work tag should not have side-effects. This error is ' +\n          'likely caused by a bug in React. Please file an issue.',\n      );\n    }\n  }\n}\n\nfunction hideOrUnhideAllChildren(finishedWork, isHidden) {\n  if (supportsMutation) {\n    // We only have the top Fiber that was inserted but we need to recurse down its\n    // children to find all the terminal nodes.\n    let node: Fiber = finishedWork;\n    while (true) {\n      if (node.tag === HostComponent) {\n        const instance = node.stateNode;\n        if (isHidden) {\n          hideInstance(instance);\n        } else {\n          unhideInstance(node.stateNode, node.memoizedProps);\n        }\n      } else if (node.tag === HostText) {\n        const instance = node.stateNode;\n        if (isHidden) {\n          hideTextInstance(instance);\n        } else {\n          unhideTextInstance(instance, node.memoizedProps);\n        }\n      } else if (\n        node.tag === SuspenseComponent &&\n        node.memoizedState !== null &&\n        node.memoizedState.dehydrated === null\n      ) {\n        // Found a nested Suspense component that timed out. Skip over the\n        // primary child fragment, which should remain hidden.\n        const fallbackChildFragment: Fiber = (node.child: any).sibling;\n        fallbackChildFragment.return = node;\n        node = fallbackChildFragment;\n        continue;\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n      if (node === finishedWork) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node.return === null || node.return === finishedWork) {\n          return;\n        }\n        node = node.return;\n      }\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  }\n}\n\nfunction commitAttachRef(finishedWork: Fiber) {\n  const ref = finishedWork.ref;\n  if (ref !== null) {\n    const instance = finishedWork.stateNode;\n    let instanceToUse;\n    switch (finishedWork.tag) {\n      case HostComponent:\n        instanceToUse = getPublicInstance(instance);\n        break;\n      default:\n        instanceToUse = instance;\n    }\n    // Moved outside to ensure DCE works with this flag\n    if (enableScopeAPI && finishedWork.tag === ScopeComponent) {\n      instanceToUse = instance.methods;\n    }\n    if (typeof ref === 'function') {\n      ref(instanceToUse);\n    } else {\n      if (__DEV__) {\n        if (!ref.hasOwnProperty('current')) {\n          warningWithoutStack(\n            false,\n            'Unexpected ref object provided for %s. ' +\n              'Use either a ref-setter function or React.createRef().%s',\n            getComponentName(finishedWork.type),\n            getStackByFiberInDevAndProd(finishedWork),\n          );\n        }\n      }\n\n      ref.current = instanceToUse;\n    }\n  }\n}\n\nfunction commitDetachRef(current: Fiber) {\n  const currentRef = current.ref;\n  if (currentRef !== null) {\n    if (typeof currentRef === 'function') {\n      currentRef(null);\n    } else {\n      currentRef.current = null;\n    }\n  }\n}\n\n// User-originating errors (lifecycles and refs) should not interrupt\n// deletion, so don't let them throw. Host-originating errors should\n// interrupt deletion, so it's okay\nfunction commitUnmount(\n  finishedRoot: FiberRoot,\n  current: Fiber,\n  renderPriorityLevel: ReactPriorityLevel,\n): void {\n  onCommitUnmount(current);\n\n  switch (current.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case MemoComponent:\n    case SimpleMemoComponent: {\n      const updateQueue: FunctionComponentUpdateQueue | null = (current.updateQueue: any);\n      if (updateQueue !== null) {\n        const lastEffect = updateQueue.lastEffect;\n        if (lastEffect !== null) {\n          const firstEffect = lastEffect.next;\n\n          // When the owner fiber is deleted, the destroy function of a passive\n          // effect hook is called during the synchronous commit phase. This is\n          // a concession to implementation complexity. Calling it in the\n          // passive effect phase (like they usually are, when dependencies\n          // change during an update) would require either traversing the\n          // children of the deleted fiber again, or including unmount effects\n          // as part of the fiber effect list.\n          //\n          // Because this is during the sync commit phase, we need to change\n          // the priority.\n          //\n          // TODO: Reconsider this implementation trade off.\n          const priorityLevel =\n            renderPriorityLevel > NormalPriority\n              ? NormalPriority\n              : renderPriorityLevel;\n          runWithPriority(priorityLevel, () => {\n            let effect = firstEffect;\n            do {\n              const destroy = effect.destroy;\n              if (destroy !== undefined) {\n                safelyCallDestroy(current, destroy);\n              }\n              effect = effect.next;\n            } while (effect !== firstEffect);\n          });\n        }\n      }\n      break;\n    }\n    case ClassComponent: {\n      safelyDetachRef(current);\n      const instance = current.stateNode;\n      if (typeof instance.componentWillUnmount === 'function') {\n        safelyCallComponentWillUnmount(current, instance);\n      }\n      return;\n    }\n    case HostComponent: {\n      if (enableFlareAPI) {\n        const dependencies = current.dependencies;\n\n        if (dependencies !== null) {\n          const respondersMap = dependencies.responders;\n          if (respondersMap !== null) {\n            const responderInstances = Array.from(respondersMap.values());\n            for (\n              let i = 0, length = responderInstances.length;\n              i < length;\n              i++\n            ) {\n              const responderInstance = responderInstances[i];\n              unmountResponderInstance(responderInstance);\n            }\n            dependencies.responders = null;\n          }\n        }\n      }\n      safelyDetachRef(current);\n      return;\n    }\n    case HostPortal: {\n      // TODO: this is recursive.\n      // We are also not using this parent because\n      // the portal will get pushed immediately.\n      if (supportsMutation) {\n        unmountHostComponents(finishedRoot, current, renderPriorityLevel);\n      } else if (supportsPersistence) {\n        emptyPortalContainer(current);\n      }\n      return;\n    }\n    case FundamentalComponent: {\n      if (enableFundamentalAPI) {\n        const fundamentalInstance = current.stateNode;\n        if (fundamentalInstance !== null) {\n          unmountFundamentalComponent(fundamentalInstance);\n          current.stateNode = null;\n        }\n      }\n      return;\n    }\n    case DehydratedFragment: {\n      if (enableSuspenseCallback) {\n        const hydrationCallbacks = finishedRoot.hydrationCallbacks;\n        if (hydrationCallbacks !== null) {\n          const onDeleted = hydrationCallbacks.onDeleted;\n          if (onDeleted) {\n            onDeleted((current.stateNode: SuspenseInstance));\n          }\n        }\n      }\n      return;\n    }\n    case ScopeComponent: {\n      if (enableScopeAPI) {\n        safelyDetachRef(current);\n      }\n    }\n  }\n}\n\nfunction commitNestedUnmounts(\n  finishedRoot: FiberRoot,\n  root: Fiber,\n  renderPriorityLevel: ReactPriorityLevel,\n): void {\n  // While we're inside a removed host node we don't want to call\n  // removeChild on the inner nodes because they're removed by the top\n  // call anyway. We also want to call componentWillUnmount on all\n  // composites before this host node is removed from the tree. Therefore\n  // we do an inner loop while we're still inside the host node.\n  let node: Fiber = root;\n  while (true) {\n    commitUnmount(finishedRoot, node, renderPriorityLevel);\n    // Visit children because they may contain more composite or host nodes.\n    // Skip portals because commitUnmount() currently visits them recursively.\n    if (\n      node.child !== null &&\n      // If we use mutation we drill down into portals using commitUnmount above.\n      // If we don't use mutation we drill down into portals here instead.\n      (!supportsMutation || node.tag !== HostPortal)\n    ) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === root) {\n      return;\n    }\n    while (node.sibling === null) {\n      if (node.return === null || node.return === root) {\n        return;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction detachFiber(current: Fiber) {\n  // Cut off the return pointers to disconnect it from the tree. Ideally, we\n  // should clear the child pointer of the parent alternate to let this\n  // get GC:ed but we don't know which for sure which parent is the current\n  // one so we'll settle for GC:ing the subtree of this child. This child\n  // itself will be GC:ed when the parent updates the next time.\n  current.return = null;\n  current.child = null;\n  current.memoizedState = null;\n  current.updateQueue = null;\n  current.dependencies = null;\n  const alternate = current.alternate;\n  if (alternate !== null) {\n    alternate.return = null;\n    alternate.child = null;\n    alternate.memoizedState = null;\n    alternate.updateQueue = null;\n    alternate.dependencies = null;\n  }\n}\n\nfunction emptyPortalContainer(current: Fiber) {\n  if (!supportsPersistence) {\n    return;\n  }\n\n  const portal: {containerInfo: Container, pendingChildren: ChildSet} =\n    current.stateNode;\n  const {containerInfo} = portal;\n  const emptyChildSet = createContainerChildSet(containerInfo);\n  replaceContainerChildren(containerInfo, emptyChildSet);\n}\n\nfunction commitContainer(finishedWork: Fiber) {\n  if (!supportsPersistence) {\n    return;\n  }\n\n  switch (finishedWork.tag) {\n    case ClassComponent:\n    case HostComponent:\n    case HostText:\n    case FundamentalComponent: {\n      return;\n    }\n    case HostRoot:\n    case HostPortal: {\n      const portalOrRoot: {\n        containerInfo: Container,\n        pendingChildren: ChildSet,\n      } =\n        finishedWork.stateNode;\n      const {containerInfo, pendingChildren} = portalOrRoot;\n      replaceContainerChildren(containerInfo, pendingChildren);\n      return;\n    }\n    default: {\n      invariant(\n        false,\n        'This unit of work tag should not have side-effects. This error is ' +\n          'likely caused by a bug in React. Please file an issue.',\n      );\n    }\n  }\n}\n\nfunction getHostParentFiber(fiber: Fiber): Fiber {\n  let parent = fiber.return;\n  while (parent !== null) {\n    if (isHostParent(parent)) {\n      return parent;\n    }\n    parent = parent.return;\n  }\n  invariant(\n    false,\n    'Expected to find a host parent. This error is likely caused by a bug ' +\n      'in React. Please file an issue.',\n  );\n}\n\nfunction isHostParent(fiber: Fiber): boolean {\n  return (\n    fiber.tag === HostComponent ||\n    fiber.tag === HostRoot ||\n    fiber.tag === HostPortal\n  );\n}\n\nfunction getHostSibling(fiber: Fiber): ?Instance {\n  // We're going to search forward into the tree until we find a sibling host\n  // node. Unfortunately, if multiple insertions are done in a row we have to\n  // search past them. This leads to exponential search for the next sibling.\n  // TODO: Find a more efficient way to do this.\n  let node: Fiber = fiber;\n  siblings: while (true) {\n    // If we didn't find anything, let's try the next sibling.\n    while (node.sibling === null) {\n      if (node.return === null || isHostParent(node.return)) {\n        // If we pop out of the root or hit the parent the fiber we are the\n        // last sibling.\n        return null;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n    while (\n      node.tag !== HostComponent &&\n      node.tag !== HostText &&\n      node.tag !== DehydratedFragment\n    ) {\n      // If it is not host node and, we might have a host node inside it.\n      // Try to search down until we find one.\n      if (node.effectTag & Placement) {\n        // If we don't have a child, try the siblings instead.\n        continue siblings;\n      }\n      // If we don't have a child, try the siblings instead.\n      // We also skip portals because they are not part of this host tree.\n      if (node.child === null || node.tag === HostPortal) {\n        continue siblings;\n      } else {\n        node.child.return = node;\n        node = node.child;\n      }\n    }\n    // Check if this host node is stable or about to be placed.\n    if (!(node.effectTag & Placement)) {\n      // Found it!\n      return node.stateNode;\n    }\n  }\n}\n\nfunction commitPlacement(finishedWork: Fiber): void {\n  if (!supportsMutation) {\n    return;\n  }\n\n  // Recursively insert all host nodes into the parent.\n  const parentFiber = getHostParentFiber(finishedWork);\n\n  // Note: these two variables *must* always be updated together.\n  let parent;\n  let isContainer;\n  const parentStateNode = parentFiber.stateNode;\n  switch (parentFiber.tag) {\n    case HostComponent:\n      parent = parentStateNode;\n      isContainer = false;\n      break;\n    case HostRoot:\n      parent = parentStateNode.containerInfo;\n      isContainer = true;\n      break;\n    case HostPortal:\n      parent = parentStateNode.containerInfo;\n      isContainer = true;\n      break;\n    case FundamentalComponent:\n      if (enableFundamentalAPI) {\n        parent = parentStateNode.instance;\n        isContainer = false;\n      }\n    // eslint-disable-next-line-no-fallthrough\n    default:\n      invariant(\n        false,\n        'Invalid host parent fiber. This error is likely caused by a bug ' +\n          'in React. Please file an issue.',\n      );\n  }\n  if (parentFiber.effectTag & ContentReset) {\n    // Reset the text content of the parent before doing any insertions\n    resetTextContent(parent);\n    // Clear ContentReset from the effect tag\n    parentFiber.effectTag &= ~ContentReset;\n  }\n\n  const before = getHostSibling(finishedWork);\n  // We only have the top Fiber that was inserted but we need to recurse down its\n  // children to find all the terminal nodes.\n  let node: Fiber = finishedWork;\n  while (true) {\n    const isHost = node.tag === HostComponent || node.tag === HostText;\n    if (isHost || (enableFundamentalAPI && node.tag === FundamentalComponent)) {\n      const stateNode = isHost ? node.stateNode : node.stateNode.instance;\n      if (before) {\n        if (isContainer) {\n          insertInContainerBefore(parent, stateNode, before);\n        } else {\n          insertBefore(parent, stateNode, before);\n        }\n      } else {\n        if (isContainer) {\n          appendChildToContainer(parent, stateNode);\n        } else {\n          appendChild(parent, stateNode);\n        }\n      }\n    } else if (node.tag === HostPortal) {\n      // If the insertion itself is a portal, then we don't want to traverse\n      // down its children. Instead, we'll get insertions from each child in\n      // the portal directly.\n    } else if (node.child !== null) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === finishedWork) {\n      return;\n    }\n    while (node.sibling === null) {\n      if (node.return === null || node.return === finishedWork) {\n        return;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction unmountHostComponents(\n  finishedRoot,\n  current,\n  renderPriorityLevel,\n): void {\n  // We only have the top Fiber that was deleted but we need to recurse down its\n  // children to find all the terminal nodes.\n  let node: Fiber = current;\n\n  // Each iteration, currentParent is populated with node's host parent if not\n  // currentParentIsValid.\n  let currentParentIsValid = false;\n\n  // Note: these two variables *must* always be updated together.\n  let currentParent;\n  let currentParentIsContainer;\n\n  while (true) {\n    if (!currentParentIsValid) {\n      let parent = node.return;\n      findParent: while (true) {\n        invariant(\n          parent !== null,\n          'Expected to find a host parent. This error is likely caused by ' +\n            'a bug in React. Please file an issue.',\n        );\n        const parentStateNode = parent.stateNode;\n        switch (parent.tag) {\n          case HostComponent:\n            currentParent = parentStateNode;\n            currentParentIsContainer = false;\n            break findParent;\n          case HostRoot:\n            currentParent = parentStateNode.containerInfo;\n            currentParentIsContainer = true;\n            break findParent;\n          case HostPortal:\n            currentParent = parentStateNode.containerInfo;\n            currentParentIsContainer = true;\n            break findParent;\n          case FundamentalComponent:\n            if (enableFundamentalAPI) {\n              currentParent = parentStateNode.instance;\n              currentParentIsContainer = false;\n            }\n        }\n        parent = parent.return;\n      }\n      currentParentIsValid = true;\n    }\n\n    if (node.tag === HostComponent || node.tag === HostText) {\n      commitNestedUnmounts(finishedRoot, node, renderPriorityLevel);\n      // After all the children have unmounted, it is now safe to remove the\n      // node from the tree.\n      if (currentParentIsContainer) {\n        removeChildFromContainer(\n          ((currentParent: any): Container),\n          (node.stateNode: Instance | TextInstance),\n        );\n      } else {\n        removeChild(\n          ((currentParent: any): Instance),\n          (node.stateNode: Instance | TextInstance),\n        );\n      }\n      // Don't visit children because we already visited them.\n    } else if (enableFundamentalAPI && node.tag === FundamentalComponent) {\n      const fundamentalNode = node.stateNode.instance;\n      commitNestedUnmounts(finishedRoot, node, renderPriorityLevel);\n      // After all the children have unmounted, it is now safe to remove the\n      // node from the tree.\n      if (currentParentIsContainer) {\n        removeChildFromContainer(\n          ((currentParent: any): Container),\n          (fundamentalNode: Instance),\n        );\n      } else {\n        removeChild(\n          ((currentParent: any): Instance),\n          (fundamentalNode: Instance),\n        );\n      }\n    } else if (\n      enableSuspenseServerRenderer &&\n      node.tag === DehydratedFragment\n    ) {\n      if (enableSuspenseCallback) {\n        const hydrationCallbacks = finishedRoot.hydrationCallbacks;\n        if (hydrationCallbacks !== null) {\n          const onDeleted = hydrationCallbacks.onDeleted;\n          if (onDeleted) {\n            onDeleted((node.stateNode: SuspenseInstance));\n          }\n        }\n      }\n\n      // Delete the dehydrated suspense boundary and all of its content.\n      if (currentParentIsContainer) {\n        clearSuspenseBoundaryFromContainer(\n          ((currentParent: any): Container),\n          (node.stateNode: SuspenseInstance),\n        );\n      } else {\n        clearSuspenseBoundary(\n          ((currentParent: any): Instance),\n          (node.stateNode: SuspenseInstance),\n        );\n      }\n    } else if (node.tag === HostPortal) {\n      if (node.child !== null) {\n        // When we go into a portal, it becomes the parent to remove from.\n        // We will reassign it back when we pop the portal on the way up.\n        currentParent = node.stateNode.containerInfo;\n        currentParentIsContainer = true;\n        // Visit children because portals might contain host components.\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n    } else {\n      commitUnmount(finishedRoot, node, renderPriorityLevel);\n      // Visit children because we may find more host components below.\n      if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n    }\n    if (node === current) {\n      return;\n    }\n    while (node.sibling === null) {\n      if (node.return === null || node.return === current) {\n        return;\n      }\n      node = node.return;\n      if (node.tag === HostPortal) {\n        // When we go out of the portal, we need to restore the parent.\n        // Since we don't keep a stack of them, we will search for it.\n        currentParentIsValid = false;\n      }\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction commitDeletion(\n  finishedRoot: FiberRoot,\n  current: Fiber,\n  renderPriorityLevel: ReactPriorityLevel,\n): void {\n  if (supportsMutation) {\n    // Recursively delete all host nodes from the parent.\n    // Detach refs and call componentWillUnmount() on the whole subtree.\n    unmountHostComponents(finishedRoot, current, renderPriorityLevel);\n  } else {\n    // Detach refs and call componentWillUnmount() on the whole subtree.\n    commitNestedUnmounts(finishedRoot, current, renderPriorityLevel);\n  }\n  detachFiber(current);\n}\n\nfunction commitWork(current: Fiber | null, finishedWork: Fiber): void {\n  if (!supportsMutation) {\n    switch (finishedWork.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case MemoComponent:\n      case SimpleMemoComponent: {\n        // Note: We currently never use MountMutation, but useLayout uses\n        // UnmountMutation.\n        commitHookEffectList(UnmountMutation, MountMutation, finishedWork);\n        return;\n      }\n      case Profiler: {\n        return;\n      }\n      case SuspenseComponent: {\n        commitSuspenseComponent(finishedWork);\n        attachSuspenseRetryListeners(finishedWork);\n        return;\n      }\n      case SuspenseListComponent: {\n        attachSuspenseRetryListeners(finishedWork);\n        return;\n      }\n      case HostRoot: {\n        const root: FiberRoot = finishedWork.stateNode;\n        if (supportsHydration) {\n          if (root.hydrate) {\n            // We've just hydrated. No need to hydrate again.\n            root.hydrate = false;\n          }\n        }\n        break;\n      }\n    }\n\n    commitContainer(finishedWork);\n    return;\n  }\n\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case MemoComponent:\n    case SimpleMemoComponent: {\n      // Note: We currently never use MountMutation, but useLayout uses\n      // UnmountMutation.\n      commitHookEffectList(UnmountMutation, MountMutation, finishedWork);\n      return;\n    }\n    case ClassComponent: {\n      return;\n    }\n    case HostComponent: {\n      const instance: Instance = finishedWork.stateNode;\n      if (instance != null) {\n        // Commit the work prepared earlier.\n        const newProps = finishedWork.memoizedProps;\n        // For hydration we reuse the update path but we treat the oldProps\n        // as the newProps. The updatePayload will contain the real change in\n        // this case.\n        const oldProps = current !== null ? current.memoizedProps : newProps;\n        const type = finishedWork.type;\n        // TODO: Type the updateQueue to be specific to host components.\n        const updatePayload: null | UpdatePayload = (finishedWork.updateQueue: any);\n        finishedWork.updateQueue = null;\n        if (updatePayload !== null) {\n          commitUpdate(\n            instance,\n            updatePayload,\n            type,\n            oldProps,\n            newProps,\n            finishedWork,\n          );\n        }\n        if (enableFlareAPI) {\n          const prevListeners = oldProps.listeners;\n          const nextListeners = newProps.listeners;\n          if (prevListeners !== nextListeners) {\n            updateEventListeners(nextListeners, finishedWork, null);\n          }\n        }\n      }\n      return;\n    }\n    case HostText: {\n      invariant(\n        finishedWork.stateNode !== null,\n        'This should have a text node initialized. This error is likely ' +\n          'caused by a bug in React. Please file an issue.',\n      );\n      const textInstance: TextInstance = finishedWork.stateNode;\n      const newText: string = finishedWork.memoizedProps;\n      // For hydration we reuse the update path but we treat the oldProps\n      // as the newProps. The updatePayload will contain the real change in\n      // this case.\n      const oldText: string =\n        current !== null ? current.memoizedProps : newText;\n      commitTextUpdate(textInstance, oldText, newText);\n      return;\n    }\n    case HostRoot: {\n      const root: FiberRoot = finishedWork.stateNode;\n      if (supportsHydration) {\n        if (root.hydrate) {\n          // We've just hydrated. No need to hydrate again.\n          root.hydrate = false;\n        }\n      }\n      return;\n    }\n    case Profiler: {\n      return;\n    }\n    case SuspenseComponent: {\n      commitSuspenseComponent(finishedWork);\n      attachSuspenseRetryListeners(finishedWork);\n      return;\n    }\n    case SuspenseListComponent: {\n      attachSuspenseRetryListeners(finishedWork);\n      return;\n    }\n    case IncompleteClassComponent: {\n      return;\n    }\n    case FundamentalComponent: {\n      if (enableFundamentalAPI) {\n        const fundamentalInstance = finishedWork.stateNode;\n        updateFundamentalComponent(fundamentalInstance);\n      }\n      return;\n    }\n    case ScopeComponent: {\n      if (enableScopeAPI) {\n        const scopeInstance = finishedWork.stateNode;\n        scopeInstance.fiber = finishedWork;\n        if (enableFlareAPI) {\n          const newProps = finishedWork.memoizedProps;\n          const oldProps = current !== null ? current.memoizedProps : newProps;\n          const prevListeners = oldProps.listeners;\n          const nextListeners = newProps.listeners;\n          if (prevListeners !== nextListeners) {\n            updateEventListeners(nextListeners, finishedWork, null);\n          }\n        }\n      }\n      return;\n    }\n    default: {\n      invariant(\n        false,\n        'This unit of work tag should not have side-effects. This error is ' +\n          'likely caused by a bug in React. Please file an issue.',\n      );\n    }\n  }\n}\n\nfunction commitSuspenseComponent(finishedWork: Fiber) {\n  let newState: SuspenseState | null = finishedWork.memoizedState;\n\n  let newDidTimeout;\n  let primaryChildParent = finishedWork;\n  if (newState === null) {\n    newDidTimeout = false;\n  } else {\n    newDidTimeout = true;\n    primaryChildParent = finishedWork.child;\n    markCommitTimeOfFallback();\n  }\n\n  if (supportsMutation && primaryChildParent !== null) {\n    hideOrUnhideAllChildren(primaryChildParent, newDidTimeout);\n  }\n\n  if (enableSuspenseCallback && newState !== null) {\n    const suspenseCallback = finishedWork.memoizedProps.suspenseCallback;\n    if (typeof suspenseCallback === 'function') {\n      const thenables: Set<Thenable> | null = (finishedWork.updateQueue: any);\n      if (thenables !== null) {\n        suspenseCallback(new Set(thenables));\n      }\n    } else if (__DEV__) {\n      if (suspenseCallback !== undefined) {\n        warning(false, 'Unexpected type for suspenseCallback.');\n      }\n    }\n  }\n}\n\nfunction commitSuspenseHydrationCallbacks(\n  finishedRoot: FiberRoot,\n  finishedWork: Fiber,\n) {\n  if (enableSuspenseCallback) {\n    const hydrationCallbacks = finishedRoot.hydrationCallbacks;\n    if (hydrationCallbacks !== null) {\n      const onHydrated = hydrationCallbacks.onHydrated;\n      if (onHydrated) {\n        const newState: SuspenseState | null = finishedWork.memoizedState;\n        if (newState === null) {\n          const current = finishedWork.alternate;\n          if (current !== null) {\n            const prevState: SuspenseState | null = current.memoizedState;\n            if (prevState !== null && prevState.dehydrated !== null) {\n              onHydrated(prevState.dehydrated);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction attachSuspenseRetryListeners(finishedWork: Fiber) {\n  // If this boundary just timed out, then it will have a set of thenables.\n  // For each thenable, attach a listener so that when it resolves, React\n  // attempts to re-render the boundary in the primary (pre-timeout) state.\n  const thenables: Set<Thenable> | null = (finishedWork.updateQueue: any);\n  if (thenables !== null) {\n    finishedWork.updateQueue = null;\n    let retryCache = finishedWork.stateNode;\n    if (retryCache === null) {\n      retryCache = finishedWork.stateNode = new PossiblyWeakSet();\n    }\n    thenables.forEach(thenable => {\n      // Memoize using the boundary fiber to prevent redundant listeners.\n      let retry = resolveRetryThenable.bind(null, finishedWork, thenable);\n      if (!retryCache.has(thenable)) {\n        if (enableSchedulerTracing) {\n          if (thenable.__reactDoNotTraceInteractions !== true) {\n            retry = Schedule_tracing_wrap(retry);\n          }\n        }\n        retryCache.add(thenable);\n        thenable.then(retry, retry);\n      }\n    });\n  }\n}\n\nfunction commitResetTextContent(current: Fiber) {\n  if (!supportsMutation) {\n    return;\n  }\n  resetTextContent(current.stateNode);\n}\n\nexport {\n  commitBeforeMutationLifeCycles,\n  commitResetTextContent,\n  commitPlacement,\n  commitDeletion,\n  commitWork,\n  commitLifeCycles,\n  commitAttachRef,\n  commitDetachRef,\n};\n"]},"metadata":{},"sourceType":"module"}