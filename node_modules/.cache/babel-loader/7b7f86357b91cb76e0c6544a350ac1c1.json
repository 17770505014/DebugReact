{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport getComponentName from 'shared/getComponentName';\nimport warningWithoutStack from 'shared/warningWithoutStack';\nimport { ClassComponent, HostRoot, SuspenseComponent, IncompleteClassComponent } from 'shared/ReactWorkTags';\nimport { DidCapture, Incomplete, NoEffect, ShouldCapture, LifecycleEffectMask } from 'shared/ReactSideEffectTags';\nimport { NoMode, BlockingMode } from './ReactTypeOfMode';\nimport { shouldCaptureSuspense } from './ReactFiberSuspenseComponent';\nimport { createCapturedValue } from './ReactCapturedValue';\nimport { enqueueCapturedUpdate, createUpdate, CaptureUpdate, ForceUpdate, enqueueUpdate } from './ReactUpdateQueue';\nimport { logError } from './ReactFiberCommitWork';\nimport { getStackByFiberInDevAndProd } from './ReactCurrentFiber';\nimport { markFailedErrorBoundaryForHotReloading } from './ReactFiberHotReloading';\nimport { suspenseStackCursor, InvisibleParentSuspenseContext, hasSuspenseContext } from './ReactFiberSuspenseContext';\nimport { renderDidError, onUncaughtError, markLegacyErrorBoundaryAsFailed, isAlreadyFailedLegacyErrorBoundary, pingSuspendedRoot, checkForWrongSuspensePriorityInDEV } from './ReactFiberWorkLoop';\nimport { Sync } from './ReactFiberExpirationTime';\nconst PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n\nfunction createRootErrorUpdate(fiber, errorInfo, expirationTime) {\n  const update = createUpdate(expirationTime, null); // Unmount the root by rendering null.\n\n  update.tag = CaptureUpdate; // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n\n  update.payload = {\n    element: null\n  };\n  const error = errorInfo.value;\n\n  update.callback = () => {\n    onUncaughtError(error);\n    logError(fiber, errorInfo);\n  };\n\n  return update;\n}\n\nfunction createClassErrorUpdate(fiber, errorInfo, expirationTime) {\n  const update = createUpdate(expirationTime, null);\n  update.tag = CaptureUpdate;\n  const getDerivedStateFromError = fiber.type.getDerivedStateFromError;\n\n  if (typeof getDerivedStateFromError === 'function') {\n    const error = errorInfo.value;\n\n    update.payload = () => {\n      logError(fiber, errorInfo);\n      return getDerivedStateFromError(error);\n    };\n  }\n\n  const inst = fiber.stateNode;\n\n  if (inst !== null && typeof inst.componentDidCatch === 'function') {\n    update.callback = function callback() {\n      if (__DEV__) {\n        markFailedErrorBoundaryForHotReloading(fiber);\n      }\n\n      if (typeof getDerivedStateFromError !== 'function') {\n        // To preserve the preexisting retry behavior of error boundaries,\n        // we keep track of which ones already failed during this batch.\n        // This gets reset before we yield back to the browser.\n        // TODO: Warn in strict mode if getDerivedStateFromError is\n        // not defined.\n        markLegacyErrorBoundaryAsFailed(this); // Only log here if componentDidCatch is the only error boundary method defined\n\n        logError(fiber, errorInfo);\n      }\n\n      const error = errorInfo.value;\n      const stack = errorInfo.stack;\n      this.componentDidCatch(error, {\n        componentStack: stack !== null ? stack : ''\n      });\n\n      if (__DEV__) {\n        if (typeof getDerivedStateFromError !== 'function') {\n          // If componentDidCatch is the only error boundary method defined,\n          // then it needs to call setState to recover from errors.\n          // If no state update is scheduled then the boundary will swallow the error.\n          warningWithoutStack(fiber.expirationTime === Sync, '%s: Error boundaries should implement getDerivedStateFromError(). ' + 'In that method, return a state update to display an error message or fallback UI.', getComponentName(fiber.type) || 'Unknown');\n        }\n      }\n    };\n  } else if (__DEV__) {\n    update.callback = () => {\n      markFailedErrorBoundaryForHotReloading(fiber);\n    };\n  }\n\n  return update;\n}\n\nfunction attachPingListener(root, renderExpirationTime, thenable) {\n  // Attach a listener to the promise to \"ping\" the root and retry. But\n  // only if one does not already exist for the current render expiration\n  // time (which acts like a \"thread ID\" here).\n  let pingCache = root.pingCache;\n  let threadIDs;\n\n  if (pingCache === null) {\n    pingCache = root.pingCache = new PossiblyWeakMap();\n    threadIDs = new Set();\n    pingCache.set(thenable, threadIDs);\n  } else {\n    threadIDs = pingCache.get(thenable);\n\n    if (threadIDs === undefined) {\n      threadIDs = new Set();\n      pingCache.set(thenable, threadIDs);\n    }\n  }\n\n  if (!threadIDs.has(renderExpirationTime)) {\n    // Memoize using the thread ID to prevent redundant listeners.\n    threadIDs.add(renderExpirationTime);\n    let ping = pingSuspendedRoot.bind(null, root, thenable, renderExpirationTime);\n    thenable.then(ping, ping);\n  }\n}\n\nfunction throwException(root, returnFiber, sourceFiber, value, renderExpirationTime) {\n  // The source fiber did not complete.\n  sourceFiber.effectTag |= Incomplete; // Its effect list is no longer valid.\n\n  sourceFiber.firstEffect = sourceFiber.lastEffect = null;\n\n  if (value !== null && typeof value === 'object' && typeof value.then === 'function') {\n    // This is a thenable.\n    const thenable = value;\n    checkForWrongSuspensePriorityInDEV(sourceFiber);\n    let hasInvisibleParentBoundary = hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext); // Schedule the nearest Suspense to re-render the timed out view.\n\n    let workInProgress = returnFiber;\n\n    do {\n      if (workInProgress.tag === SuspenseComponent && shouldCaptureSuspense(workInProgress, hasInvisibleParentBoundary)) {\n        // Found the nearest boundary.\n        // Stash the promise on the boundary fiber. If the boundary times out, we'll\n        // attach another listener to flip the boundary back to its normal state.\n        const thenables = workInProgress.updateQueue;\n\n        if (thenables === null) {\n          const updateQueue = new Set();\n          updateQueue.add(thenable);\n          workInProgress.updateQueue = updateQueue;\n        } else {\n          thenables.add(thenable);\n        } // If the boundary is outside of blocking mode, we should *not*\n        // suspend the commit. Pretend as if the suspended component rendered\n        // null and keep rendering. In the commit phase, we'll schedule a\n        // subsequent synchronous update to re-render the Suspense.\n        //\n        // Note: It doesn't matter whether the component that suspended was\n        // inside a blocking mode tree. If the Suspense is outside of it, we\n        // should *not* suspend the commit.\n\n\n        if ((workInProgress.mode & BlockingMode) === NoMode) {\n          workInProgress.effectTag |= DidCapture; // We're going to commit this fiber even though it didn't complete.\n          // But we shouldn't call any lifecycle methods or callbacks. Remove\n          // all lifecycle effect tags.\n\n          sourceFiber.effectTag &= ~(LifecycleEffectMask | Incomplete);\n\n          if (sourceFiber.tag === ClassComponent) {\n            const currentSourceFiber = sourceFiber.alternate;\n\n            if (currentSourceFiber === null) {\n              // This is a new mount. Change the tag so it's not mistaken for a\n              // completed class component. For example, we should not call\n              // componentWillUnmount if it is deleted.\n              sourceFiber.tag = IncompleteClassComponent;\n            } else {\n              // When we try rendering again, we should not reuse the current fiber,\n              // since it's known to be in an inconsistent state. Use a force update to\n              // prevent a bail out.\n              const update = createUpdate(Sync, null);\n              update.tag = ForceUpdate;\n              enqueueUpdate(sourceFiber, update);\n            }\n          } // The source fiber did not complete. Mark it with Sync priority to\n          // indicate that it still has pending work.\n\n\n          sourceFiber.expirationTime = Sync; // Exit without suspending.\n\n          return;\n        } // Confirmed that the boundary is in a concurrent mode tree. Continue\n        // with the normal suspend path.\n        //\n        // After this we'll use a set of heuristics to determine whether this\n        // render pass will run to completion or restart or \"suspend\" the commit.\n        // The actual logic for this is spread out in different places.\n        //\n        // This first principle is that if we're going to suspend when we complete\n        // a root, then we should also restart if we get an update or ping that\n        // might unsuspend it, and vice versa. The only reason to suspend is\n        // because you think you might want to restart before committing. However,\n        // it doesn't make sense to restart only while in the period we're suspended.\n        //\n        // Restarting too aggressively is also not good because it starves out any\n        // intermediate loading state. So we use heuristics to determine when.\n        // Suspense Heuristics\n        //\n        // If nothing threw a Promise or all the same fallbacks are already showing,\n        // then don't suspend/restart.\n        //\n        // If this is an initial render of a new tree of Suspense boundaries and\n        // those trigger a fallback, then don't suspend/restart. We want to ensure\n        // that we can show the initial loading state as quickly as possible.\n        //\n        // If we hit a \"Delayed\" case, such as when we'd switch from content back into\n        // a fallback, then we should always suspend/restart. SuspenseConfig applies to\n        // this case. If none is defined, JND is used instead.\n        //\n        // If we're already showing a fallback and it gets \"retried\", allowing us to show\n        // another level, but there's still an inner boundary that would show a fallback,\n        // then we suspend/restart for 500ms since the last time we showed a fallback\n        // anywhere in the tree. This effectively throttles progressive loading into a\n        // consistent train of commits. This also gives us an opportunity to restart to\n        // get to the completed state slightly earlier.\n        //\n        // If there's ambiguity due to batching it's resolved in preference of:\n        // 1) \"delayed\", 2) \"initial render\", 3) \"retry\".\n        //\n        // We want to ensure that a \"busy\" state doesn't get force committed. We want to\n        // ensure that new initial loading states can commit as soon as possible.\n\n\n        attachPingListener(root, renderExpirationTime, thenable);\n        workInProgress.effectTag |= ShouldCapture;\n        workInProgress.expirationTime = renderExpirationTime;\n        return;\n      } // This boundary already captured during this render. Continue to the next\n      // boundary.\n\n\n      workInProgress = workInProgress.return;\n    } while (workInProgress !== null); // No boundary was found. Fallthrough to error mode.\n    // TODO: Use invariant so the message is stripped in prod?\n\n\n    value = new Error((getComponentName(sourceFiber.type) || 'A React component') + ' suspended while rendering, but no fallback UI was specified.\\n' + '\\n' + 'Add a <Suspense fallback=...> component higher in the tree to ' + 'provide a loading indicator or placeholder to display.' + getStackByFiberInDevAndProd(sourceFiber));\n  } // We didn't find a boundary that could handle this type of exception. Start\n  // over and traverse parent path again, this time treating the exception\n  // as an error.\n\n\n  renderDidError();\n  value = createCapturedValue(value, sourceFiber);\n  let workInProgress = returnFiber;\n\n  do {\n    switch (workInProgress.tag) {\n      case HostRoot:\n        {\n          const errorInfo = value;\n          workInProgress.effectTag |= ShouldCapture;\n          workInProgress.expirationTime = renderExpirationTime;\n          const update = createRootErrorUpdate(workInProgress, errorInfo, renderExpirationTime);\n          enqueueCapturedUpdate(workInProgress, update);\n          return;\n        }\n\n      case ClassComponent:\n        // Capture and retry\n        const errorInfo = value;\n        const ctor = workInProgress.type;\n        const instance = workInProgress.stateNode;\n\n        if ((workInProgress.effectTag & DidCapture) === NoEffect && (typeof ctor.getDerivedStateFromError === 'function' || instance !== null && typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance))) {\n          workInProgress.effectTag |= ShouldCapture;\n          workInProgress.expirationTime = renderExpirationTime; // Schedule the error boundary to re-render using updated state\n\n          const update = createClassErrorUpdate(workInProgress, errorInfo, renderExpirationTime);\n          enqueueCapturedUpdate(workInProgress, update);\n          return;\n        }\n\n        break;\n\n      default:\n        break;\n    }\n\n    workInProgress = workInProgress.return;\n  } while (workInProgress !== null);\n}\n\nexport { throwException, createRootErrorUpdate, createClassErrorUpdate };","map":{"version":3,"sources":["/Users/gaoshaoyun/Documents/library/debug-react/src/react/packages/react-reconciler/src/ReactFiberThrow.js"],"names":["getComponentName","warningWithoutStack","ClassComponent","HostRoot","SuspenseComponent","IncompleteClassComponent","DidCapture","Incomplete","NoEffect","ShouldCapture","LifecycleEffectMask","NoMode","BlockingMode","shouldCaptureSuspense","createCapturedValue","enqueueCapturedUpdate","createUpdate","CaptureUpdate","ForceUpdate","enqueueUpdate","logError","getStackByFiberInDevAndProd","markFailedErrorBoundaryForHotReloading","suspenseStackCursor","InvisibleParentSuspenseContext","hasSuspenseContext","renderDidError","onUncaughtError","markLegacyErrorBoundaryAsFailed","isAlreadyFailedLegacyErrorBoundary","pingSuspendedRoot","checkForWrongSuspensePriorityInDEV","Sync","PossiblyWeakMap","WeakMap","Map","createRootErrorUpdate","fiber","errorInfo","expirationTime","update","tag","payload","element","error","value","callback","createClassErrorUpdate","getDerivedStateFromError","type","inst","stateNode","componentDidCatch","__DEV__","stack","componentStack","attachPingListener","root","renderExpirationTime","thenable","pingCache","threadIDs","Set","set","get","undefined","has","add","ping","bind","then","throwException","returnFiber","sourceFiber","effectTag","firstEffect","lastEffect","hasInvisibleParentBoundary","current","workInProgress","thenables","updateQueue","mode","currentSourceFiber","alternate","return","Error","ctor","instance"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber} from './ReactFiber';\nimport type {FiberRoot} from './ReactFiberRoot';\nimport type {ExpirationTime} from './ReactFiberExpirationTime';\nimport type {CapturedValue} from './ReactCapturedValue';\nimport type {Update} from './ReactUpdateQueue';\nimport type {Thenable} from './ReactFiberWorkLoop';\nimport type {SuspenseContext} from './ReactFiberSuspenseContext';\n\nimport getComponentName from 'shared/getComponentName';\nimport warningWithoutStack from 'shared/warningWithoutStack';\nimport {\n  ClassComponent,\n  HostRoot,\n  SuspenseComponent,\n  IncompleteClassComponent,\n} from 'shared/ReactWorkTags';\nimport {\n  DidCapture,\n  Incomplete,\n  NoEffect,\n  ShouldCapture,\n  LifecycleEffectMask,\n} from 'shared/ReactSideEffectTags';\nimport {NoMode, BlockingMode} from './ReactTypeOfMode';\nimport {shouldCaptureSuspense} from './ReactFiberSuspenseComponent';\n\nimport {createCapturedValue} from './ReactCapturedValue';\nimport {\n  enqueueCapturedUpdate,\n  createUpdate,\n  CaptureUpdate,\n  ForceUpdate,\n  enqueueUpdate,\n} from './ReactUpdateQueue';\nimport {logError} from './ReactFiberCommitWork';\nimport {getStackByFiberInDevAndProd} from './ReactCurrentFiber';\nimport {markFailedErrorBoundaryForHotReloading} from './ReactFiberHotReloading';\nimport {\n  suspenseStackCursor,\n  InvisibleParentSuspenseContext,\n  hasSuspenseContext,\n} from './ReactFiberSuspenseContext';\nimport {\n  renderDidError,\n  onUncaughtError,\n  markLegacyErrorBoundaryAsFailed,\n  isAlreadyFailedLegacyErrorBoundary,\n  pingSuspendedRoot,\n  checkForWrongSuspensePriorityInDEV,\n} from './ReactFiberWorkLoop';\n\nimport {Sync} from './ReactFiberExpirationTime';\n\nconst PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n\nfunction createRootErrorUpdate(\n  fiber: Fiber,\n  errorInfo: CapturedValue<mixed>,\n  expirationTime: ExpirationTime,\n): Update<mixed> {\n  const update = createUpdate(expirationTime, null);\n  // Unmount the root by rendering null.\n  update.tag = CaptureUpdate;\n  // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n  update.payload = {element: null};\n  const error = errorInfo.value;\n  update.callback = () => {\n    onUncaughtError(error);\n    logError(fiber, errorInfo);\n  };\n  return update;\n}\n\nfunction createClassErrorUpdate(\n  fiber: Fiber,\n  errorInfo: CapturedValue<mixed>,\n  expirationTime: ExpirationTime,\n): Update<mixed> {\n  const update = createUpdate(expirationTime, null);\n  update.tag = CaptureUpdate;\n  const getDerivedStateFromError = fiber.type.getDerivedStateFromError;\n  if (typeof getDerivedStateFromError === 'function') {\n    const error = errorInfo.value;\n    update.payload = () => {\n      logError(fiber, errorInfo);\n      return getDerivedStateFromError(error);\n    };\n  }\n\n  const inst = fiber.stateNode;\n  if (inst !== null && typeof inst.componentDidCatch === 'function') {\n    update.callback = function callback() {\n      if (__DEV__) {\n        markFailedErrorBoundaryForHotReloading(fiber);\n      }\n      if (typeof getDerivedStateFromError !== 'function') {\n        // To preserve the preexisting retry behavior of error boundaries,\n        // we keep track of which ones already failed during this batch.\n        // This gets reset before we yield back to the browser.\n        // TODO: Warn in strict mode if getDerivedStateFromError is\n        // not defined.\n        markLegacyErrorBoundaryAsFailed(this);\n\n        // Only log here if componentDidCatch is the only error boundary method defined\n        logError(fiber, errorInfo);\n      }\n      const error = errorInfo.value;\n      const stack = errorInfo.stack;\n      this.componentDidCatch(error, {\n        componentStack: stack !== null ? stack : '',\n      });\n      if (__DEV__) {\n        if (typeof getDerivedStateFromError !== 'function') {\n          // If componentDidCatch is the only error boundary method defined,\n          // then it needs to call setState to recover from errors.\n          // If no state update is scheduled then the boundary will swallow the error.\n          warningWithoutStack(\n            fiber.expirationTime === Sync,\n            '%s: Error boundaries should implement getDerivedStateFromError(). ' +\n              'In that method, return a state update to display an error message or fallback UI.',\n            getComponentName(fiber.type) || 'Unknown',\n          );\n        }\n      }\n    };\n  } else if (__DEV__) {\n    update.callback = () => {\n      markFailedErrorBoundaryForHotReloading(fiber);\n    };\n  }\n  return update;\n}\n\nfunction attachPingListener(\n  root: FiberRoot,\n  renderExpirationTime: ExpirationTime,\n  thenable: Thenable,\n) {\n  // Attach a listener to the promise to \"ping\" the root and retry. But\n  // only if one does not already exist for the current render expiration\n  // time (which acts like a \"thread ID\" here).\n  let pingCache = root.pingCache;\n  let threadIDs;\n  if (pingCache === null) {\n    pingCache = root.pingCache = new PossiblyWeakMap();\n    threadIDs = new Set();\n    pingCache.set(thenable, threadIDs);\n  } else {\n    threadIDs = pingCache.get(thenable);\n    if (threadIDs === undefined) {\n      threadIDs = new Set();\n      pingCache.set(thenable, threadIDs);\n    }\n  }\n  if (!threadIDs.has(renderExpirationTime)) {\n    // Memoize using the thread ID to prevent redundant listeners.\n    threadIDs.add(renderExpirationTime);\n    let ping = pingSuspendedRoot.bind(\n      null,\n      root,\n      thenable,\n      renderExpirationTime,\n    );\n    thenable.then(ping, ping);\n  }\n}\n\nfunction throwException(\n  root: FiberRoot,\n  returnFiber: Fiber,\n  sourceFiber: Fiber,\n  value: mixed,\n  renderExpirationTime: ExpirationTime,\n) {\n  // The source fiber did not complete.\n  sourceFiber.effectTag |= Incomplete;\n  // Its effect list is no longer valid.\n  sourceFiber.firstEffect = sourceFiber.lastEffect = null;\n\n  if (\n    value !== null &&\n    typeof value === 'object' &&\n    typeof value.then === 'function'\n  ) {\n    // This is a thenable.\n    const thenable: Thenable = (value: any);\n\n    checkForWrongSuspensePriorityInDEV(sourceFiber);\n\n    let hasInvisibleParentBoundary = hasSuspenseContext(\n      suspenseStackCursor.current,\n      (InvisibleParentSuspenseContext: SuspenseContext),\n    );\n\n    // Schedule the nearest Suspense to re-render the timed out view.\n    let workInProgress = returnFiber;\n    do {\n      if (\n        workInProgress.tag === SuspenseComponent &&\n        shouldCaptureSuspense(workInProgress, hasInvisibleParentBoundary)\n      ) {\n        // Found the nearest boundary.\n\n        // Stash the promise on the boundary fiber. If the boundary times out, we'll\n        // attach another listener to flip the boundary back to its normal state.\n        const thenables: Set<Thenable> = (workInProgress.updateQueue: any);\n        if (thenables === null) {\n          const updateQueue = (new Set(): any);\n          updateQueue.add(thenable);\n          workInProgress.updateQueue = updateQueue;\n        } else {\n          thenables.add(thenable);\n        }\n\n        // If the boundary is outside of blocking mode, we should *not*\n        // suspend the commit. Pretend as if the suspended component rendered\n        // null and keep rendering. In the commit phase, we'll schedule a\n        // subsequent synchronous update to re-render the Suspense.\n        //\n        // Note: It doesn't matter whether the component that suspended was\n        // inside a blocking mode tree. If the Suspense is outside of it, we\n        // should *not* suspend the commit.\n        if ((workInProgress.mode & BlockingMode) === NoMode) {\n          workInProgress.effectTag |= DidCapture;\n\n          // We're going to commit this fiber even though it didn't complete.\n          // But we shouldn't call any lifecycle methods or callbacks. Remove\n          // all lifecycle effect tags.\n          sourceFiber.effectTag &= ~(LifecycleEffectMask | Incomplete);\n\n          if (sourceFiber.tag === ClassComponent) {\n            const currentSourceFiber = sourceFiber.alternate;\n            if (currentSourceFiber === null) {\n              // This is a new mount. Change the tag so it's not mistaken for a\n              // completed class component. For example, we should not call\n              // componentWillUnmount if it is deleted.\n              sourceFiber.tag = IncompleteClassComponent;\n            } else {\n              // When we try rendering again, we should not reuse the current fiber,\n              // since it's known to be in an inconsistent state. Use a force update to\n              // prevent a bail out.\n              const update = createUpdate(Sync, null);\n              update.tag = ForceUpdate;\n              enqueueUpdate(sourceFiber, update);\n            }\n          }\n\n          // The source fiber did not complete. Mark it with Sync priority to\n          // indicate that it still has pending work.\n          sourceFiber.expirationTime = Sync;\n\n          // Exit without suspending.\n          return;\n        }\n\n        // Confirmed that the boundary is in a concurrent mode tree. Continue\n        // with the normal suspend path.\n        //\n        // After this we'll use a set of heuristics to determine whether this\n        // render pass will run to completion or restart or \"suspend\" the commit.\n        // The actual logic for this is spread out in different places.\n        //\n        // This first principle is that if we're going to suspend when we complete\n        // a root, then we should also restart if we get an update or ping that\n        // might unsuspend it, and vice versa. The only reason to suspend is\n        // because you think you might want to restart before committing. However,\n        // it doesn't make sense to restart only while in the period we're suspended.\n        //\n        // Restarting too aggressively is also not good because it starves out any\n        // intermediate loading state. So we use heuristics to determine when.\n\n        // Suspense Heuristics\n        //\n        // If nothing threw a Promise or all the same fallbacks are already showing,\n        // then don't suspend/restart.\n        //\n        // If this is an initial render of a new tree of Suspense boundaries and\n        // those trigger a fallback, then don't suspend/restart. We want to ensure\n        // that we can show the initial loading state as quickly as possible.\n        //\n        // If we hit a \"Delayed\" case, such as when we'd switch from content back into\n        // a fallback, then we should always suspend/restart. SuspenseConfig applies to\n        // this case. If none is defined, JND is used instead.\n        //\n        // If we're already showing a fallback and it gets \"retried\", allowing us to show\n        // another level, but there's still an inner boundary that would show a fallback,\n        // then we suspend/restart for 500ms since the last time we showed a fallback\n        // anywhere in the tree. This effectively throttles progressive loading into a\n        // consistent train of commits. This also gives us an opportunity to restart to\n        // get to the completed state slightly earlier.\n        //\n        // If there's ambiguity due to batching it's resolved in preference of:\n        // 1) \"delayed\", 2) \"initial render\", 3) \"retry\".\n        //\n        // We want to ensure that a \"busy\" state doesn't get force committed. We want to\n        // ensure that new initial loading states can commit as soon as possible.\n\n        attachPingListener(root, renderExpirationTime, thenable);\n\n        workInProgress.effectTag |= ShouldCapture;\n        workInProgress.expirationTime = renderExpirationTime;\n\n        return;\n      }\n      // This boundary already captured during this render. Continue to the next\n      // boundary.\n      workInProgress = workInProgress.return;\n    } while (workInProgress !== null);\n    // No boundary was found. Fallthrough to error mode.\n    // TODO: Use invariant so the message is stripped in prod?\n    value = new Error(\n      (getComponentName(sourceFiber.type) || 'A React component') +\n        ' suspended while rendering, but no fallback UI was specified.\\n' +\n        '\\n' +\n        'Add a <Suspense fallback=...> component higher in the tree to ' +\n        'provide a loading indicator or placeholder to display.' +\n        getStackByFiberInDevAndProd(sourceFiber),\n    );\n  }\n\n  // We didn't find a boundary that could handle this type of exception. Start\n  // over and traverse parent path again, this time treating the exception\n  // as an error.\n  renderDidError();\n  value = createCapturedValue(value, sourceFiber);\n  let workInProgress = returnFiber;\n  do {\n    switch (workInProgress.tag) {\n      case HostRoot: {\n        const errorInfo = value;\n        workInProgress.effectTag |= ShouldCapture;\n        workInProgress.expirationTime = renderExpirationTime;\n        const update = createRootErrorUpdate(\n          workInProgress,\n          errorInfo,\n          renderExpirationTime,\n        );\n        enqueueCapturedUpdate(workInProgress, update);\n        return;\n      }\n      case ClassComponent:\n        // Capture and retry\n        const errorInfo = value;\n        const ctor = workInProgress.type;\n        const instance = workInProgress.stateNode;\n        if (\n          (workInProgress.effectTag & DidCapture) === NoEffect &&\n          (typeof ctor.getDerivedStateFromError === 'function' ||\n            (instance !== null &&\n              typeof instance.componentDidCatch === 'function' &&\n              !isAlreadyFailedLegacyErrorBoundary(instance)))\n        ) {\n          workInProgress.effectTag |= ShouldCapture;\n          workInProgress.expirationTime = renderExpirationTime;\n          // Schedule the error boundary to re-render using updated state\n          const update = createClassErrorUpdate(\n            workInProgress,\n            errorInfo,\n            renderExpirationTime,\n          );\n          enqueueCapturedUpdate(workInProgress, update);\n          return;\n        }\n        break;\n      default:\n        break;\n    }\n    workInProgress = workInProgress.return;\n  } while (workInProgress !== null);\n}\n\nexport {throwException, createRootErrorUpdate, createClassErrorUpdate};\n"]},"metadata":{},"sourceType":"module"}