{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { FundamentalComponent } from 'shared/ReactWorkTags';\nimport { findCurrentHostFiber, findCurrentHostFiberWithNoPortals } from 'react-reconciler/reflection';\nimport { get as getInstance } from 'shared/ReactInstanceMap';\nimport { HostComponent, ClassComponent, HostRoot, SuspenseComponent } from 'shared/ReactWorkTags';\nimport getComponentName from 'shared/getComponentName';\nimport invariant from 'shared/invariant';\nimport warningWithoutStack from 'shared/warningWithoutStack';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport { getPublicInstance } from './ReactFiberHostConfig';\nimport { findCurrentUnmaskedContext, processChildContext, emptyContextObject, isContextProvider as isLegacyContextProvider } from './ReactFiberContext';\nimport { createFiberRoot } from './ReactFiberRoot';\nimport { injectInternals } from './ReactFiberDevToolsHook';\nimport { requestCurrentTimeForUpdate, computeExpirationForFiber, scheduleWork, flushRoot, batchedEventUpdates, batchedUpdates, unbatchedUpdates, flushSync, flushControlled, deferredUpdates, syncUpdates, discreteUpdates, flushDiscreteUpdates, flushPassiveEffects, warnIfNotScopedWithMatchingAct, warnIfUnmockedScheduler, IsThisRendererActing } from './ReactFiberWorkLoop';\nimport { createUpdate, enqueueUpdate } from './ReactUpdateQueue';\nimport ReactFiberInstrumentation from './ReactFiberInstrumentation';\nimport { getStackByFiberInDevAndProd, phase as ReactCurrentFiberPhase, current as ReactCurrentFiberCurrent } from './ReactCurrentFiber';\nimport { StrictMode } from './ReactTypeOfMode';\nimport { Sync, computeInteractiveExpiration, computeContinuousHydrationExpiration } from './ReactFiberExpirationTime';\nimport { requestCurrentSuspenseConfig } from './ReactFiberSuspenseConfig';\nimport { scheduleRefresh, scheduleRoot, setRefreshHandler, findHostInstancesForRefresh } from './ReactFiberHotReloading';\nlet didWarnAboutNestedUpdates;\nlet didWarnAboutFindNodeInStrictMode;\n\nif (__DEV__) {\n  didWarnAboutNestedUpdates = false;\n  didWarnAboutFindNodeInStrictMode = {};\n}\n\nfunction getContextForSubtree(parentComponent) {\n  if (!parentComponent) {\n    return emptyContextObject;\n  }\n\n  const fiber = getInstance(parentComponent);\n  const parentContext = findCurrentUnmaskedContext(fiber);\n\n  if (fiber.tag === ClassComponent) {\n    const Component = fiber.type;\n\n    if (isLegacyContextProvider(Component)) {\n      return processChildContext(fiber, Component, parentContext);\n    }\n  }\n\n  return parentContext;\n}\n\nfunction findHostInstance(component) {\n  const fiber = getInstance(component);\n\n  if (fiber === undefined) {\n    if (typeof component.render === 'function') {\n      invariant(false, 'Unable to find node on an unmounted component.');\n    } else {\n      invariant(false, 'Argument appears to not be a ReactComponent. Keys: %s', Object.keys(component));\n    }\n  }\n\n  const hostFiber = findCurrentHostFiber(fiber);\n\n  if (hostFiber === null) {\n    return null;\n  }\n\n  return hostFiber.stateNode;\n}\n\nfunction findHostInstanceWithWarning(component, methodName) {\n  if (__DEV__) {\n    const fiber = getInstance(component);\n\n    if (fiber === undefined) {\n      if (typeof component.render === 'function') {\n        invariant(false, 'Unable to find node on an unmounted component.');\n      } else {\n        invariant(false, 'Argument appears to not be a ReactComponent. Keys: %s', Object.keys(component));\n      }\n    }\n\n    const hostFiber = findCurrentHostFiber(fiber);\n\n    if (hostFiber === null) {\n      return null;\n    }\n\n    if (hostFiber.mode & StrictMode) {\n      const componentName = getComponentName(fiber.type) || 'Component';\n\n      if (!didWarnAboutFindNodeInStrictMode[componentName]) {\n        didWarnAboutFindNodeInStrictMode[componentName] = true;\n\n        if (fiber.mode & StrictMode) {\n          warningWithoutStack(false, '%s is deprecated in StrictMode. ' + '%s was passed an instance of %s which is inside StrictMode. ' + 'Instead, add a ref directly to the element you want to reference. ' + 'Learn more about using refs safely here: ' + 'https://fb.me/react-strict-mode-find-node%s', methodName, methodName, componentName, getStackByFiberInDevAndProd(hostFiber));\n        } else {\n          warningWithoutStack(false, '%s is deprecated in StrictMode. ' + '%s was passed an instance of %s which renders StrictMode children. ' + 'Instead, add a ref directly to the element you want to reference. ' + 'Learn more about using refs safely here: ' + 'https://fb.me/react-strict-mode-find-node%s', methodName, methodName, componentName, getStackByFiberInDevAndProd(hostFiber));\n        }\n      }\n    }\n\n    return hostFiber.stateNode;\n  }\n\n  return findHostInstance(component);\n}\n\nexport function createContainer(containerInfo, tag, hydrate, hydrationCallbacks) {\n  return createFiberRoot(containerInfo, tag, hydrate, hydrationCallbacks);\n}\nexport function updateContainer(element, container, parentComponent, callback) {\n  const current = container.current;\n  const currentTime = requestCurrentTimeForUpdate();\n\n  if (__DEV__) {\n    // $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests\n    if ('undefined' !== typeof jest) {\n      warnIfUnmockedScheduler(current);\n      warnIfNotScopedWithMatchingAct(current);\n    }\n  }\n\n  const suspenseConfig = requestCurrentSuspenseConfig();\n  const expirationTime = computeExpirationForFiber(currentTime, current, suspenseConfig);\n\n  if (__DEV__) {\n    if (ReactFiberInstrumentation.debugTool) {\n      if (current.alternate === null) {\n        ReactFiberInstrumentation.debugTool.onMountContainer(container);\n      } else if (element === null) {\n        ReactFiberInstrumentation.debugTool.onUnmountContainer(container);\n      } else {\n        ReactFiberInstrumentation.debugTool.onUpdateContainer(container);\n      }\n    }\n  }\n\n  const context = getContextForSubtree(parentComponent);\n\n  if (container.context === null) {\n    container.context = context;\n  } else {\n    container.pendingContext = context;\n  }\n\n  if (__DEV__) {\n    if (ReactCurrentFiberPhase === 'render' && ReactCurrentFiberCurrent !== null && !didWarnAboutNestedUpdates) {\n      didWarnAboutNestedUpdates = true;\n      warningWithoutStack(false, 'Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\\n\\n' + 'Check the render method of %s.', getComponentName(ReactCurrentFiberCurrent.type) || 'Unknown');\n    }\n  }\n\n  const update = createUpdate(expirationTime, suspenseConfig); // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n\n  update.payload = {\n    element\n  };\n  callback = callback === undefined ? null : callback;\n\n  if (callback !== null) {\n    warningWithoutStack(typeof callback === 'function', 'render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);\n    update.callback = callback;\n  }\n\n  enqueueUpdate(current, update);\n  scheduleWork(current, expirationTime);\n  return expirationTime;\n}\nexport { batchedEventUpdates, batchedUpdates, unbatchedUpdates, deferredUpdates, syncUpdates, discreteUpdates, flushDiscreteUpdates, flushControlled, flushSync, flushPassiveEffects, IsThisRendererActing };\nexport function getPublicRootInstance(container) {\n  const containerFiber = container.current;\n\n  if (!containerFiber.child) {\n    return null;\n  }\n\n  switch (containerFiber.child.tag) {\n    case HostComponent:\n      return getPublicInstance(containerFiber.child.stateNode);\n\n    default:\n      return containerFiber.child.stateNode;\n  }\n}\nexport function attemptSynchronousHydration(fiber) {\n  switch (fiber.tag) {\n    case HostRoot:\n      let root = fiber.stateNode;\n\n      if (root.hydrate) {\n        // Flush the first scheduled \"update\".\n        flushRoot(root, root.firstPendingTime);\n      }\n\n      break;\n\n    case SuspenseComponent:\n      flushSync(() => scheduleWork(fiber, Sync)); // If we're still blocked after this, we need to increase\n      // the priority of any promises resolving within this\n      // boundary so that they next attempt also has higher pri.\n\n      let retryExpTime = computeInteractiveExpiration(requestCurrentTimeForUpdate());\n      markRetryTimeIfNotHydrated(fiber, retryExpTime);\n      break;\n  }\n}\n\nfunction markRetryTimeImpl(fiber, retryTime) {\n  let suspenseState = fiber.memoizedState;\n\n  if (suspenseState !== null && suspenseState.dehydrated !== null) {\n    if (suspenseState.retryTime < retryTime) {\n      suspenseState.retryTime = retryTime;\n    }\n  }\n} // Increases the priority of thennables when they resolve within this boundary.\n\n\nfunction markRetryTimeIfNotHydrated(fiber, retryTime) {\n  markRetryTimeImpl(fiber, retryTime);\n  let alternate = fiber.alternate;\n\n  if (alternate) {\n    markRetryTimeImpl(alternate, retryTime);\n  }\n}\n\nexport function attemptUserBlockingHydration(fiber) {\n  if (fiber.tag !== SuspenseComponent) {\n    // We ignore HostRoots here because we can't increase\n    // their priority and they should not suspend on I/O,\n    // since you have to wrap anything that might suspend in\n    // Suspense.\n    return;\n  }\n\n  let expTime = computeInteractiveExpiration(requestCurrentTimeForUpdate());\n  scheduleWork(fiber, expTime);\n  markRetryTimeIfNotHydrated(fiber, expTime);\n}\nexport function attemptContinuousHydration(fiber) {\n  if (fiber.tag !== SuspenseComponent) {\n    // We ignore HostRoots here because we can't increase\n    // their priority and they should not suspend on I/O,\n    // since you have to wrap anything that might suspend in\n    // Suspense.\n    return;\n  }\n\n  let expTime = computeContinuousHydrationExpiration(requestCurrentTimeForUpdate());\n  scheduleWork(fiber, expTime);\n  markRetryTimeIfNotHydrated(fiber, expTime);\n}\nexport function attemptHydrationAtCurrentPriority(fiber) {\n  if (fiber.tag !== SuspenseComponent) {\n    // We ignore HostRoots here because we can't increase\n    // their priority other than synchronously flush it.\n    return;\n  }\n\n  const currentTime = requestCurrentTimeForUpdate();\n  const expTime = computeExpirationForFiber(currentTime, fiber, null);\n  scheduleWork(fiber, expTime);\n  markRetryTimeIfNotHydrated(fiber, expTime);\n}\nexport { findHostInstance };\nexport { findHostInstanceWithWarning };\nexport function findHostInstanceWithNoPortals(fiber) {\n  const hostFiber = findCurrentHostFiberWithNoPortals(fiber);\n\n  if (hostFiber === null) {\n    return null;\n  }\n\n  if (hostFiber.tag === FundamentalComponent) {\n    return hostFiber.stateNode.instance;\n  }\n\n  return hostFiber.stateNode;\n}\n\nlet shouldSuspendImpl = fiber => false;\n\nexport function shouldSuspend(fiber) {\n  return shouldSuspendImpl(fiber);\n}\nlet overrideHookState = null;\nlet overrideProps = null;\nlet scheduleUpdate = null;\nlet setSuspenseHandler = null;\n\nif (__DEV__) {\n  const copyWithSetImpl = (obj, path, idx, value) => {\n    if (idx >= path.length) {\n      return value;\n    }\n\n    const key = path[idx];\n    const updated = Array.isArray(obj) ? obj.slice() : { ...obj\n    }; // $FlowFixMe number or string is fine here\n\n    updated[key] = copyWithSetImpl(obj[key], path, idx + 1, value);\n    return updated;\n  };\n\n  const copyWithSet = (obj, path, value) => {\n    return copyWithSetImpl(obj, path, 0, value);\n  }; // Support DevTools editable values for useState and useReducer.\n\n\n  overrideHookState = (fiber, id, path, value) => {\n    // For now, the \"id\" of stateful hooks is just the stateful hook index.\n    // This may change in the future with e.g. nested hooks.\n    let currentHook = fiber.memoizedState;\n\n    while (currentHook !== null && id > 0) {\n      currentHook = currentHook.next;\n      id--;\n    }\n\n    if (currentHook !== null) {\n      const newState = copyWithSet(currentHook.memoizedState, path, value);\n      currentHook.memoizedState = newState;\n      currentHook.baseState = newState; // We aren't actually adding an update to the queue,\n      // because there is no update we can add for useReducer hooks that won't trigger an error.\n      // (There's no appropriate action type for DevTools overrides.)\n      // As a result though, React will see the scheduled update as a noop and bailout.\n      // Shallow cloning props works as a workaround for now to bypass the bailout check.\n\n      fiber.memoizedProps = { ...fiber.memoizedProps\n      };\n      scheduleWork(fiber, Sync);\n    }\n  }; // Support DevTools props for function components, forwardRef, memo, host components, etc.\n\n\n  overrideProps = (fiber, path, value) => {\n    fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);\n\n    if (fiber.alternate) {\n      fiber.alternate.pendingProps = fiber.pendingProps;\n    }\n\n    scheduleWork(fiber, Sync);\n  };\n\n  scheduleUpdate = fiber => {\n    scheduleWork(fiber, Sync);\n  };\n\n  setSuspenseHandler = newShouldSuspendImpl => {\n    shouldSuspendImpl = newShouldSuspendImpl;\n  };\n}\n\nexport function injectIntoDevTools(devToolsConfig) {\n  const {\n    findFiberByHostInstance\n  } = devToolsConfig;\n  const {\n    ReactCurrentDispatcher\n  } = ReactSharedInternals;\n  return injectInternals({ ...devToolsConfig,\n    overrideHookState,\n    overrideProps,\n    setSuspenseHandler,\n    scheduleUpdate,\n    currentDispatcherRef: ReactCurrentDispatcher,\n\n    findHostInstanceByFiber(fiber) {\n      const hostFiber = findCurrentHostFiber(fiber);\n\n      if (hostFiber === null) {\n        return null;\n      }\n\n      return hostFiber.stateNode;\n    },\n\n    findFiberByHostInstance(instance) {\n      if (!findFiberByHostInstance) {\n        // Might not be implemented by the renderer.\n        return null;\n      }\n\n      return findFiberByHostInstance(instance);\n    },\n\n    // React Refresh\n    findHostInstancesForRefresh: __DEV__ ? findHostInstancesForRefresh : null,\n    scheduleRefresh: __DEV__ ? scheduleRefresh : null,\n    scheduleRoot: __DEV__ ? scheduleRoot : null,\n    setRefreshHandler: __DEV__ ? setRefreshHandler : null,\n    // Enables DevTools to append owner stacks to error messages in DEV mode.\n    getCurrentFiber: __DEV__ ? () => ReactCurrentFiberCurrent : null\n  });\n}","map":{"version":3,"sources":["/Users/gaoshaoyun/Documents/library/debug-react/src/react/packages/react-reconciler/src/ReactFiberReconciler.js"],"names":["FundamentalComponent","findCurrentHostFiber","findCurrentHostFiberWithNoPortals","get","getInstance","HostComponent","ClassComponent","HostRoot","SuspenseComponent","getComponentName","invariant","warningWithoutStack","ReactSharedInternals","getPublicInstance","findCurrentUnmaskedContext","processChildContext","emptyContextObject","isContextProvider","isLegacyContextProvider","createFiberRoot","injectInternals","requestCurrentTimeForUpdate","computeExpirationForFiber","scheduleWork","flushRoot","batchedEventUpdates","batchedUpdates","unbatchedUpdates","flushSync","flushControlled","deferredUpdates","syncUpdates","discreteUpdates","flushDiscreteUpdates","flushPassiveEffects","warnIfNotScopedWithMatchingAct","warnIfUnmockedScheduler","IsThisRendererActing","createUpdate","enqueueUpdate","ReactFiberInstrumentation","getStackByFiberInDevAndProd","phase","ReactCurrentFiberPhase","current","ReactCurrentFiberCurrent","StrictMode","Sync","computeInteractiveExpiration","computeContinuousHydrationExpiration","requestCurrentSuspenseConfig","scheduleRefresh","scheduleRoot","setRefreshHandler","findHostInstancesForRefresh","didWarnAboutNestedUpdates","didWarnAboutFindNodeInStrictMode","__DEV__","getContextForSubtree","parentComponent","fiber","parentContext","tag","Component","type","findHostInstance","component","undefined","render","Object","keys","hostFiber","stateNode","findHostInstanceWithWarning","methodName","mode","componentName","createContainer","containerInfo","hydrate","hydrationCallbacks","updateContainer","element","container","callback","currentTime","jest","suspenseConfig","expirationTime","debugTool","alternate","onMountContainer","onUnmountContainer","onUpdateContainer","context","pendingContext","update","payload","getPublicRootInstance","containerFiber","child","attemptSynchronousHydration","root","firstPendingTime","retryExpTime","markRetryTimeIfNotHydrated","markRetryTimeImpl","retryTime","suspenseState","memoizedState","dehydrated","attemptUserBlockingHydration","expTime","attemptContinuousHydration","attemptHydrationAtCurrentPriority","findHostInstanceWithNoPortals","instance","shouldSuspendImpl","shouldSuspend","overrideHookState","overrideProps","scheduleUpdate","setSuspenseHandler","copyWithSetImpl","obj","path","idx","value","length","key","updated","Array","isArray","slice","copyWithSet","id","currentHook","next","newState","baseState","memoizedProps","pendingProps","newShouldSuspendImpl","injectIntoDevTools","devToolsConfig","findFiberByHostInstance","ReactCurrentDispatcher","currentDispatcherRef","findHostInstanceByFiber","getCurrentFiber"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber} from './ReactFiber';\nimport type {FiberRoot} from './ReactFiberRoot';\nimport type {RootTag} from 'shared/ReactRootTags';\nimport type {\n  Instance,\n  TextInstance,\n  Container,\n  PublicInstance,\n} from './ReactFiberHostConfig';\nimport {FundamentalComponent} from 'shared/ReactWorkTags';\nimport type {ReactNodeList} from 'shared/ReactTypes';\nimport type {ExpirationTime} from './ReactFiberExpirationTime';\nimport type {\n  SuspenseHydrationCallbacks,\n  SuspenseState,\n} from './ReactFiberSuspenseComponent';\n\nimport {\n  findCurrentHostFiber,\n  findCurrentHostFiberWithNoPortals,\n} from 'react-reconciler/reflection';\nimport {get as getInstance} from 'shared/ReactInstanceMap';\nimport {\n  HostComponent,\n  ClassComponent,\n  HostRoot,\n  SuspenseComponent,\n} from 'shared/ReactWorkTags';\nimport getComponentName from 'shared/getComponentName';\nimport invariant from 'shared/invariant';\nimport warningWithoutStack from 'shared/warningWithoutStack';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\n\nimport {getPublicInstance} from './ReactFiberHostConfig';\nimport {\n  findCurrentUnmaskedContext,\n  processChildContext,\n  emptyContextObject,\n  isContextProvider as isLegacyContextProvider,\n} from './ReactFiberContext';\nimport {createFiberRoot} from './ReactFiberRoot';\nimport {injectInternals} from './ReactFiberDevToolsHook';\nimport {\n  requestCurrentTimeForUpdate,\n  computeExpirationForFiber,\n  scheduleWork,\n  flushRoot,\n  batchedEventUpdates,\n  batchedUpdates,\n  unbatchedUpdates,\n  flushSync,\n  flushControlled,\n  deferredUpdates,\n  syncUpdates,\n  discreteUpdates,\n  flushDiscreteUpdates,\n  flushPassiveEffects,\n  warnIfNotScopedWithMatchingAct,\n  warnIfUnmockedScheduler,\n  IsThisRendererActing,\n} from './ReactFiberWorkLoop';\nimport {createUpdate, enqueueUpdate} from './ReactUpdateQueue';\nimport ReactFiberInstrumentation from './ReactFiberInstrumentation';\nimport {\n  getStackByFiberInDevAndProd,\n  phase as ReactCurrentFiberPhase,\n  current as ReactCurrentFiberCurrent,\n} from './ReactCurrentFiber';\nimport {StrictMode} from './ReactTypeOfMode';\nimport {\n  Sync,\n  computeInteractiveExpiration,\n  computeContinuousHydrationExpiration,\n} from './ReactFiberExpirationTime';\nimport {requestCurrentSuspenseConfig} from './ReactFiberSuspenseConfig';\nimport {\n  scheduleRefresh,\n  scheduleRoot,\n  setRefreshHandler,\n  findHostInstancesForRefresh,\n} from './ReactFiberHotReloading';\n\ntype OpaqueRoot = FiberRoot;\n\n// 0 is PROD, 1 is DEV.\n// Might add PROFILE later.\ntype BundleType = 0 | 1;\n\ntype DevToolsConfig = {|\n  bundleType: BundleType,\n  version: string,\n  rendererPackageName: string,\n  // Note: this actually *does* depend on Fiber internal fields.\n  // Used by \"inspect clicked DOM element\" in React DevTools.\n  findFiberByHostInstance?: (instance: Instance | TextInstance) => Fiber,\n  // Used by RN in-app inspector.\n  // This API is unfortunately RN-specific.\n  // TODO: Change it to accept Fiber instead and type it properly.\n  getInspectorDataForViewTag?: (tag: number) => Object,\n|};\n\nlet didWarnAboutNestedUpdates;\nlet didWarnAboutFindNodeInStrictMode;\n\nif (__DEV__) {\n  didWarnAboutNestedUpdates = false;\n  didWarnAboutFindNodeInStrictMode = {};\n}\n\nfunction getContextForSubtree(\n  parentComponent: ?React$Component<any, any>,\n): Object {\n  if (!parentComponent) {\n    return emptyContextObject;\n  }\n\n  const fiber = getInstance(parentComponent);\n  const parentContext = findCurrentUnmaskedContext(fiber);\n\n  if (fiber.tag === ClassComponent) {\n    const Component = fiber.type;\n    if (isLegacyContextProvider(Component)) {\n      return processChildContext(fiber, Component, parentContext);\n    }\n  }\n\n  return parentContext;\n}\n\nfunction findHostInstance(component: Object): PublicInstance | null {\n  const fiber = getInstance(component);\n  if (fiber === undefined) {\n    if (typeof component.render === 'function') {\n      invariant(false, 'Unable to find node on an unmounted component.');\n    } else {\n      invariant(\n        false,\n        'Argument appears to not be a ReactComponent. Keys: %s',\n        Object.keys(component),\n      );\n    }\n  }\n  const hostFiber = findCurrentHostFiber(fiber);\n  if (hostFiber === null) {\n    return null;\n  }\n  return hostFiber.stateNode;\n}\n\nfunction findHostInstanceWithWarning(\n  component: Object,\n  methodName: string,\n): PublicInstance | null {\n  if (__DEV__) {\n    const fiber = getInstance(component);\n    if (fiber === undefined) {\n      if (typeof component.render === 'function') {\n        invariant(false, 'Unable to find node on an unmounted component.');\n      } else {\n        invariant(\n          false,\n          'Argument appears to not be a ReactComponent. Keys: %s',\n          Object.keys(component),\n        );\n      }\n    }\n    const hostFiber = findCurrentHostFiber(fiber);\n    if (hostFiber === null) {\n      return null;\n    }\n    if (hostFiber.mode & StrictMode) {\n      const componentName = getComponentName(fiber.type) || 'Component';\n      if (!didWarnAboutFindNodeInStrictMode[componentName]) {\n        didWarnAboutFindNodeInStrictMode[componentName] = true;\n        if (fiber.mode & StrictMode) {\n          warningWithoutStack(\n            false,\n            '%s is deprecated in StrictMode. ' +\n              '%s was passed an instance of %s which is inside StrictMode. ' +\n              'Instead, add a ref directly to the element you want to reference. ' +\n              'Learn more about using refs safely here: ' +\n              'https://fb.me/react-strict-mode-find-node%s',\n            methodName,\n            methodName,\n            componentName,\n            getStackByFiberInDevAndProd(hostFiber),\n          );\n        } else {\n          warningWithoutStack(\n            false,\n            '%s is deprecated in StrictMode. ' +\n              '%s was passed an instance of %s which renders StrictMode children. ' +\n              'Instead, add a ref directly to the element you want to reference. ' +\n              'Learn more about using refs safely here: ' +\n              'https://fb.me/react-strict-mode-find-node%s',\n            methodName,\n            methodName,\n            componentName,\n            getStackByFiberInDevAndProd(hostFiber),\n          );\n        }\n      }\n    }\n    return hostFiber.stateNode;\n  }\n  return findHostInstance(component);\n}\n\nexport function createContainer(\n  containerInfo: Container,\n  tag: RootTag,\n  hydrate: boolean,\n  hydrationCallbacks: null | SuspenseHydrationCallbacks,\n): OpaqueRoot {\n  return createFiberRoot(containerInfo, tag, hydrate, hydrationCallbacks);\n}\n\nexport function updateContainer(\n  element: ReactNodeList,\n  container: OpaqueRoot,\n  parentComponent: ?React$Component<any, any>,\n  callback: ?Function,\n): ExpirationTime {\n  const current = container.current;\n  const currentTime = requestCurrentTimeForUpdate();\n  if (__DEV__) {\n    // $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests\n    if ('undefined' !== typeof jest) {\n      warnIfUnmockedScheduler(current);\n      warnIfNotScopedWithMatchingAct(current);\n    }\n  }\n  const suspenseConfig = requestCurrentSuspenseConfig();\n  const expirationTime = computeExpirationForFiber(\n    currentTime,\n    current,\n    suspenseConfig,\n  );\n\n  if (__DEV__) {\n    if (ReactFiberInstrumentation.debugTool) {\n      if (current.alternate === null) {\n        ReactFiberInstrumentation.debugTool.onMountContainer(container);\n      } else if (element === null) {\n        ReactFiberInstrumentation.debugTool.onUnmountContainer(container);\n      } else {\n        ReactFiberInstrumentation.debugTool.onUpdateContainer(container);\n      }\n    }\n  }\n\n  const context = getContextForSubtree(parentComponent);\n  if (container.context === null) {\n    container.context = context;\n  } else {\n    container.pendingContext = context;\n  }\n\n  if (__DEV__) {\n    if (\n      ReactCurrentFiberPhase === 'render' &&\n      ReactCurrentFiberCurrent !== null &&\n      !didWarnAboutNestedUpdates\n    ) {\n      didWarnAboutNestedUpdates = true;\n      warningWithoutStack(\n        false,\n        'Render methods should be a pure function of props and state; ' +\n          'triggering nested component updates from render is not allowed. ' +\n          'If necessary, trigger nested updates in componentDidUpdate.\\n\\n' +\n          'Check the render method of %s.',\n        getComponentName(ReactCurrentFiberCurrent.type) || 'Unknown',\n      );\n    }\n  }\n\n  const update = createUpdate(expirationTime, suspenseConfig);\n  // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n  update.payload = {element};\n\n  callback = callback === undefined ? null : callback;\n  if (callback !== null) {\n    warningWithoutStack(\n      typeof callback === 'function',\n      'render(...): Expected the last optional `callback` argument to be a ' +\n        'function. Instead received: %s.',\n      callback,\n    );\n    update.callback = callback;\n  }\n\n  enqueueUpdate(current, update);\n  scheduleWork(current, expirationTime);\n\n  return expirationTime;\n}\n\nexport {\n  batchedEventUpdates,\n  batchedUpdates,\n  unbatchedUpdates,\n  deferredUpdates,\n  syncUpdates,\n  discreteUpdates,\n  flushDiscreteUpdates,\n  flushControlled,\n  flushSync,\n  flushPassiveEffects,\n  IsThisRendererActing,\n};\n\nexport function getPublicRootInstance(\n  container: OpaqueRoot,\n): React$Component<any, any> | PublicInstance | null {\n  const containerFiber = container.current;\n  if (!containerFiber.child) {\n    return null;\n  }\n  switch (containerFiber.child.tag) {\n    case HostComponent:\n      return getPublicInstance(containerFiber.child.stateNode);\n    default:\n      return containerFiber.child.stateNode;\n  }\n}\n\nexport function attemptSynchronousHydration(fiber: Fiber): void {\n  switch (fiber.tag) {\n    case HostRoot:\n      let root: FiberRoot = fiber.stateNode;\n      if (root.hydrate) {\n        // Flush the first scheduled \"update\".\n        flushRoot(root, root.firstPendingTime);\n      }\n      break;\n    case SuspenseComponent:\n      flushSync(() => scheduleWork(fiber, Sync));\n      // If we're still blocked after this, we need to increase\n      // the priority of any promises resolving within this\n      // boundary so that they next attempt also has higher pri.\n      let retryExpTime = computeInteractiveExpiration(\n        requestCurrentTimeForUpdate(),\n      );\n      markRetryTimeIfNotHydrated(fiber, retryExpTime);\n      break;\n  }\n}\n\nfunction markRetryTimeImpl(fiber: Fiber, retryTime: ExpirationTime) {\n  let suspenseState: null | SuspenseState = fiber.memoizedState;\n  if (suspenseState !== null && suspenseState.dehydrated !== null) {\n    if (suspenseState.retryTime < retryTime) {\n      suspenseState.retryTime = retryTime;\n    }\n  }\n}\n\n// Increases the priority of thennables when they resolve within this boundary.\nfunction markRetryTimeIfNotHydrated(fiber: Fiber, retryTime: ExpirationTime) {\n  markRetryTimeImpl(fiber, retryTime);\n  let alternate = fiber.alternate;\n  if (alternate) {\n    markRetryTimeImpl(alternate, retryTime);\n  }\n}\n\nexport function attemptUserBlockingHydration(fiber: Fiber): void {\n  if (fiber.tag !== SuspenseComponent) {\n    // We ignore HostRoots here because we can't increase\n    // their priority and they should not suspend on I/O,\n    // since you have to wrap anything that might suspend in\n    // Suspense.\n    return;\n  }\n  let expTime = computeInteractiveExpiration(requestCurrentTimeForUpdate());\n  scheduleWork(fiber, expTime);\n  markRetryTimeIfNotHydrated(fiber, expTime);\n}\n\nexport function attemptContinuousHydration(fiber: Fiber): void {\n  if (fiber.tag !== SuspenseComponent) {\n    // We ignore HostRoots here because we can't increase\n    // their priority and they should not suspend on I/O,\n    // since you have to wrap anything that might suspend in\n    // Suspense.\n    return;\n  }\n  let expTime = computeContinuousHydrationExpiration(\n    requestCurrentTimeForUpdate(),\n  );\n  scheduleWork(fiber, expTime);\n  markRetryTimeIfNotHydrated(fiber, expTime);\n}\n\nexport function attemptHydrationAtCurrentPriority(fiber: Fiber): void {\n  if (fiber.tag !== SuspenseComponent) {\n    // We ignore HostRoots here because we can't increase\n    // their priority other than synchronously flush it.\n    return;\n  }\n  const currentTime = requestCurrentTimeForUpdate();\n  const expTime = computeExpirationForFiber(currentTime, fiber, null);\n  scheduleWork(fiber, expTime);\n  markRetryTimeIfNotHydrated(fiber, expTime);\n}\n\nexport {findHostInstance};\n\nexport {findHostInstanceWithWarning};\n\nexport function findHostInstanceWithNoPortals(\n  fiber: Fiber,\n): PublicInstance | null {\n  const hostFiber = findCurrentHostFiberWithNoPortals(fiber);\n  if (hostFiber === null) {\n    return null;\n  }\n  if (hostFiber.tag === FundamentalComponent) {\n    return hostFiber.stateNode.instance;\n  }\n  return hostFiber.stateNode;\n}\n\nlet shouldSuspendImpl = fiber => false;\n\nexport function shouldSuspend(fiber: Fiber): boolean {\n  return shouldSuspendImpl(fiber);\n}\n\nlet overrideHookState = null;\nlet overrideProps = null;\nlet scheduleUpdate = null;\nlet setSuspenseHandler = null;\n\nif (__DEV__) {\n  const copyWithSetImpl = (\n    obj: Object | Array<any>,\n    path: Array<string | number>,\n    idx: number,\n    value: any,\n  ) => {\n    if (idx >= path.length) {\n      return value;\n    }\n    const key = path[idx];\n    const updated = Array.isArray(obj) ? obj.slice() : {...obj};\n    // $FlowFixMe number or string is fine here\n    updated[key] = copyWithSetImpl(obj[key], path, idx + 1, value);\n    return updated;\n  };\n\n  const copyWithSet = (\n    obj: Object | Array<any>,\n    path: Array<string | number>,\n    value: any,\n  ): Object | Array<any> => {\n    return copyWithSetImpl(obj, path, 0, value);\n  };\n\n  // Support DevTools editable values for useState and useReducer.\n  overrideHookState = (\n    fiber: Fiber,\n    id: number,\n    path: Array<string | number>,\n    value: any,\n  ) => {\n    // For now, the \"id\" of stateful hooks is just the stateful hook index.\n    // This may change in the future with e.g. nested hooks.\n    let currentHook = fiber.memoizedState;\n    while (currentHook !== null && id > 0) {\n      currentHook = currentHook.next;\n      id--;\n    }\n    if (currentHook !== null) {\n      const newState = copyWithSet(currentHook.memoizedState, path, value);\n      currentHook.memoizedState = newState;\n      currentHook.baseState = newState;\n\n      // We aren't actually adding an update to the queue,\n      // because there is no update we can add for useReducer hooks that won't trigger an error.\n      // (There's no appropriate action type for DevTools overrides.)\n      // As a result though, React will see the scheduled update as a noop and bailout.\n      // Shallow cloning props works as a workaround for now to bypass the bailout check.\n      fiber.memoizedProps = {...fiber.memoizedProps};\n\n      scheduleWork(fiber, Sync);\n    }\n  };\n\n  // Support DevTools props for function components, forwardRef, memo, host components, etc.\n  overrideProps = (fiber: Fiber, path: Array<string | number>, value: any) => {\n    fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);\n    if (fiber.alternate) {\n      fiber.alternate.pendingProps = fiber.pendingProps;\n    }\n    scheduleWork(fiber, Sync);\n  };\n\n  scheduleUpdate = (fiber: Fiber) => {\n    scheduleWork(fiber, Sync);\n  };\n\n  setSuspenseHandler = (newShouldSuspendImpl: Fiber => boolean) => {\n    shouldSuspendImpl = newShouldSuspendImpl;\n  };\n}\n\nexport function injectIntoDevTools(devToolsConfig: DevToolsConfig): boolean {\n  const {findFiberByHostInstance} = devToolsConfig;\n  const {ReactCurrentDispatcher} = ReactSharedInternals;\n\n  return injectInternals({\n    ...devToolsConfig,\n    overrideHookState,\n    overrideProps,\n    setSuspenseHandler,\n    scheduleUpdate,\n    currentDispatcherRef: ReactCurrentDispatcher,\n    findHostInstanceByFiber(fiber: Fiber): Instance | TextInstance | null {\n      const hostFiber = findCurrentHostFiber(fiber);\n      if (hostFiber === null) {\n        return null;\n      }\n      return hostFiber.stateNode;\n    },\n    findFiberByHostInstance(instance: Instance | TextInstance): Fiber | null {\n      if (!findFiberByHostInstance) {\n        // Might not be implemented by the renderer.\n        return null;\n      }\n      return findFiberByHostInstance(instance);\n    },\n    // React Refresh\n    findHostInstancesForRefresh: __DEV__ ? findHostInstancesForRefresh : null,\n    scheduleRefresh: __DEV__ ? scheduleRefresh : null,\n    scheduleRoot: __DEV__ ? scheduleRoot : null,\n    setRefreshHandler: __DEV__ ? setRefreshHandler : null,\n    // Enables DevTools to append owner stacks to error messages in DEV mode.\n    getCurrentFiber: __DEV__ ? () => ReactCurrentFiberCurrent : null,\n  });\n}\n"]},"metadata":{},"sourceType":"module"}