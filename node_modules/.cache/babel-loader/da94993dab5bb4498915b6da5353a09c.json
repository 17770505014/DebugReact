{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// UpdateQueue is a linked list of prioritized updates.\n//\n// Like fibers, update queues come in pairs: a current queue, which represents\n// the visible state of the screen, and a work-in-progress queue, which can be\n// mutated and processed asynchronously before it is committed — a form of\n// double buffering. If a work-in-progress render is discarded before finishing,\n// we create a new work-in-progress by cloning the current queue.\n//\n// Both queues share a persistent, singly-linked list structure. To schedule an\n// update, we append it to the end of both queues. Each queue maintains a\n// pointer to first update in the persistent list that hasn't been processed.\n// The work-in-progress pointer always has a position equal to or greater than\n// the current queue, since we always work on that one. The current queue's\n// pointer is only updated during the commit phase, when we swap in the\n// work-in-progress.\n//\n// For example:\n//\n//   Current pointer:           A - B - C - D - E - F\n//   Work-in-progress pointer:              D - E - F\n//                                          ^\n//                                          The work-in-progress queue has\n//                                          processed more updates than current.\n//\n// The reason we append to both queues is because otherwise we might drop\n// updates without ever processing them. For example, if we only add updates to\n// the work-in-progress queue, some updates could be lost whenever a work-in\n// -progress render restarts by cloning from current. Similarly, if we only add\n// updates to the current queue, the updates will be lost whenever an already\n// in-progress queue commits and swaps with the current queue. However, by\n// adding to both queues, we guarantee that the update will be part of the next\n// work-in-progress. (And because the work-in-progress queue becomes the\n// current queue once it commits, there's no danger of applying the same\n// update twice.)\n//\n// Prioritization\n// --------------\n//\n// Updates are not sorted by priority, but by insertion; new updates are always\n// appended to the end of the list.\n//\n// The priority is still important, though. When processing the update queue\n// during the render phase, only the updates with sufficient priority are\n// included in the result. If we skip an update because it has insufficient\n// priority, it remains in the queue to be processed later, during a lower\n// priority render. Crucially, all updates subsequent to a skipped update also\n// remain in the queue *regardless of their priority*. That means high priority\n// updates are sometimes processed twice, at two separate priorities. We also\n// keep track of a base state, that represents the state before the first\n// update in the queue is applied.\n//\n// For example:\n//\n//   Given a base state of '', and the following queue of updates\n//\n//     A1 - B2 - C1 - D2\n//\n//   where the number indicates the priority, and the update is applied to the\n//   previous state by appending a letter, React will process these updates as\n//   two separate renders, one per distinct priority level:\n//\n//   First render, at priority 1:\n//     Base state: ''\n//     Updates: [A1, C1]\n//     Result state: 'AC'\n//\n//   Second render, at priority 2:\n//     Base state: 'A'            <-  The base state does not include C1,\n//                                    because B2 was skipped.\n//     Updates: [B2, C1, D2]      <-  C1 was rebased on top of B2\n//     Result state: 'ABCD'\n//\n// Because we process updates in insertion order, and rebase high priority\n// updates when preceding updates are skipped, the final result is deterministic\n// regardless of priority. Intermediate state may vary according to system\n// resources, but the final state is always the same.\nimport { NoWork } from './ReactFiberExpirationTime';\nimport { enterDisallowedContextReadInDEV, exitDisallowedContextReadInDEV } from './ReactFiberNewContext';\nimport { Callback, ShouldCapture, DidCapture } from 'shared/ReactSideEffectTags';\nimport { ClassComponent } from 'shared/ReactWorkTags';\nimport { debugRenderPhaseSideEffects, debugRenderPhaseSideEffectsForStrictMode } from 'shared/ReactFeatureFlags';\nimport { StrictMode } from './ReactTypeOfMode';\nimport { markRenderEventTimeAndConfig, markUnprocessedUpdateTime } from './ReactFiberWorkLoop';\nimport invariant from 'shared/invariant';\nimport warningWithoutStack from 'shared/warningWithoutStack';\nimport { getCurrentPriorityLevel } from './SchedulerWithReactIntegration';\nexport const UpdateState = 0;\nexport const ReplaceState = 1;\nexport const ForceUpdate = 2;\nexport const CaptureUpdate = 3; // Global state that is reset at the beginning of calling `processUpdateQueue`.\n// It should only be read right after calling `processUpdateQueue`, via\n// `checkHasForceUpdateAfterProcessing`.\n\nlet hasForceUpdate = false;\nlet didWarnUpdateInsideUpdate;\nlet currentlyProcessingQueue;\nexport let resetCurrentlyProcessingQueue;\n\nif (__DEV__) {\n  didWarnUpdateInsideUpdate = false;\n  currentlyProcessingQueue = null;\n\n  resetCurrentlyProcessingQueue = () => {\n    currentlyProcessingQueue = null;\n  };\n}\n\nexport function createUpdateQueue(baseState) {\n  const queue = {\n    baseState,\n    firstUpdate: null,\n    lastUpdate: null,\n    firstCapturedUpdate: null,\n    lastCapturedUpdate: null,\n    firstEffect: null,\n    lastEffect: null,\n    firstCapturedEffect: null,\n    lastCapturedEffect: null\n  };\n  return queue;\n}\n\nfunction cloneUpdateQueue(currentQueue) {\n  const queue = {\n    baseState: currentQueue.baseState,\n    firstUpdate: currentQueue.firstUpdate,\n    lastUpdate: currentQueue.lastUpdate,\n    // TODO: With resuming, if we bail out and resuse the child tree, we should\n    // keep these effects.\n    firstCapturedUpdate: null,\n    lastCapturedUpdate: null,\n    firstEffect: null,\n    lastEffect: null,\n    firstCapturedEffect: null,\n    lastCapturedEffect: null\n  };\n  return queue;\n}\n\nexport function createUpdate(expirationTime, suspenseConfig) {\n  let update = {\n    expirationTime,\n    suspenseConfig,\n    tag: UpdateState,\n    payload: null,\n    callback: null,\n    next: null,\n    nextEffect: null\n  };\n\n  if (__DEV__) {\n    update.priority = getCurrentPriorityLevel();\n  }\n\n  return update;\n}\n\nfunction appendUpdateToQueue(queue, update) {\n  // Append the update to the end of the list.\n  if (queue.lastUpdate === null) {\n    // Queue is empty\n    queue.firstUpdate = queue.lastUpdate = update;\n  } else {\n    queue.lastUpdate.next = update;\n    queue.lastUpdate = update;\n  }\n}\n\nexport function enqueueUpdate(fiber, update) {\n  // Update queues are created lazily.\n  const alternate = fiber.alternate;\n  let queue1;\n  let queue2;\n\n  if (alternate === null) {\n    // There's only one fiber.\n    queue1 = fiber.updateQueue;\n    queue2 = null;\n\n    if (queue1 === null) {\n      queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);\n    }\n  } else {\n    // There are two owners.\n    queue1 = fiber.updateQueue;\n    queue2 = alternate.updateQueue;\n\n    if (queue1 === null) {\n      if (queue2 === null) {\n        // Neither fiber has an update queue. Create new ones.\n        queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);\n        queue2 = alternate.updateQueue = createUpdateQueue(alternate.memoizedState);\n      } else {\n        // Only one fiber has an update queue. Clone to create a new one.\n        queue1 = fiber.updateQueue = cloneUpdateQueue(queue2);\n      }\n    } else {\n      if (queue2 === null) {\n        // Only one fiber has an update queue. Clone to create a new one.\n        queue2 = alternate.updateQueue = cloneUpdateQueue(queue1);\n      } else {// Both owners have an update queue.\n      }\n    }\n  }\n\n  if (queue2 === null || queue1 === queue2) {\n    // There's only a single queue.\n    appendUpdateToQueue(queue1, update);\n  } else {\n    // There are two queues. We need to append the update to both queues,\n    // while accounting for the persistent structure of the list — we don't\n    // want the same update to be added multiple times.\n    if (queue1.lastUpdate === null || queue2.lastUpdate === null) {\n      // One of the queues is not empty. We must add the update to both queues.\n      appendUpdateToQueue(queue1, update);\n      appendUpdateToQueue(queue2, update);\n    } else {\n      // Both queues are non-empty. The last update is the same in both lists,\n      // because of structural sharing. So, only append to one of the lists.\n      appendUpdateToQueue(queue1, update); // But we still need to update the `lastUpdate` pointer of queue2.\n\n      queue2.lastUpdate = update;\n    }\n  }\n\n  if (__DEV__) {\n    if (fiber.tag === ClassComponent && (currentlyProcessingQueue === queue1 || queue2 !== null && currentlyProcessingQueue === queue2) && !didWarnUpdateInsideUpdate) {\n      warningWithoutStack(false, 'An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.');\n      didWarnUpdateInsideUpdate = true;\n    }\n  }\n}\nexport function enqueueCapturedUpdate(workInProgress, update) {\n  // Captured updates go into a separate list, and only on the work-in-\n  // progress queue.\n  let workInProgressQueue = workInProgress.updateQueue;\n\n  if (workInProgressQueue === null) {\n    workInProgressQueue = workInProgress.updateQueue = createUpdateQueue(workInProgress.memoizedState);\n  } else {\n    // TODO: I put this here rather than createWorkInProgress so that we don't\n    // clone the queue unnecessarily. There's probably a better way to\n    // structure this.\n    workInProgressQueue = ensureWorkInProgressQueueIsAClone(workInProgress, workInProgressQueue);\n  } // Append the update to the end of the list.\n\n\n  if (workInProgressQueue.lastCapturedUpdate === null) {\n    // This is the first render phase update\n    workInProgressQueue.firstCapturedUpdate = workInProgressQueue.lastCapturedUpdate = update;\n  } else {\n    workInProgressQueue.lastCapturedUpdate.next = update;\n    workInProgressQueue.lastCapturedUpdate = update;\n  }\n}\n\nfunction ensureWorkInProgressQueueIsAClone(workInProgress, queue) {\n  const current = workInProgress.alternate;\n\n  if (current !== null) {\n    // If the work-in-progress queue is equal to the current queue,\n    // we need to clone it first.\n    if (queue === current.updateQueue) {\n      queue = workInProgress.updateQueue = cloneUpdateQueue(queue);\n    }\n  }\n\n  return queue;\n}\n\nfunction getStateFromUpdate(workInProgress, queue, update, prevState, nextProps, instance) {\n  switch (update.tag) {\n    case ReplaceState:\n      {\n        const payload = update.payload;\n\n        if (typeof payload === 'function') {\n          // Updater function\n          if (__DEV__) {\n            enterDisallowedContextReadInDEV();\n\n            if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {\n              payload.call(instance, prevState, nextProps);\n            }\n          }\n\n          const nextState = payload.call(instance, prevState, nextProps);\n\n          if (__DEV__) {\n            exitDisallowedContextReadInDEV();\n          }\n\n          return nextState;\n        } // State object\n\n\n        return payload;\n      }\n\n    case CaptureUpdate:\n      {\n        workInProgress.effectTag = workInProgress.effectTag & ~ShouldCapture | DidCapture;\n      }\n    // Intentional fallthrough\n\n    case UpdateState:\n      {\n        const payload = update.payload;\n        let partialState;\n\n        if (typeof payload === 'function') {\n          // Updater function\n          if (__DEV__) {\n            enterDisallowedContextReadInDEV();\n\n            if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {\n              payload.call(instance, prevState, nextProps);\n            }\n          }\n\n          partialState = payload.call(instance, prevState, nextProps);\n\n          if (__DEV__) {\n            exitDisallowedContextReadInDEV();\n          }\n        } else {\n          // Partial state object\n          partialState = payload;\n        }\n\n        if (partialState === null || partialState === undefined) {\n          // Null and undefined are treated as no-ops.\n          return prevState;\n        } // Merge the partial state and the previous state.\n\n\n        return Object.assign({}, prevState, partialState);\n      }\n\n    case ForceUpdate:\n      {\n        hasForceUpdate = true;\n        return prevState;\n      }\n  }\n\n  return prevState;\n}\n\nexport function processUpdateQueue(workInProgress, queue, props, instance, renderExpirationTime) {\n  hasForceUpdate = false;\n  queue = ensureWorkInProgressQueueIsAClone(workInProgress, queue);\n\n  if (__DEV__) {\n    currentlyProcessingQueue = queue;\n  } // These values may change as we process the queue.\n\n\n  let newBaseState = queue.baseState;\n  let newFirstUpdate = null;\n  let newExpirationTime = NoWork; // Iterate through the list of updates to compute the result.\n\n  let update = queue.firstUpdate;\n  let resultState = newBaseState;\n\n  while (update !== null) {\n    const updateExpirationTime = update.expirationTime;\n\n    if (updateExpirationTime < renderExpirationTime) {\n      // This update does not have sufficient priority. Skip it.\n      if (newFirstUpdate === null) {\n        // This is the first skipped update. It will be the first update in\n        // the new list.\n        newFirstUpdate = update; // Since this is the first update that was skipped, the current result\n        // is the new base state.\n\n        newBaseState = resultState;\n      } // Since this update will remain in the list, update the remaining\n      // expiration time.\n\n\n      if (newExpirationTime < updateExpirationTime) {\n        newExpirationTime = updateExpirationTime;\n      }\n    } else {\n      // This update does have sufficient priority.\n      // Mark the event time of this update as relevant to this render pass.\n      // TODO: This should ideally use the true event time of this update rather than\n      // its priority which is a derived and not reverseable value.\n      // TODO: We should skip this update if it was already committed but currently\n      // we have no way of detecting the difference between a committed and suspended\n      // update here.\n      markRenderEventTimeAndConfig(updateExpirationTime, update.suspenseConfig); // Process it and compute a new result.\n\n      resultState = getStateFromUpdate(workInProgress, queue, update, resultState, props, instance);\n      const callback = update.callback;\n\n      if (callback !== null) {\n        workInProgress.effectTag |= Callback; // Set this to null, in case it was mutated during an aborted render.\n\n        update.nextEffect = null;\n\n        if (queue.lastEffect === null) {\n          queue.firstEffect = queue.lastEffect = update;\n        } else {\n          queue.lastEffect.nextEffect = update;\n          queue.lastEffect = update;\n        }\n      }\n    } // Continue to the next update.\n\n\n    update = update.next;\n  } // Separately, iterate though the list of captured updates.\n\n\n  let newFirstCapturedUpdate = null;\n  update = queue.firstCapturedUpdate;\n\n  while (update !== null) {\n    const updateExpirationTime = update.expirationTime;\n\n    if (updateExpirationTime < renderExpirationTime) {\n      // This update does not have sufficient priority. Skip it.\n      if (newFirstCapturedUpdate === null) {\n        // This is the first skipped captured update. It will be the first\n        // update in the new list.\n        newFirstCapturedUpdate = update; // If this is the first update that was skipped, the current result is\n        // the new base state.\n\n        if (newFirstUpdate === null) {\n          newBaseState = resultState;\n        }\n      } // Since this update will remain in the list, update the remaining\n      // expiration time.\n\n\n      if (newExpirationTime < updateExpirationTime) {\n        newExpirationTime = updateExpirationTime;\n      }\n    } else {\n      // This update does have sufficient priority. Process it and compute\n      // a new result.\n      resultState = getStateFromUpdate(workInProgress, queue, update, resultState, props, instance);\n      const callback = update.callback;\n\n      if (callback !== null) {\n        workInProgress.effectTag |= Callback; // Set this to null, in case it was mutated during an aborted render.\n\n        update.nextEffect = null;\n\n        if (queue.lastCapturedEffect === null) {\n          queue.firstCapturedEffect = queue.lastCapturedEffect = update;\n        } else {\n          queue.lastCapturedEffect.nextEffect = update;\n          queue.lastCapturedEffect = update;\n        }\n      }\n    }\n\n    update = update.next;\n  }\n\n  if (newFirstUpdate === null) {\n    queue.lastUpdate = null;\n  }\n\n  if (newFirstCapturedUpdate === null) {\n    queue.lastCapturedUpdate = null;\n  } else {\n    workInProgress.effectTag |= Callback;\n  }\n\n  if (newFirstUpdate === null && newFirstCapturedUpdate === null) {\n    // We processed every update, without skipping. That means the new base\n    // state is the same as the result state.\n    newBaseState = resultState;\n  }\n\n  queue.baseState = newBaseState;\n  queue.firstUpdate = newFirstUpdate;\n  queue.firstCapturedUpdate = newFirstCapturedUpdate; // Set the remaining expiration time to be whatever is remaining in the queue.\n  // This should be fine because the only two other things that contribute to\n  // expiration time are props and context. We're already in the middle of the\n  // begin phase by the time we start processing the queue, so we've already\n  // dealt with the props. Context in components that specify\n  // shouldComponentUpdate is tricky; but we'll have to account for\n  // that regardless.\n\n  markUnprocessedUpdateTime(newExpirationTime);\n  workInProgress.expirationTime = newExpirationTime;\n  workInProgress.memoizedState = resultState;\n\n  if (__DEV__) {\n    currentlyProcessingQueue = null;\n  }\n}\n\nfunction callCallback(callback, context) {\n  invariant(typeof callback === 'function', 'Invalid argument passed as callback. Expected a function. Instead ' + 'received: %s', callback);\n  callback.call(context);\n}\n\nexport function resetHasForceUpdateBeforeProcessing() {\n  hasForceUpdate = false;\n}\nexport function checkHasForceUpdateAfterProcessing() {\n  return hasForceUpdate;\n}\nexport function commitUpdateQueue(finishedWork, finishedQueue, instance, renderExpirationTime) {\n  // If the finished render included captured updates, and there are still\n  // lower priority updates left over, we need to keep the captured updates\n  // in the queue so that they are rebased and not dropped once we process the\n  // queue again at the lower priority.\n  if (finishedQueue.firstCapturedUpdate !== null) {\n    // Join the captured update list to the end of the normal list.\n    if (finishedQueue.lastUpdate !== null) {\n      finishedQueue.lastUpdate.next = finishedQueue.firstCapturedUpdate;\n      finishedQueue.lastUpdate = finishedQueue.lastCapturedUpdate;\n    } // Clear the list of captured updates.\n\n\n    finishedQueue.firstCapturedUpdate = finishedQueue.lastCapturedUpdate = null;\n  } // Commit the effects\n\n\n  commitUpdateEffects(finishedQueue.firstEffect, instance);\n  finishedQueue.firstEffect = finishedQueue.lastEffect = null;\n  commitUpdateEffects(finishedQueue.firstCapturedEffect, instance);\n  finishedQueue.firstCapturedEffect = finishedQueue.lastCapturedEffect = null;\n}\n\nfunction commitUpdateEffects(effect, instance) {\n  while (effect !== null) {\n    const callback = effect.callback;\n\n    if (callback !== null) {\n      effect.callback = null;\n      callCallback(callback, instance);\n    }\n\n    effect = effect.nextEffect;\n  }\n}","map":{"version":3,"sources":["/Users/gaoshaoyun/Documents/library/debug-react/src/react/packages/react-reconciler/src/ReactUpdateQueue.js"],"names":["NoWork","enterDisallowedContextReadInDEV","exitDisallowedContextReadInDEV","Callback","ShouldCapture","DidCapture","ClassComponent","debugRenderPhaseSideEffects","debugRenderPhaseSideEffectsForStrictMode","StrictMode","markRenderEventTimeAndConfig","markUnprocessedUpdateTime","invariant","warningWithoutStack","getCurrentPriorityLevel","UpdateState","ReplaceState","ForceUpdate","CaptureUpdate","hasForceUpdate","didWarnUpdateInsideUpdate","currentlyProcessingQueue","resetCurrentlyProcessingQueue","__DEV__","createUpdateQueue","baseState","queue","firstUpdate","lastUpdate","firstCapturedUpdate","lastCapturedUpdate","firstEffect","lastEffect","firstCapturedEffect","lastCapturedEffect","cloneUpdateQueue","currentQueue","createUpdate","expirationTime","suspenseConfig","update","tag","payload","callback","next","nextEffect","priority","appendUpdateToQueue","enqueueUpdate","fiber","alternate","queue1","queue2","updateQueue","memoizedState","enqueueCapturedUpdate","workInProgress","workInProgressQueue","ensureWorkInProgressQueueIsAClone","current","getStateFromUpdate","prevState","nextProps","instance","mode","call","nextState","effectTag","partialState","undefined","Object","assign","processUpdateQueue","props","renderExpirationTime","newBaseState","newFirstUpdate","newExpirationTime","resultState","updateExpirationTime","newFirstCapturedUpdate","callCallback","context","resetHasForceUpdateBeforeProcessing","checkHasForceUpdateAfterProcessing","commitUpdateQueue","finishedWork","finishedQueue","commitUpdateEffects","effect"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\n// UpdateQueue is a linked list of prioritized updates.\n//\n// Like fibers, update queues come in pairs: a current queue, which represents\n// the visible state of the screen, and a work-in-progress queue, which can be\n// mutated and processed asynchronously before it is committed — a form of\n// double buffering. If a work-in-progress render is discarded before finishing,\n// we create a new work-in-progress by cloning the current queue.\n//\n// Both queues share a persistent, singly-linked list structure. To schedule an\n// update, we append it to the end of both queues. Each queue maintains a\n// pointer to first update in the persistent list that hasn't been processed.\n// The work-in-progress pointer always has a position equal to or greater than\n// the current queue, since we always work on that one. The current queue's\n// pointer is only updated during the commit phase, when we swap in the\n// work-in-progress.\n//\n// For example:\n//\n//   Current pointer:           A - B - C - D - E - F\n//   Work-in-progress pointer:              D - E - F\n//                                          ^\n//                                          The work-in-progress queue has\n//                                          processed more updates than current.\n//\n// The reason we append to both queues is because otherwise we might drop\n// updates without ever processing them. For example, if we only add updates to\n// the work-in-progress queue, some updates could be lost whenever a work-in\n// -progress render restarts by cloning from current. Similarly, if we only add\n// updates to the current queue, the updates will be lost whenever an already\n// in-progress queue commits and swaps with the current queue. However, by\n// adding to both queues, we guarantee that the update will be part of the next\n// work-in-progress. (And because the work-in-progress queue becomes the\n// current queue once it commits, there's no danger of applying the same\n// update twice.)\n//\n// Prioritization\n// --------------\n//\n// Updates are not sorted by priority, but by insertion; new updates are always\n// appended to the end of the list.\n//\n// The priority is still important, though. When processing the update queue\n// during the render phase, only the updates with sufficient priority are\n// included in the result. If we skip an update because it has insufficient\n// priority, it remains in the queue to be processed later, during a lower\n// priority render. Crucially, all updates subsequent to a skipped update also\n// remain in the queue *regardless of their priority*. That means high priority\n// updates are sometimes processed twice, at two separate priorities. We also\n// keep track of a base state, that represents the state before the first\n// update in the queue is applied.\n//\n// For example:\n//\n//   Given a base state of '', and the following queue of updates\n//\n//     A1 - B2 - C1 - D2\n//\n//   where the number indicates the priority, and the update is applied to the\n//   previous state by appending a letter, React will process these updates as\n//   two separate renders, one per distinct priority level:\n//\n//   First render, at priority 1:\n//     Base state: ''\n//     Updates: [A1, C1]\n//     Result state: 'AC'\n//\n//   Second render, at priority 2:\n//     Base state: 'A'            <-  The base state does not include C1,\n//                                    because B2 was skipped.\n//     Updates: [B2, C1, D2]      <-  C1 was rebased on top of B2\n//     Result state: 'ABCD'\n//\n// Because we process updates in insertion order, and rebase high priority\n// updates when preceding updates are skipped, the final result is deterministic\n// regardless of priority. Intermediate state may vary according to system\n// resources, but the final state is always the same.\n\nimport type {Fiber} from './ReactFiber';\nimport type {ExpirationTime} from './ReactFiberExpirationTime';\nimport type {SuspenseConfig} from './ReactFiberSuspenseConfig';\nimport type {ReactPriorityLevel} from './SchedulerWithReactIntegration';\n\nimport {NoWork} from './ReactFiberExpirationTime';\nimport {\n  enterDisallowedContextReadInDEV,\n  exitDisallowedContextReadInDEV,\n} from './ReactFiberNewContext';\nimport {Callback, ShouldCapture, DidCapture} from 'shared/ReactSideEffectTags';\nimport {ClassComponent} from 'shared/ReactWorkTags';\n\nimport {\n  debugRenderPhaseSideEffects,\n  debugRenderPhaseSideEffectsForStrictMode,\n} from 'shared/ReactFeatureFlags';\n\nimport {StrictMode} from './ReactTypeOfMode';\nimport {\n  markRenderEventTimeAndConfig,\n  markUnprocessedUpdateTime,\n} from './ReactFiberWorkLoop';\n\nimport invariant from 'shared/invariant';\nimport warningWithoutStack from 'shared/warningWithoutStack';\nimport {getCurrentPriorityLevel} from './SchedulerWithReactIntegration';\n\nexport type Update<State> = {\n  expirationTime: ExpirationTime,\n  suspenseConfig: null | SuspenseConfig,\n\n  tag: 0 | 1 | 2 | 3,\n  payload: any,\n  callback: (() => mixed) | null,\n\n  next: Update<State> | null,\n  nextEffect: Update<State> | null,\n\n  //DEV only\n  priority?: ReactPriorityLevel,\n};\n\nexport type UpdateQueue<State> = {\n  baseState: State,\n\n  firstUpdate: Update<State> | null,\n  lastUpdate: Update<State> | null,\n\n  firstCapturedUpdate: Update<State> | null,\n  lastCapturedUpdate: Update<State> | null,\n\n  firstEffect: Update<State> | null,\n  lastEffect: Update<State> | null,\n\n  firstCapturedEffect: Update<State> | null,\n  lastCapturedEffect: Update<State> | null,\n};\n\nexport const UpdateState = 0;\nexport const ReplaceState = 1;\nexport const ForceUpdate = 2;\nexport const CaptureUpdate = 3;\n\n// Global state that is reset at the beginning of calling `processUpdateQueue`.\n// It should only be read right after calling `processUpdateQueue`, via\n// `checkHasForceUpdateAfterProcessing`.\nlet hasForceUpdate = false;\n\nlet didWarnUpdateInsideUpdate;\nlet currentlyProcessingQueue;\nexport let resetCurrentlyProcessingQueue;\nif (__DEV__) {\n  didWarnUpdateInsideUpdate = false;\n  currentlyProcessingQueue = null;\n  resetCurrentlyProcessingQueue = () => {\n    currentlyProcessingQueue = null;\n  };\n}\n\nexport function createUpdateQueue<State>(baseState: State): UpdateQueue<State> {\n  const queue: UpdateQueue<State> = {\n    baseState,\n    firstUpdate: null,\n    lastUpdate: null,\n    firstCapturedUpdate: null,\n    lastCapturedUpdate: null,\n    firstEffect: null,\n    lastEffect: null,\n    firstCapturedEffect: null,\n    lastCapturedEffect: null,\n  };\n  return queue;\n}\n\nfunction cloneUpdateQueue<State>(\n  currentQueue: UpdateQueue<State>,\n): UpdateQueue<State> {\n  const queue: UpdateQueue<State> = {\n    baseState: currentQueue.baseState,\n    firstUpdate: currentQueue.firstUpdate,\n    lastUpdate: currentQueue.lastUpdate,\n\n    // TODO: With resuming, if we bail out and resuse the child tree, we should\n    // keep these effects.\n    firstCapturedUpdate: null,\n    lastCapturedUpdate: null,\n\n    firstEffect: null,\n    lastEffect: null,\n\n    firstCapturedEffect: null,\n    lastCapturedEffect: null,\n  };\n  return queue;\n}\n\nexport function createUpdate(\n  expirationTime: ExpirationTime,\n  suspenseConfig: null | SuspenseConfig,\n): Update<*> {\n  let update: Update<*> = {\n    expirationTime,\n    suspenseConfig,\n\n    tag: UpdateState,\n    payload: null,\n    callback: null,\n\n    next: null,\n    nextEffect: null,\n  };\n  if (__DEV__) {\n    update.priority = getCurrentPriorityLevel();\n  }\n  return update;\n}\n\nfunction appendUpdateToQueue<State>(\n  queue: UpdateQueue<State>,\n  update: Update<State>,\n) {\n  // Append the update to the end of the list.\n  if (queue.lastUpdate === null) {\n    // Queue is empty\n    queue.firstUpdate = queue.lastUpdate = update;\n  } else {\n    queue.lastUpdate.next = update;\n    queue.lastUpdate = update;\n  }\n}\n\nexport function enqueueUpdate<State>(fiber: Fiber, update: Update<State>) {\n  // Update queues are created lazily.\n  const alternate = fiber.alternate;\n  let queue1;\n  let queue2;\n  if (alternate === null) {\n    // There's only one fiber.\n    queue1 = fiber.updateQueue;\n    queue2 = null;\n    if (queue1 === null) {\n      queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);\n    }\n  } else {\n    // There are two owners.\n    queue1 = fiber.updateQueue;\n    queue2 = alternate.updateQueue;\n    if (queue1 === null) {\n      if (queue2 === null) {\n        // Neither fiber has an update queue. Create new ones.\n        queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);\n        queue2 = alternate.updateQueue = createUpdateQueue(\n          alternate.memoizedState,\n        );\n      } else {\n        // Only one fiber has an update queue. Clone to create a new one.\n        queue1 = fiber.updateQueue = cloneUpdateQueue(queue2);\n      }\n    } else {\n      if (queue2 === null) {\n        // Only one fiber has an update queue. Clone to create a new one.\n        queue2 = alternate.updateQueue = cloneUpdateQueue(queue1);\n      } else {\n        // Both owners have an update queue.\n      }\n    }\n  }\n  if (queue2 === null || queue1 === queue2) {\n    // There's only a single queue.\n    appendUpdateToQueue(queue1, update);\n  } else {\n    // There are two queues. We need to append the update to both queues,\n    // while accounting for the persistent structure of the list — we don't\n    // want the same update to be added multiple times.\n    if (queue1.lastUpdate === null || queue2.lastUpdate === null) {\n      // One of the queues is not empty. We must add the update to both queues.\n      appendUpdateToQueue(queue1, update);\n      appendUpdateToQueue(queue2, update);\n    } else {\n      // Both queues are non-empty. The last update is the same in both lists,\n      // because of structural sharing. So, only append to one of the lists.\n      appendUpdateToQueue(queue1, update);\n      // But we still need to update the `lastUpdate` pointer of queue2.\n      queue2.lastUpdate = update;\n    }\n  }\n\n  if (__DEV__) {\n    if (\n      fiber.tag === ClassComponent &&\n      (currentlyProcessingQueue === queue1 ||\n        (queue2 !== null && currentlyProcessingQueue === queue2)) &&\n      !didWarnUpdateInsideUpdate\n    ) {\n      warningWithoutStack(\n        false,\n        'An update (setState, replaceState, or forceUpdate) was scheduled ' +\n          'from inside an update function. Update functions should be pure, ' +\n          'with zero side-effects. Consider using componentDidUpdate or a ' +\n          'callback.',\n      );\n      didWarnUpdateInsideUpdate = true;\n    }\n  }\n}\n\nexport function enqueueCapturedUpdate<State>(\n  workInProgress: Fiber,\n  update: Update<State>,\n) {\n  // Captured updates go into a separate list, and only on the work-in-\n  // progress queue.\n  let workInProgressQueue = workInProgress.updateQueue;\n  if (workInProgressQueue === null) {\n    workInProgressQueue = workInProgress.updateQueue = createUpdateQueue(\n      workInProgress.memoizedState,\n    );\n  } else {\n    // TODO: I put this here rather than createWorkInProgress so that we don't\n    // clone the queue unnecessarily. There's probably a better way to\n    // structure this.\n    workInProgressQueue = ensureWorkInProgressQueueIsAClone(\n      workInProgress,\n      workInProgressQueue,\n    );\n  }\n\n  // Append the update to the end of the list.\n  if (workInProgressQueue.lastCapturedUpdate === null) {\n    // This is the first render phase update\n    workInProgressQueue.firstCapturedUpdate = workInProgressQueue.lastCapturedUpdate = update;\n  } else {\n    workInProgressQueue.lastCapturedUpdate.next = update;\n    workInProgressQueue.lastCapturedUpdate = update;\n  }\n}\n\nfunction ensureWorkInProgressQueueIsAClone<State>(\n  workInProgress: Fiber,\n  queue: UpdateQueue<State>,\n): UpdateQueue<State> {\n  const current = workInProgress.alternate;\n  if (current !== null) {\n    // If the work-in-progress queue is equal to the current queue,\n    // we need to clone it first.\n    if (queue === current.updateQueue) {\n      queue = workInProgress.updateQueue = cloneUpdateQueue(queue);\n    }\n  }\n  return queue;\n}\n\nfunction getStateFromUpdate<State>(\n  workInProgress: Fiber,\n  queue: UpdateQueue<State>,\n  update: Update<State>,\n  prevState: State,\n  nextProps: any,\n  instance: any,\n): any {\n  switch (update.tag) {\n    case ReplaceState: {\n      const payload = update.payload;\n      if (typeof payload === 'function') {\n        // Updater function\n        if (__DEV__) {\n          enterDisallowedContextReadInDEV();\n          if (\n            debugRenderPhaseSideEffects ||\n            (debugRenderPhaseSideEffectsForStrictMode &&\n              workInProgress.mode & StrictMode)\n          ) {\n            payload.call(instance, prevState, nextProps);\n          }\n        }\n        const nextState = payload.call(instance, prevState, nextProps);\n        if (__DEV__) {\n          exitDisallowedContextReadInDEV();\n        }\n        return nextState;\n      }\n      // State object\n      return payload;\n    }\n    case CaptureUpdate: {\n      workInProgress.effectTag =\n        (workInProgress.effectTag & ~ShouldCapture) | DidCapture;\n    }\n    // Intentional fallthrough\n    case UpdateState: {\n      const payload = update.payload;\n      let partialState;\n      if (typeof payload === 'function') {\n        // Updater function\n        if (__DEV__) {\n          enterDisallowedContextReadInDEV();\n          if (\n            debugRenderPhaseSideEffects ||\n            (debugRenderPhaseSideEffectsForStrictMode &&\n              workInProgress.mode & StrictMode)\n          ) {\n            payload.call(instance, prevState, nextProps);\n          }\n        }\n        partialState = payload.call(instance, prevState, nextProps);\n        if (__DEV__) {\n          exitDisallowedContextReadInDEV();\n        }\n      } else {\n        // Partial state object\n        partialState = payload;\n      }\n      if (partialState === null || partialState === undefined) {\n        // Null and undefined are treated as no-ops.\n        return prevState;\n      }\n      // Merge the partial state and the previous state.\n      return Object.assign({}, prevState, partialState);\n    }\n    case ForceUpdate: {\n      hasForceUpdate = true;\n      return prevState;\n    }\n  }\n  return prevState;\n}\n\nexport function processUpdateQueue<State>(\n  workInProgress: Fiber,\n  queue: UpdateQueue<State>,\n  props: any,\n  instance: any,\n  renderExpirationTime: ExpirationTime,\n): void {\n  hasForceUpdate = false;\n\n  queue = ensureWorkInProgressQueueIsAClone(workInProgress, queue);\n\n  if (__DEV__) {\n    currentlyProcessingQueue = queue;\n  }\n\n  // These values may change as we process the queue.\n  let newBaseState = queue.baseState;\n  let newFirstUpdate = null;\n  let newExpirationTime = NoWork;\n\n  // Iterate through the list of updates to compute the result.\n  let update = queue.firstUpdate;\n  let resultState = newBaseState;\n  while (update !== null) {\n    const updateExpirationTime = update.expirationTime;\n    if (updateExpirationTime < renderExpirationTime) {\n      // This update does not have sufficient priority. Skip it.\n      if (newFirstUpdate === null) {\n        // This is the first skipped update. It will be the first update in\n        // the new list.\n        newFirstUpdate = update;\n        // Since this is the first update that was skipped, the current result\n        // is the new base state.\n        newBaseState = resultState;\n      }\n      // Since this update will remain in the list, update the remaining\n      // expiration time.\n      if (newExpirationTime < updateExpirationTime) {\n        newExpirationTime = updateExpirationTime;\n      }\n    } else {\n      // This update does have sufficient priority.\n\n      // Mark the event time of this update as relevant to this render pass.\n      // TODO: This should ideally use the true event time of this update rather than\n      // its priority which is a derived and not reverseable value.\n      // TODO: We should skip this update if it was already committed but currently\n      // we have no way of detecting the difference between a committed and suspended\n      // update here.\n      markRenderEventTimeAndConfig(updateExpirationTime, update.suspenseConfig);\n\n      // Process it and compute a new result.\n      resultState = getStateFromUpdate(\n        workInProgress,\n        queue,\n        update,\n        resultState,\n        props,\n        instance,\n      );\n      const callback = update.callback;\n      if (callback !== null) {\n        workInProgress.effectTag |= Callback;\n        // Set this to null, in case it was mutated during an aborted render.\n        update.nextEffect = null;\n        if (queue.lastEffect === null) {\n          queue.firstEffect = queue.lastEffect = update;\n        } else {\n          queue.lastEffect.nextEffect = update;\n          queue.lastEffect = update;\n        }\n      }\n    }\n    // Continue to the next update.\n    update = update.next;\n  }\n\n  // Separately, iterate though the list of captured updates.\n  let newFirstCapturedUpdate = null;\n  update = queue.firstCapturedUpdate;\n  while (update !== null) {\n    const updateExpirationTime = update.expirationTime;\n    if (updateExpirationTime < renderExpirationTime) {\n      // This update does not have sufficient priority. Skip it.\n      if (newFirstCapturedUpdate === null) {\n        // This is the first skipped captured update. It will be the first\n        // update in the new list.\n        newFirstCapturedUpdate = update;\n        // If this is the first update that was skipped, the current result is\n        // the new base state.\n        if (newFirstUpdate === null) {\n          newBaseState = resultState;\n        }\n      }\n      // Since this update will remain in the list, update the remaining\n      // expiration time.\n      if (newExpirationTime < updateExpirationTime) {\n        newExpirationTime = updateExpirationTime;\n      }\n    } else {\n      // This update does have sufficient priority. Process it and compute\n      // a new result.\n      resultState = getStateFromUpdate(\n        workInProgress,\n        queue,\n        update,\n        resultState,\n        props,\n        instance,\n      );\n      const callback = update.callback;\n      if (callback !== null) {\n        workInProgress.effectTag |= Callback;\n        // Set this to null, in case it was mutated during an aborted render.\n        update.nextEffect = null;\n        if (queue.lastCapturedEffect === null) {\n          queue.firstCapturedEffect = queue.lastCapturedEffect = update;\n        } else {\n          queue.lastCapturedEffect.nextEffect = update;\n          queue.lastCapturedEffect = update;\n        }\n      }\n    }\n    update = update.next;\n  }\n\n  if (newFirstUpdate === null) {\n    queue.lastUpdate = null;\n  }\n  if (newFirstCapturedUpdate === null) {\n    queue.lastCapturedUpdate = null;\n  } else {\n    workInProgress.effectTag |= Callback;\n  }\n  if (newFirstUpdate === null && newFirstCapturedUpdate === null) {\n    // We processed every update, without skipping. That means the new base\n    // state is the same as the result state.\n    newBaseState = resultState;\n  }\n\n  queue.baseState = newBaseState;\n  queue.firstUpdate = newFirstUpdate;\n  queue.firstCapturedUpdate = newFirstCapturedUpdate;\n\n  // Set the remaining expiration time to be whatever is remaining in the queue.\n  // This should be fine because the only two other things that contribute to\n  // expiration time are props and context. We're already in the middle of the\n  // begin phase by the time we start processing the queue, so we've already\n  // dealt with the props. Context in components that specify\n  // shouldComponentUpdate is tricky; but we'll have to account for\n  // that regardless.\n  markUnprocessedUpdateTime(newExpirationTime);\n  workInProgress.expirationTime = newExpirationTime;\n  workInProgress.memoizedState = resultState;\n\n  if (__DEV__) {\n    currentlyProcessingQueue = null;\n  }\n}\n\nfunction callCallback(callback, context) {\n  invariant(\n    typeof callback === 'function',\n    'Invalid argument passed as callback. Expected a function. Instead ' +\n      'received: %s',\n    callback,\n  );\n  callback.call(context);\n}\n\nexport function resetHasForceUpdateBeforeProcessing() {\n  hasForceUpdate = false;\n}\n\nexport function checkHasForceUpdateAfterProcessing(): boolean {\n  return hasForceUpdate;\n}\n\nexport function commitUpdateQueue<State>(\n  finishedWork: Fiber,\n  finishedQueue: UpdateQueue<State>,\n  instance: any,\n  renderExpirationTime: ExpirationTime,\n): void {\n  // If the finished render included captured updates, and there are still\n  // lower priority updates left over, we need to keep the captured updates\n  // in the queue so that they are rebased and not dropped once we process the\n  // queue again at the lower priority.\n  if (finishedQueue.firstCapturedUpdate !== null) {\n    // Join the captured update list to the end of the normal list.\n    if (finishedQueue.lastUpdate !== null) {\n      finishedQueue.lastUpdate.next = finishedQueue.firstCapturedUpdate;\n      finishedQueue.lastUpdate = finishedQueue.lastCapturedUpdate;\n    }\n    // Clear the list of captured updates.\n    finishedQueue.firstCapturedUpdate = finishedQueue.lastCapturedUpdate = null;\n  }\n\n  // Commit the effects\n  commitUpdateEffects(finishedQueue.firstEffect, instance);\n  finishedQueue.firstEffect = finishedQueue.lastEffect = null;\n\n  commitUpdateEffects(finishedQueue.firstCapturedEffect, instance);\n  finishedQueue.firstCapturedEffect = finishedQueue.lastCapturedEffect = null;\n}\n\nfunction commitUpdateEffects<State>(\n  effect: Update<State> | null,\n  instance: any,\n): void {\n  while (effect !== null) {\n    const callback = effect.callback;\n    if (callback !== null) {\n      effect.callback = null;\n      callCallback(callback, instance);\n    }\n    effect = effect.nextEffect;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}