{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { getPropertyInfo, shouldIgnoreAttribute, shouldRemoveAttribute, isAttributeNameSafe, BOOLEAN, OVERLOADED_BOOLEAN } from '../shared/DOMProperty';\nimport sanitizeURL from '../shared/sanitizeURL';\nimport { toStringOrTrustedType } from './ToStringValue';\nimport { disableJavaScriptURLs } from 'shared/ReactFeatureFlags';\nimport { setAttribute, setAttributeNS } from './setAttribute';\n\n/**\n * Get the value for a property on a node. Only used in DEV for SSR validation.\n * The \"expected\" argument is used as a hint of what the expected value is.\n * Some properties have multiple equivalent values.\n */\nexport function getValueForProperty(node, name, expected, propertyInfo) {\n  if (__DEV__) {\n    if (propertyInfo.mustUseProperty) {\n      const {\n        propertyName\n      } = propertyInfo;\n      return node[propertyName];\n    } else {\n      if (!disableJavaScriptURLs && propertyInfo.sanitizeURL) {\n        // If we haven't fully disabled javascript: URLs, and if\n        // the hydration is successful of a javascript: URL, we\n        // still want to warn on the client.\n        sanitizeURL('' + expected);\n      }\n\n      const attributeName = propertyInfo.attributeName;\n      let stringValue = null;\n\n      if (propertyInfo.type === OVERLOADED_BOOLEAN) {\n        if (node.hasAttribute(attributeName)) {\n          const value = node.getAttribute(attributeName);\n\n          if (value === '') {\n            return true;\n          }\n\n          if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\n            return value;\n          }\n\n          if (value === '' + expected) {\n            return expected;\n          }\n\n          return value;\n        }\n      } else if (node.hasAttribute(attributeName)) {\n        if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\n          // We had an attribute but shouldn't have had one, so read it\n          // for the error message.\n          return node.getAttribute(attributeName);\n        }\n\n        if (propertyInfo.type === BOOLEAN) {\n          // If this was a boolean, it doesn't matter what the value is\n          // the fact that we have it is the same as the expected.\n          return expected;\n        } // Even if this property uses a namespace we use getAttribute\n        // because we assume its namespaced name is the same as our config.\n        // To use getAttributeNS we need the local name which we don't have\n        // in our config atm.\n\n\n        stringValue = node.getAttribute(attributeName);\n      }\n\n      if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\n        return stringValue === null ? expected : stringValue;\n      } else if (stringValue === '' + expected) {\n        return expected;\n      } else {\n        return stringValue;\n      }\n    }\n  }\n}\n/**\n * Get the value for a attribute on a node. Only used in DEV for SSR validation.\n * The third argument is used as a hint of what the expected value is. Some\n * attributes have multiple equivalent values.\n */\n\nexport function getValueForAttribute(node, name, expected) {\n  if (__DEV__) {\n    if (!isAttributeNameSafe(name)) {\n      return;\n    }\n\n    if (!node.hasAttribute(name)) {\n      return expected === undefined ? undefined : null;\n    }\n\n    const value = node.getAttribute(name);\n\n    if (value === '' + expected) {\n      return expected;\n    }\n\n    return value;\n  }\n}\n/**\n * Sets the value for a property on a node.\n *\n * @param {DOMElement} node\n * @param {string} name\n * @param {*} value\n */\n\nexport function setValueForProperty(node, name, value, isCustomComponentTag) {\n  const propertyInfo = getPropertyInfo(name);\n\n  if (shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag)) {\n    return;\n  }\n\n  if (shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag)) {\n    value = null;\n  } // If the prop isn't in the special list, treat it as a simple attribute.\n\n\n  if (isCustomComponentTag || propertyInfo === null) {\n    if (isAttributeNameSafe(name)) {\n      const attributeName = name;\n\n      if (value === null) {\n        node.removeAttribute(attributeName);\n      } else {\n        setAttribute(node, attributeName, toStringOrTrustedType(value));\n      }\n    }\n\n    return;\n  }\n\n  const {\n    mustUseProperty\n  } = propertyInfo;\n\n  if (mustUseProperty) {\n    const {\n      propertyName\n    } = propertyInfo;\n\n    if (value === null) {\n      const {\n        type\n      } = propertyInfo;\n      node[propertyName] = type === BOOLEAN ? false : '';\n    } else {\n      // Contrary to `setAttribute`, object properties are properly\n      // `toString`ed by IE8/9.\n      node[propertyName] = value;\n    }\n\n    return;\n  } // The rest are treated as attributes with special cases.\n\n\n  const {\n    attributeName,\n    attributeNamespace\n  } = propertyInfo;\n\n  if (value === null) {\n    node.removeAttribute(attributeName);\n  } else {\n    const {\n      type\n    } = propertyInfo;\n    let attributeValue;\n\n    if (type === BOOLEAN || type === OVERLOADED_BOOLEAN && value === true) {\n      // If attribute type is boolean, we know for sure it won't be an execution sink\n      // and we won't require Trusted Type here.\n      attributeValue = '';\n    } else {\n      // `setAttribute` with objects becomes only `[object]` in IE8/9,\n      // ('' + value) makes it output the correct toString()-value.\n      attributeValue = toStringOrTrustedType(value);\n\n      if (propertyInfo.sanitizeURL) {\n        sanitizeURL(attributeValue.toString());\n      }\n    }\n\n    if (attributeNamespace) {\n      setAttributeNS(node, attributeNamespace, attributeName, attributeValue);\n    } else {\n      setAttribute(node, attributeName, attributeValue);\n    }\n  }\n}","map":{"version":3,"sources":["/Users/gaoshaoyun/Documents/library/debug-react/src/react/packages/react-dom/src/client/DOMPropertyOperations.js"],"names":["getPropertyInfo","shouldIgnoreAttribute","shouldRemoveAttribute","isAttributeNameSafe","BOOLEAN","OVERLOADED_BOOLEAN","sanitizeURL","toStringOrTrustedType","disableJavaScriptURLs","setAttribute","setAttributeNS","getValueForProperty","node","name","expected","propertyInfo","__DEV__","mustUseProperty","propertyName","attributeName","stringValue","type","hasAttribute","value","getAttribute","getValueForAttribute","undefined","setValueForProperty","isCustomComponentTag","removeAttribute","attributeNamespace","attributeValue","toString"],"mappings":"AAAA;;;;;;;;AASA,SACEA,eADF,EAEEC,qBAFF,EAGEC,qBAHF,EAIEC,mBAJF,EAKEC,OALF,EAMEC,kBANF,QAOO,uBAPP;AAQA,OAAOC,WAAP,MAAwB,uBAAxB;AACA,SAAQC,qBAAR,QAAoC,iBAApC;AACA,SAAQC,qBAAR,QAAoC,0BAApC;AACA,SAAQC,YAAR,EAAsBC,cAAtB,QAA2C,gBAA3C;;AAIA;;;;;AAKA,OAAO,SAASC,mBAAT,CACLC,IADK,EAELC,IAFK,EAGLC,QAHK,EAILC,YAJK,EAKE;AACP,MAAIC,OAAJ,EAAa;AACX,QAAID,YAAY,CAACE,eAAjB,EAAkC;AAChC,YAAM;AAACC,QAAAA;AAAD,UAAiBH,YAAvB;AACA,aAAQH,IAAD,CAAYM,YAAZ,CAAP;AACD,KAHD,MAGO;AACL,UAAI,CAACV,qBAAD,IAA0BO,YAAY,CAACT,WAA3C,EAAwD;AACtD;AACA;AACA;AACAA,QAAAA,WAAW,CAAC,KAAMQ,QAAP,CAAX;AACD;;AAED,YAAMK,aAAa,GAAGJ,YAAY,CAACI,aAAnC;AAEA,UAAIC,WAAW,GAAG,IAAlB;;AAEA,UAAIL,YAAY,CAACM,IAAb,KAAsBhB,kBAA1B,EAA8C;AAC5C,YAAIO,IAAI,CAACU,YAAL,CAAkBH,aAAlB,CAAJ,EAAsC;AACpC,gBAAMI,KAAK,GAAGX,IAAI,CAACY,YAAL,CAAkBL,aAAlB,CAAd;;AACA,cAAII,KAAK,KAAK,EAAd,EAAkB;AAChB,mBAAO,IAAP;AACD;;AACD,cAAIrB,qBAAqB,CAACW,IAAD,EAAOC,QAAP,EAAiBC,YAAjB,EAA+B,KAA/B,CAAzB,EAAgE;AAC9D,mBAAOQ,KAAP;AACD;;AACD,cAAIA,KAAK,KAAK,KAAMT,QAApB,EAAoC;AAClC,mBAAOA,QAAP;AACD;;AACD,iBAAOS,KAAP;AACD;AACF,OAdD,MAcO,IAAIX,IAAI,CAACU,YAAL,CAAkBH,aAAlB,CAAJ,EAAsC;AAC3C,YAAIjB,qBAAqB,CAACW,IAAD,EAAOC,QAAP,EAAiBC,YAAjB,EAA+B,KAA/B,CAAzB,EAAgE;AAC9D;AACA;AACA,iBAAOH,IAAI,CAACY,YAAL,CAAkBL,aAAlB,CAAP;AACD;;AACD,YAAIJ,YAAY,CAACM,IAAb,KAAsBjB,OAA1B,EAAmC;AACjC;AACA;AACA,iBAAOU,QAAP;AACD,SAV0C,CAW3C;AACA;AACA;AACA;;;AACAM,QAAAA,WAAW,GAAGR,IAAI,CAACY,YAAL,CAAkBL,aAAlB,CAAd;AACD;;AAED,UAAIjB,qBAAqB,CAACW,IAAD,EAAOC,QAAP,EAAiBC,YAAjB,EAA+B,KAA/B,CAAzB,EAAgE;AAC9D,eAAOK,WAAW,KAAK,IAAhB,GAAuBN,QAAvB,GAAkCM,WAAzC;AACD,OAFD,MAEO,IAAIA,WAAW,KAAK,KAAMN,QAA1B,EAA0C;AAC/C,eAAOA,QAAP;AACD,OAFM,MAEA;AACL,eAAOM,WAAP;AACD;AACF;AACF;AACF;AAED;;;;;;AAKA,OAAO,SAASK,oBAAT,CACLb,IADK,EAELC,IAFK,EAGLC,QAHK,EAIE;AACP,MAAIE,OAAJ,EAAa;AACX,QAAI,CAACb,mBAAmB,CAACU,IAAD,CAAxB,EAAgC;AAC9B;AACD;;AACD,QAAI,CAACD,IAAI,CAACU,YAAL,CAAkBT,IAAlB,CAAL,EAA8B;AAC5B,aAAOC,QAAQ,KAAKY,SAAb,GAAyBA,SAAzB,GAAqC,IAA5C;AACD;;AACD,UAAMH,KAAK,GAAGX,IAAI,CAACY,YAAL,CAAkBX,IAAlB,CAAd;;AACA,QAAIU,KAAK,KAAK,KAAMT,QAApB,EAAoC;AAClC,aAAOA,QAAP;AACD;;AACD,WAAOS,KAAP;AACD;AACF;AAED;;;;;;;;AAOA,OAAO,SAASI,mBAAT,CACLf,IADK,EAELC,IAFK,EAGLU,KAHK,EAILK,oBAJK,EAKL;AACA,QAAMb,YAAY,GAAGf,eAAe,CAACa,IAAD,CAApC;;AACA,MAAIZ,qBAAqB,CAACY,IAAD,EAAOE,YAAP,EAAqBa,oBAArB,CAAzB,EAAqE;AACnE;AACD;;AACD,MAAI1B,qBAAqB,CAACW,IAAD,EAAOU,KAAP,EAAcR,YAAd,EAA4Ba,oBAA5B,CAAzB,EAA4E;AAC1EL,IAAAA,KAAK,GAAG,IAAR;AACD,GAPD,CAQA;;;AACA,MAAIK,oBAAoB,IAAIb,YAAY,KAAK,IAA7C,EAAmD;AACjD,QAAIZ,mBAAmB,CAACU,IAAD,CAAvB,EAA+B;AAC7B,YAAMM,aAAa,GAAGN,IAAtB;;AACA,UAAIU,KAAK,KAAK,IAAd,EAAoB;AAClBX,QAAAA,IAAI,CAACiB,eAAL,CAAqBV,aAArB;AACD,OAFD,MAEO;AACLV,QAAAA,YAAY,CAACG,IAAD,EAAOO,aAAP,EAAsBZ,qBAAqB,CAACgB,KAAD,CAA3C,CAAZ;AACD;AACF;;AACD;AACD;;AACD,QAAM;AAACN,IAAAA;AAAD,MAAoBF,YAA1B;;AACA,MAAIE,eAAJ,EAAqB;AACnB,UAAM;AAACC,MAAAA;AAAD,QAAiBH,YAAvB;;AACA,QAAIQ,KAAK,KAAK,IAAd,EAAoB;AAClB,YAAM;AAACF,QAAAA;AAAD,UAASN,YAAf;AACCH,MAAAA,IAAD,CAAYM,YAAZ,IAA4BG,IAAI,KAAKjB,OAAT,GAAmB,KAAnB,GAA2B,EAAvD;AACD,KAHD,MAGO;AACL;AACA;AACCQ,MAAAA,IAAD,CAAYM,YAAZ,IAA4BK,KAA5B;AACD;;AACD;AACD,GAhCD,CAiCA;;;AACA,QAAM;AAACJ,IAAAA,aAAD;AAAgBW,IAAAA;AAAhB,MAAsCf,YAA5C;;AACA,MAAIQ,KAAK,KAAK,IAAd,EAAoB;AAClBX,IAAAA,IAAI,CAACiB,eAAL,CAAqBV,aAArB;AACD,GAFD,MAEO;AACL,UAAM;AAACE,MAAAA;AAAD,QAASN,YAAf;AACA,QAAIgB,cAAJ;;AACA,QAAIV,IAAI,KAAKjB,OAAT,IAAqBiB,IAAI,KAAKhB,kBAAT,IAA+BkB,KAAK,KAAK,IAAlE,EAAyE;AACvE;AACA;AACAQ,MAAAA,cAAc,GAAG,EAAjB;AACD,KAJD,MAIO;AACL;AACA;AACAA,MAAAA,cAAc,GAAGxB,qBAAqB,CAACgB,KAAD,CAAtC;;AACA,UAAIR,YAAY,CAACT,WAAjB,EAA8B;AAC5BA,QAAAA,WAAW,CAACyB,cAAc,CAACC,QAAf,EAAD,CAAX;AACD;AACF;;AACD,QAAIF,kBAAJ,EAAwB;AACtBpB,MAAAA,cAAc,CAACE,IAAD,EAAOkB,kBAAP,EAA2BX,aAA3B,EAA0CY,cAA1C,CAAd;AACD,KAFD,MAEO;AACLtB,MAAAA,YAAY,CAACG,IAAD,EAAOO,aAAP,EAAsBY,cAAtB,CAAZ;AACD;AACF;AACF","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport {\n  getPropertyInfo,\n  shouldIgnoreAttribute,\n  shouldRemoveAttribute,\n  isAttributeNameSafe,\n  BOOLEAN,\n  OVERLOADED_BOOLEAN,\n} from '../shared/DOMProperty';\nimport sanitizeURL from '../shared/sanitizeURL';\nimport {toStringOrTrustedType} from './ToStringValue';\nimport {disableJavaScriptURLs} from 'shared/ReactFeatureFlags';\nimport {setAttribute, setAttributeNS} from './setAttribute';\n\nimport type {PropertyInfo} from '../shared/DOMProperty';\n\n/**\n * Get the value for a property on a node. Only used in DEV for SSR validation.\n * The \"expected\" argument is used as a hint of what the expected value is.\n * Some properties have multiple equivalent values.\n */\nexport function getValueForProperty(\n  node: Element,\n  name: string,\n  expected: mixed,\n  propertyInfo: PropertyInfo,\n): mixed {\n  if (__DEV__) {\n    if (propertyInfo.mustUseProperty) {\n      const {propertyName} = propertyInfo;\n      return (node: any)[propertyName];\n    } else {\n      if (!disableJavaScriptURLs && propertyInfo.sanitizeURL) {\n        // If we haven't fully disabled javascript: URLs, and if\n        // the hydration is successful of a javascript: URL, we\n        // still want to warn on the client.\n        sanitizeURL('' + (expected: any));\n      }\n\n      const attributeName = propertyInfo.attributeName;\n\n      let stringValue = null;\n\n      if (propertyInfo.type === OVERLOADED_BOOLEAN) {\n        if (node.hasAttribute(attributeName)) {\n          const value = node.getAttribute(attributeName);\n          if (value === '') {\n            return true;\n          }\n          if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\n            return value;\n          }\n          if (value === '' + (expected: any)) {\n            return expected;\n          }\n          return value;\n        }\n      } else if (node.hasAttribute(attributeName)) {\n        if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\n          // We had an attribute but shouldn't have had one, so read it\n          // for the error message.\n          return node.getAttribute(attributeName);\n        }\n        if (propertyInfo.type === BOOLEAN) {\n          // If this was a boolean, it doesn't matter what the value is\n          // the fact that we have it is the same as the expected.\n          return expected;\n        }\n        // Even if this property uses a namespace we use getAttribute\n        // because we assume its namespaced name is the same as our config.\n        // To use getAttributeNS we need the local name which we don't have\n        // in our config atm.\n        stringValue = node.getAttribute(attributeName);\n      }\n\n      if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\n        return stringValue === null ? expected : stringValue;\n      } else if (stringValue === '' + (expected: any)) {\n        return expected;\n      } else {\n        return stringValue;\n      }\n    }\n  }\n}\n\n/**\n * Get the value for a attribute on a node. Only used in DEV for SSR validation.\n * The third argument is used as a hint of what the expected value is. Some\n * attributes have multiple equivalent values.\n */\nexport function getValueForAttribute(\n  node: Element,\n  name: string,\n  expected: mixed,\n): mixed {\n  if (__DEV__) {\n    if (!isAttributeNameSafe(name)) {\n      return;\n    }\n    if (!node.hasAttribute(name)) {\n      return expected === undefined ? undefined : null;\n    }\n    const value = node.getAttribute(name);\n    if (value === '' + (expected: any)) {\n      return expected;\n    }\n    return value;\n  }\n}\n\n/**\n * Sets the value for a property on a node.\n *\n * @param {DOMElement} node\n * @param {string} name\n * @param {*} value\n */\nexport function setValueForProperty(\n  node: Element,\n  name: string,\n  value: mixed,\n  isCustomComponentTag: boolean,\n) {\n  const propertyInfo = getPropertyInfo(name);\n  if (shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag)) {\n    return;\n  }\n  if (shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag)) {\n    value = null;\n  }\n  // If the prop isn't in the special list, treat it as a simple attribute.\n  if (isCustomComponentTag || propertyInfo === null) {\n    if (isAttributeNameSafe(name)) {\n      const attributeName = name;\n      if (value === null) {\n        node.removeAttribute(attributeName);\n      } else {\n        setAttribute(node, attributeName, toStringOrTrustedType(value));\n      }\n    }\n    return;\n  }\n  const {mustUseProperty} = propertyInfo;\n  if (mustUseProperty) {\n    const {propertyName} = propertyInfo;\n    if (value === null) {\n      const {type} = propertyInfo;\n      (node: any)[propertyName] = type === BOOLEAN ? false : '';\n    } else {\n      // Contrary to `setAttribute`, object properties are properly\n      // `toString`ed by IE8/9.\n      (node: any)[propertyName] = value;\n    }\n    return;\n  }\n  // The rest are treated as attributes with special cases.\n  const {attributeName, attributeNamespace} = propertyInfo;\n  if (value === null) {\n    node.removeAttribute(attributeName);\n  } else {\n    const {type} = propertyInfo;\n    let attributeValue;\n    if (type === BOOLEAN || (type === OVERLOADED_BOOLEAN && value === true)) {\n      // If attribute type is boolean, we know for sure it won't be an execution sink\n      // and we won't require Trusted Type here.\n      attributeValue = '';\n    } else {\n      // `setAttribute` with objects becomes only `[object]` in IE8/9,\n      // ('' + value) makes it output the correct toString()-value.\n      attributeValue = toStringOrTrustedType(value);\n      if (propertyInfo.sanitizeURL) {\n        sanitizeURL(attributeValue.toString());\n      }\n    }\n    if (attributeNamespace) {\n      setAttributeNS(node, attributeNamespace, attributeName, attributeValue);\n    } else {\n      setAttribute(node, attributeName, attributeValue);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}