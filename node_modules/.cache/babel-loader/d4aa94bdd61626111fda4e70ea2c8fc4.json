{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { HostComponent, HostText, HostRoot, SuspenseComponent } from 'shared/ReactWorkTags';\nimport { Deletion, Placement, Hydrating } from 'shared/ReactSideEffectTags';\nimport invariant from 'shared/invariant';\nimport { createFiberFromHostInstanceForDeletion, createFiberFromDehydratedFragment } from './ReactFiber';\nimport { shouldSetTextContent, supportsHydration, canHydrateInstance, canHydrateTextInstance, canHydrateSuspenseInstance, getNextHydratableSibling, getFirstHydratableChild, hydrateInstance, hydrateTextInstance, hydrateSuspenseInstance, getNextHydratableInstanceAfterSuspenseInstance, didNotMatchHydratedContainerTextInstance, didNotMatchHydratedTextInstance, didNotHydrateContainerInstance, didNotHydrateInstance, didNotFindHydratableContainerInstance, didNotFindHydratableContainerTextInstance, didNotFindHydratableContainerSuspenseInstance, didNotFindHydratableInstance, didNotFindHydratableTextInstance, didNotFindHydratableSuspenseInstance } from './ReactFiberHostConfig';\nimport { enableSuspenseServerRenderer } from 'shared/ReactFeatureFlags';\nimport warning from 'shared/warning';\nimport { Never } from './ReactFiberExpirationTime'; // The deepest Fiber on the stack involved in a hydration context.\n// This may have been an insertion or a hydration.\n\nlet hydrationParentFiber = null;\nlet nextHydratableInstance = null;\nlet isHydrating = false;\n\nfunction warnIfHydrating() {\n  if (__DEV__) {\n    warning(!isHydrating, 'We should not be hydrating here. This is a bug in React. Please file a bug.');\n  }\n}\n\nfunction enterHydrationState(fiber) {\n  if (!supportsHydration) {\n    return false;\n  }\n\n  const parentInstance = fiber.stateNode.containerInfo;\n  nextHydratableInstance = getFirstHydratableChild(parentInstance);\n  hydrationParentFiber = fiber;\n  isHydrating = true;\n  return true;\n}\n\nfunction reenterHydrationStateFromDehydratedSuspenseInstance(fiber, suspenseInstance) {\n  if (!supportsHydration) {\n    return false;\n  }\n\n  nextHydratableInstance = getNextHydratableSibling(suspenseInstance);\n  popToNextHostParent(fiber);\n  isHydrating = true;\n  return true;\n}\n\nfunction deleteHydratableInstance(returnFiber, instance) {\n  if (__DEV__) {\n    switch (returnFiber.tag) {\n      case HostRoot:\n        didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance);\n        break;\n\n      case HostComponent:\n        didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);\n        break;\n    }\n  }\n\n  const childToDelete = createFiberFromHostInstanceForDeletion();\n  childToDelete.stateNode = instance;\n  childToDelete.return = returnFiber;\n  childToDelete.effectTag = Deletion; // This might seem like it belongs on progressedFirstDeletion. However,\n  // these children are not part of the reconciliation list of children.\n  // Even if we abort and rereconcile the children, that will try to hydrate\n  // again and the nodes are still in the host tree so these will be\n  // recreated.\n\n  if (returnFiber.lastEffect !== null) {\n    returnFiber.lastEffect.nextEffect = childToDelete;\n    returnFiber.lastEffect = childToDelete;\n  } else {\n    returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n  }\n}\n\nfunction insertNonHydratedInstance(returnFiber, fiber) {\n  fiber.effectTag = fiber.effectTag & ~Hydrating | Placement;\n\n  if (__DEV__) {\n    switch (returnFiber.tag) {\n      case HostRoot:\n        {\n          const parentContainer = returnFiber.stateNode.containerInfo;\n\n          switch (fiber.tag) {\n            case HostComponent:\n              const type = fiber.type;\n              const props = fiber.pendingProps;\n              didNotFindHydratableContainerInstance(parentContainer, type, props);\n              break;\n\n            case HostText:\n              const text = fiber.pendingProps;\n              didNotFindHydratableContainerTextInstance(parentContainer, text);\n              break;\n\n            case SuspenseComponent:\n              didNotFindHydratableContainerSuspenseInstance(parentContainer);\n              break;\n          }\n\n          break;\n        }\n\n      case HostComponent:\n        {\n          const parentType = returnFiber.type;\n          const parentProps = returnFiber.memoizedProps;\n          const parentInstance = returnFiber.stateNode;\n\n          switch (fiber.tag) {\n            case HostComponent:\n              const type = fiber.type;\n              const props = fiber.pendingProps;\n              didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props);\n              break;\n\n            case HostText:\n              const text = fiber.pendingProps;\n              didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text);\n              break;\n\n            case SuspenseComponent:\n              didNotFindHydratableSuspenseInstance(parentType, parentProps, parentInstance);\n              break;\n          }\n\n          break;\n        }\n\n      default:\n        return;\n    }\n  }\n}\n\nfunction tryHydrate(fiber, nextInstance) {\n  switch (fiber.tag) {\n    case HostComponent:\n      {\n        const type = fiber.type;\n        const props = fiber.pendingProps;\n        const instance = canHydrateInstance(nextInstance, type, props);\n\n        if (instance !== null) {\n          fiber.stateNode = instance;\n          return true;\n        }\n\n        return false;\n      }\n\n    case HostText:\n      {\n        const text = fiber.pendingProps;\n        const textInstance = canHydrateTextInstance(nextInstance, text);\n\n        if (textInstance !== null) {\n          fiber.stateNode = textInstance;\n          return true;\n        }\n\n        return false;\n      }\n\n    case SuspenseComponent:\n      {\n        if (enableSuspenseServerRenderer) {\n          const suspenseInstance = canHydrateSuspenseInstance(nextInstance);\n\n          if (suspenseInstance !== null) {\n            const suspenseState = {\n              dehydrated: suspenseInstance,\n              retryTime: Never\n            };\n            fiber.memoizedState = suspenseState; // Store the dehydrated fragment as a child fiber.\n            // This simplifies the code for getHostSibling and deleting nodes,\n            // since it doesn't have to consider all Suspense boundaries and\n            // check if they're dehydrated ones or not.\n\n            const dehydratedFragment = createFiberFromDehydratedFragment(suspenseInstance);\n            dehydratedFragment.return = fiber;\n            fiber.child = dehydratedFragment;\n            return true;\n          }\n        }\n\n        return false;\n      }\n\n    default:\n      return false;\n  }\n}\n\nfunction tryToClaimNextHydratableInstance(fiber) {\n  if (!isHydrating) {\n    return;\n  }\n\n  let nextInstance = nextHydratableInstance;\n\n  if (!nextInstance) {\n    // Nothing to hydrate. Make it an insertion.\n    insertNonHydratedInstance(hydrationParentFiber, fiber);\n    isHydrating = false;\n    hydrationParentFiber = fiber;\n    return;\n  }\n\n  const firstAttemptedInstance = nextInstance;\n\n  if (!tryHydrate(fiber, nextInstance)) {\n    // If we can't hydrate this instance let's try the next one.\n    // We use this as a heuristic. It's based on intuition and not data so it\n    // might be flawed or unnecessary.\n    nextInstance = getNextHydratableSibling(firstAttemptedInstance);\n\n    if (!nextInstance || !tryHydrate(fiber, nextInstance)) {\n      // Nothing to hydrate. Make it an insertion.\n      insertNonHydratedInstance(hydrationParentFiber, fiber);\n      isHydrating = false;\n      hydrationParentFiber = fiber;\n      return;\n    } // We matched the next one, we'll now assume that the first one was\n    // superfluous and we'll delete it. Since we can't eagerly delete it\n    // we'll have to schedule a deletion. To do that, this node needs a dummy\n    // fiber associated with it.\n\n\n    deleteHydratableInstance(hydrationParentFiber, firstAttemptedInstance);\n  }\n\n  hydrationParentFiber = fiber;\n  nextHydratableInstance = getFirstHydratableChild(nextInstance);\n}\n\nfunction prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {\n  if (!supportsHydration) {\n    invariant(false, 'Expected prepareToHydrateHostInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  const instance = fiber.stateNode;\n  const updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber); // TODO: Type this specific to this type of component.\n\n  fiber.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there\n  // is a new ref we mark this as an update.\n\n  if (updatePayload !== null) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction prepareToHydrateHostTextInstance(fiber) {\n  if (!supportsHydration) {\n    invariant(false, 'Expected prepareToHydrateHostTextInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  const textInstance = fiber.stateNode;\n  const textContent = fiber.memoizedProps;\n  const shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);\n\n  if (__DEV__) {\n    if (shouldUpdate) {\n      // We assume that prepareToHydrateHostTextInstance is called in a context where the\n      // hydration parent is the parent host component of this host text.\n      const returnFiber = hydrationParentFiber;\n\n      if (returnFiber !== null) {\n        switch (returnFiber.tag) {\n          case HostRoot:\n            {\n              const parentContainer = returnFiber.stateNode.containerInfo;\n              didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);\n              break;\n            }\n\n          case HostComponent:\n            {\n              const parentType = returnFiber.type;\n              const parentProps = returnFiber.memoizedProps;\n              const parentInstance = returnFiber.stateNode;\n              didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);\n              break;\n            }\n        }\n      }\n    }\n  }\n\n  return shouldUpdate;\n}\n\nfunction prepareToHydrateHostSuspenseInstance(fiber) {\n  if (!supportsHydration) {\n    invariant(false, 'Expected prepareToHydrateHostSuspenseInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  let suspenseState = fiber.memoizedState;\n  let suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;\n  invariant(suspenseInstance, 'Expected to have a hydrated suspense instance. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n  hydrateSuspenseInstance(suspenseInstance, fiber);\n}\n\nfunction skipPastDehydratedSuspenseInstance(fiber) {\n  if (!supportsHydration) {\n    invariant(false, 'Expected skipPastDehydratedSuspenseInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  let suspenseState = fiber.memoizedState;\n  let suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;\n  invariant(suspenseInstance, 'Expected to have a hydrated suspense instance. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n  return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);\n}\n\nfunction popToNextHostParent(fiber) {\n  let parent = fiber.return;\n\n  while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== SuspenseComponent) {\n    parent = parent.return;\n  }\n\n  hydrationParentFiber = parent;\n}\n\nfunction popHydrationState(fiber) {\n  if (!supportsHydration) {\n    return false;\n  }\n\n  if (fiber !== hydrationParentFiber) {\n    // We're deeper than the current hydration context, inside an inserted\n    // tree.\n    return false;\n  }\n\n  if (!isHydrating) {\n    // If we're not currently hydrating but we're in a hydration context, then\n    // we were an insertion and now need to pop up reenter hydration of our\n    // siblings.\n    popToNextHostParent(fiber);\n    isHydrating = true;\n    return false;\n  }\n\n  const type = fiber.type; // If we have any remaining hydratable nodes, we need to delete them now.\n  // We only do this deeper than head and body since they tend to have random\n  // other nodes in them. We also ignore components with pure text content in\n  // side of them.\n  // TODO: Better heuristic.\n\n  if (fiber.tag !== HostComponent || type !== 'head' && type !== 'body' && !shouldSetTextContent(type, fiber.memoizedProps)) {\n    let nextInstance = nextHydratableInstance;\n\n    while (nextInstance) {\n      deleteHydratableInstance(fiber, nextInstance);\n      nextInstance = getNextHydratableSibling(nextInstance);\n    }\n  }\n\n  popToNextHostParent(fiber);\n\n  if (fiber.tag === SuspenseComponent) {\n    nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);\n  } else {\n    nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;\n  }\n\n  return true;\n}\n\nfunction resetHydrationState() {\n  if (!supportsHydration) {\n    return;\n  }\n\n  hydrationParentFiber = null;\n  nextHydratableInstance = null;\n  isHydrating = false;\n}\n\nfunction getIsHydrating() {\n  return isHydrating;\n}\n\nexport { warnIfHydrating, enterHydrationState, reenterHydrationStateFromDehydratedSuspenseInstance, resetHydrationState, tryToClaimNextHydratableInstance, prepareToHydrateHostInstance, prepareToHydrateHostTextInstance, prepareToHydrateHostSuspenseInstance, popHydrationState, getIsHydrating };","map":{"version":3,"sources":["/Users/gaoshaoyun/Documents/library/debug-react/src/react/packages/react-reconciler/src/ReactFiberHydrationContext.js"],"names":["HostComponent","HostText","HostRoot","SuspenseComponent","Deletion","Placement","Hydrating","invariant","createFiberFromHostInstanceForDeletion","createFiberFromDehydratedFragment","shouldSetTextContent","supportsHydration","canHydrateInstance","canHydrateTextInstance","canHydrateSuspenseInstance","getNextHydratableSibling","getFirstHydratableChild","hydrateInstance","hydrateTextInstance","hydrateSuspenseInstance","getNextHydratableInstanceAfterSuspenseInstance","didNotMatchHydratedContainerTextInstance","didNotMatchHydratedTextInstance","didNotHydrateContainerInstance","didNotHydrateInstance","didNotFindHydratableContainerInstance","didNotFindHydratableContainerTextInstance","didNotFindHydratableContainerSuspenseInstance","didNotFindHydratableInstance","didNotFindHydratableTextInstance","didNotFindHydratableSuspenseInstance","enableSuspenseServerRenderer","warning","Never","hydrationParentFiber","nextHydratableInstance","isHydrating","warnIfHydrating","__DEV__","enterHydrationState","fiber","parentInstance","stateNode","containerInfo","reenterHydrationStateFromDehydratedSuspenseInstance","suspenseInstance","popToNextHostParent","deleteHydratableInstance","returnFiber","instance","tag","type","memoizedProps","childToDelete","return","effectTag","lastEffect","nextEffect","firstEffect","insertNonHydratedInstance","parentContainer","props","pendingProps","text","parentType","parentProps","tryHydrate","nextInstance","textInstance","suspenseState","dehydrated","retryTime","memoizedState","dehydratedFragment","child","tryToClaimNextHydratableInstance","firstAttemptedInstance","prepareToHydrateHostInstance","rootContainerInstance","hostContext","updatePayload","updateQueue","prepareToHydrateHostTextInstance","textContent","shouldUpdate","prepareToHydrateHostSuspenseInstance","skipPastDehydratedSuspenseInstance","parent","popHydrationState","resetHydrationState","getIsHydrating"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber} from './ReactFiber';\nimport type {\n  Instance,\n  TextInstance,\n  HydratableInstance,\n  SuspenseInstance,\n  Container,\n  HostContext,\n} from './ReactFiberHostConfig';\nimport type {SuspenseState} from './ReactFiberSuspenseComponent';\n\nimport {\n  HostComponent,\n  HostText,\n  HostRoot,\n  SuspenseComponent,\n} from 'shared/ReactWorkTags';\nimport {Deletion, Placement, Hydrating} from 'shared/ReactSideEffectTags';\nimport invariant from 'shared/invariant';\n\nimport {\n  createFiberFromHostInstanceForDeletion,\n  createFiberFromDehydratedFragment,\n} from './ReactFiber';\nimport {\n  shouldSetTextContent,\n  supportsHydration,\n  canHydrateInstance,\n  canHydrateTextInstance,\n  canHydrateSuspenseInstance,\n  getNextHydratableSibling,\n  getFirstHydratableChild,\n  hydrateInstance,\n  hydrateTextInstance,\n  hydrateSuspenseInstance,\n  getNextHydratableInstanceAfterSuspenseInstance,\n  didNotMatchHydratedContainerTextInstance,\n  didNotMatchHydratedTextInstance,\n  didNotHydrateContainerInstance,\n  didNotHydrateInstance,\n  didNotFindHydratableContainerInstance,\n  didNotFindHydratableContainerTextInstance,\n  didNotFindHydratableContainerSuspenseInstance,\n  didNotFindHydratableInstance,\n  didNotFindHydratableTextInstance,\n  didNotFindHydratableSuspenseInstance,\n} from './ReactFiberHostConfig';\nimport {enableSuspenseServerRenderer} from 'shared/ReactFeatureFlags';\nimport warning from 'shared/warning';\nimport {Never} from './ReactFiberExpirationTime';\n\n// The deepest Fiber on the stack involved in a hydration context.\n// This may have been an insertion or a hydration.\nlet hydrationParentFiber: null | Fiber = null;\nlet nextHydratableInstance: null | HydratableInstance = null;\nlet isHydrating: boolean = false;\n\nfunction warnIfHydrating() {\n  if (__DEV__) {\n    warning(\n      !isHydrating,\n      'We should not be hydrating here. This is a bug in React. Please file a bug.',\n    );\n  }\n}\n\nfunction enterHydrationState(fiber: Fiber): boolean {\n  if (!supportsHydration) {\n    return false;\n  }\n\n  const parentInstance = fiber.stateNode.containerInfo;\n  nextHydratableInstance = getFirstHydratableChild(parentInstance);\n  hydrationParentFiber = fiber;\n  isHydrating = true;\n  return true;\n}\n\nfunction reenterHydrationStateFromDehydratedSuspenseInstance(\n  fiber: Fiber,\n  suspenseInstance: SuspenseInstance,\n): boolean {\n  if (!supportsHydration) {\n    return false;\n  }\n  nextHydratableInstance = getNextHydratableSibling(suspenseInstance);\n  popToNextHostParent(fiber);\n  isHydrating = true;\n  return true;\n}\n\nfunction deleteHydratableInstance(\n  returnFiber: Fiber,\n  instance: HydratableInstance,\n) {\n  if (__DEV__) {\n    switch (returnFiber.tag) {\n      case HostRoot:\n        didNotHydrateContainerInstance(\n          returnFiber.stateNode.containerInfo,\n          instance,\n        );\n        break;\n      case HostComponent:\n        didNotHydrateInstance(\n          returnFiber.type,\n          returnFiber.memoizedProps,\n          returnFiber.stateNode,\n          instance,\n        );\n        break;\n    }\n  }\n\n  const childToDelete = createFiberFromHostInstanceForDeletion();\n  childToDelete.stateNode = instance;\n  childToDelete.return = returnFiber;\n  childToDelete.effectTag = Deletion;\n\n  // This might seem like it belongs on progressedFirstDeletion. However,\n  // these children are not part of the reconciliation list of children.\n  // Even if we abort and rereconcile the children, that will try to hydrate\n  // again and the nodes are still in the host tree so these will be\n  // recreated.\n  if (returnFiber.lastEffect !== null) {\n    returnFiber.lastEffect.nextEffect = childToDelete;\n    returnFiber.lastEffect = childToDelete;\n  } else {\n    returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n  }\n}\n\nfunction insertNonHydratedInstance(returnFiber: Fiber, fiber: Fiber) {\n  fiber.effectTag = (fiber.effectTag & ~Hydrating) | Placement;\n  if (__DEV__) {\n    switch (returnFiber.tag) {\n      case HostRoot: {\n        const parentContainer = returnFiber.stateNode.containerInfo;\n        switch (fiber.tag) {\n          case HostComponent:\n            const type = fiber.type;\n            const props = fiber.pendingProps;\n            didNotFindHydratableContainerInstance(parentContainer, type, props);\n            break;\n          case HostText:\n            const text = fiber.pendingProps;\n            didNotFindHydratableContainerTextInstance(parentContainer, text);\n            break;\n          case SuspenseComponent:\n            didNotFindHydratableContainerSuspenseInstance(parentContainer);\n            break;\n        }\n        break;\n      }\n      case HostComponent: {\n        const parentType = returnFiber.type;\n        const parentProps = returnFiber.memoizedProps;\n        const parentInstance = returnFiber.stateNode;\n        switch (fiber.tag) {\n          case HostComponent:\n            const type = fiber.type;\n            const props = fiber.pendingProps;\n            didNotFindHydratableInstance(\n              parentType,\n              parentProps,\n              parentInstance,\n              type,\n              props,\n            );\n            break;\n          case HostText:\n            const text = fiber.pendingProps;\n            didNotFindHydratableTextInstance(\n              parentType,\n              parentProps,\n              parentInstance,\n              text,\n            );\n            break;\n          case SuspenseComponent:\n            didNotFindHydratableSuspenseInstance(\n              parentType,\n              parentProps,\n              parentInstance,\n            );\n            break;\n        }\n        break;\n      }\n      default:\n        return;\n    }\n  }\n}\n\nfunction tryHydrate(fiber, nextInstance) {\n  switch (fiber.tag) {\n    case HostComponent: {\n      const type = fiber.type;\n      const props = fiber.pendingProps;\n      const instance = canHydrateInstance(nextInstance, type, props);\n      if (instance !== null) {\n        fiber.stateNode = (instance: Instance);\n        return true;\n      }\n      return false;\n    }\n    case HostText: {\n      const text = fiber.pendingProps;\n      const textInstance = canHydrateTextInstance(nextInstance, text);\n      if (textInstance !== null) {\n        fiber.stateNode = (textInstance: TextInstance);\n        return true;\n      }\n      return false;\n    }\n    case SuspenseComponent: {\n      if (enableSuspenseServerRenderer) {\n        const suspenseInstance: null | SuspenseInstance = canHydrateSuspenseInstance(\n          nextInstance,\n        );\n        if (suspenseInstance !== null) {\n          const suspenseState: SuspenseState = {\n            dehydrated: suspenseInstance,\n            retryTime: Never,\n          };\n          fiber.memoizedState = suspenseState;\n          // Store the dehydrated fragment as a child fiber.\n          // This simplifies the code for getHostSibling and deleting nodes,\n          // since it doesn't have to consider all Suspense boundaries and\n          // check if they're dehydrated ones or not.\n          const dehydratedFragment = createFiberFromDehydratedFragment(\n            suspenseInstance,\n          );\n          dehydratedFragment.return = fiber;\n          fiber.child = dehydratedFragment;\n          return true;\n        }\n      }\n      return false;\n    }\n    default:\n      return false;\n  }\n}\n\nfunction tryToClaimNextHydratableInstance(fiber: Fiber): void {\n  if (!isHydrating) {\n    return;\n  }\n  let nextInstance = nextHydratableInstance;\n  if (!nextInstance) {\n    // Nothing to hydrate. Make it an insertion.\n    insertNonHydratedInstance((hydrationParentFiber: any), fiber);\n    isHydrating = false;\n    hydrationParentFiber = fiber;\n    return;\n  }\n  const firstAttemptedInstance = nextInstance;\n  if (!tryHydrate(fiber, nextInstance)) {\n    // If we can't hydrate this instance let's try the next one.\n    // We use this as a heuristic. It's based on intuition and not data so it\n    // might be flawed or unnecessary.\n    nextInstance = getNextHydratableSibling(firstAttemptedInstance);\n    if (!nextInstance || !tryHydrate(fiber, nextInstance)) {\n      // Nothing to hydrate. Make it an insertion.\n      insertNonHydratedInstance((hydrationParentFiber: any), fiber);\n      isHydrating = false;\n      hydrationParentFiber = fiber;\n      return;\n    }\n    // We matched the next one, we'll now assume that the first one was\n    // superfluous and we'll delete it. Since we can't eagerly delete it\n    // we'll have to schedule a deletion. To do that, this node needs a dummy\n    // fiber associated with it.\n    deleteHydratableInstance(\n      (hydrationParentFiber: any),\n      firstAttemptedInstance,\n    );\n  }\n  hydrationParentFiber = fiber;\n  nextHydratableInstance = getFirstHydratableChild((nextInstance: any));\n}\n\nfunction prepareToHydrateHostInstance(\n  fiber: Fiber,\n  rootContainerInstance: Container,\n  hostContext: HostContext,\n): boolean {\n  if (!supportsHydration) {\n    invariant(\n      false,\n      'Expected prepareToHydrateHostInstance() to never be called. ' +\n        'This error is likely caused by a bug in React. Please file an issue.',\n    );\n  }\n\n  const instance: Instance = fiber.stateNode;\n  const updatePayload = hydrateInstance(\n    instance,\n    fiber.type,\n    fiber.memoizedProps,\n    rootContainerInstance,\n    hostContext,\n    fiber,\n  );\n  // TODO: Type this specific to this type of component.\n  fiber.updateQueue = (updatePayload: any);\n  // If the update payload indicates that there is a change or if there\n  // is a new ref we mark this as an update.\n  if (updatePayload !== null) {\n    return true;\n  }\n  return false;\n}\n\nfunction prepareToHydrateHostTextInstance(fiber: Fiber): boolean {\n  if (!supportsHydration) {\n    invariant(\n      false,\n      'Expected prepareToHydrateHostTextInstance() to never be called. ' +\n        'This error is likely caused by a bug in React. Please file an issue.',\n    );\n  }\n\n  const textInstance: TextInstance = fiber.stateNode;\n  const textContent: string = fiber.memoizedProps;\n  const shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);\n  if (__DEV__) {\n    if (shouldUpdate) {\n      // We assume that prepareToHydrateHostTextInstance is called in a context where the\n      // hydration parent is the parent host component of this host text.\n      const returnFiber = hydrationParentFiber;\n      if (returnFiber !== null) {\n        switch (returnFiber.tag) {\n          case HostRoot: {\n            const parentContainer = returnFiber.stateNode.containerInfo;\n            didNotMatchHydratedContainerTextInstance(\n              parentContainer,\n              textInstance,\n              textContent,\n            );\n            break;\n          }\n          case HostComponent: {\n            const parentType = returnFiber.type;\n            const parentProps = returnFiber.memoizedProps;\n            const parentInstance = returnFiber.stateNode;\n            didNotMatchHydratedTextInstance(\n              parentType,\n              parentProps,\n              parentInstance,\n              textInstance,\n              textContent,\n            );\n            break;\n          }\n        }\n      }\n    }\n  }\n  return shouldUpdate;\n}\n\nfunction prepareToHydrateHostSuspenseInstance(fiber: Fiber): void {\n  if (!supportsHydration) {\n    invariant(\n      false,\n      'Expected prepareToHydrateHostSuspenseInstance() to never be called. ' +\n        'This error is likely caused by a bug in React. Please file an issue.',\n    );\n  }\n\n  let suspenseState: null | SuspenseState = fiber.memoizedState;\n  let suspenseInstance: null | SuspenseInstance =\n    suspenseState !== null ? suspenseState.dehydrated : null;\n  invariant(\n    suspenseInstance,\n    'Expected to have a hydrated suspense instance. ' +\n      'This error is likely caused by a bug in React. Please file an issue.',\n  );\n  hydrateSuspenseInstance(suspenseInstance, fiber);\n}\n\nfunction skipPastDehydratedSuspenseInstance(\n  fiber: Fiber,\n): null | HydratableInstance {\n  if (!supportsHydration) {\n    invariant(\n      false,\n      'Expected skipPastDehydratedSuspenseInstance() to never be called. ' +\n        'This error is likely caused by a bug in React. Please file an issue.',\n    );\n  }\n  let suspenseState: null | SuspenseState = fiber.memoizedState;\n  let suspenseInstance: null | SuspenseInstance =\n    suspenseState !== null ? suspenseState.dehydrated : null;\n  invariant(\n    suspenseInstance,\n    'Expected to have a hydrated suspense instance. ' +\n      'This error is likely caused by a bug in React. Please file an issue.',\n  );\n  return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);\n}\n\nfunction popToNextHostParent(fiber: Fiber): void {\n  let parent = fiber.return;\n  while (\n    parent !== null &&\n    parent.tag !== HostComponent &&\n    parent.tag !== HostRoot &&\n    parent.tag !== SuspenseComponent\n  ) {\n    parent = parent.return;\n  }\n  hydrationParentFiber = parent;\n}\n\nfunction popHydrationState(fiber: Fiber): boolean {\n  if (!supportsHydration) {\n    return false;\n  }\n  if (fiber !== hydrationParentFiber) {\n    // We're deeper than the current hydration context, inside an inserted\n    // tree.\n    return false;\n  }\n  if (!isHydrating) {\n    // If we're not currently hydrating but we're in a hydration context, then\n    // we were an insertion and now need to pop up reenter hydration of our\n    // siblings.\n    popToNextHostParent(fiber);\n    isHydrating = true;\n    return false;\n  }\n\n  const type = fiber.type;\n\n  // If we have any remaining hydratable nodes, we need to delete them now.\n  // We only do this deeper than head and body since they tend to have random\n  // other nodes in them. We also ignore components with pure text content in\n  // side of them.\n  // TODO: Better heuristic.\n  if (\n    fiber.tag !== HostComponent ||\n    (type !== 'head' &&\n      type !== 'body' &&\n      !shouldSetTextContent(type, fiber.memoizedProps))\n  ) {\n    let nextInstance = nextHydratableInstance;\n    while (nextInstance) {\n      deleteHydratableInstance(fiber, nextInstance);\n      nextInstance = getNextHydratableSibling(nextInstance);\n    }\n  }\n\n  popToNextHostParent(fiber);\n  if (fiber.tag === SuspenseComponent) {\n    nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);\n  } else {\n    nextHydratableInstance = hydrationParentFiber\n      ? getNextHydratableSibling(fiber.stateNode)\n      : null;\n  }\n  return true;\n}\n\nfunction resetHydrationState(): void {\n  if (!supportsHydration) {\n    return;\n  }\n\n  hydrationParentFiber = null;\n  nextHydratableInstance = null;\n  isHydrating = false;\n}\n\nfunction getIsHydrating(): boolean {\n  return isHydrating;\n}\n\nexport {\n  warnIfHydrating,\n  enterHydrationState,\n  reenterHydrationStateFromDehydratedSuspenseInstance,\n  resetHydrationState,\n  tryToClaimNextHydratableInstance,\n  prepareToHydrateHostInstance,\n  prepareToHydrateHostTextInstance,\n  prepareToHydrateHostSuspenseInstance,\n  popHydrationState,\n  getIsHydrating,\n};\n"]},"metadata":{},"sourceType":"module"}